/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app/layout.js":
/*!***************************!*\
  !*** ./src/app/layout.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fabric */ "./node_modules/fabric/dist/fabric.js");
/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fabric__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nouislider */ "./node_modules/nouislider/distribute/nouislider.js");
/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(nouislider__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var nouislider_distribute_nouislider_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nouislider/distribute/nouislider.css */ "./node_modules/nouislider/distribute/nouislider.css");
// import { auth } from './auth.js';
console.log('hello, Manager');



var canvas;
var number;
var grid = 30;
var backgroundColor = '#626262';
var lineStroke = '#ebebeb';
var tableFill = 'rgba(187, 187, 187, 0.7)';
var tableStroke = '#5c5c5c';
var tableShadow = 'rgba(0, 0, 0, 0.4) 3px 3px 7px';
var chairFill = 'rgba(75, 75, 75, 0.7)';
var chairStroke = '#32230b';
var chairShadow = 'rgba(0, 0, 0, 0.4) 3px 3px 7px'; // const barFill = 'rgba(0, 93, 127, 0.7)';

var barFill = 'rgba(0, 162, 255, 0.7)';
var barStroke = '#003e54';
var barShadow = 'rgba(0, 0, 0, 0.4) 3px 3px 7px';
var barText = 'Bar';
var wallFill = 'rgba(136, 136, 136, 0.7)';
var wallStroke = '#686868';
var wallShadow = 'rgba(0, 0, 0, 0.4) 5px 5px 20px';
var photoUrlLandscape = 'https://images8.alphacoders.com/292/292379.jpg',
    photoUrlPortrait = 'https://presspack.rte.ie/wp-content/blogs.dir/2/files/2015/04/AMC_TWD_Maggie_Portraits_4817_V1.jpg';
var widthEl = document.getElementById('width');
var heightEl = document.getElementById('height');
var canvasEl = document.getElementById('canvas');

if (localStorage.getItem('widthEl') && localStorage.getItem('heightEl')) {
  document.getElementById('width').value = localStorage.getItem('widthEl');
  document.getElementById('height').value = localStorage.getItem('heightEl');
} else {
  localStorage.setItem('heightEl', heightEl.value);
  localStorage.setItem('widthEl', widthEl.value);
}

canvasEl.setAttribute('width', localStorage.getItem('widthEl'));
canvasEl.setAttribute('height', localStorage.getItem('heightEl'));

function initCanvas() {
  if (canvas) {
    canvas.clear();
    canvas.dispose();
  }

  canvas = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Canvas('canvas');
  number = parseInt(localStorage.getItem('totalTables')) + 1; // number = 1;

  canvas.backgroundColor = backgroundColor; // canvas.setBackgroundImage(
  //     'https://presspack.rte.ie/wp-content/blogs.dir/2/files/2015/04/AMC_TWD_Maggie_Portraits_4817_V1.jpg',
  //     canvas.renderAll.bind(canvas)
  // );

  for (var i = 0; i < canvas.height / grid; i++) {
    var lineX = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Line([0, i * grid, canvas.height, i * grid], {
      stroke: lineStroke,
      selectable: false,
      name: 'line'
    });
    var lineY = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Line([i * grid, 0, i * grid, canvas.height], {
      stroke: lineStroke,
      selectable: false,
      name: 'line'
    }); // canvas.add(lineX);
    // canvas.add(lineY);

    sendLinesToBack();
  }

  canvas.on('object:moving', function (e) {
    snapToGrid(e.target);
  });
  canvas.on('object:scaling', function (e) {
    if (e.target.scaleX > 5) {
      e.target.scaleX = 5;
    }

    if (e.target.scaleY > 5) {
      e.target.scaleY = 5;
    }

    if (!e.target.strokeWidthUnscaled && e.target.strokeWidth) {
      e.target.strokeWidthUnscaled = e.target.strokeWidth;
    }

    if (e.target.strokeWidthUnscaled) {
      e.target.strokeWidth = e.target.strokeWidthUnscaled / e.target.scaleX;

      if (e.target.strokeWidth === e.target.strokeWidthUnscaled) {
        e.target.strokeWidth = e.target.strokeWidthUnscaled / e.target.scaleY;
      }
    }
  });
  canvas.on('object:modified', function (e) {
    e.target.scaleX = e.target.scaleX >= 0.25 ? Math.round(e.target.scaleX * 2) / 2 : 0.5;
    e.target.scaleY = e.target.scaleY >= 0.25 ? Math.round(e.target.scaleY * 2) / 2 : 0.5;
    snapToGrid(e.target);

    if (e.target.name === 'table') {
      canvas.bringToFront(e.target);
    } else {
      canvas.sendToBack(e.target);
    }

    sendLinesToBack();
  });
  canvas.on('object:moving', function (e) {
    checkBoudningBox(e);
  });
  canvas.on('object:rotating', function (e) {
    checkBoudningBox(e);
  });
  canvas.on('object:scaling', function (e) {
    checkBoudningBox(e);
  });
}

initCanvas();

function resizeCanvas() {
  widthEl = document.getElementById('width');
  heightEl = document.getElementById('height');
  canvasEl.width = widthEl.value ? widthEl.value : 302;
  canvasEl.height = heightEl.value ? heightEl.value : 812;
  var canvasContainerEl = document.querySelectorAll('.canvas-container')[0];
  canvasContainerEl.style.width = canvasEl.width;
  canvasContainerEl.style.height = canvasEl.height;
}

resizeCanvas();
widthEl.addEventListener('change', function () {
  resizeCanvas();
  initCanvas(); // addDefaultObjects();

  canvasLoader();
  sendLinesToBack();
});
heightEl.addEventListener('change', function () {
  resizeCanvas();
  initCanvas(); // addDefaultObjects();

  canvasLoader();
  sendLinesToBack();
});

function generateId() {
  return Math.random().toString(36).substr(2, 8);
}

function addRect(left, top, width, height) {
  var id = generateId();
  var o = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Rect({
    width: width,
    height: height,
    fill: tableFill,
    stroke: tableStroke,
    strokeWidth: 2,
    shadow: tableShadow,
    originX: 'center',
    originY: 'center',
    centeredRotation: true,
    snapAngle: 45,
    selectable: true
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.IText(number.toString(), {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'table',
    id: id,
    number: number
  });
  canvas.add(g);
  number++;
  return g;
}

function addCircle(left, top, radius) {
  var id = generateId();
  var o = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Circle({
    radius: radius,
    fill: tableFill,
    stroke: tableStroke,
    strokeWidth: 2,
    shadow: tableShadow,
    originX: 'center',
    originY: 'center',
    centeredRotation: true
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.IText(number.toString(), {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'table',
    id: id,
    number: number
  });
  canvas.add(g);
  number++;
  return g;
}

function addTriangle(left, top, radius) {
  var id = generateId();
  var o = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Triangle({
    radius: radius,
    fill: tableFill,
    stroke: tableStroke,
    strokeWidth: 2,
    shadow: tableShadow,
    originX: 'center',
    originY: 'center',
    centeredRotation: true
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.IText(number.toString(), {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'table',
    id: id,
    number: number
  });
  canvas.add(g);
  number++;
  return g;
}

function addChair(left, top, width, height) {
  var o = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Rect({
    left: left,
    top: top,
    width: 30,
    height: 30,
    fill: chairFill,
    stroke: chairStroke,
    strokeWidth: 2,
    shadow: chairShadow,
    originX: 'left',
    originY: 'top',
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'chair',
    id: generateId()
  });
  canvas.add(o);
  return o;
}

function addBar(left, top, width, height) {
  var o = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Rect({
    width: width,
    height: height,
    fill: barFill,
    stroke: barStroke,
    strokeWidth: 2,
    shadow: barShadow,
    originX: 'center',
    originY: 'center',
    name: 'bar',
    id: generateId()
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.IText(barText, {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'bar'
  });
  canvas.add(g);
  return g;
}

function addWall(left, top, width, height) {
  var o = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Rect({
    left: left,
    top: top,
    width: width,
    height: height,
    fill: wallFill,
    stroke: wallStroke,
    strokeWidth: 2,
    shadow: wallShadow,
    originX: 'left',
    originY: 'top',
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'wall',
    id: generateId()
  });
  canvas.add(o);
  return o;
}

function snapToGrid(target) {
  target.set({
    left: Math.round(target.left / (grid / 2)) * grid / 2,
    top: Math.round(target.top / (grid / 2)) * grid / 2
  });
}

function checkBoudningBox(e) {
  var obj = e.target;

  if (!obj) {
    return;
  }

  obj.setCoords();
  var objBoundingBox = obj.getBoundingRect();

  if (objBoundingBox.top < 0) {
    obj.set('top', 0);
    obj.setCoords();
  }

  if (objBoundingBox.left > canvas.width - objBoundingBox.width) {
    obj.set('left', canvas.width - objBoundingBox.width);
    obj.setCoords();
  }

  if (objBoundingBox.top > canvas.height - objBoundingBox.height) {
    obj.set('top', canvas.height - objBoundingBox.height);
    obj.setCoords();
  }

  if (objBoundingBox.left < 0) {
    obj.set('left', 0);
    obj.setCoords();
  }
}

function sendLinesToBack() {
  canvas.getObjects().map(function (o) {
    if (o.name === 'line') {
      canvas.sendToBack(o);
    }
  });
}

document.querySelectorAll('.rectangle')[0].addEventListener('click', function () {
  var o = addRect(0, 0, 60, 60);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.circle')[0].addEventListener('click', function () {
  var o = addCircle(0, 0, 30);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.triangle')[0].addEventListener('click', function () {
  var o = addTriangle(0, 0, 30);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.chair')[0].addEventListener('click', function () {
  var o = addChair(0, 0);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.bar')[0].addEventListener('click', function () {
  var o = addBar(0, 0, 180, 60);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.wall')[0].addEventListener('click', function () {
  var o = addWall(0, 0, 60, 180);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.remove')[0].addEventListener('click', function () {
  var o = canvas.getActiveObject();

  if (o) {
    // o.remove();
    canvas.remove(o);
    canvas.discardActiveObject();
    canvas.renderAll();
  }
});
document.querySelectorAll('.customer-mode')[0].addEventListener('click', function () {
  canvas.getObjects().map(function (o) {
    o.hasControls = false;
    o.lockMovementX = true;
    o.lockMovementY = true;

    if (o.name === 'chair' || o.name === 'bar' || o.name === 'wall') {
      o.selectable = false;
    }

    o.borderColor = '#38A62E';
    o.borderScaleFactor = 2.5;
  });
  canvas.selection = false;
  canvas.hoverCursor = 'pointer';
  canvas.discardActiveObject();
  canvas.renderAll();
  document.querySelectorAll('.admin-menu')[0].style.display = 'none';
  document.querySelectorAll('.customer-menu')[0].style.display = 'block';
}); // document
//     .querySelectorAll('.admin-mode')[0]
//     .addEventListener('click', function () {
//         canvas.getObjects().map((o) => {
//             o.hasControls = true;
//             o.lockMovementX = false;
//             o.lockMovementY = false;
//             if (o.name === 'chair' || o.name === 'bar' || o.name === 'wall') {
//                 o.selectable = true;
//             }
//             o.borderColor = 'rgba(102, 153, 255, 0.75)';
//             o.borderScaleFactor = 1;
//         });
//         canvas.selection = true;
//         canvas.hoverCursor = 'move';
//         canvas.discardActiveObject();
//         canvas.renderAll();
//         document.querySelectorAll('.admin-menu')[0].style.display = 'block';
//         document.querySelectorAll('.customer-menu')[0].style.display = 'none';
//     });

canvas.getObjects().map(function (o) {
  o.hasControls = true;
  o.lockMovementX = false;
  o.lockMovementY = false;

  if (o.name === 'chair' || o.name === 'bar' || o.name === 'wall') {
    o.selectable = true;
  }

  o.borderColor = 'rgba(102, 153, 255, 0.75)';
  o.borderScaleFactor = 1;
});
canvas.selection = true;
canvas.hoverCursor = 'move';
canvas.discardActiveObject();
canvas.renderAll();
document.querySelectorAll('.admin-menu')[0].style.display = 'block'; // document.querySelectorAll('.customer-menu')[0].style.display = 'none';
// function formatTime(val) {
//     const hours = Math.floor(val / 60);
//     const minutes = val % 60;
//     const englishHours = hours > 12 ? hours - 12 : hours;
//     const normal = hours + ':' + minutes + (minutes === 0 ? '0' : '');
//     const english =
//         englishHours +
//         ':' +
//         minutes +
//         (minutes === 0 ? '0' : '') +
//         ' ' +
//         (hours > 12 ? 'PM' : 'AM');
//     return normal + ' (' + english + ')';
// }
// document.querySelectorAll('.submit')[0].addEventListener('click', function () {
//     const obj = canvas.getActiveObject();
//     $('#modal').modal('show');
//     let modalText = 'You have not selected anything';
//     if (obj) {
//         modalText =
//             'You have selected table ' +
//             obj.number +
//             ', time: ' +
//             formatTime(slider.noUiSlider.get());
//     }
//     document.querySelectorAll('#modal-table-id')[0].innerHTML = modalText;
// });
// const slider = document.getElementById('slider');
// noUiSlider.create(slider, {
//     start: 1200,
//     step: 15,
//     connect: 'lower',
//     range: {
//         min: 0,
//         max: 1425,
//     },
// });
// const sliderValue = document.getElementById('slider-value');
// slider.noUiSlider.on('update', function (values, handle) {
//     sliderValue.innerHTML = formatTime(values[handle]);
// });

function addDefaultObjects() {
  addChair(15, 105);
  addChair(15, 135);
  addChair(75, 105);
  addChair(75, 135);
  addChair(225, 75);
  addChair(255, 75);
  addChair(225, 135);
  addChair(255, 135);
  addChair(225, 195);
  addChair(255, 195);
  addChair(225, 255);
  addChair(255, 255);
  addChair(15, 195);
  addChair(45, 195);
  addChair(15, 255);
  addChair(45, 255);
  addChair(15, 315);
  addChair(45, 315);
  addChair(15, 375);
  addChair(45, 375);
  addChair(225, 315);
  addChair(255, 315);
  addChair(225, 375);
  addChair(255, 375);
  addChair(15, 435);
  addChair(15, 495);
  addChair(15, 555);
  addChair(15, 615);
  addChair(225, 615);
  addChair(255, 615);
  addChair(195, 495);
  addChair(195, 525);
  addChair(255, 495);
  addChair(255, 525);
  addChair(225, 675);
  addChair(255, 675);
  addRect(30, 90, 60, 90);
  addRect(210, 90, 90, 60);
  addRect(210, 210, 90, 60);
  addRect(0, 210, 90, 60);
  addRect(0, 330, 90, 60);
  addRect(210, 330, 90, 60);
  addRect(0, 450, 60, 60);
  addRect(0, 570, 60, 60);
  addRect(210, 480, 60, 90);
  addRect(210, 630, 90, 60);
  addBar(120, 0, 180, 60);
  addWall(120, 510, 60, 60);
} // addDefaultObjects();


var totalTables = 0;

function controlNumbering(json_canvas) {
  for (var i = 0; i < json_canvas.objects.length; i++) {
    // console.log(json_canvas.objects[i]);
    if (json_canvas.objects[i].type == 'group') {
      if (parseInt(json_canvas.objects[i].objects[1].text)) {
        console.log(json_canvas.objects[i].objects[1].text);
        totalTables++;
        localStorage.setItem('totalTables', totalTables);
      }
    }
  }

  totalTables = 0;
  return json_canvas;
}

document.getElementById('save').addEventListener('click', function () {
  var json_canvas = canvas.toJSON();
  json_canvas = controlNumbering(json_canvas);
  localStorage.setItem('json_canvas', JSON.stringify(json_canvas));
  localStorage.setItem('heightEl', heightEl.value);
  localStorage.setItem('widthEl', widthEl.value);
}); // canvas.clear();

function canvasLoader() {
  var json = JSON.parse(localStorage.getItem('json_canvas'));
  canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
}

canvasLoader();
sendLinesToBack();

/***/ }),

/***/ "./node_modules/fabric/dist/fabric.js":
/*!********************************************!*\
  !*** ./node_modules/fabric/dist/fabric.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* build: `node build.js modules=ALL exclude=gestures,accessors requirejs minifier=uglifyjs` */
/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

var fabric = fabric || { version: '4.3.1' };
if (true) {
  exports.fabric = fabric;
}
/* _AMD_START_ */
else {}
/* _AMD_END_ */
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  if (document instanceof (typeof HTMLDocument !== 'undefined' ? HTMLDocument : Document)) {
    fabric.document = document;
  }
  else {
    fabric.document = document.implementation.createHTMLDocument('');
  }
  fabric.window = window;
}
else {
  // assume we're running under node.js when document/window are not present
  var jsdom = __webpack_require__(/*! jsdom */ "?3216");
  var virtualWindow = new jsdom.JSDOM(
    decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
    {
      features: {
        FetchExternalResources: ['img']
      },
      resources: 'usable'
    }).window;
  fabric.document = virtualWindow.document;
  fabric.jsdomImplForWrapper = __webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ "?aa72").implForWrapper;
  fabric.nodeCanvas = __webpack_require__(/*! jsdom/lib/jsdom/utils */ "?c310").Canvas;
  fabric.window = virtualWindow;
  DOMParser = fabric.window.DOMParser;
}

/**
 * True when in environment that supports touch events
 * @type boolean
 */
fabric.isTouchSupported = 'ontouchstart' in fabric.window || 'ontouchstart' in fabric.document ||
  (fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0);

/**
 * True when in environment that's probably Node.js
 * @type boolean
 */
fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                      typeof window === 'undefined';

/* _FROM_SVG_START_ */
/**
 * Attributes parsed from all SVG elements
 * @type array
 */
fabric.SHARED_ATTRIBUTES = [
  'display',
  'transform',
  'fill', 'fill-opacity', 'fill-rule',
  'opacity',
  'stroke', 'stroke-dasharray', 'stroke-linecap', 'stroke-dashoffset',
  'stroke-linejoin', 'stroke-miterlimit',
  'stroke-opacity', 'stroke-width',
  'id', 'paint-order', 'vector-effect',
  'instantiated_by_use', 'clip-path',
];
/* _FROM_SVG_END_ */

/**
 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
 */
fabric.DPI = 96;
fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)';
fabric.commaWsp = '(?:\\s+,?\\s*|,\\s*)';
fabric.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig;
fabric.reNonWord = /[ \n\.,;!\?\-]/;
fabric.fontPaths = { };
fabric.iMatrix = [1, 0, 0, 1, 0, 0];
fabric.svgNS = 'http://www.w3.org/2000/svg';

/**
 * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.perfLimitSizeTotal = 2097152;

/**
 * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.maxCacheSideLimit = 4096;

/**
 * Lowest pixel limit for cache canvases, set at 256PX
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.minCacheSideLimit = 256;

/**
 * Cache Object for widths of chars in text rendering.
 */
fabric.charWidthsCache = { };

/**
 * if webgl is enabled and available, textureSize will determine the size
 * of the canvas backend
 * @since 2.0.0
 * @type Number
 * @default
 */
fabric.textureSize = 2048;

/**
 * When 'true', style information is not retained when copy/pasting text, making
 * pasted text use destination style.
 * Defaults to 'false'.
 * @type Boolean
 * @default
 */
fabric.disableStyleCopyPaste = false;

/**
 * Enable webgl for filtering picture is available
 * A filtering backend will be initialized, this will both take memory and
 * time since a default 2048x2048 canvas will be created for the gl context
 * @since 2.0.0
 * @type Boolean
 * @default
 */
fabric.enableGLFiltering = true;

/**
 * Device Pixel Ratio
 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
 */
fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                          fabric.window.webkitDevicePixelRatio ||
                          fabric.window.mozDevicePixelRatio ||
                          1;
/**
 * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,
 * which is unitless and not rendered equally across browsers.
 *
 * Values that work quite well (as of October 2017) are:
 * - Chrome: 1.5
 * - Edge: 1.75
 * - Firefox: 0.9
 * - Safari: 0.95
 *
 * @since 2.0.0
 * @type Number
 * @default 1
 */
fabric.browserShadowBlurConstant = 1;

/**
 * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.arcToSegmentsCache = { };

/**
 * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.
 * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing
 * you do not get any speed benefit and you get a big object in memory.
 * The object was a private variable before, while now is appended to the lib so that you have access to it and you
 * can eventually clear it.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.boundsOfCurveCache = { };

/**
 * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better
 * @default true
 */
fabric.cachesBoundsOfCurve = true;

/**
 * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on
 * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true
 * this has to be set before instantiating the filtering backend ( before filtering the first image )
 * @type Boolean
 * @default false
 */
fabric.forceGLPutImageData = false;

fabric.initFilterBackend = function() {
  if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
    console.log('max texture size: ' + fabric.maxTextureSize);
    return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
  }
  else if (fabric.Canvas2dFilterBackend) {
    return (new fabric.Canvas2dFilterBackend());
  }
};


if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
  window.fabric = fabric;
}


(function() {

  /**
   * @private
   * @param {String} eventName
   * @param {Function} handler
   */
  function _removeEventListener(eventName, handler) {
    if (!this.__eventListeners[eventName]) {
      return;
    }
    var eventListener = this.__eventListeners[eventName];
    if (handler) {
      eventListener[eventListener.indexOf(handler)] = false;
    }
    else {
      fabric.util.array.fill(eventListener, false);
    }
  }

  /**
   * Observes specified event
   * @memberOf fabric.Observable
   * @alias on
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
   * @return {Self} thisArg
   * @chainable
   */
  function on(eventName, handler) {
    if (!this.__eventListeners) {
      this.__eventListeners = { };
    }
    // one object with key/value pairs was passed
    if (arguments.length === 1) {
      for (var prop in eventName) {
        this.on(prop, eventName[prop]);
      }
    }
    else {
      if (!this.__eventListeners[eventName]) {
        this.__eventListeners[eventName] = [];
      }
      this.__eventListeners[eventName].push(handler);
    }
    return this;
  }

  /**
   * Stops event observing for a particular event handler. Calling this method
   * without arguments removes all handlers for all events
   * @memberOf fabric.Observable
   * @alias off
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function to be deleted from EventListeners
   * @return {Self} thisArg
   * @chainable
   */
  function off(eventName, handler) {
    if (!this.__eventListeners) {
      return this;
    }

    // remove all key/value pairs (event name -> event handler)
    if (arguments.length === 0) {
      for (eventName in this.__eventListeners) {
        _removeEventListener.call(this, eventName);
      }
    }
    // one object with key/value pairs was passed
    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
      for (var prop in eventName) {
        _removeEventListener.call(this, prop, eventName[prop]);
      }
    }
    else {
      _removeEventListener.call(this, eventName, handler);
    }
    return this;
  }

  /**
   * Fires event with an optional options object
   * @memberOf fabric.Observable
   * @param {String} eventName Event name to fire
   * @param {Object} [options] Options object
   * @return {Self} thisArg
   * @chainable
   */
  function fire(eventName, options) {
    if (!this.__eventListeners) {
      return this;
    }

    var listenersForEvent = this.__eventListeners[eventName];
    if (!listenersForEvent) {
      return this;
    }

    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
    }
    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
      return value !== false;
    });
    return this;
  }

  /**
   * @namespace fabric.Observable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
   * @see {@link http://fabricjs.com/events|Events demo}
   */
  fabric.Observable = {
    fire: fire,
    on: on,
    off: off,
  };
})();


/**
 * @namespace fabric.Collection
 */
fabric.Collection = {

  _objects: [],

  /**
   * Adds objects to collection, Canvas or Group, then renders canvas
   * (if `renderOnAddRemove` is not `false`).
   * in case of Group no changes to bounding box are made.
   * Objects should be instances of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the add method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  add: function () {
    this._objects.push.apply(this._objects, arguments);
    if (this._onObjectAdded) {
      for (var i = 0, length = arguments.length; i < length; i++) {
        this._onObjectAdded(arguments[i]);
      }
    }
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
   * An object should be an instance of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the insertAt method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {Object} object Object to insert
   * @param {Number} index Index to insert object at
   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
   * @return {Self} thisArg
   * @chainable
   */
  insertAt: function (object, index, nonSplicing) {
    var objects = this._objects;
    if (nonSplicing) {
      objects[index] = object;
    }
    else {
      objects.splice(index, 0, object);
    }
    this._onObjectAdded && this._onObjectAdded(object);
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  remove: function() {
    var objects = this._objects,
        index, somethingRemoved = false;

    for (var i = 0, length = arguments.length; i < length; i++) {
      index = objects.indexOf(arguments[i]);

      // only call onObjectRemoved if an object was actually removed
      if (index !== -1) {
        somethingRemoved = true;
        objects.splice(index, 1);
        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
      }
    }

    this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
    return this;
  },

  /**
   * Executes given function for each object in this group
   * @param {Function} callback
   *                   Callback invoked with current object as first argument,
   *                   index - as second and an array of all objects - as third.
   *                   Callback is invoked in a context of Global Object (e.g. `window`)
   *                   when no `context` argument is given
   *
   * @param {Object} context Context (aka thisObject)
   * @return {Self} thisArg
   * @chainable
   */
  forEachObject: function(callback, context) {
    var objects = this.getObjects();
    for (var i = 0, len = objects.length; i < len; i++) {
      callback.call(context, objects[i], i, objects);
    }
    return this;
  },

  /**
   * Returns an array of children objects of this instance
   * Type parameter introduced in 1.3.10
   * since 2.3.5 this method return always a COPY of the array;
   * @param {String} [type] When specified, only objects of this type are returned
   * @return {Array}
   */
  getObjects: function(type) {
    if (typeof type === 'undefined') {
      return this._objects.concat();
    }
    return this._objects.filter(function(o) {
      return o.type === type;
    });
  },

  /**
   * Returns object at specified index
   * @param {Number} index
   * @return {Self} thisArg
   */
  item: function (index) {
    return this._objects[index];
  },

  /**
   * Returns true if collection contains no objects
   * @return {Boolean} true if collection is empty
   */
  isEmpty: function () {
    return this._objects.length === 0;
  },

  /**
   * Returns a size of a collection (i.e: length of an array containing its objects)
   * @return {Number} Collection size
   */
  size: function() {
    return this._objects.length;
  },

  /**
   * Returns true if collection contains an object
   * @param {Object} object Object to check against
   * @return {Boolean} `true` if collection contains an object
   */
  contains: function(object) {
    return this._objects.indexOf(object) > -1;
  },

  /**
   * Returns number representation of a collection complexity
   * @return {Number} complexity
   */
  complexity: function () {
    return this._objects.reduce(function (memo, current) {
      memo += current.complexity ? current.complexity() : 0;
      return memo;
    }, 0);
  }
};


/**
 * @namespace fabric.CommonMethods
 */
fabric.CommonMethods = {

  /**
   * Sets object's properties from options
   * @param {Object} [options] Options object
   */
  _setOptions: function(options) {
    for (var prop in options) {
      this.set(prop, options[prop]);
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Gradient to
   */
  _initGradient: function(filler, property) {
    if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
      this.set(property, new fabric.Gradient(filler));
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Pattern to
   * @param {Function} [callback] callback to invoke after pattern load
   */
  _initPattern: function(filler, property, callback) {
    if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
      this.set(property, new fabric.Pattern(filler, callback));
    }
    else {
      callback && callback();
    }
  },

  /**
   * @private
   */
  _setObject: function(obj) {
    for (var prop in obj) {
      this._set(prop, obj[prop]);
    }
  },

  /**
   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
   * @param {String|Object} key Property name or object (if object, iterate over the object properties)
   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  set: function(key, value) {
    if (typeof key === 'object') {
      this._setObject(key);
    }
    else {
      this._set(key, value);
    }
    return this;
  },

  _set: function(key, value) {
    this[key] = value;
  },

  /**
   * Toggles specified property from `true` to `false` or from `false` to `true`
   * @param {String} property Property to toggle
   * @return {fabric.Object} thisArg
   * @chainable
   */
  toggle: function(property) {
    var value = this.get(property);
    if (typeof value === 'boolean') {
      this.set(property, !value);
    }
    return this;
  },

  /**
   * Basic getter
   * @param {String} property Property name
   * @return {*} value of a property
   */
  get: function(property) {
    return this[property];
  }
};


(function(global) {

  var sqrt = Math.sqrt,
      atan2 = Math.atan2,
      pow = Math.pow,
      PiBy180 = Math.PI / 180,
      PiBy2 = Math.PI / 2;

  /**
   * @namespace fabric.util
   */
  fabric.util = {

    /**
     * Calculate the cos of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    cos: function(angle) {
      if (angle === 0) { return 1; }
      if (angle < 0) {
        // cos(a) = cos(-a)
        angle = -angle;
      }
      var angleSlice = angle / PiBy2;
      switch (angleSlice) {
        case 1: case 3: return 0;
        case 2: return -1;
      }
      return Math.cos(angle);
    },

    /**
     * Calculate the sin of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    sin: function(angle) {
      if (angle === 0) { return 0; }
      var angleSlice = angle / PiBy2, sign = 1;
      if (angle < 0) {
        // sin(-a) = -sin(a)
        sign = -1;
      }
      switch (angleSlice) {
        case 1: return sign;
        case 2: return 0;
        case 3: return -sign;
      }
      return Math.sin(angle);
    },

    /**
     * Removes value from an array.
     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
     * @static
     * @memberOf fabric.util
     * @param {Array} array
     * @param {*} value
     * @return {Array} original array
     */
    removeFromArray: function(array, value) {
      var idx = array.indexOf(value);
      if (idx !== -1) {
        array.splice(idx, 1);
      }
      return array;
    },

    /**
     * Returns random number between 2 specified ones.
     * @static
     * @memberOf fabric.util
     * @param {Number} min lower limit
     * @param {Number} max upper limit
     * @return {Number} random value (between min and max)
     */
    getRandomInt: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    /**
     * Transforms degrees to radians.
     * @static
     * @memberOf fabric.util
     * @param {Number} degrees value in degrees
     * @return {Number} value in radians
     */
    degreesToRadians: function(degrees) {
      return degrees * PiBy180;
    },

    /**
     * Transforms radians to degrees.
     * @static
     * @memberOf fabric.util
     * @param {Number} radians value in radians
     * @return {Number} value in degrees
     */
    radiansToDegrees: function(radians) {
      return radians / PiBy180;
    },

    /**
     * Rotates `point` around `origin` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {fabric.Point} point The point to rotate
     * @param {fabric.Point} origin The origin of the rotation
     * @param {Number} radians The radians of the angle for the rotation
     * @return {fabric.Point} The new rotated point
     */
    rotatePoint: function(point, origin, radians) {
      point.subtractEquals(origin);
      var v = fabric.util.rotateVector(point, radians);
      return new fabric.Point(v.x, v.y).addEquals(origin);
    },

    /**
     * Rotates `vector` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {Object} vector The vector to rotate (x and y)
     * @param {Number} radians The radians of the angle for the rotation
     * @return {Object} The new rotated point
     */
    rotateVector: function(vector, radians) {
      var sin = fabric.util.sin(radians),
          cos = fabric.util.cos(radians),
          rx = vector.x * cos - vector.y * sin,
          ry = vector.x * sin + vector.y * cos;
      return {
        x: rx,
        y: ry
      };
    },

    /**
     * Apply transform t to point p
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Point} p The point to transform
     * @param  {Array} t The transform
     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
     * @return {fabric.Point} The transformed point
     */
    transformPoint: function(p, t, ignoreOffset) {
      if (ignoreOffset) {
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y,
          t[1] * p.x + t[3] * p.y
        );
      }
      return new fabric.Point(
        t[0] * p.x + t[2] * p.y + t[4],
        t[1] * p.x + t[3] * p.y + t[5]
      );
    },

    /**
     * Returns coordinates of points's bounding rectangle (left, top, width, height)
     * @param {Array} points 4 points array
     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix
     * @return {Object} Object with left, top, width, height properties
     */
    makeBoundingBoxFromPoints: function(points, transform) {
      if (transform) {
        for (var i = 0; i < points.length; i++) {
          points[i] = fabric.util.transformPoint(points[i], transform);
        }
      }
      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
          minX = fabric.util.array.min(xPoints),
          maxX = fabric.util.array.max(xPoints),
          width = maxX - minX,
          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
          minY = fabric.util.array.min(yPoints),
          maxY = fabric.util.array.max(yPoints),
          height = maxY - minY;

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Invert transformation t
     * @static
     * @memberOf fabric.util
     * @param {Array} t The transform
     * @return {Array} The inverted transform
     */
    invertTransform: function(t) {
      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
      r[4] = -o.x;
      r[5] = -o.y;
      return r;
    },

    /**
     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
     * @static
     * @memberOf fabric.util
     * @param {Number|String} number number to operate on
     * @param {Number} fractionDigits number of fraction digits to "leave"
     * @return {Number}
     */
    toFixed: function(number, fractionDigits) {
      return parseFloat(Number(number).toFixed(fractionDigits));
    },

    /**
     * Converts from attribute value to pixel value if applicable.
     * Returns converted pixels or original value not converted.
     * @param {Number|String} value number to operate on
     * @param {Number} fontSize
     * @return {Number|String}
     */
    parseUnit: function(value, fontSize) {
      var unit = /\D{0,2}$/.exec(value),
          number = parseFloat(value);
      if (!fontSize) {
        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }
      switch (unit[0]) {
        case 'mm':
          return number * fabric.DPI / 25.4;

        case 'cm':
          return number * fabric.DPI / 2.54;

        case 'in':
          return number * fabric.DPI;

        case 'pt':
          return number * fabric.DPI / 72; // or * 4 / 3

        case 'pc':
          return number * fabric.DPI / 72 * 12; // or * 16

        case 'em':
          return number * fontSize;

        default:
          return number;
      }
    },

    /**
     * Function which always returns `false`.
     * @static
     * @memberOf fabric.util
     * @return {Boolean}
     */
    falseFunction: function() {
      return false;
    },

    /**
     * Returns klass "Class" object of given namespace
     * @memberOf fabric.util
     * @param {String} type Type of object (eg. 'circle')
     * @param {String} namespace Namespace to get klass "Class" object from
     * @return {Object} klass "Class"
     */
    getKlass: function(type, namespace) {
      // capitalize first letter only
      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
      return fabric.util.resolveNamespace(namespace)[type];
    },

    /**
     * Returns array of attributes for given svg that fabric parses
     * @memberOf fabric.util
     * @param {String} type Type of svg element (eg. 'circle')
     * @return {Array} string names of supported attributes
     */
    getSvgAttributes: function(type) {
      var attributes = [
        'instantiated_by_use',
        'style',
        'id',
        'class'
      ];
      switch (type) {
        case 'linearGradient':
          attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);
          break;
        case 'radialGradient':
          attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);
          break;
        case 'stop':
          attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);
          break;
      }
      return attributes;
    },

    /**
     * Returns object of given namespace
     * @memberOf fabric.util
     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
     * @return {Object} Object for given namespace (default fabric)
     */
    resolveNamespace: function(namespace) {
      if (!namespace) {
        return fabric;
      }

      var parts = namespace.split('.'),
          len = parts.length, i,
          obj = global || fabric.window;

      for (i = 0; i < len; ++i) {
        obj = obj[parts[i]];
      }

      return obj;
    },

    /**
     * Loads image element from given url and passes it to a callback
     * @memberOf fabric.util
     * @param {String} url URL representing an image
     * @param {Function} callback Callback; invoked with loaded image
     * @param {*} [context] Context to invoke callback in
     * @param {Object} [crossOrigin] crossOrigin value to set image element to
     */
    loadImage: function(url, callback, context, crossOrigin) {
      if (!url) {
        callback && callback.call(context, url);
        return;
      }

      var img = fabric.util.createImage();

      /** @ignore */
      var onLoadCallback = function () {
        callback && callback.call(context, img, false);
        img = img.onload = img.onerror = null;
      };

      img.onload = onLoadCallback;
      /** @ignore */
      img.onerror = function() {
        fabric.log('Error loading ' + img.src);
        callback && callback.call(context, null, true);
        img = img.onload = img.onerror = null;
      };

      // data-urls appear to be buggy with crossOrigin
      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
      // see https://code.google.com/p/chromium/issues/detail?id=315152
      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
      // crossOrigin null is the same as not set.
      if (url.indexOf('data') !== 0 &&
        crossOrigin !== undefined &&
        crossOrigin !== null) {
        img.crossOrigin = crossOrigin;
      }

      // IE10 / IE11-Fix: SVG contents from data: URI
      // will only be available if the IMG is present
      // in the DOM (and visible)
      if (url.substring(0,14) === 'data:image/svg') {
        img.onload = null;
        fabric.util.loadImageInDom(img, onLoadCallback);
      }

      img.src = url;
    },

    /**
     * Attaches SVG image with data: URL to the dom
     * @memberOf fabric.util
     * @param {Object} img Image object with data:image/svg src
     * @param {Function} callback Callback; invoked with loaded image
     * @return {Object} DOM element (div containing the SVG image)
     */
    loadImageInDom: function(img, onLoadCallback) {
      var div = fabric.document.createElement('div');
      div.style.width = div.style.height = '1px';
      div.style.left = div.style.top = '-100%';
      div.style.position = 'absolute';
      div.appendChild(img);
      fabric.document.querySelector('body').appendChild(div);
      /**
       * Wrap in function to:
       *   1. Call existing callback
       *   2. Cleanup DOM
       */
      img.onload = function () {
        onLoadCallback();
        div.parentNode.removeChild(div);
        div = null;
      };
    },

    /**
     * Creates corresponding fabric instances from their object representations
     * @static
     * @memberOf fabric.util
     * @param {Array} objects Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * @param {String} namespace Namespace to get klass "Class" object from
     * @param {Function} reviver Method for further parsing of object elements,
     * called after each fabric object created.
     */
    enlivenObjects: function(objects, callback, namespace, reviver) {
      objects = objects || [];

      var enlivenedObjects = [],
          numLoadedObjects = 0,
          numTotalObjects = objects.length;

      function onLoaded() {
        if (++numLoadedObjects === numTotalObjects) {
          callback && callback(enlivenedObjects.filter(function(obj) {
            // filter out undefined objects (objects that gave error)
            return obj;
          }));
        }
      }

      if (!numTotalObjects) {
        callback && callback(enlivenedObjects);
        return;
      }

      objects.forEach(function (o, index) {
        // if sparse array
        if (!o || !o.type) {
          onLoaded();
          return;
        }
        var klass = fabric.util.getKlass(o.type, namespace);
        klass.fromObject(o, function (obj, error) {
          error || (enlivenedObjects[index] = obj);
          reviver && reviver(o, obj, error);
          onLoaded();
        });
      });
    },

    /**
     * Create and wait for loading of patterns
     * @static
     * @memberOf fabric.util
     * @param {Array} patterns Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * called after each fabric object created.
     */
    enlivenPatterns: function(patterns, callback) {
      patterns = patterns || [];

      function onLoaded() {
        if (++numLoadedPatterns === numPatterns) {
          callback && callback(enlivenedPatterns);
        }
      }

      var enlivenedPatterns = [],
          numLoadedPatterns = 0,
          numPatterns = patterns.length;

      if (!numPatterns) {
        callback && callback(enlivenedPatterns);
        return;
      }

      patterns.forEach(function (p, index) {
        if (p && p.source) {
          new fabric.Pattern(p, function(pattern) {
            enlivenedPatterns[index] = pattern;
            onLoaded();
          });
        }
        else {
          enlivenedPatterns[index] = p;
          onLoaded();
        }
      });
    },

    /**
     * Groups SVG elements (usually those retrieved from SVG document)
     * @static
     * @memberOf fabric.util
     * @param {Array} elements SVG elements to group
     * @param {Object} [options] Options object
     * @param {String} path Value to set sourcePath to
     * @return {fabric.Object|fabric.Group}
     */
    groupSVGElements: function(elements, options, path) {
      var object;
      if (elements && elements.length === 1) {
        return elements[0];
      }
      if (options) {
        if (options.width && options.height) {
          options.centerPoint = {
            x: options.width / 2,
            y: options.height / 2
          };
        }
        else {
          delete options.width;
          delete options.height;
        }
      }
      object = new fabric.Group(elements, options);
      if (typeof path !== 'undefined') {
        object.sourcePath = path;
      }
      return object;
    },

    /**
     * Populates an object with properties of another object
     * @static
     * @memberOf fabric.util
     * @param {Object} source Source object
     * @param {Object} destination Destination object
     * @return {Array} properties Properties names to include
     */
    populateWithProperties: function(source, destination, properties) {
      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
        for (var i = 0, len = properties.length; i < len; i++) {
          if (properties[i] in source) {
            destination[properties[i]] = source[properties[i]];
          }
        }
      }
    },

    /**
     * Draws a dashed line between two points
     *
     * This method is used to draw dashed line around selection area.
     * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
     *
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x  start x coordinate
     * @param {Number} y start y coordinate
     * @param {Number} x2 end x coordinate
     * @param {Number} y2 end y coordinate
     * @param {Array} da dash array pattern
     */
    drawDashedLine: function(ctx, x, y, x2, y2, da) {
      var dx = x2 - x,
          dy = y2 - y,
          len = sqrt(dx * dx + dy * dy),
          rot = atan2(dy, dx),
          dc = da.length,
          di = 0,
          draw = true;

      ctx.save();
      ctx.translate(x, y);
      ctx.moveTo(0, 0);
      ctx.rotate(rot);

      x = 0;
      while (len > x) {
        x += da[di++ % dc];
        if (x > len) {
          x = len;
        }
        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
        draw = !draw;
      }

      ctx.restore();
    },

    /**
     * Creates canvas element
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    createCanvasElement: function() {
      return fabric.document.createElement('canvas');
    },

    /**
     * Creates a canvas element that is a copy of another and is also painted
     * @param {CanvasElement} canvas to copy size and content of
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    copyCanvasElement: function(canvas) {
      var newCanvas = fabric.util.createCanvasElement();
      newCanvas.width = canvas.width;
      newCanvas.height = canvas.height;
      newCanvas.getContext('2d').drawImage(canvas, 0, 0);
      return newCanvas;
    },

    /**
     * since 2.6.0 moved from canvas instance to utility.
     * @param {CanvasElement} canvasEl to copy size and content of
     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too
     * @param {Number} quality <= 1 and > 0
     * @static
     * @memberOf fabric.util
     * @return {String} data url
     */
    toDataURL: function(canvasEl, format, quality) {
      return canvasEl.toDataURL('image/' + format, quality);
    },

    /**
     * Creates image element (works on client and node)
     * @static
     * @memberOf fabric.util
     * @return {HTMLImageElement} HTML image element
     */
    createImage: function() {
      return fabric.document.createElement('img');
    },

    /**
     * Multiply matrix A by matrix B to nest transformations
     * @static
     * @memberOf fabric.util
     * @param  {Array} a First transformMatrix
     * @param  {Array} b Second transformMatrix
     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
     * @return {Array} The product of the two transform matrices
     */
    multiplyTransformMatrices: function(a, b, is2x2) {
      // Matrix multiply a * b
      return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
      ];
    },

    /**
     * Decomposes standard 2x3 matrix into transform components
     * @static
     * @memberOf fabric.util
     * @param  {Array} a transformMatrix
     * @return {Object} Components of transform
     */
    qrDecompose: function(a) {
      var angle = atan2(a[1], a[0]),
          denom = pow(a[0], 2) + pow(a[1], 2),
          scaleX = sqrt(denom),
          scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX,
          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
      return {
        angle: angle / PiBy180,
        scaleX: scaleX,
        scaleY: scaleY,
        skewX: skewX / PiBy180,
        skewY: 0,
        translateX: a[4],
        translateY: a[5]
      };
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.angle] angle in degrees
     * @return {Number[]} transform matrix
     */
    calcRotateMatrix: function(options) {
      if (!options.angle) {
        return fabric.iMatrix.concat();
      }
      var theta = fabric.util.degreesToRadians(options.angle),
          cos = fabric.util.cos(theta),
          sin = fabric.util.sin(theta);
      return [cos, sin, -sin, cos, 0, 0];
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet.
     * is called DimensionsTransformMatrix because those properties are the one that influence
     * the size of the resulting box of the object.
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.scaleX]
     * @param  {Number} [options.scaleY]
     * @param  {Boolean} [options.flipX]
     * @param  {Boolean} [options.flipY]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.skewX]
     * @return {Number[]} transform matrix
     */
    calcDimensionsMatrix: function(options) {
      var scaleX = typeof options.scaleX === 'undefined' ? 1 : options.scaleX,
          scaleY = typeof options.scaleY === 'undefined' ? 1 : options.scaleY,
          scaleMatrix = [
            options.flipX ? -scaleX : scaleX,
            0,
            0,
            options.flipY ? -scaleY : scaleY,
            0,
            0],
          multiply = fabric.util.multiplyTransformMatrices,
          degreesToRadians = fabric.util.degreesToRadians;
      if (options.skewX) {
        scaleMatrix = multiply(
          scaleMatrix,
          [1, 0, Math.tan(degreesToRadians(options.skewX)), 1],
          true);
      }
      if (options.skewY) {
        scaleMatrix = multiply(
          scaleMatrix,
          [1, Math.tan(degreesToRadians(options.skewY)), 0, 1],
          true);
      }
      return scaleMatrix;
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.angle]
     * @param  {Number} [options.scaleX]
     * @param  {Number} [options.scaleY]
     * @param  {Boolean} [options.flipX]
     * @param  {Boolean} [options.flipY]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.translateX]
     * @param  {Number} [options.translateY]
     * @return {Number[]} transform matrix
     */
    composeMatrix: function(options) {
      var matrix = [1, 0, 0, 1, options.translateX || 0, options.translateY || 0],
          multiply = fabric.util.multiplyTransformMatrices;
      if (options.angle) {
        matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));
      }
      if (options.scaleX !== 1 || options.scaleY !== 1 ||
          options.skewX || options.skewY || options.flipX || options.flipY) {
        matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));
      }
      return matrix;
    },

    /**
     * reset an object transform state to neutral. Top and left are not accounted for
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to transform
     */
    resetObjectTransform: function (target) {
      target.scaleX = 1;
      target.scaleY = 1;
      target.skewX = 0;
      target.skewY = 0;
      target.flipX = false;
      target.flipY = false;
      target.rotate(0);
    },

    /**
     * Extract Object transform values
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to read from
     * @return {Object} Components of transform
     */
    saveObjectTransform: function (target) {
      return {
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        skewX: target.skewX,
        skewY: target.skewY,
        angle: target.angle,
        left: target.left,
        flipX: target.flipX,
        flipY: target.flipY,
        top: target.top
      };
    },

    /**
     * Returns true if context has transparent pixel
     * at specified location (taking tolerance into account)
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x x coordinate
     * @param {Number} y y coordinate
     * @param {Number} tolerance Tolerance
     */
    isTransparent: function(ctx, x, y, tolerance) {

      // If tolerance is > 0 adjust start coords to take into account.
      // If moves off Canvas fix to 0
      if (tolerance > 0) {
        if (x > tolerance) {
          x -= tolerance;
        }
        else {
          x = 0;
        }
        if (y > tolerance) {
          y -= tolerance;
        }
        else {
          y = 0;
        }
      }

      var _isTransparent = true, i, temp,
          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
          l = imageData.data.length;

      // Split image data - for tolerance > 1, pixelDataSize = 4;
      for (i = 3; i < l; i += 4) {
        temp = imageData.data[i];
        _isTransparent = temp <= 0;
        if (_isTransparent === false) {
          break; // Stop if colour found
        }
      }

      imageData = null;

      return _isTransparent;
    },

    /**
     * Parse preserveAspectRatio attribute from element
     * @param {string} attribute to be parsed
     * @return {Object} an object containing align and meetOrSlice attribute
     */
    parsePreserveAspectRatioAttribute: function(attribute) {
      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
          aspectRatioAttrs = attribute.split(' '), align;

      if (aspectRatioAttrs && aspectRatioAttrs.length) {
        meetOrSlice = aspectRatioAttrs.pop();
        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
          align = meetOrSlice;
          meetOrSlice = 'meet';
        }
        else if (aspectRatioAttrs.length) {
          align = aspectRatioAttrs.pop();
        }
      }
      //divide align in alignX and alignY
      alignX = align !== 'none' ? align.slice(1, 4) : 'none';
      alignY = align !== 'none' ? align.slice(5, 8) : 'none';
      return {
        meetOrSlice: meetOrSlice,
        alignX: alignX,
        alignY: alignY
      };
    },

    /**
     * Clear char widths cache for the given font family or all the cache if no
     * fontFamily is specified.
     * Use it if you know you are loading fonts in a lazy way and you are not waiting
     * for custom fonts to load properly when adding text objects to the canvas.
     * If a text object is added when its own font is not loaded yet, you will get wrong
     * measurement and so wrong bounding boxes.
     * After the font cache is cleared, either change the textObject text content or call
     * initDimensions() to trigger a recalculation
     * @memberOf fabric.util
     * @param {String} [fontFamily] font family to clear
     */
    clearFabricFontCache: function(fontFamily) {
      fontFamily = (fontFamily || '').toLowerCase();
      if (!fontFamily) {
        fabric.charWidthsCache = { };
      }
      else if (fabric.charWidthsCache[fontFamily]) {
        delete fabric.charWidthsCache[fontFamily];
      }
    },

    /**
     * Given current aspect ratio, determines the max width and height that can
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Number} ar aspect ratio
     * @param {Number} maximumArea Maximum area you want to achieve
     * @return {Object.x} Limited dimensions by X
     * @return {Object.y} Limited dimensions by Y
     */
    limitDimsByArea: function(ar, maximumArea) {
      var roughWidth = Math.sqrt(maximumArea * ar),
          perfLimitSizeY = Math.floor(maximumArea / roughWidth);
      return { x: Math.floor(roughWidth), y: perfLimitSizeY };
    },

    capValue: function(min, value, max) {
      return Math.max(min, Math.min(value, max));
    },

    /**
     * Finds the scale for the object source to fit inside the object destination,
     * keeping aspect ratio intact.
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Object | fabric.Object} source
     * @param {Number} source.height natural unscaled height of the object
     * @param {Number} source.width natural unscaled width of the object
     * @param {Object | fabric.Object} destination
     * @param {Number} destination.height natural unscaled height of the object
     * @param {Number} destination.width natural unscaled width of the object
     * @return {Number} scale factor to apply to source to fit into destination
     */
    findScaleToFit: function(source, destination) {
      return Math.min(destination.width / source.width, destination.height / source.height);
    },

    /**
     * Finds the scale for the object source to cover entirely the object destination,
     * keeping aspect ratio intact.
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Object | fabric.Object} source
     * @param {Number} source.height natural unscaled height of the object
     * @param {Number} source.width natural unscaled width of the object
     * @param {Object | fabric.Object} destination
     * @param {Number} destination.height natural unscaled height of the object
     * @param {Number} destination.width natural unscaled width of the object
     * @return {Number} scale factor to apply to source to cover destination
     */
    findScaleToCover: function(source, destination) {
      return Math.max(destination.width / source.width, destination.height / source.height);
    },

    /**
     * given an array of 6 number returns something like `"matrix(...numbers)"`
     * @memberOf fabric.util
     * @param {Array} transform an array with 6 numbers
     * @return {String} transform matrix for svg
     * @return {Object.y} Limited dimensions by Y
     */
    matrixToSVG: function(transform) {
      return 'matrix(' + transform.map(function(value) {
        return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);
      }).join(' ') + ')';
    },

    /**
     * given a width and height, return the size of the bounding box
     * that can contains the box with width/height with applied transform
     * described in options.
     * Use to calculate the boxes around objects for controls.
     * @memberOf fabric.util
     * @param {Number} width
     * @param {Number} height
     * @param {Object} options
     * @param {Number} options.scaleX
     * @param {Number} options.scaleY
     * @param {Number} options.skewX
     * @param {Number} options.skewY
     * @return {Object.x} width of containing
     * @return {Object.y} height of containing
     */
    sizeAfterTransform: function(width, height, options) {
      var dimX = width / 2, dimY = height / 2,
          points = [
            {
              x: -dimX,
              y: -dimY
            },
            {
              x: dimX,
              y: -dimY
            },
            {
              x: -dimX,
              y: dimY
            },
            {
              x: dimX,
              y: dimY
            }],
          transformMatrix = fabric.util.calcDimensionsMatrix(options),
          bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);
      return {
        x: bbox.width,
        y: bbox.height,
      };
    }
  };
})( true ? exports : 0);


(function() {
  var _join = Array.prototype.join,
      commandLengths = {
        m: 2,
        l: 2,
        h: 1,
        v: 1,
        c: 6,
        s: 4,
        q: 4,
        t: 2,
        a: 7
      },
      repeatedCommands = {
        m: 'l',
        M: 'L'
      };
  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
    var costh2 = fabric.util.cos(th2),
        sinth2 = fabric.util.sin(th2),
        costh3 = fabric.util.cos(th3),
        sinth3 = fabric.util.sin(th3),
        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

    return ['C',
      cp1X, cp1Y,
      cp2X, cp2Y,
      toX, toY
    ];
  }

  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
   * http://mozilla.org/MPL/2.0/
   */
  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
    var PI = Math.PI, th = rotateX * PI / 180,
        sinTh = fabric.util.sin(th),
        cosTh = fabric.util.cos(th),
        fromX = 0, fromY = 0;

    rx = Math.abs(rx);
    ry = Math.abs(ry);

    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
        root = 0;

    if (pl < 0) {
      var s = Math.sqrt(1 - pl / (rx2 * ry2));
      rx *= s;
      ry *= s;
    }
    else {
      root = (large === sweep ? -1.0 : 1.0) *
              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
    }

    var cx = root * rx * py / ry,
        cy = -root * ry * px / rx,
        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

    if (sweep === 0 && dtheta > 0) {
      dtheta -= 2 * PI;
    }
    else if (sweep === 1 && dtheta < 0) {
      dtheta += 2 * PI;
    }

    // Convert into cubic bezier segments <= 90deg
    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
        result = [], mDelta = dtheta / segments,
        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
        th3 = mTheta + mDelta;

    for (var i = 0; i < segments; i++) {
      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
      fromX = result[i][5];
      fromY = result[i][6];
      mTheta = th3;
      th3 += mDelta;
    }
    return result;
  }

  /*
   * Private
   */
  function calcVectorAngle(ux, uy, vx, vy) {
    var ta = Math.atan2(uy, ux),
        tb = Math.atan2(vy, vx);
    if (tb >= ta) {
      return tb - ta;
    }
    else {
      return 2 * Math.PI - (ta - tb);
    }
  }

  /**
   * Calculate bounding box of a beziercurve
   * @param {Number} x0 starting point
   * @param {Number} y0
   * @param {Number} x1 first control point
   * @param {Number} y1
   * @param {Number} x2 secondo control point
   * @param {Number} y2
   * @param {Number} x3 end of bezier
   * @param {Number} y3
   */
  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
  // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?
  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
    var argsString;
    if (fabric.cachesBoundsOfCurve) {
      argsString = _join.call(arguments);
      if (fabric.boundsOfCurveCache[argsString]) {
        return fabric.boundsOfCurveCache[argsString];
      }
    }

    var sqrt = Math.sqrt,
        min = Math.min, max = Math.max,
        abs = Math.abs, tvalues = [],
        bounds = [[], []],
        a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    b = 6 * x0 - 12 * x1 + 6 * x2;
    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
    c = 3 * x1 - 3 * x0;

    for (var i = 0; i < 2; ++i) {
      if (i > 0) {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (abs(a) < 1e-12) {
        if (abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      if (b2ac < 0) {
        continue;
      }
      sqrtb2ac = sqrt(b2ac);
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    var x, y, j = tvalues.length, jlen = j, mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
      bounds[0][j] = x;

      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
      bounds[1][j] = y;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    var result = [
      {
        x: min.apply(null, bounds[0]),
        y: min.apply(null, bounds[1])
      },
      {
        x: max.apply(null, bounds[0]),
        y: max.apply(null, bounds[1])
      }
    ];
    if (fabric.cachesBoundsOfCurve) {
      fabric.boundsOfCurveCache[argsString] = result;
    }
    return result;
  }

  /**
   * Converts arc to a bunch of bezier curves
   * @param {Number} fx starting point x
   * @param {Number} fy starting point y
   * @param {Array} coords Arc command
   */
  function fromArcToBeziers(fx, fy, coords) {
    var rx = coords[1],
        ry = coords[2],
        rot = coords[3],
        large = coords[4],
        sweep = coords[5],
        tx = coords[6],
        ty = coords[7],
        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segsNorm.length; i < len; i++) {
      segsNorm[i][1] += fx;
      segsNorm[i][2] += fy;
      segsNorm[i][3] += fx;
      segsNorm[i][4] += fy;
      segsNorm[i][5] += fx;
      segsNorm[i][6] += fy;
    }
    return segsNorm;
  };

  /**
   * This function take a parsed SVG path and make it simpler for fabricJS logic.
   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )
   * S converted in C, T converted in Q, A converted in C.
   * @param {Array} path the array of commands of a parsed svg path for fabric.Path
   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path
   */
  function makePathSimpler(path) {
    // x and y represent the last point of the path. the previous command point.
    // we add them to each relative command to make it an absolute comment.
    // we also swap the v V h H with L, because are easier to transform.
    var x = 0, y = 0, len = path.length,
        // x1 and y1 represent the last point of the subpath. the subpath is started with
        // m or M command. When a z or Z command is drawn, x and y need to be resetted to
        // the last x1 and y1.
        x1 = 0, y1 = 0, current, i, converted,
        // previous will host the letter of the previous command, to handle S and T.
        // controlX and controlY will host the previous reflected control point
        destinationPath = [], previous, controlX, controlY;
    for (i = 0; i < len; ++i) {
      converted = false;
      current = path[i].slice(0);
      switch (current[0]) { // first letter
        case 'l': // lineto, relative
          current[0] = 'L';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'L':
          x = current[1];
          y = current[2];
          break;
        case 'h': // horizontal lineto, relative
          current[1] += x;
          // falls through
        case 'H':
          current[0] = 'L';
          current[2] = y;
          x = current[1];
          break;
        case 'v': // vertical lineto, relative
          current[1] += y;
          // falls through
        case 'V':
          current[0] = 'L';
          y = current[1];
          current[1] = x;
          current[2] = y;
          break;
        case 'm': // moveTo, relative
          current[0] = 'M';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'M':
          x = current[1];
          y = current[2];
          x1 = current[1];
          y1 = current[2];
          break;
        case 'c': // bezierCurveTo, relative
          current[0] = 'C';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          current[5] += x;
          current[6] += y;
          // falls through
        case 'C':
          controlX = current[3];
          controlY = current[4];
          x = current[5];
          y = current[6];
          break;
        case 's': // shorthand cubic bezierCurveTo, relative
          current[0] = 'S';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          // falls through
        case 'S':
          // would be sScC but since we are swapping sSc for C, we check just that.
          if (previous === 'C') {
            // calculate reflection of previous control points
            controlX = 2 * x - controlX;
            controlY = 2 * y - controlY;
          }
          else {
            // If there is no previous command or if the previous command was not a C, c, S, or s,
            // the control point is coincident with the current point
            controlX = x;
            controlY = y;
          }
          x = current[3];
          y = current[4];
          current[0] = 'C';
          current[5] = current[3];
          current[6] = current[4];
          current[3] = current[1];
          current[4] = current[2];
          current[1] = controlX;
          current[2] = controlY;
          // current[3] and current[4] are NOW the second control point.
          // we keep it for the next reflection.
          controlX = current[3];
          controlY = current[4];
          break;
        case 'q': // quadraticCurveTo, relative
          current[0] = 'Q';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          // falls through
        case 'Q':
          controlX = current[1];
          controlY = current[2];
          x = current[3];
          y = current[4];
          break;
        case 't': // shorthand quadraticCurveTo, relative
          current[0] = 'T';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'T':
          if (previous === 'Q') {
            // calculate reflection of previous control point
            controlX = 2 * x - controlX;
            controlY = 2 * y - controlY;
          }
          else {
            // If there is no previous command or if the previous command was not a Q, q, T or t,
            // assume the control point is coincident with the current point
            controlX = x;
            controlY = y;
          }
          current[0] = 'Q';
          x = current[1];
          y = current[2];
          current[1] = controlX;
          current[2] = controlY;
          current[3] = x;
          current[4] = y;
          break;
        case 'a':
          current[0] = 'A';
          current[6] += x;
          current[7] += y;
          // falls through
        case 'A':
          converted = true;
          destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));
          x = current[6];
          y = current[7];
          break;
        case 'z':
        case 'Z':
          x = x1;
          y = y1;
          break;
        default:
      }
      if (!converted) {
        destinationPath.push(current);
      }
      previous = current[0];
    }
    return destinationPath;
  };

  /**
   * Calc length from point x1,y1 to x2,y2
   * @param {Number} x1 starting point x
   * @param {Number} y1 starting point y
   * @param {Number} x2 starting point x
   * @param {Number} y2 starting point y
   * @return {Number} length of segment
   */
  function calcLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }

  // functions for the Cubic beizer
  // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350
  function CB1(t) {
    return t * t * t;
  }
  function CB2(t) {
    return 3 * t * t * (1 - t);
  }
  function CB3(t) {
    return 3 * t * (1 - t) * (1 - t);
  }
  function CB4(t) {
    return (1 - t) * (1 - t) * (1 - t);
  }

  function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    return function(pct) {
      var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);
      return {
        x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,
        y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4
      };
    };
  }

  function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    return function (pct) {
      var invT = 1 - pct,
          tangentX = (3 * invT * invT * (p2x - p1x)) + (6 * invT * pct * (p3x - p2x)) +
          (3 * pct * pct * (p4x - p3x)),
          tangentY = (3 * invT * invT * (p2y - p1y)) + (6 * invT * pct * (p3y - p2y)) +
          (3 * pct * pct * (p4y - p3y));
      return Math.atan2(tangentY, tangentX);
    };
  }

  function QB1(t) {
    return t * t;
  }

  function QB2(t) {
    return 2 * t * (1 - t);
  }

  function QB3(t) {
    return (1 - t) * (1 - t);
  }

  function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
    return function(pct) {
      var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);
      return {
        x: p3x * c1 + p2x * c2 + p1x * c3,
        y: p3y * c1 + p2y * c2 + p1y * c3
      };
    };
  }

  function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
    return function (pct) {
      var invT = 1 - pct,
          tangentX = (2 * invT * (p2x - p1x)) + (2 * pct * (p3x - p2x)),
          tangentY = (2 * invT * (p2y - p1y)) + (2 * pct * (p3y - p2y));
      return Math.atan2(tangentY, tangentX);
    };
  }


  // this will run over a path segment ( a cubic or quadratic segment) and approximate it
  // with 100 segemnts. This will good enough to calculate the length of the curve
  function pathIterator(iterator, x1, y1) {
    var tempP = { x: x1, y: y1 }, p, tmpLen = 0, perc;
    for (perc = 0.01; perc <= 1; perc += 0.01) {
      p = iterator(perc);
      tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);
      tempP = p;
    }
    return tmpLen;
  }

  /**
   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1
   * that correspond to that pixels run over the path.
   * The percentage will be then used to find the correct point on the canvas for the path.
   * @param {Array} segInfo fabricJS collection of information on a parsed path
   * @param {Number} distance from starting point, in pixels.
   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;
   */
  function findPercentageForDistance(segInfo, distance) {
    var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = { x: segInfo.x, y: segInfo.y },
        p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
    // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100
    // the path
    while (tmpLen < distance && perc <= 1 && nextStep > 0.0001) {
      p = iterator(perc);
      lastPerc = perc;
      nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);
      // compare tmpLen each cycle with distance, decide next perc to test.
      if ((nextLen + tmpLen) > distance) {
        // we discard this step and we make smaller steps.
        nextStep /= 2;
        perc -= nextStep;
      }
      else {
        tempP = p;
        perc += nextStep;
        tmpLen += nextLen;
      }
    }
    p.angle = angleFinder(lastPerc);
    return p;
  }

  /**
   * Run over a parsed and simplifed path and extrac some informations.
   * informations are length of each command and starting point
   * @param {Array} path fabricJS parsed path commands
   * @return {Array} path commands informations
   */
  function getPathSegmentsInfo(path) {
    var totalLength = 0, len = path.length, current,
        //x2 and y2 are the coords of segment start
        //x1 and y1 are the coords of the current point
        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;
    for (var i = 0; i < len; i++) {
      current = path[i];
      tempInfo = {
        x: x1,
        y: y1,
        command: current[0],
      };
      switch (current[0]) { //first letter
        case 'M':
          tempInfo.length = 0;
          x2 = x1 = current[1];
          y2 = y1 = current[2];
          break;
        case 'L':
          tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);
          x1 = current[1];
          y1 = current[2];
          break;
        case 'C':
          iterator = getPointOnCubicBezierIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4],
            current[5],
            current[6]
          );
          angleFinder = getTangentCubicIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4],
            current[5],
            current[6]
          );
          tempInfo.iterator = iterator;
          tempInfo.angleFinder = angleFinder;
          tempInfo.length = pathIterator(iterator, x1, y1);
          x1 = current[5];
          y1 = current[6];
          break;
        case 'Q':
          iterator = getPointOnQuadraticBezierIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4]
          );
          angleFinder = getTangentQuadraticIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4]
          );
          tempInfo.iterator = iterator;
          tempInfo.angleFinder = angleFinder;
          tempInfo.length = pathIterator(iterator, x1, y1);
          x1 = current[3];
          y1 = current[4];
          break;
        case 'Z':
        case 'z':
          // we add those in order to ease calculations later
          tempInfo.destX = x2;
          tempInfo.destY = y2;
          tempInfo.length = calcLineLength(x1, y1, x2, y2);
          x1 = x2;
          y1 = y2;
          break;
      }
      totalLength += tempInfo.length;
      info.push(tempInfo);
    }
    info.push({ length: totalLength, x: x1, y: y1 });
    return info;
  }

  function getPointOnPath(path, distance, infos) {
    if (!infos) {
      infos = getPathSegmentsInfo(path);
    }
    var i = 0;
    while ((distance - infos[i].length > 0) && i < (infos.length - 2)) {
      distance -= infos[i].length;
      i++;
    }
    // var distance = infos[infos.length - 1] * perc;
    var segInfo = infos[i], segPercent = distance / segInfo.length,
        command = segInfo.command, segment = path[i], info;

    switch (command) {
      case 'M':
        return { x: segInfo.x, y: segInfo.y, angle: 0 };
      case 'Z':
      case 'z':
        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
          new fabric.Point(segInfo.destX, segInfo.destY),
          segPercent
        );
        info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);
        return info;
      case 'L':
        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
          new fabric.Point(segment[1], segment[2]),
          segPercent
        );
        info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);
        return info;
      case 'C':
        return findPercentageForDistance(segInfo, distance);
      case 'Q':
        return findPercentageForDistance(segInfo, distance);
    }
  }

  function parsePath(pathString) {
    var result = [],
        coords = [],
        currentPath,
        parsed,
        re = fabric.rePathCommand,
        rNumber = '[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*',
        rNumberCommaWsp = '(' + rNumber + ')' + fabric.commaWsp,
        rFlagCommaWsp = '([01])' + fabric.commaWsp + '?',
        rArcSeq = rNumberCommaWsp + '?' + rNumberCommaWsp + '?' + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp +
          rNumberCommaWsp + '?(' + rNumber + ')',
        regArcArgumentSequence = new RegExp(rArcSeq, 'g'),
        match,
        coordsStr,
        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
        path;
    if (!pathString || !pathString.match) {
      return result;
    }
    path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

    for (var i = 0, coordsParsed, len = path.length; i < len; i++) {
      currentPath = path[i];

      coordsStr = currentPath.slice(1).trim();
      coords.length = 0;

      var command = currentPath.charAt(0);
      coordsParsed = [command];

      if (command.toLowerCase() === 'a') {
        // arcs have special flags that apparently don't require spaces so handle special
        for (var args; (args = regArcArgumentSequence.exec(coordsStr));) {
          for (var j = 1; j < args.length; j++) {
            coords.push(args[j]);
          }
        }
      }
      else {
        while ((match = re.exec(coordsStr))) {
          coords.push(match[0]);
        }
      }

      for (var j = 0, jlen = coords.length; j < jlen; j++) {
        parsed = parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          coordsParsed.push(parsed);
        }
      }

      var commandLength = commandLengths[command.toLowerCase()],
          repeatedCommand = repeatedCommands[command] || command;

      if (coordsParsed.length - 1 > commandLength) {
        for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
          result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
          command = repeatedCommand;
        }
      }
      else {
        result.push(coordsParsed);
      }
    }

    return result;
  };

  /**
   * Calculate bounding box of a elliptic-arc
   * @deprecated
   * @param {Number} fx start point of arc
   * @param {Number} fy
   * @param {Number} rx horizontal radius
   * @param {Number} ry vertical radius
   * @param {Number} rot angle of horizontal axis
   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
   * @param {Number} tx end point of arc
   * @param {Number} ty
   */
  function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

    var fromX = 0, fromY = 0, bound, bounds = [],
        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segs.length; i < len; i++) {
      bound = getBoundsOfCurve(fromX, fromY, segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5], segs[i][6]);
      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
      fromX = segs[i][5];
      fromY = segs[i][6];
    }
    return bounds;
  };

  /**
   * Draws arc
   * @deprecated
   * @param {CanvasRenderingContext2D} ctx
   * @param {Number} fx
   * @param {Number} fy
   * @param {Array} coords coords of the arc, without the front 'A/a'
   */
  function drawArc(ctx, fx, fy, coords) {
    coords = coords.slice(0).unshift('X'); // command A or a does not matter
    var beziers = fromArcToBeziers(fx, fy, coords);
    beziers.forEach(function(bezier) {
      ctx.bezierCurveTo.apply(ctx, bezier.slice(1));
    });
  };

  fabric.util.parsePath = parsePath;
  fabric.util.makePathSimpler = makePathSimpler;
  fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;
  fabric.util.fromArcToBeziers = fromArcToBeziers;
  /**
   * Typo of `fromArcToBeziers` kept for not breaking the api once corrected.
   * Will be removed in fabric 5.0
   * @deprecated
   */
  fabric.util.fromArcToBeizers = fromArcToBeziers;
  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
  fabric.util.getPointOnPath = getPointOnPath;
  // kept because we do not want to make breaking changes.
  // but useless and deprecated.
  fabric.util.getBoundsOfArc = getBoundsOfArc;
  fabric.util.drawArc = drawArc;
})();


(function() {

  var slice = Array.prototype.slice;

  /**
   * Invokes method on all items in a given array
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} method Name of a method to invoke
   * @return {Array}
   */
  function invoke(array, method) {
    var args = slice.call(arguments, 2), result = [];
    for (var i = 0, len = array.length; i < len; i++) {
      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
    }
    return result;
  }

  /**
   * Finds maximum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function max(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 >= value2;
    });
  }

  /**
   * Finds minimum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function min(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 < value2;
    });
  }

  /**
   * @private
   */
  function fill(array, value) {
    var k = array.length;
    while (k--) {
      array[k] = value;
    }
    return array;
  }

  /**
   * @private
   */
  function find(array, byProperty, condition) {
    if (!array || array.length === 0) {
      return;
    }

    var i = array.length - 1,
        result = byProperty ? array[i][byProperty] : array[i];
    if (byProperty) {
      while (i--) {
        if (condition(array[i][byProperty], result)) {
          result = array[i][byProperty];
        }
      }
    }
    else {
      while (i--) {
        if (condition(array[i], result)) {
          result = array[i];
        }
      }
    }
    return result;
  }

  /**
   * @namespace fabric.util.array
   */
  fabric.util.array = {
    fill: fill,
    invoke: invoke,
    min: min,
    max: max
  };

})();


(function() {
  /**
   * Copies all enumerable properties of one js object to another
   * this does not and cannot compete with generic utils.
   * Does not clone or extend fabric.Object subclasses.
   * This is mostly for internal use and has extra handling for fabricJS objects
   * it skips the canvas and group properties in deep cloning.
   * @memberOf fabric.util.object
   * @param {Object} destination Where to copy to
   * @param {Object} source Where to copy from
   * @return {Object}
   */

  function extend(destination, source, deep) {
    // JScript DontEnum bug is not taken care of
    // the deep clone is for internal use, is not meant to avoid
    // javascript traps or cloning html element or self referenced objects.
    if (deep) {
      if (!fabric.isLikelyNode && source instanceof Element) {
        // avoid cloning deep images, canvases,
        destination = source;
      }
      else if (source instanceof Array) {
        destination = [];
        for (var i = 0, len = source.length; i < len; i++) {
          destination[i] = extend({ }, source[i], deep);
        }
      }
      else if (source && typeof source === 'object') {
        for (var property in source) {
          if (property === 'canvas' || property === 'group') {
            // we do not want to clone this props at all.
            // we want to keep the keys in the copy
            destination[property] = null;
          }
          else if (source.hasOwnProperty(property)) {
            destination[property] = extend({ }, source[property], deep);
          }
        }
      }
      else {
        // this sounds odd for an extend but is ok for recursive use
        destination = source;
      }
    }
    else {
      for (var property in source) {
        destination[property] = source[property];
      }
    }
    return destination;
  }

  /**
   * Creates an empty object and copies all enumerable properties of another object to it
   * @memberOf fabric.util.object
   * TODO: this function return an empty object if you try to clone null
   * @param {Object} object Object to clone
   * @return {Object}
   */
  function clone(object, deep) {
    return extend({ }, object, deep);
  }

  /** @namespace fabric.util.object */
  fabric.util.object = {
    extend: extend,
    clone: clone
  };
  fabric.util.object.extend(fabric.util, fabric.Observable);
})();


(function() {

  /**
   * Camelizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to camelize
   * @return {String} Camelized version of a string
   */
  function camelize(string) {
    return string.replace(/-+(.)?/g, function(match, character) {
      return character ? character.toUpperCase() : '';
    });
  }

  /**
   * Capitalizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to capitalize
   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
   * and other letters stay untouched, if false first letter is capitalized
   * and other letters are converted to lowercase.
   * @return {String} Capitalized version of a string
   */
  function capitalize(string, firstLetterOnly) {
    return string.charAt(0).toUpperCase() +
      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
  }

  /**
   * Escapes XML in a string
   * @memberOf fabric.util.string
   * @param {String} string String to escape
   * @return {String} Escaped version of a string
   */
  function escapeXml(string) {
    return string.replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  /**
   * Divide a string in the user perceived single units
   * @memberOf fabric.util.string
   * @param {String} textstring String to escape
   * @return {Array} array containing the graphemes
   */
  function graphemeSplit(textstring) {
    var i = 0, chr, graphemes = [];
    for (i = 0, chr; i < textstring.length; i++) {
      if ((chr = getWholeChar(textstring, i)) === false) {
        continue;
      }
      graphemes.push(chr);
    }
    return graphemes;
  }

  // taken from mdn in the charAt doc page.
  function getWholeChar(str, i) {
    var code = str.charCodeAt(i);

    if (isNaN(code)) {
      return ''; // Position not found
    }
    if (code < 0xD800 || code > 0xDFFF) {
      return str.charAt(i);
    }

    // High surrogate (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 <= code && code <= 0xDBFF) {
      if (str.length <= (i + 1)) {
        throw 'High surrogate without following low surrogate';
      }
      var next = str.charCodeAt(i + 1);
      if (0xDC00 > next || next > 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return str.charAt(i) + str.charAt(i + 1);
    }
    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
    if (i === 0) {
      throw 'Low surrogate without preceding high surrogate';
    }
    var prev = str.charCodeAt(i - 1);

    // (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 > prev || prev > 0xDBFF) {
      throw 'Low surrogate without preceding high surrogate';
    }
    // We can pass over low surrogates now as the second component
    // in a pair which we have already processed
    return false;
  }


  /**
   * String utilities
   * @namespace fabric.util.string
   */
  fabric.util.string = {
    camelize: camelize,
    capitalize: capitalize,
    escapeXml: escapeXml,
    graphemeSplit: graphemeSplit
  };
})();


(function() {

  var slice = Array.prototype.slice, emptyFunction = function() { },

      IS_DONTENUM_BUGGY = (function() {
        for (var p in { toString: 1 }) {
          if (p === 'toString') {
            return false;
          }
        }
        return true;
      })(),

      /** @ignore */
      addMethods = function(klass, source, parent) {
        for (var property in source) {

          if (property in klass.prototype &&
              typeof klass.prototype[property] === 'function' &&
              (source[property] + '').indexOf('callSuper') > -1) {

            klass.prototype[property] = (function(property) {
              return function() {

                var superclass = this.constructor.superclass;
                this.constructor.superclass = parent;
                var returnValue = source[property].apply(this, arguments);
                this.constructor.superclass = superclass;

                if (property !== 'initialize') {
                  return returnValue;
                }
              };
            })(property);
          }
          else {
            klass.prototype[property] = source[property];
          }

          if (IS_DONTENUM_BUGGY) {
            if (source.toString !== Object.prototype.toString) {
              klass.prototype.toString = source.toString;
            }
            if (source.valueOf !== Object.prototype.valueOf) {
              klass.prototype.valueOf = source.valueOf;
            }
          }
        }
      };

  function Subclass() { }

  function callSuper(methodName) {
    var parentMethod = null,
        _this = this;

    // climb prototype chain to find method not equal to callee's method
    while (_this.constructor.superclass) {
      var superClassMethod = _this.constructor.superclass.prototype[methodName];
      if (_this[methodName] !== superClassMethod) {
        parentMethod = superClassMethod;
        break;
      }
      // eslint-disable-next-line
      _this = _this.constructor.superclass.prototype;
    }

    if (!parentMethod) {
      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
    }

    return (arguments.length > 1)
      ? parentMethod.apply(this, slice.call(arguments, 1))
      : parentMethod.call(this);
  }

  /**
   * Helper for creation of "classes".
   * @memberOf fabric.util
   * @param {Function} [parent] optional "Class" to inherit from
   * @param {Object} [properties] Properties shared by all instances of this class
   *                  (be careful modifying objects defined here as this would affect all instances)
   */
  function createClass() {
    var parent = null,
        properties = slice.call(arguments, 0);

    if (typeof properties[0] === 'function') {
      parent = properties.shift();
    }
    function klass() {
      this.initialize.apply(this, arguments);
    }

    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      Subclass.prototype = parent.prototype;
      klass.prototype = new Subclass();
      parent.subclasses.push(klass);
    }
    for (var i = 0, length = properties.length; i < length; i++) {
      addMethods(klass, properties[i], parent);
    }
    if (!klass.prototype.initialize) {
      klass.prototype.initialize = emptyFunction;
    }
    klass.prototype.constructor = klass;
    klass.prototype.callSuper = callSuper;
    return klass;
  }

  fabric.util.createClass = createClass;
})();


(function () {
  // since ie11 can use addEventListener but they do not support options, i need to check
  var couldUseAttachEvent = !!fabric.document.createElement('div').attachEvent,
      touchEvents = ['touchstart', 'touchmove', 'touchend'];
  /**
   * Adds an event listener to an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.addListener = function(element, eventName, handler, options) {
    element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
  };

  /**
   * Removes an event listener from an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.removeListener = function(element, eventName, handler, options) {
    element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
  };

  function getTouchInfo(event) {
    var touchProp = event.changedTouches;
    if (touchProp && touchProp[0]) {
      return touchProp[0];
    }
    return event;
  }

  fabric.util.getPointer = function(event) {
    var element = event.target,
        scroll = fabric.util.getScrollLeftTop(element),
        _evt = getTouchInfo(event);
    return {
      x: _evt.clientX + scroll.left,
      y: _evt.clientY + scroll.top
    };
  };

  fabric.util.isTouchEvent = function(event) {
    return touchEvents.indexOf(event.type) > -1 || event.pointerType === 'touch';
  };
})();


(function () {

  /**
   * Cross-browser wrapper for setting element's style
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {Object} styles
   * @return {HTMLElement} Element that was passed as a first argument
   */
  function setStyle(element, styles) {
    var elementStyle = element.style;
    if (!elementStyle) {
      return element;
    }
    if (typeof styles === 'string') {
      element.style.cssText += ';' + styles;
      return styles.indexOf('opacity') > -1
        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
        : element;
    }
    for (var property in styles) {
      if (property === 'opacity') {
        setOpacity(element, styles[property]);
      }
      else {
        var normalizedProperty = (property === 'float' || property === 'cssFloat')
          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
          : property;
        elementStyle[normalizedProperty] = styles[property];
      }
    }
    return element;
  }

  var parseEl = fabric.document.createElement('div'),
      supportsOpacity = typeof parseEl.style.opacity === 'string',
      supportsFilters = typeof parseEl.style.filter === 'string',
      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

      /** @ignore */
      setOpacity = function (element) { return element; };

  if (supportsOpacity) {
    /** @ignore */
    setOpacity = function(element, value) {
      element.style.opacity = value;
      return element;
    };
  }
  else if (supportsFilters) {
    /** @ignore */
    setOpacity = function(element, value) {
      var es = element.style;
      if (element.currentStyle && !element.currentStyle.hasLayout) {
        es.zoom = 1;
      }
      if (reOpacity.test(es.filter)) {
        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
        es.filter = es.filter.replace(reOpacity, value);
      }
      else {
        es.filter += ' alpha(opacity=' + (value * 100) + ')';
      }
      return element;
    };
  }

  fabric.util.setStyle = setStyle;

})();


(function() {

  var _slice = Array.prototype.slice;

  /**
   * Takes id and returns an element with that id (if one exists in a document)
   * @memberOf fabric.util
   * @param {String|HTMLElement} id
   * @return {HTMLElement|null}
   */
  function getById(id) {
    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
  }

  var sliceCanConvertNodelists,
      /**
       * Converts an array-like object (e.g. arguments or NodeList) to an array
       * @memberOf fabric.util
       * @param {Object} arrayLike
       * @return {Array}
       */
      toArray = function(arrayLike) {
        return _slice.call(arrayLike, 0);
      };

  try {
    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
  }
  catch (err) { }

  if (!sliceCanConvertNodelists) {
    toArray = function(arrayLike) {
      var arr = new Array(arrayLike.length), i = arrayLike.length;
      while (i--) {
        arr[i] = arrayLike[i];
      }
      return arr;
    };
  }

  /**
   * Creates specified element with specified attributes
   * @memberOf fabric.util
   * @param {String} tagName Type of an element to create
   * @param {Object} [attributes] Attributes to set on an element
   * @return {HTMLElement} Newly created element
   */
  function makeElement(tagName, attributes) {
    var el = fabric.document.createElement(tagName);
    for (var prop in attributes) {
      if (prop === 'class') {
        el.className = attributes[prop];
      }
      else if (prop === 'for') {
        el.htmlFor = attributes[prop];
      }
      else {
        el.setAttribute(prop, attributes[prop]);
      }
    }
    return el;
  }

  /**
   * Adds class to an element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to add class to
   * @param {String} className Class to add to an element
   */
  function addClass(element, className) {
    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
      element.className += (element.className ? ' ' : '') + className;
    }
  }

  /**
   * Wraps element with another element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to wrap
   * @param {HTMLElement|String} wrapper Element to wrap with
   * @param {Object} [attributes] Attributes to set on a wrapper
   * @return {HTMLElement} wrapper
   */
  function wrapElement(element, wrapper, attributes) {
    if (typeof wrapper === 'string') {
      wrapper = makeElement(wrapper, attributes);
    }
    if (element.parentNode) {
      element.parentNode.replaceChild(wrapper, element);
    }
    wrapper.appendChild(element);
    return wrapper;
  }

  /**
   * Returns element scroll offsets
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to operate on
   * @return {Object} Object with left/top values
   */
  function getScrollLeftTop(element) {

    var left = 0,
        top = 0,
        docElement = fabric.document.documentElement,
        body = fabric.document.body || {
          scrollLeft: 0, scrollTop: 0
        };

    // While loop checks (and then sets element to) .parentNode OR .host
    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
    //  but the .parentNode of a root ShadowDOM node will always be null, instead
    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
    while (element && (element.parentNode || element.host)) {

      // Set element to element parent, or 'host' in case of ShadowDOM
      element = element.parentNode || element.host;

      if (element === fabric.document) {
        left = body.scrollLeft || docElement.scrollLeft || 0;
        top = body.scrollTop ||  docElement.scrollTop || 0;
      }
      else {
        left += element.scrollLeft || 0;
        top += element.scrollTop || 0;
      }

      if (element.nodeType === 1 && element.style.position === 'fixed') {
        break;
      }
    }

    return { left: left, top: top };
  }

  /**
   * Returns offset for a given element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get offset for
   * @return {Object} Object with "left" and "top" properties
   */
  function getElementOffset(element) {
    var docElem,
        doc = element && element.ownerDocument,
        box = { left: 0, top: 0 },
        offset = { left: 0, top: 0 },
        scrollLeftTop,
        offsetAttributes = {
          borderLeftWidth: 'left',
          borderTopWidth:  'top',
          paddingLeft:     'left',
          paddingTop:      'top'
        };

    if (!doc) {
      return offset;
    }

    for (var attr in offsetAttributes) {
      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
    }

    docElem = doc.documentElement;
    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
      box = element.getBoundingClientRect();
    }

    scrollLeftTop = getScrollLeftTop(element);

    return {
      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
    };
  }

  /**
   * Returns style attribute value of a given element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get style attribute for
   * @param {String} attr Style attribute to get for element
   * @return {String} Style attribute value of the given element.
   */
  var getElementStyle;
  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
    getElementStyle = function(element, attr) {
      var style = fabric.document.defaultView.getComputedStyle(element, null);
      return style ? style[attr] : undefined;
    };
  }
  else {
    getElementStyle = function(element, attr) {
      var value = element.style[attr];
      if (!value && element.currentStyle) {
        value = element.currentStyle[attr];
      }
      return value;
    };
  }

  (function () {
    var style = fabric.document.documentElement.style,
        selectProp = 'userSelect' in style
          ? 'userSelect'
          : 'MozUserSelect' in style
            ? 'MozUserSelect'
            : 'WebkitUserSelect' in style
              ? 'WebkitUserSelect'
              : 'KhtmlUserSelect' in style
                ? 'KhtmlUserSelect'
                : '';

    /**
     * Makes element unselectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make unselectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementUnselectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = fabric.util.falseFunction;
      }
      if (selectProp) {
        element.style[selectProp] = 'none';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = 'on';
      }
      return element;
    }

    /**
     * Makes element selectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make selectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementSelectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = null;
      }
      if (selectProp) {
        element.style[selectProp] = '';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = '';
      }
      return element;
    }

    fabric.util.makeElementUnselectable = makeElementUnselectable;
    fabric.util.makeElementSelectable = makeElementSelectable;
  })();

  function getNodeCanvas(element) {
    var impl = fabric.jsdomImplForWrapper(element);
    return impl._canvas || impl._image;
  };

  function cleanUpJsdomNode(element) {
    if (!fabric.isLikelyNode) {
      return;
    }
    var impl = fabric.jsdomImplForWrapper(element);
    if (impl) {
      impl._image = null;
      impl._canvas = null;
      // unsure if necessary
      impl._currentSrc = null;
      impl._attributes = null;
      impl._classList = null;
    }
  }

  function setImageSmoothing(ctx, value) {
    ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
      || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
    ctx.imageSmoothingEnabled = value;
  }

  /**
   * setImageSmoothing sets the context imageSmoothingEnabled property.
   * Used by canvas and by ImageObject.
   * @memberOf fabric.util
   * @since 4.0.0
   * @param {HTMLRenderingContext2D} ctx to set on
   * @param {Boolean} value true or false
   */
  fabric.util.setImageSmoothing = setImageSmoothing;
  fabric.util.getById = getById;
  fabric.util.toArray = toArray;
  fabric.util.addClass = addClass;
  fabric.util.makeElement = makeElement;
  fabric.util.wrapElement = wrapElement;
  fabric.util.getScrollLeftTop = getScrollLeftTop;
  fabric.util.getElementOffset = getElementOffset;
  fabric.util.getNodeCanvas = getNodeCanvas;
  fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;

})();


(function() {

  function addParamToUrl(url, param) {
    return url + (/\?/.test(url) ? '&' : '?') + param;
  }

  function emptyFn() { }

  /**
   * Cross-browser abstraction for sending XMLHttpRequest
   * @memberOf fabric.util
   * @param {String} url URL to send XMLHttpRequest to
   * @param {Object} [options] Options object
   * @param {String} [options.method="GET"]
   * @param {String} [options.parameters] parameters to append to url in GET or in body
   * @param {String} [options.body] body to send with POST or PUT request
   * @param {Function} options.onComplete Callback to invoke when request is completed
   * @return {XMLHttpRequest} request
   */
  function request(url, options) {
    options || (options = { });

    var method = options.method ? options.method.toUpperCase() : 'GET',
        onComplete = options.onComplete || function() { },
        xhr = new fabric.window.XMLHttpRequest(),
        body = options.body || options.parameters;

    /** @ignore */
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        onComplete(xhr);
        xhr.onreadystatechange = emptyFn;
      }
    };

    if (method === 'GET') {
      body = null;
      if (typeof options.parameters === 'string') {
        url = addParamToUrl(url, options.parameters);
      }
    }

    xhr.open(method, url, true);

    if (method === 'POST' || method === 'PUT') {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    xhr.send(body);
    return xhr;
  }

  fabric.util.request = request;
})();


/**
 * Wrapper around `console.log` (when available)
 * @param {*} [values] Values to log
 */
fabric.log = console.log;

/**
 * Wrapper around `console.warn` (when available)
 * @param {*} [values] Values to log as a warning
 */
fabric.warn = console.warn;


(function() {

  function noop() {
    return false;
  }

  function defaultEasing(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Number} [options.startValue=0] Starting value
   * @param {Number} [options.endValue=100] Ending value
   * @param {Number} [options.byValue=100] Value to modify the property by
   * @param {Function} [options.easing] Easing function
   * @param {Number} [options.duration=500] Duration of change (in ms)
   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
   */
  function animate(options) {

    requestAnimFrame(function(timestamp) {
      options || (options = { });

      var start = timestamp || +new Date(),
          duration = options.duration || 500,
          finish = start + duration, time,
          onChange = options.onChange || noop,
          abort = options.abort || noop,
          onComplete = options.onComplete || noop,
          easing = options.easing || defaultEasing,
          startValue = 'startValue' in options ? options.startValue : 0,
          endValue = 'endValue' in options ? options.endValue : 100,
          byValue = options.byValue || endValue - startValue;

      options.onStart && options.onStart();

      (function tick(ticktime) {
        // TODO: move abort call after calculation
        // and pass (current,valuePerc, timePerc) as arguments
        time = ticktime || +new Date();
        var currentTime = time > finish ? duration : (time - start),
            timePerc = currentTime / duration,
            current = easing(currentTime, startValue, byValue, duration),
            valuePerc = Math.abs((current - startValue) / byValue);
        if (abort()) {
          onComplete(endValue, 1, 1);
          return;
        }
        if (time > finish) {
          onChange(endValue, 1, 1);
          onComplete(endValue, 1, 1);
          return;
        }
        else {
          onChange(current, valuePerc, timePerc);
          requestAnimFrame(tick);
        }
      })(start);
    });
  }

  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                          fabric.window.webkitRequestAnimationFrame ||
                          fabric.window.mozRequestAnimationFrame    ||
                          fabric.window.oRequestAnimationFrame      ||
                          fabric.window.msRequestAnimationFrame     ||
                          function(callback) {
                            return fabric.window.setTimeout(callback, 1000 / 60);
                          };

  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

  /**
   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
   * @memberOf fabric.util
   * @param {Function} callback Callback to invoke
   * @param {DOMElement} element optional Element to associate with animation
   */
  function requestAnimFrame() {
    return _requestAnimFrame.apply(fabric.window, arguments);
  }

  function cancelAnimFrame() {
    return _cancelAnimFrame.apply(fabric.window, arguments);
  }

  fabric.util.animate = animate;
  fabric.util.requestAnimFrame = requestAnimFrame;
  fabric.util.cancelAnimFrame = cancelAnimFrame;
})();


(function() {
  // Calculate an in-between color. Returns a "rgba()" string.
  // Credit: Edwin Martin <edwin@bitstorm.org>
  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
  function calculateColor(begin, end, pos) {
    var color = 'rgba('
        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
    color += ')';
    return color;
  }

  /**
   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {String} fromColor The starting color in hex or rgb(a) format.
   * @param {String} toColor The starting color in hex or rgb(a) format.
   * @param {Number} [duration] Duration of change (in ms).
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
   */
  function animateColor(fromColor, toColor, duration, options) {
    var startColor = new fabric.Color(fromColor).getSource(),
        endColor = new fabric.Color(toColor).getSource(),
        originalOnComplete = options.onComplete,
        originalOnChange = options.onChange;
    options = options || {};

    fabric.util.animate(fabric.util.object.extend(options, {
      duration: duration || 500,
      startValue: startColor,
      endValue: endColor,
      byValue: endColor,
      easing: function (currentTime, startValue, byValue, duration) {
        var posValue = options.colorEasing
          ? options.colorEasing(currentTime, duration)
          : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
        return calculateColor(startValue, byValue, posValue);
      },
      // has to take in account for color restoring;
      onComplete: function(current, valuePerc, timePerc) {
        if (originalOnComplete) {
          return originalOnComplete(
            calculateColor(endColor, endColor, 0),
            valuePerc,
            timePerc
          );
        }
      },
      onChange: function(current, valuePerc, timePerc) {
        if (originalOnChange) {
          if (Array.isArray(current)) {
            return originalOnChange(
              calculateColor(current, current, 0),
              valuePerc,
              timePerc
            );
          }
          originalOnChange(current, valuePerc, timePerc);
        }
      }
    }));
  }

  fabric.util.animateColor = animateColor;

})();


(function() {

  function normalize(a, c, p, s) {
    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    }
    else {
      //handle the 0/0 case:
      if (c === 0 && a === 0) {
        s = p / (2 * Math.PI) * Math.asin(1);
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
    }
    return { a: a, c: c, p: p, s: s };
  }

  function elastic(opts, t, d) {
    return opts.a *
      Math.pow(2, 10 * (t -= 1)) *
      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
  }

  /**
   * Cubic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }

  /**
   * Cubic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCubic(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }

  /**
   * Quartic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuart(t, b, c, d) {
    return c * (t /= d) * t * t * t + b;
  }

  /**
   * Quartic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuart(t, b, c, d) {
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  }

  /**
   * Quartic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuart(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t + b;
    }
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }

  /**
   * Quintic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuint(t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  }

  /**
   * Quintic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuint(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  }

  /**
   * Quintic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuint(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }

  /**
   * Sinusoidal easing in
   * @memberOf fabric.util.ease
   */
  function easeInSine(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Sinusoidal easing out
   * @memberOf fabric.util.ease
   */
  function easeOutSine(t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
  }

  /**
   * Sinusoidal easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutSine(t, b, c, d) {
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
  }

  /**
   * Exponential easing in
   * @memberOf fabric.util.ease
   */
  function easeInExpo(t, b, c, d) {
    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
  }

  /**
   * Exponential easing out
   * @memberOf fabric.util.ease
   */
  function easeOutExpo(t, b, c, d) {
    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  }

  /**
   * Exponential easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutExpo(t, b, c, d) {
    if (t === 0) {
      return b;
    }
    if (t === d) {
      return b + c;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
    }
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }

  /**
   * Circular easing in
   * @memberOf fabric.util.ease
   */
  function easeInCirc(t, b, c, d) {
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
  }

  /**
   * Circular easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCirc(t, b, c, d) {
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
  }

  /**
   * Circular easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCirc(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
    }
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }

  /**
   * Elastic easing in
   * @memberOf fabric.util.ease
   */
  function easeInElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return -elastic(opts, t, d) + b;
  }

  /**
   * Elastic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
  }

  /**
   * Elastic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d / 2;
    if (t === 2) {
      return b + c;
    }
    if (!p) {
      p = d * (0.3 * 1.5);
    }
    var opts = normalize(a, c, p, s);
    if (t < 1) {
      return -0.5 * elastic(opts, t, d) + b;
    }
    return opts.a * Math.pow(2, -10 * (t -= 1)) *
      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
  }

  /**
   * Backwards easing in
   * @memberOf fabric.util.ease
   */
  function easeInBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  }

  /**
   * Backwards easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  }

  /**
   * Backwards easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
    }
    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
  }

  /**
   * Bouncing easing in
   * @memberOf fabric.util.ease
   */
  function easeInBounce(t, b, c, d) {
    return c - easeOutBounce (d - t, 0, c, d) + b;
  }

  /**
   * Bouncing easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBounce(t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
      return c * (7.5625 * t * t) + b;
    }
    else if (t < (2 / 2.75)) {
      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
    }
    else if (t < (2.5 / 2.75)) {
      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
    }
    else {
      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    }
  }

  /**
   * Bouncing easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBounce(t, b, c, d) {
    if (t < d / 2) {
      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
    }
    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  }

  /**
   * Easing functions
   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
   * @namespace fabric.util.ease
   */
  fabric.util.ease = {

    /**
     * Quadratic easing in
     * @memberOf fabric.util.ease
     */
    easeInQuad: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },

    /**
     * Quadratic easing out
     * @memberOf fabric.util.ease
     */
    easeOutQuad: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },

    /**
     * Quadratic easing in and out
     * @memberOf fabric.util.ease
     */
    easeInOutQuad: function(t, b, c, d) {
      t /= (d / 2);
      if (t < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },

    /**
     * Cubic easing in
     * @memberOf fabric.util.ease
     */
    easeInCubic: function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    },

    easeOutCubic: easeOutCubic,
    easeInOutCubic: easeInOutCubic,
    easeInQuart: easeInQuart,
    easeOutQuart: easeOutQuart,
    easeInOutQuart: easeInOutQuart,
    easeInQuint: easeInQuint,
    easeOutQuint: easeOutQuint,
    easeInOutQuint: easeInOutQuint,
    easeInSine: easeInSine,
    easeOutSine: easeOutSine,
    easeInOutSine: easeInOutSine,
    easeInExpo: easeInExpo,
    easeOutExpo: easeOutExpo,
    easeInOutExpo: easeInOutExpo,
    easeInCirc: easeInCirc,
    easeOutCirc: easeOutCirc,
    easeInOutCirc: easeInOutCirc,
    easeInElastic: easeInElastic,
    easeOutElastic: easeOutElastic,
    easeInOutElastic: easeInOutElastic,
    easeInBack: easeInBack,
    easeOutBack: easeOutBack,
    easeInOutBack: easeInOutBack,
    easeInBounce: easeInBounce,
    easeOutBounce: easeOutBounce,
    easeInOutBounce: easeInOutBounce
  };

})();


(function(global) {

  'use strict';

  /**
   * @name fabric
   * @namespace
   */

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      parseUnit = fabric.util.parseUnit,
      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

      svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
        'image', 'text'],
      svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
      svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
      svgValidParents = ['symbol', 'g', 'a', 'svg', 'clipPath', 'defs'],

      attributesMap = {
        cx:                   'left',
        x:                    'left',
        r:                    'radius',
        cy:                   'top',
        y:                    'top',
        display:              'visible',
        visibility:           'visible',
        transform:            'transformMatrix',
        'fill-opacity':       'fillOpacity',
        'fill-rule':          'fillRule',
        'font-family':        'fontFamily',
        'font-size':          'fontSize',
        'font-style':         'fontStyle',
        'font-weight':        'fontWeight',
        'letter-spacing':     'charSpacing',
        'paint-order':        'paintFirst',
        'stroke-dasharray':   'strokeDashArray',
        'stroke-dashoffset':  'strokeDashOffset',
        'stroke-linecap':     'strokeLineCap',
        'stroke-linejoin':    'strokeLineJoin',
        'stroke-miterlimit':  'strokeMiterLimit',
        'stroke-opacity':     'strokeOpacity',
        'stroke-width':       'strokeWidth',
        'text-decoration':    'textDecoration',
        'text-anchor':        'textAnchor',
        opacity:              'opacity',
        'clip-path':          'clipPath',
        'clip-rule':          'clipRule',
        'vector-effect':      'strokeUniform',
        'image-rendering':    'imageSmoothing',
      },

      colorAttributes = {
        stroke: 'strokeOpacity',
        fill:   'fillOpacity'
      },

      fSize = 'font-size', cPath = 'clip-path';

  fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
  fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
  fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
  fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);

  fabric.cssRules = { };
  fabric.gradientDefs = { };
  fabric.clipPaths = { };

  function normalizeAttr(attr) {
    // transform attribute names
    if (attr in attributesMap) {
      return attributesMap[attr];
    }
    return attr;
  }

  function normalizeValue(attr, value, parentAttributes, fontSize) {
    var isArray = Object.prototype.toString.call(value) === '[object Array]',
        parsed;

    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
      value = '';
    }
    else if (attr === 'strokeUniform') {
      return (value === 'non-scaling-stroke');
    }
    else if (attr === 'strokeDashArray') {
      if (value === 'none') {
        value = null;
      }
      else {
        value = value.replace(/,/g, ' ').split(/\s+/).map(parseFloat);
      }
    }
    else if (attr === 'transformMatrix') {
      if (parentAttributes && parentAttributes.transformMatrix) {
        value = multiplyTransformMatrices(
          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
      }
      else {
        value = fabric.parseTransformAttribute(value);
      }
    }
    else if (attr === 'visible') {
      value = value !== 'none' && value !== 'hidden';
      // display=none on parent element always takes precedence over child element
      if (parentAttributes && parentAttributes.visible === false) {
        value = false;
      }
    }
    else if (attr === 'opacity') {
      value = parseFloat(value);
      if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
        value *= parentAttributes.opacity;
      }
    }
    else if (attr === 'textAnchor' /* text-anchor */) {
      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
    }
    else if (attr === 'charSpacing') {
      // parseUnit returns px and we convert it to em
      parsed = parseUnit(value, fontSize) / fontSize * 1000;
    }
    else if (attr === 'paintFirst') {
      var fillIndex = value.indexOf('fill');
      var strokeIndex = value.indexOf('stroke');
      var value = 'fill';
      if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
        value = 'stroke';
      }
      else if (fillIndex === -1 && strokeIndex > -1) {
        value = 'stroke';
      }
    }
    else if (attr === 'href' || attr === 'xlink:href' || attr === 'font') {
      return value;
    }
    else if (attr === 'imageSmoothing') {
      return (value === 'optimizeQuality');
    }
    else {
      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
    }

    return (!isArray && isNaN(parsed) ? value : parsed);
  }

  /**
    * @private
    */
  function getSvgRegex(arr) {
    return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
  }

  /**
   * @private
   * @param {Object} attributes Array of attributes to parse
   */
  function _setStrokeFillOpacity(attributes) {
    for (var attr in colorAttributes) {

      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
        continue;
      }

      if (typeof attributes[attr] === 'undefined') {
        if (!fabric.Object.prototype[attr]) {
          continue;
        }
        attributes[attr] = fabric.Object.prototype[attr];
      }

      if (attributes[attr].indexOf('url(') === 0) {
        continue;
      }

      var color = new fabric.Color(attributes[attr]);
      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
    }
    return attributes;
  }

  /**
   * @private
   */
  function _getMultipleNodes(doc, nodeNames) {
    var nodeName, nodeArray = [], nodeList, i, len;
    for (i = 0, len = nodeNames.length; i < len; i++) {
      nodeName = nodeNames[i];
      nodeList = doc.getElementsByTagName(nodeName);
      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
    }
    return nodeArray;
  }

  /**
   * Parses "transform" attribute, returning an array of values
   * @static
   * @function
   * @memberOf fabric
   * @param {String} attributeValue String containing attribute value
   * @return {Array} Array of 6 elements representing transformation matrix
   */
  fabric.parseTransformAttribute = (function() {
    function rotateMatrix(matrix, args) {
      var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
          x = 0, y = 0;
      if (args.length === 3) {
        x = args[1];
        y = args[2];
      }

      matrix[0] = cos;
      matrix[1] = sin;
      matrix[2] = -sin;
      matrix[3] = cos;
      matrix[4] = x - (cos * x - sin * y);
      matrix[5] = y - (sin * x + cos * y);
    }

    function scaleMatrix(matrix, args) {
      var multiplierX = args[0],
          multiplierY = (args.length === 2) ? args[1] : args[0];

      matrix[0] = multiplierX;
      matrix[3] = multiplierY;
    }

    function skewMatrix(matrix, args, pos) {
      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
    }

    function translateMatrix(matrix, args) {
      matrix[4] = args[0];
      if (args.length === 2) {
        matrix[5] = args[1];
      }
    }

    // identity matrix
    var iMatrix = fabric.iMatrix,

        // == begin transform regexp
        number = fabric.reNum,

        commaWsp = fabric.commaWsp,

        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + ')' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        matrix = '(?:(matrix)\\s*\\(\\s*' +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' +
                  '\\s*\\))',

        transform = '(?:' +
                    matrix + '|' +
                    translate + '|' +
                    scale + '|' +
                    rotate + '|' +
                    skewX + '|' +
                    skewY +
                    ')',

        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

        transformList = '^\\s*(?:' + transforms + '?)\\s*$',

        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
        reTransformList = new RegExp(transformList),
        // == end transform regexp

        reTransform = new RegExp(transform, 'g');

    return function(attributeValue) {

      // start with identity matrix
      var matrix = iMatrix.concat(),
          matrices = [];

      // return if no argument was given or
      // an argument does not match transform attribute regexp
      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
        return matrix;
      }

      attributeValue.replace(reTransform, function(match) {

        var m = new RegExp(transform).exec(match).filter(function (match) {
              // match !== '' && match != null
              return (!!match);
            }),
            operation = m[1],
            args = m.slice(2).map(parseFloat);

        switch (operation) {
          case 'translate':
            translateMatrix(matrix, args);
            break;
          case 'rotate':
            args[0] = fabric.util.degreesToRadians(args[0]);
            rotateMatrix(matrix, args);
            break;
          case 'scale':
            scaleMatrix(matrix, args);
            break;
          case 'skewX':
            skewMatrix(matrix, args, 2);
            break;
          case 'skewY':
            skewMatrix(matrix, args, 1);
            break;
          case 'matrix':
            matrix = args;
            break;
        }

        // snapshot current matrix into matrices array
        matrices.push(matrix.concat());
        // reset
        matrix = iMatrix.concat();
      });

      var combinedMatrix = matrices[0];
      while (matrices.length > 1) {
        matrices.shift();
        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
      }
      return combinedMatrix;
    };
  })();

  /**
   * @private
   */
  function parseStyleString(style, oStyle) {
    var attr, value;
    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
      var pair = chunk.split(':');

      attr = pair[0].trim().toLowerCase();
      value =  pair[1].trim();

      oStyle[attr] = value;
    });
  }

  /**
   * @private
   */
  function parseStyleObject(style, oStyle) {
    var attr, value;
    for (var prop in style) {
      if (typeof style[prop] === 'undefined') {
        continue;
      }

      attr = prop.toLowerCase();
      value = style[prop];

      oStyle[attr] = value;
    }
  }

  /**
   * @private
   */
  function getGlobalStylesForElement(element, svgUid) {
    var styles = { };
    for (var rule in fabric.cssRules[svgUid]) {
      if (elementMatchesRule(element, rule.split(' '))) {
        for (var property in fabric.cssRules[svgUid][rule]) {
          styles[property] = fabric.cssRules[svgUid][rule][property];
        }
      }
    }
    return styles;
  }

  /**
   * @private
   */
  function elementMatchesRule(element, selectors) {
    var firstMatching, parentMatching = true;
    //start from rightmost selector.
    firstMatching = selectorMatches(element, selectors.pop());
    if (firstMatching && selectors.length) {
      parentMatching = doesSomeParentMatch(element, selectors);
    }
    return firstMatching && parentMatching && (selectors.length === 0);
  }

  function doesSomeParentMatch(element, selectors) {
    var selector, parentMatching = true;
    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
      if (parentMatching) {
        selector = selectors.pop();
      }
      element = element.parentNode;
      parentMatching = selectorMatches(element, selector);
    }
    return selectors.length === 0;
  }

  /**
   * @private
   */
  function selectorMatches(element, selector) {
    var nodeName = element.nodeName,
        classNames = element.getAttribute('class'),
        id = element.getAttribute('id'), matcher, i;
    // i check if a selector matches slicing away part from it.
    // if i get empty string i should match
    matcher = new RegExp('^' + nodeName, 'i');
    selector = selector.replace(matcher, '');
    if (id && selector.length) {
      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
      selector = selector.replace(matcher, '');
    }
    if (classNames && selector.length) {
      classNames = classNames.split(' ');
      for (i = classNames.length; i--;) {
        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
    }
    return selector.length === 0;
  }

  /**
   * @private
   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM
   */
  function elementById(doc, id) {
    var el;
    doc.getElementById && (el = doc.getElementById(id));
    if (el) {
      return el;
    }
    var node, i, len, nodelist = doc.getElementsByTagName('*');
    for (i = 0, len = nodelist.length; i < len; i++) {
      node = nodelist[i];
      if (id === node.getAttribute('id')) {
        return node;
      }
    }
  }

  /**
   * @private
   */
  function parseUseDirectives(doc) {
    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
    while (nodelist.length && i < nodelist.length) {
      var el = nodelist[i],
          xlink = (el.getAttribute('xlink:href') || el.getAttribute('href')).substr(1),
          x = el.getAttribute('x') || 0,
          y = el.getAttribute('y') || 0,
          el2 = elementById(doc, xlink).cloneNode(true),
          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
          parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;

      applyViewboxTransform(el2);
      if (/^svg$/i.test(el2.nodeName)) {
        var el3 = el2.ownerDocument.createElementNS(namespace, 'g');
        for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
        }
        // el2.firstChild != null
        while (el2.firstChild) {
          el3.appendChild(el2.firstChild);
        }
        el2 = el3;
      }

      for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
        attr = attrs.item(j);
        if (attr.nodeName === 'x' || attr.nodeName === 'y' ||
          attr.nodeName === 'xlink:href' || attr.nodeName === 'href') {
          continue;
        }

        if (attr.nodeName === 'transform') {
          currentTrans = attr.nodeValue + ' ' + currentTrans;
        }
        else {
          el2.setAttribute(attr.nodeName, attr.nodeValue);
        }
      }

      el2.setAttribute('transform', currentTrans);
      el2.setAttribute('instantiated_by_use', '1');
      el2.removeAttribute('id');
      parentNode = el.parentNode;
      parentNode.replaceChild(el2, el);
      // some browsers do not shorten nodelist after replaceChild (IE8)
      if (nodelist.length === oldLength) {
        i++;
      }
    }
  }

  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
  // matches, e.g.: +14.56e-12, etc.
  var reViewBoxAttrValue = new RegExp(
    '^' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*' +
    '$'
  );

  /**
   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
   */
  function applyViewboxTransform(element) {
    if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {
      return;
    }
    var viewBoxAttr = element.getAttribute('viewBox'),
        scaleX = 1,
        scaleY = 1,
        minX = 0,
        minY = 0,
        viewBoxWidth, viewBoxHeight, matrix, el,
        widthAttr = element.getAttribute('width'),
        heightAttr = element.getAttribute('height'),
        x = element.getAttribute('x') || 0,
        y = element.getAttribute('y') || 0,
        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
        missingViewBox = (!viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
        toBeParsed = missingViewBox && missingDimAttr,
        parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;

    parsedDim.width = 0;
    parsedDim.height = 0;
    parsedDim.toBeParsed = toBeParsed;

    if (missingViewBox) {
      if (((x || y) && element.parentNode.nodeName !== '#document')) {
        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
        matrix = (element.getAttribute('transform') || '') + translateMatrix;
        element.setAttribute('transform', matrix);
        element.removeAttribute('x');
        element.removeAttribute('y');
      }
    }

    if (toBeParsed) {
      return parsedDim;
    }

    if (missingViewBox) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      // set a transform for elements that have x y and are inner(only) SVGs
      return parsedDim;
    }
    minX = -parseFloat(viewBoxAttr[1]);
    minY = -parseFloat(viewBoxAttr[2]);
    viewBoxWidth = parseFloat(viewBoxAttr[3]);
    viewBoxHeight = parseFloat(viewBoxAttr[4]);
    parsedDim.minX = minX;
    parsedDim.minY = minY;
    parsedDim.viewBoxWidth = viewBoxWidth;
    parsedDim.viewBoxHeight = viewBoxHeight;
    if (!missingDimAttr) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      scaleX = parsedDim.width / viewBoxWidth;
      scaleY = parsedDim.height / viewBoxHeight;
    }
    else {
      parsedDim.width = viewBoxWidth;
      parsedDim.height = viewBoxHeight;
    }

    // default is to preserve aspect ratio
    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
    if (preserveAspectRatio.alignX !== 'none') {
      //translate all container for the effect of Mid, Min, Max
      if (preserveAspectRatio.meetOrSlice === 'meet') {
        scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
        // calculate additional translation to move the viewbox
      }
      if (preserveAspectRatio.meetOrSlice === 'slice') {
        scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
        // calculate additional translation to move the viewbox
      }
      widthDiff = parsedDim.width - viewBoxWidth * scaleX;
      heightDiff = parsedDim.height - viewBoxHeight * scaleX;
      if (preserveAspectRatio.alignX === 'Mid') {
        widthDiff /= 2;
      }
      if (preserveAspectRatio.alignY === 'Mid') {
        heightDiff /= 2;
      }
      if (preserveAspectRatio.alignX === 'Min') {
        widthDiff = 0;
      }
      if (preserveAspectRatio.alignY === 'Min') {
        heightDiff = 0;
      }
    }

    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
      return parsedDim;
    }
    if ((x || y) && element.parentNode.nodeName !== '#document') {
      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
    }

    matrix = translateMatrix + ' matrix(' + scaleX +
                  ' 0' +
                  ' 0 ' +
                  scaleY + ' ' +
                  (minX * scaleX + widthDiff) + ' ' +
                  (minY * scaleY + heightDiff) + ') ';
    // seems unused.
    // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);
    if (element.nodeName === 'svg') {
      el = element.ownerDocument.createElementNS(fabric.svgNS, 'g');
      // element.firstChild != null
      while (element.firstChild) {
        el.appendChild(element.firstChild);
      }
      element.appendChild(el);
    }
    else {
      el = element;
      el.removeAttribute('x');
      el.removeAttribute('y');
      matrix = el.getAttribute('transform') + matrix;
    }
    el.setAttribute('transform', matrix);
    return parsedDim;
  }

  function hasAncestorWithNodeName(element, nodeName) {
    while (element && (element = element.parentNode)) {
      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
        && !element.getAttribute('instantiated_by_use')) {
        return true;
      }
    }
    return false;
  }

  /**
   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
   * @static
   * @function
   * @memberOf fabric
   * @param {SVGDocument} doc SVG document to parse
   * @param {Function} callback Callback to call when parsing is finished;
   * It's being passed an array of elements (parsed from a document).
   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
   * @param {Object} [parsingOptions] options for parsing document
   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
   */
  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
    if (!doc) {
      return;
    }

    parseUseDirectives(doc);

    var svgUid =  fabric.Object.__uid++, i, len,
        options = applyViewboxTransform(doc),
        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
    options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
    options.svgUid = svgUid;

    if (descendants.length === 0 && fabric.isLikelyNode) {
      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
      // https://github.com/ajaxorg/node-o3-xml/issues/21
      descendants = doc.selectNodes('//*[name(.)!="svg"]');
      var arr = [];
      for (i = 0, len = descendants.length; i < len; i++) {
        arr[i] = descendants[i];
      }
      descendants = arr;
    }

    var elements = descendants.filter(function(el) {
      applyViewboxTransform(el);
      return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
            !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
    });
    if (!elements || (elements && !elements.length)) {
      callback && callback([], {});
      return;
    }
    var clipPaths = { };
    descendants.filter(function(el) {
      return el.nodeName.replace('svg:', '') === 'clipPath';
    }).forEach(function(el) {
      var id = el.getAttribute('id');
      clipPaths[id] = fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el) {
        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));
      });
    });
    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
    fabric.clipPaths[svgUid] = clipPaths;
    // Precedence of rules:   style > class > attribute
    fabric.parseElements(elements, function(instances, elements) {
      if (callback) {
        callback(instances, options, elements, descendants);
        delete fabric.gradientDefs[svgUid];
        delete fabric.cssRules[svgUid];
        delete fabric.clipPaths[svgUid];
      }
    }, clone(options), reviver, parsingOptions);
  };

  function recursivelyParseGradientsXlink(doc, gradient) {
    var gradientsAttrs = ['gradientTransform', 'x1', 'x2', 'y1', 'y2', 'gradientUnits', 'cx', 'cy', 'r', 'fx', 'fy'],
        xlinkAttr = 'xlink:href',
        xLink = gradient.getAttribute(xlinkAttr).substr(1),
        referencedGradient = elementById(doc, xLink);
    if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
      recursivelyParseGradientsXlink(doc, referencedGradient);
    }
    gradientsAttrs.forEach(function(attr) {
      if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
        gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
      }
    });
    if (!gradient.children.length) {
      var referenceClone = referencedGradient.cloneNode(true);
      while (referenceClone.firstChild) {
        gradient.appendChild(referenceClone.firstChild);
      }
    }
    gradient.removeAttribute(xlinkAttr);
  }

  var reFontDeclaration = new RegExp(
    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
      fabric.reNum +
    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

  extend(fabric, {
    /**
     * Parses a short font declaration, building adding its properties to a style object
     * @static
     * @function
     * @memberOf fabric
     * @param {String} value font declaration
     * @param {Object} oStyle definition
     */
    parseFontDeclaration: function(value, oStyle) {
      var match = value.match(reFontDeclaration);

      if (!match) {
        return;
      }
      var fontStyle = match[1],
          // font variant is not used
          // fontVariant = match[2],
          fontWeight = match[3],
          fontSize = match[4],
          lineHeight = match[5],
          fontFamily = match[6];

      if (fontStyle) {
        oStyle.fontStyle = fontStyle;
      }
      if (fontWeight) {
        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
      }
      if (fontSize) {
        oStyle.fontSize = parseUnit(fontSize);
      }
      if (fontFamily) {
        oStyle.fontFamily = fontFamily;
      }
      if (lineHeight) {
        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
      }
    },

    /**
     * Parses an SVG document, returning all of the gradient declarations found in it
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
     */
    getGradientDefs: function(doc) {
      var tagArray = [
            'linearGradient',
            'radialGradient',
            'svg:linearGradient',
            'svg:radialGradient'],
          elList = _getMultipleNodes(doc, tagArray),
          el, j = 0, gradientDefs = { };
      j = elList.length;
      while (j--) {
        el = elList[j];
        if (el.getAttribute('xlink:href')) {
          recursivelyParseGradientsXlink(doc, el);
        }
        gradientDefs[el.getAttribute('id')] = el;
      }
      return gradientDefs;
    },

    /**
     * Returns an object of attributes' name/value, given element and an array of attribute names;
     * Parses parent "g" nodes recursively upwards.
     * @static
     * @memberOf fabric
     * @param {DOMElement} element Element to parse
     * @param {Array} attributes Array of attributes to parse
     * @return {Object} object containing parsed attributes' names/values
     */
    parseAttributes: function(element, attributes, svgUid) {

      if (!element) {
        return;
      }

      var value,
          parentAttributes = { },
          fontSize, parentFontSize;

      if (typeof svgUid === 'undefined') {
        svgUid = element.getAttribute('svgUid');
      }
      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
      if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
      }

      var ownAttributes = attributes.reduce(function(memo, attr) {
        value = element.getAttribute(attr);
        if (value) { // eslint-disable-line
          memo[attr] = value;
        }
        return memo;
      }, { });
      // add values parsed from style, which take precedence over attributes
      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
      var cssAttrs = extend(
        getGlobalStylesForElement(element, svgUid),
        fabric.parseStyleAttribute(element)
      );
      ownAttributes = extend(
        ownAttributes,
        cssAttrs
      );
      if (cssAttrs[cPath]) {
        element.setAttribute(cPath, cssAttrs[cPath]);
      }
      fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;
      if (ownAttributes[fSize]) {
        // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.
        ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);
      }

      var normalizedAttr, normalizedValue, normalizedStyle = {};
      for (var attr in ownAttributes) {
        normalizedAttr = normalizeAttr(attr);
        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
        normalizedStyle[normalizedAttr] = normalizedValue;
      }
      if (normalizedStyle && normalizedStyle.font) {
        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
      }
      var mergedAttrs = extend(parentAttributes, normalizedStyle);
      return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
    },

    /**
     * Transforms an array of svg elements to corresponding fabric.* instances
     * @static
     * @memberOf fabric
     * @param {Array} elements Array of elements to parse
     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
     * @param {Object} [options] Options object
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     */
    parseElements: function(elements, callback, options, reviver, parsingOptions) {
      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
    },

    /**
     * Parses "style" attribute, retuning an object with values
     * @static
     * @memberOf fabric
     * @param {SVGElement} element Element to parse
     * @return {Object} Objects with values parsed from style attribute of an element
     */
    parseStyleAttribute: function(element) {
      var oStyle = { },
          style = element.getAttribute('style');

      if (!style) {
        return oStyle;
      }

      if (typeof style === 'string') {
        parseStyleString(style, oStyle);
      }
      else {
        parseStyleObject(style, oStyle);
      }

      return oStyle;
    },

    /**
     * Parses "points" attribute, returning an array of values
     * @static
     * @memberOf fabric
     * @param {String} points points attribute string
     * @return {Array} array of points
     */
    parsePointsAttribute: function(points) {

      // points attribute is required and must not be empty
      if (!points) {
        return null;
      }

      // replace commas with whitespace and remove bookending whitespace
      points = points.replace(/,/g, ' ').trim();

      points = points.split(/\s+/);
      var parsedPoints = [], i, len;

      for (i = 0, len = points.length; i < len; i += 2) {
        parsedPoints.push({
          x: parseFloat(points[i]),
          y: parseFloat(points[i + 1])
        });
      }

      // odd number of points is an error
      // if (parsedPoints.length % 2 !== 0) {
      //   return null;
      // }

      return parsedPoints;
    },

    /**
     * Returns CSS rules for a given SVG document
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} CSS rules of this document
     */
    getCSSRules: function(doc) {
      var styles = doc.getElementsByTagName('style'), i, len,
          allRules = { }, rules;

      // very crude parsing of style contents
      for (i = 0, len = styles.length; i < len; i++) {
        var styleContents = styles[i].textContent;

        // remove comments
        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
        if (styleContents.trim() === '') {
          continue;
        }
        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
        rules = rules.map(function(rule) { return rule.trim(); });
        // eslint-disable-next-line no-loop-func
        rules.forEach(function(rule) {

          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
              ruleObj = { }, declaration = match[2].trim(),
              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);

          for (i = 0, len = propertyValuePairs.length; i < len; i++) {
            var pair = propertyValuePairs[i].split(/\s*:\s*/),
                property = pair[0],
                value = pair[1];
            ruleObj[property] = value;
          }
          rule = match[1];
          rule.split(',').forEach(function(_rule) {
            _rule = _rule.replace(/^svg/i, '').trim();
            if (_rule === '') {
              return;
            }
            if (allRules[_rule]) {
              fabric.util.object.extend(allRules[_rule], ruleObj);
            }
            else {
              allRules[_rule] = fabric.util.object.clone(ruleObj);
            }
          });
        });
      }
      return allRules;
    },

    /**
     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
     * @memberOf fabric
     * @param {String} url
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromURL: function(url, callback, reviver, options) {

      url = url.replace(/^\n\s*/, '').trim();
      new fabric.util.request(url, {
        method: 'get',
        onComplete: onComplete
      });

      function onComplete(r) {

        var xml = r.responseXML;
        if (!xml || !xml.documentElement) {
          callback && callback(null);
          return false;
        }

        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
          callback && callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    },

    /**
     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
     * @memberOf fabric
     * @param {String} string
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromString: function(string, callback, reviver, options) {
      var parser = new fabric.window.DOMParser(),
          doc = parser.parseFromString(string.trim(), 'text/xml');
      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
        callback(results, _options, elements, allElements);
      }, reviver, options);
    }
  });

})( true ? exports : 0);


fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {
  this.elements = elements;
  this.callback = callback;
  this.options = options;
  this.reviver = reviver;
  this.svgUid = (options && options.svgUid) || 0;
  this.parsingOptions = parsingOptions;
  this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
  this.doc = doc;
};

(function(proto) {
  proto.parse = function() {
    this.instances = new Array(this.elements.length);
    this.numElements = this.elements.length;
    this.createObjects();
  };

  proto.createObjects = function() {
    var _this = this;
    this.elements.forEach(function(element, i) {
      element.setAttribute('svgUid', _this.svgUid);
      _this.createObject(element, i);
    });
  };

  proto.findTag = function(el) {
    return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
  };

  proto.createObject = function(el, index) {
    var klass = this.findTag(el);
    if (klass && klass.fromElement) {
      try {
        klass.fromElement(el, this.createCallback(index, el), this.options);
      }
      catch (err) {
        fabric.log(err);
      }
    }
    else {
      this.checkIfDone();
    }
  };

  proto.createCallback = function(index, el) {
    var _this = this;
    return function(obj) {
      var _options;
      _this.resolveGradient(obj, el, 'fill');
      _this.resolveGradient(obj, el, 'stroke');
      if (obj instanceof fabric.Image && obj._originalElement) {
        _options = obj.parsePreserveAspectRatioAttribute(el);
      }
      obj._removeTransformMatrix(_options);
      _this.resolveClipPath(obj, el);
      _this.reviver && _this.reviver(el, obj);
      _this.instances[index] = obj;
      _this.checkIfDone();
    };
  };

  proto.extractPropertyDefinition = function(obj, property, storage) {
    var value = obj[property], regex = this.regexUrl;
    if (!regex.test(value)) {
      return;
    }
    regex.lastIndex = 0;
    var id = regex.exec(value)[1];
    regex.lastIndex = 0;
    return fabric[storage][this.svgUid][id];
  };

  proto.resolveGradient = function(obj, el, property) {
    var gradientDef = this.extractPropertyDefinition(obj, property, 'gradientDefs');
    if (gradientDef) {
      var opacityAttr = el.getAttribute(property + '-opacity');
      var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
      obj.set(property, gradient);
    }
  };

  proto.createClipPathCallback = function(obj, container) {
    return function(_newObj) {
      _newObj._removeTransformMatrix();
      _newObj.fillRule = _newObj.clipRule;
      container.push(_newObj);
    };
  };

  proto.resolveClipPath = function(obj, usingElement) {
    var clipPath = this.extractPropertyDefinition(obj, 'clipPath', 'clipPaths'),
        element, klass, objTransformInv, container, gTransform, options;
    if (clipPath) {
      container = [];
      objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
      // move the clipPath tag as sibling to the real element that is using it
      var clipPathTag = clipPath[0].parentNode;
      var clipPathOwner = usingElement;
      while (clipPathOwner.parentNode && clipPathOwner.getAttribute('clip-path') !== obj.clipPath) {
        clipPathOwner = clipPathOwner.parentNode;
      }
      clipPathOwner.parentNode.appendChild(clipPathTag);
      for (var i = 0; i < clipPath.length; i++) {
        element = clipPath[i];
        klass = this.findTag(element);
        klass.fromElement(
          element,
          this.createClipPathCallback(obj, container),
          this.options
        );
      }
      if (container.length === 1) {
        clipPath = container[0];
      }
      else {
        clipPath = new fabric.Group(container);
      }
      gTransform = fabric.util.multiplyTransformMatrices(
        objTransformInv,
        clipPath.calcTransformMatrix()
      );
      if (clipPath.clipPath) {
        this.resolveClipPath(clipPath, clipPathOwner);
      }
      var options = fabric.util.qrDecompose(gTransform);
      clipPath.flipX = false;
      clipPath.flipY = false;
      clipPath.set('scaleX', options.scaleX);
      clipPath.set('scaleY', options.scaleY);
      clipPath.angle = options.angle;
      clipPath.skewX = options.skewX;
      clipPath.skewY = 0;
      clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, 'center', 'center');
      obj.clipPath = clipPath;
    }
    else {
      // if clip-path does not resolve to any element, delete the property.
      delete obj.clipPath;
    }
  };

  proto.checkIfDone = function() {
    if (--this.numElements === 0) {
      this.instances = this.instances.filter(function(el) {
        // eslint-disable-next-line no-eq-null, eqeqeq
        return el != null;
      });
      this.callback(this.instances, this.elements);
    }
  };
})(fabric.ElementsParser.prototype);


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Point) {
    fabric.warn('fabric.Point is already defined');
    return;
  }

  fabric.Point = Point;

  /**
   * Point class
   * @class fabric.Point
   * @memberOf fabric
   * @constructor
   * @param {Number} x
   * @param {Number} y
   * @return {fabric.Point} thisArg
   */
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  Point.prototype = /** @lends fabric.Point.prototype */ {

    type: 'point',

    constructor: Point,

    /**
     * Adds another point to this one and returns another one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point instance with added values
     */
    add: function (that) {
      return new Point(this.x + that.x, this.y + that.y);
    },

    /**
     * Adds another point to this one
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    addEquals: function (that) {
      this.x += that.x;
      this.y += that.y;
      return this;
    },

    /**
     * Adds value to this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point} new Point with added value
     */
    scalarAdd: function (scalar) {
      return new Point(this.x + scalar, this.y + scalar);
    },

    /**
     * Adds value to this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarAddEquals: function (scalar) {
      this.x += scalar;
      this.y += scalar;
      return this;
    },

    /**
     * Subtracts another point from this point and returns a new one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point object with subtracted values
     */
    subtract: function (that) {
      return new Point(this.x - that.x, this.y - that.y);
    },

    /**
     * Subtracts another point from this point
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    subtractEquals: function (that) {
      this.x -= that.x;
      this.y -= that.y;
      return this;
    },

    /**
     * Subtracts value from this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    scalarSubtract: function (scalar) {
      return new Point(this.x - scalar, this.y - scalar);
    },

    /**
     * Subtracts value from this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarSubtractEquals: function (scalar) {
      this.x -= scalar;
      this.y -= scalar;
      return this;
    },

    /**
     * Multiplies this point by a value and returns a new one
     * TODO: rename in scalarMultiply in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    multiply: function (scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    },

    /**
     * Multiplies this point by a value
     * TODO: rename in scalarMultiplyEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    multiplyEquals: function (scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    },

    /**
     * Divides this point by a value and returns a new one
     * TODO: rename in scalarDivide in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    divide: function (scalar) {
      return new Point(this.x / scalar, this.y / scalar);
    },

    /**
     * Divides this point by a value
     * TODO: rename in scalarDivideEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    divideEquals: function (scalar) {
      this.x /= scalar;
      this.y /= scalar;
      return this;
    },

    /**
     * Returns true if this point is equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    eq: function (that) {
      return (this.x === that.x && this.y === that.y);
    },

    /**
     * Returns true if this point is less than another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lt: function (that) {
      return (this.x < that.x && this.y < that.y);
    },

    /**
     * Returns true if this point is less than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lte: function (that) {
      return (this.x <= that.x && this.y <= that.y);
    },

    /**

     * Returns true if this point is greater another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gt: function (that) {
      return (this.x > that.x && this.y > that.y);
    },

    /**
     * Returns true if this point is greater than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gte: function (that) {
      return (this.x >= that.x && this.y >= that.y);
    },

    /**
     * Returns new point which is the result of linear interpolation with this one and another one
     * @param {fabric.Point} that
     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
     * @return {fabric.Point}
     */
    lerp: function (that, t) {
      if (typeof t === 'undefined') {
        t = 0.5;
      }
      t = Math.max(Math.min(1, t), 0);
      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
    },

    /**
     * Returns distance from this point and another one
     * @param {fabric.Point} that
     * @return {Number}
     */
    distanceFrom: function (that) {
      var dx = this.x - that.x,
          dy = this.y - that.y;
      return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Returns the point between this point and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    midPointFrom: function (that) {
      return this.lerp(that);
    },

    /**
     * Returns a new point which is the min of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    min: function (that) {
      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
    },

    /**
     * Returns a new point which is the max of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    max: function (that) {
      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
    },

    /**
     * Returns string representation of this point
     * @return {String}
     */
    toString: function () {
      return this.x + ',' + this.y;
    },

    /**
     * Sets x/y of this point
     * @param {Number} x
     * @param {Number} y
     * @chainable
     */
    setXY: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * Sets x of this point
     * @param {Number} x
     * @chainable
     */
    setX: function (x) {
      this.x = x;
      return this;
    },

    /**
     * Sets y of this point
     * @param {Number} y
     * @chainable
     */
    setY: function (y) {
      this.y = y;
      return this;
    },

    /**
     * Sets x/y of this point from another point
     * @param {fabric.Point} that
     * @chainable
     */
    setFromPoint: function (that) {
      this.x = that.x;
      this.y = that.y;
      return this;
    },

    /**
     * Swaps x/y of this point and another point
     * @param {fabric.Point} that
     */
    swap: function (that) {
      var x = this.x,
          y = this.y;
      this.x = that.x;
      this.y = that.y;
      that.x = x;
      that.y = y;
    },

    /**
     * return a cloned instance of the point
     * @return {fabric.Point}
     */
    clone: function () {
      return new Point(this.x, this.y);
    }
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Intersection) {
    fabric.warn('fabric.Intersection is already defined');
    return;
  }

  /**
   * Intersection class
   * @class fabric.Intersection
   * @memberOf fabric
   * @constructor
   */
  function Intersection(status) {
    this.status = status;
    this.points = [];
  }

  fabric.Intersection = Intersection;

  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

    constructor: Intersection,

    /**
     * Appends a point to intersection
     * @param {fabric.Point} point
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoint: function (point) {
      this.points.push(point);
      return this;
    },

    /**
     * Appends points to intersection
     * @param {Array} points
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoints: function (points) {
      this.points = this.points.concat(points);
      return this;
    }
  };

  /**
   * Checks if one line intersects another
   * TODO: rename in intersectSegmentSegment
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {fabric.Point} b1
   * @param {fabric.Point} b2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
    var result,
        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    if (uB !== 0) {
      var ua = uaT / uB,
          ub = ubT / uB;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        result = new Intersection('Intersection');
        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
      }
      else {
        result = new Intersection();
      }
    }
    else {
      if (uaT === 0 || ubT === 0) {
        result = new Intersection('Coincident');
      }
      else {
        result = new Intersection('Parallel');
      }
    }
    return result;
  };

  /**
   * Checks if line intersects polygon
   * TODO: rename in intersectSegmentPolygon
   * fix detection of coincident
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {Array} points
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
    var result = new Intersection(),
        length = points.length,
        b1, b2, inter, i;

    for (i = 0; i < length; i++) {
      b1 = points[i];
      b2 = points[(i + 1) % length];
      inter = Intersection.intersectLineLine(a1, a2, b1, b2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects another polygon
   * @static
   * @param {Array} points1
   * @param {Array} points2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
    var result = new Intersection(),
        length = points1.length, i;

    for (i = 0; i < length; i++) {
      var a1 = points1[i],
          a2 = points1[(i + 1) % length],
          inter = Intersection.intersectLinePolygon(a1, a2, points2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects rectangle
   * @static
   * @param {Array} points
   * @param {fabric.Point} r1
   * @param {fabric.Point} r2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
    var min = r1.min(r2),
        max = r1.max(r2),
        topRight = new fabric.Point(max.x, min.y),
        bottomLeft = new fabric.Point(min.x, max.y),
        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
        result = new Intersection();

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Color) {
    fabric.warn('fabric.Color is already defined.');
    return;
  }

  /**
   * Color class
   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
   *
   * @class fabric.Color
   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
   * @return {fabric.Color} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
   */
  function Color(color) {
    if (!color) {
      this.setSource([0, 0, 0, 1]);
    }
    else {
      this._tryParsingColor(color);
    }
  }

  fabric.Color = Color;

  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

    /**
     * @private
     * @param {String|Array} color Color value to parse
     */
    _tryParsingColor: function(color) {
      var source;

      if (color in Color.colorNameMap) {
        color = Color.colorNameMap[color];
      }

      if (color === 'transparent') {
        source = [255, 255, 255, 0];
      }

      if (!source) {
        source = Color.sourceFromHex(color);
      }
      if (!source) {
        source = Color.sourceFromRgb(color);
      }
      if (!source) {
        source = Color.sourceFromHsl(color);
      }
      if (!source) {
        //if color is not recognize let's make black as canvas does
        source = [0, 0, 0, 1];
      }
      if (source) {
        this.setSource(source);
      }
    },

    /**
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @private
     * @param {Number} r Red color value
     * @param {Number} g Green color value
     * @param {Number} b Blue color value
     * @return {Array} Hsl color
     */
    _rgbToHsl: function(r, g, b) {
      r /= 255; g /= 255; b /= 255;

      var h, s, l,
          max = fabric.util.array.max([r, g, b]),
          min = fabric.util.array.min([r, g, b]);

      l = (max + min) / 2;

      if (max === min) {
        h = s = 0; // achromatic
      }
      else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }

      return [
        Math.round(h * 360),
        Math.round(s * 100),
        Math.round(l * 100)
      ];
    },

    /**
     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @return {Array}
     */
    getSource: function() {
      return this._source;
    },

    /**
     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @param {Array} source
     */
    setSource: function(source) {
      this._source = source;
    },

    /**
     * Returns color representation in RGB format
     * @return {String} ex: rgb(0-255,0-255,0-255)
     */
    toRgb: function() {
      var source = this.getSource();
      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
    },

    /**
     * Returns color representation in RGBA format
     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
     */
    toRgba: function() {
      var source = this.getSource();
      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
    },

    /**
     * Returns color representation in HSL format
     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
     */
    toHsl: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
    },

    /**
     * Returns color representation in HSLA format
     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
     */
    toHsla: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
    },

    /**
     * Returns color representation in HEX format
     * @return {String} ex: FF5555
     */
    toHex: function() {
      var source = this.getSource(), r, g, b;

      r = source[0].toString(16);
      r = (r.length === 1) ? ('0' + r) : r;

      g = source[1].toString(16);
      g = (g.length === 1) ? ('0' + g) : g;

      b = source[2].toString(16);
      b = (b.length === 1) ? ('0' + b) : b;

      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
    },

    /**
     * Returns color representation in HEXA format
     * @return {String} ex: FF5555CC
     */
    toHexa: function() {
      var source = this.getSource(), a;

      a = Math.round(source[3] * 255);
      a = a.toString(16);
      a = (a.length === 1) ? ('0' + a) : a;

      return this.toHex() + a.toUpperCase();
    },

    /**
     * Gets value of alpha channel for this color
     * @return {Number} 0-1
     */
    getAlpha: function() {
      return this.getSource()[3];
    },

    /**
     * Sets value of alpha channel for this color
     * @param {Number} alpha Alpha value 0-1
     * @return {fabric.Color} thisArg
     */
    setAlpha: function(alpha) {
      var source = this.getSource();
      source[3] = alpha;
      this.setSource(source);
      return this;
    },

    /**
     * Transforms color to its grayscale representation
     * @return {fabric.Color} thisArg
     */
    toGrayscale: function() {
      var source = this.getSource(),
          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
          currentAlpha = source[3];
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Transforms color to its black and white representation
     * @param {Number} threshold
     * @return {fabric.Color} thisArg
     */
    toBlackWhite: function(threshold) {
      var source = this.getSource(),
          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
          currentAlpha = source[3];

      threshold = threshold || 127;

      average = (Number(average) < Number(threshold)) ? 0 : 255;
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Overlays color with another color
     * @param {String|fabric.Color} otherColor
     * @return {fabric.Color} thisArg
     */
    overlayWith: function(otherColor) {
      if (!(otherColor instanceof Color)) {
        otherColor = new Color(otherColor);
      }

      var result = [],
          alpha = this.getAlpha(),
          otherAlpha = 0.5,
          source = this.getSource(),
          otherSource = otherColor.getSource(), i;

      for (i = 0; i < 3; i++) {
        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
      }

      result[3] = alpha;
      this.setSource(result);
      return this;
    }
  };

  /**
   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  // eslint-disable-next-line max-len
  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

  /**
   * Map of the 148 color names with HEX code
   * @static
   * @field
   * @memberOf fabric.Color
   * @see: https://www.w3.org/TR/css3-color/#svg-color
   */
  fabric.Color.colorNameMap = {
    aliceblue:            '#F0F8FF',
    antiquewhite:         '#FAEBD7',
    aqua:                 '#00FFFF',
    aquamarine:           '#7FFFD4',
    azure:                '#F0FFFF',
    beige:                '#F5F5DC',
    bisque:               '#FFE4C4',
    black:                '#000000',
    blanchedalmond:       '#FFEBCD',
    blue:                 '#0000FF',
    blueviolet:           '#8A2BE2',
    brown:                '#A52A2A',
    burlywood:            '#DEB887',
    cadetblue:            '#5F9EA0',
    chartreuse:           '#7FFF00',
    chocolate:            '#D2691E',
    coral:                '#FF7F50',
    cornflowerblue:       '#6495ED',
    cornsilk:             '#FFF8DC',
    crimson:              '#DC143C',
    cyan:                 '#00FFFF',
    darkblue:             '#00008B',
    darkcyan:             '#008B8B',
    darkgoldenrod:        '#B8860B',
    darkgray:             '#A9A9A9',
    darkgrey:             '#A9A9A9',
    darkgreen:            '#006400',
    darkkhaki:            '#BDB76B',
    darkmagenta:          '#8B008B',
    darkolivegreen:       '#556B2F',
    darkorange:           '#FF8C00',
    darkorchid:           '#9932CC',
    darkred:              '#8B0000',
    darksalmon:           '#E9967A',
    darkseagreen:         '#8FBC8F',
    darkslateblue:        '#483D8B',
    darkslategray:        '#2F4F4F',
    darkslategrey:        '#2F4F4F',
    darkturquoise:        '#00CED1',
    darkviolet:           '#9400D3',
    deeppink:             '#FF1493',
    deepskyblue:          '#00BFFF',
    dimgray:              '#696969',
    dimgrey:              '#696969',
    dodgerblue:           '#1E90FF',
    firebrick:            '#B22222',
    floralwhite:          '#FFFAF0',
    forestgreen:          '#228B22',
    fuchsia:              '#FF00FF',
    gainsboro:            '#DCDCDC',
    ghostwhite:           '#F8F8FF',
    gold:                 '#FFD700',
    goldenrod:            '#DAA520',
    gray:                 '#808080',
    grey:                 '#808080',
    green:                '#008000',
    greenyellow:          '#ADFF2F',
    honeydew:             '#F0FFF0',
    hotpink:              '#FF69B4',
    indianred:            '#CD5C5C',
    indigo:               '#4B0082',
    ivory:                '#FFFFF0',
    khaki:                '#F0E68C',
    lavender:             '#E6E6FA',
    lavenderblush:        '#FFF0F5',
    lawngreen:            '#7CFC00',
    lemonchiffon:         '#FFFACD',
    lightblue:            '#ADD8E6',
    lightcoral:           '#F08080',
    lightcyan:            '#E0FFFF',
    lightgoldenrodyellow: '#FAFAD2',
    lightgray:            '#D3D3D3',
    lightgrey:            '#D3D3D3',
    lightgreen:           '#90EE90',
    lightpink:            '#FFB6C1',
    lightsalmon:          '#FFA07A',
    lightseagreen:        '#20B2AA',
    lightskyblue:         '#87CEFA',
    lightslategray:       '#778899',
    lightslategrey:       '#778899',
    lightsteelblue:       '#B0C4DE',
    lightyellow:          '#FFFFE0',
    lime:                 '#00FF00',
    limegreen:            '#32CD32',
    linen:                '#FAF0E6',
    magenta:              '#FF00FF',
    maroon:               '#800000',
    mediumaquamarine:     '#66CDAA',
    mediumblue:           '#0000CD',
    mediumorchid:         '#BA55D3',
    mediumpurple:         '#9370DB',
    mediumseagreen:       '#3CB371',
    mediumslateblue:      '#7B68EE',
    mediumspringgreen:    '#00FA9A',
    mediumturquoise:      '#48D1CC',
    mediumvioletred:      '#C71585',
    midnightblue:         '#191970',
    mintcream:            '#F5FFFA',
    mistyrose:            '#FFE4E1',
    moccasin:             '#FFE4B5',
    navajowhite:          '#FFDEAD',
    navy:                 '#000080',
    oldlace:              '#FDF5E6',
    olive:                '#808000',
    olivedrab:            '#6B8E23',
    orange:               '#FFA500',
    orangered:            '#FF4500',
    orchid:               '#DA70D6',
    palegoldenrod:        '#EEE8AA',
    palegreen:            '#98FB98',
    paleturquoise:        '#AFEEEE',
    palevioletred:        '#DB7093',
    papayawhip:           '#FFEFD5',
    peachpuff:            '#FFDAB9',
    peru:                 '#CD853F',
    pink:                 '#FFC0CB',
    plum:                 '#DDA0DD',
    powderblue:           '#B0E0E6',
    purple:               '#800080',
    rebeccapurple:        '#663399',
    red:                  '#FF0000',
    rosybrown:            '#BC8F8F',
    royalblue:            '#4169E1',
    saddlebrown:          '#8B4513',
    salmon:               '#FA8072',
    sandybrown:           '#F4A460',
    seagreen:             '#2E8B57',
    seashell:             '#FFF5EE',
    sienna:               '#A0522D',
    silver:               '#C0C0C0',
    skyblue:              '#87CEEB',
    slateblue:            '#6A5ACD',
    slategray:            '#708090',
    slategrey:            '#708090',
    snow:                 '#FFFAFA',
    springgreen:          '#00FF7F',
    steelblue:            '#4682B4',
    tan:                  '#D2B48C',
    teal:                 '#008080',
    thistle:              '#D8BFD8',
    tomato:               '#FF6347',
    turquoise:            '#40E0D0',
    violet:               '#EE82EE',
    wheat:                '#F5DEB3',
    white:                '#FFFFFF',
    whitesmoke:           '#F5F5F5',
    yellow:               '#FFFF00',
    yellowgreen:          '#9ACD32'
  };

  /**
   * @private
   * @param {Number} p
   * @param {Number} q
   * @param {Number} t
   * @return {Number}
   */
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }

  /**
   * Returns new color object, when given a color in RGB format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
   * @return {fabric.Color}
   */
  fabric.Color.fromRgb = function(color) {
    return Color.fromSource(Color.sourceFromRgb(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
   * @return {Array} source
   */
  fabric.Color.sourceFromRgb = function(color) {
    var match = color.match(Color.reRGBa);
    if (match) {
      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

      return [
        parseInt(r, 10),
        parseInt(g, 10),
        parseInt(b, 10),
        match[4] ? parseFloat(match[4]) : 1
      ];
    }
  };

  /**
   * Returns new color object, when given a color in RGBA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromRgba = Color.fromRgb;

  /**
   * Returns new color object, when given a color in HSL format
   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
   * @memberOf fabric.Color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsl = function(color) {
    return Color.fromSource(Color.sourceFromHsl(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
   * @memberOf fabric.Color
   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
   * @return {Array} source
   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
   */
  fabric.Color.sourceFromHsl = function(color) {
    var match = color.match(Color.reHSLa);
    if (!match) {
      return;
    }

    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
        r, g, b;

    if (s === 0) {
      r = g = b = l;
    }
    else {
      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
          p = l * 2 - q;

      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255),
      match[4] ? parseFloat(match[4]) : 1
    ];
  };

  /**
   * Returns new color object, when given a color in HSLA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsla = Color.fromHsl;

  /**
   * Returns new color object, when given a color in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color Color value ex: FF5555
   * @return {fabric.Color}
   */
  fabric.Color.fromHex = function(color) {
    return Color.fromSource(Color.sourceFromHex(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color ex: FF5555 or FF5544CC (RGBa)
   * @return {Array} source
   */
  fabric.Color.sourceFromHex = function(color) {
    if (color.match(Color.reHex)) {
      var value = color.slice(color.indexOf('#') + 1),
          isShortNotation = (value.length === 3 || value.length === 4),
          isRGBa = (value.length === 8 || value.length === 4),
          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

      return [
        parseInt(r, 16),
        parseInt(g, 16),
        parseInt(b, 16),
        parseFloat((parseInt(a, 16) / 255).toFixed(2))
      ];
    }
  };

  /**
   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
   * @static
   * @memberOf fabric.Color
   * @param {Array} source
   * @return {fabric.Color}
   */
  fabric.Color.fromSource = function(source) {
    var oColor = new Color();
    oColor.setSource(source);
    return oColor;
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      scaleMap = ['e', 'se', 's', 'sw', 'w', 'nw', 'n', 'ne', 'e'],
      skewMap = ['ns', 'nesw', 'ew', 'nwse'],
      controls = {},
      LEFT = 'left', TOP = 'top', RIGHT = 'right', BOTTOM = 'bottom', CENTER = 'center',
      opposite = {
        top: BOTTOM,
        bottom: TOP,
        left: RIGHT,
        right: LEFT,
        center: CENTER,
      }, radiansToDegrees = fabric.util.radiansToDegrees,
      sign = (Math.sign || function(x) { return ((x > 0) - (x < 0)) || +x; });

  /**
   * Combine control position and object angle to find the control direction compared
   * to the object center.
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   * @param {fabric.Control} control the control class
   * @return {Number} 0 - 7 a quadrant number
   */
  function findCornerQuadrant(fabricObject, control) {
    var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;
    return Math.round((cornerAngle % 360) / 45);
  }

  function fireEvent(eventName, options) {
    var target = options.transform.target,
        canvas = target.canvas,
        canvasOptions = fabric.util.object.clone(options);
    canvasOptions.target = target;
    canvas && canvas.fire('object:' + eventName, canvasOptions);
    target.fire(eventName, options);
  }

  /**
   * Inspect event and fabricObject properties to understand if the scaling action
   * @param {Event} eventData from the user action
   * @param {fabric.Object} fabricObject the fabric object about to scale
   * @return {Boolean} true if scale is proportional
   */
  function scaleIsProportional(eventData, fabricObject) {
    var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey,
        uniformIsToggled = eventData[uniScaleKey];
    return (canvas.uniformScaling && !uniformIsToggled) ||
    (!canvas.uniformScaling && uniformIsToggled);
  }

  /**
   * Checks if transform is centered
   * @param {Object} transform transform data
   * @return {Boolean} true if transform is centered
   */
  function isTransformCentered(transform) {
    return transform.originX === CENTER && transform.originY === CENTER;
  }

  /**
   * Inspect fabricObject to understand if the current scaling action is allowed
   * @param {fabric.Object} fabricObject the fabric object about to scale
   * @param {String} by 'x' or 'y' or ''
   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally
   * @return {Boolean} true if scaling is not allowed at current conditions
   */
  function scalingIsForbidden(fabricObject, by, scaleProportionally) {
    var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;
    if (lockX && lockY) {
      return true;
    }
    if (!by && (lockX || lockY) && scaleProportionally) {
      return true;
    }
    if (lockX && by === 'x') {
      return true;
    }
    if (lockY && by === 'y') {
      return true;
    }
    return false;
  }

  /**
   * return the correct cursor style for the scale action
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function scaleCursorStyleHandler(eventData, control, fabricObject) {
    var notAllowed = 'not-allowed',
        scaleProportionally = scaleIsProportional(eventData, fabricObject),
        by = '';
    if (control.x !== 0 && control.y === 0) {
      by = 'x';
    }
    else if (control.x === 0 && control.y !== 0) {
      by = 'y';
    }
    if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {
      return notAllowed;
    }
    var n = findCornerQuadrant(fabricObject, control);
    return scaleMap[n] + '-resize';
  }

  /**
   * return the correct cursor style for the skew action
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function skewCursorStyleHandler(eventData, control, fabricObject) {
    var notAllowed = 'not-allowed';
    if (control.x !== 0 && fabricObject.lockSkewingY) {
      return notAllowed;
    }
    if (control.y !== 0 && fabricObject.lockSkewingX) {
      return notAllowed;
    }
    var n = findCornerQuadrant(fabricObject, control) % 4;
    return skewMap[n] + '-resize';
  }

  /**
   * Combine skew and scale style handlers to cover fabric standard use case
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {
    if (eventData[fabricObject.canvas.altActionKey]) {
      return controls.skewCursorStyleHandler(eventData, control, fabricObject);
    }
    return controls.scaleCursorStyleHandler(eventData, control, fabricObject);
  }

  /**
   * Inspect event, control and fabricObject to return the correct action name
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} an action name
   */
  function scaleOrSkewActionName(eventData, control, fabricObject) {
    var isAlternative = eventData[fabricObject.canvas.altActionKey];
    if (control.x === 0) {
      // then is scaleY or skewX
      return isAlternative ? 'skewX' : 'scaleY';
    }
    if (control.y === 0) {
      // then is scaleY or skewX
      return isAlternative ? 'skewY' : 'scaleX';
    }
  }

  /**
   * Find the correct style for the control that is used for rotation.
   * this function is very simple and it just take care of not-allowed or standard cursor
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function rotationStyleHandler(eventData, control, fabricObject) {
    if (fabricObject.lockRotation) {
      return 'not-allowed';
    }
    return control.cursorStyle;
  }

  function commonEventInfo(eventData, transform, x, y) {
    return {
      e: eventData,
      transform: transform,
      pointer: {
        x: x,
        y: y,
      }
    };
  }

  /**
   * Wrap an action handler with saving/restoring object position on the transform.
   * this is the code that permits to objects to keep their position while transforming.
   * @param {Function} actionHandler the function to wrap
   * @return {Function} a function with an action handler signature
   */
  function wrapWithFixedAnchor(actionHandler) {
    return function(eventData, transform, x, y) {
      var target = transform.target, centerPoint = target.getCenterPoint(),
          constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY),
          actionPerformed = actionHandler(eventData, transform, x, y);
      target.setPositionByOrigin(constraint, transform.originX, transform.originY);
      return actionPerformed;
    };
  }

  /**
   * Transforms a point described by x and y in a distance from the top left corner of the object
   * bounding box.
   * @param {Object} transform
   * @param {String} originX
   * @param {String} originY
   * @param {number} x
   * @param {number} y
   * @return {Fabric.Point} the normalized point
   */
  function getLocalPoint(transform, originX, originY, x, y) {
    var target = transform.target,
        control = target.controls[transform.corner],
        zoom = target.canvas.getZoom(),
        padding = target.padding / zoom,
        localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);
    if (localPoint.x >= padding) {
      localPoint.x -= padding;
    }
    if (localPoint.x <= -padding) {
      localPoint.x += padding;
    }
    if (localPoint.y >= padding) {
      localPoint.y -= padding;
    }
    if (localPoint.y <= padding) {
      localPoint.y += padding;
    }
    localPoint.x -= control.offsetX;
    localPoint.y -= control.offsetY;
    return localPoint;
  }

  /**
   * Detect if the fabric object is flipped on one side.
   * @param {fabric.Object} target
   * @return {Boolean} true if one flip, but not two.
   */
  function targetHasOneFlip(target) {
    return target.flipX !== target.flipY;
  }

  /**
   * Utility function to compensate the scale factor when skew is applied on both axes
   * @private
   */
  function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {
    if (target[oppositeSkew] !== 0) {
      var newDim = target._getTransformedDimensions()[axis];
      var newValue = reference / newDim * target[scaleToCompensate];
      target.set(scaleToCompensate, newValue);
    }
  }

  /**
   * Action handler for skewing on the X axis
   * @private
   */
  function skewObjectX(eventData, transform, x, y) {
    var target = transform.target,
        // find how big the object would be, if there was no skewX. takes in account scaling
        dimNoSkew = target._getTransformedDimensions(0, target.skewY),
        localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        // the mouse is in the center of the object, and we want it to stay there.
        // so the object will grow twice as much as the mouse.
        // this makes the skew growth to localPoint * 2 - dimNoSkew.
        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x,
        currentSkew = target.skewX, newSkew;
    if (totalSkewSize < 2) {
      // let's make it easy to go back to position 0.
      newSkew = 0;
    }
    else {
      newSkew = radiansToDegrees(
        Math.atan2((totalSkewSize / target.scaleX), (dimNoSkew.y / target.scaleY))
      );
      // now we have to find the sign of the skew.
      // it mostly depend on the origin of transformation.
      if (transform.originX === LEFT && transform.originY === BOTTOM) {
        newSkew = -newSkew;
      }
      if (transform.originX === RIGHT && transform.originY === TOP) {
        newSkew = -newSkew;
      }
      if (targetHasOneFlip(target)) {
        newSkew = -newSkew;
      }
    }
    var hasSkewed = currentSkew !== newSkew;
    if (hasSkewed) {
      var dimBeforeSkewing = target._getTransformedDimensions().y;
      target.set('skewX', newSkew);
      compensateScaleForSkew(target, 'skewY', 'scaleY', 'y', dimBeforeSkewing);
      fireEvent('skewing', commonEventInfo(eventData, transform, x, y));
    }
    return hasSkewed;
  }

  /**
   * Action handler for skewing on the Y axis
   * @private
   */
  function skewObjectY(eventData, transform, x, y) {
    var target = transform.target,
        // find how big the object would be, if there was no skewX. takes in account scaling
        dimNoSkew = target._getTransformedDimensions(target.skewX, 0),
        localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        // the mouse is in the center of the object, and we want it to stay there.
        // so the object will grow twice as much as the mouse.
        // this makes the skew growth to localPoint * 2 - dimNoSkew.
        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y,
        currentSkew = target.skewY, newSkew;
    if (totalSkewSize < 2) {
      // let's make it easy to go back to position 0.
      newSkew = 0;
    }
    else {
      newSkew = radiansToDegrees(
        Math.atan2((totalSkewSize / target.scaleY), (dimNoSkew.x / target.scaleX))
      );
      // now we have to find the sign of the skew.
      // it mostly depend on the origin of transformation.
      if (transform.originX === LEFT && transform.originY === BOTTOM) {
        newSkew = -newSkew;
      }
      if (transform.originX === RIGHT && transform.originY === TOP) {
        newSkew = -newSkew;
      }
      if (targetHasOneFlip(target)) {
        newSkew = -newSkew;
      }
    }
    var hasSkewed = currentSkew !== newSkew;
    if (hasSkewed) {
      var dimBeforeSkewing = target._getTransformedDimensions().x;
      target.set('skewY', newSkew);
      compensateScaleForSkew(target, 'skewX', 'scaleX', 'x', dimBeforeSkewing);
      fireEvent('skewing', commonEventInfo(eventData, transform, x, y));
    }
    return hasSkewed;
  }

  /**
   * Wrapped Action handler for skewing on the Y axis, takes care of the
   * skew direction and determine the correct transform origin for the anchor point
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function skewHandlerX(eventData, transform, x, y) {
    // step1 figure out and change transform origin.
    // if skewX > 0 and originY bottom we anchor on right
    // if skewX > 0 and originY top we anchor on left
    // if skewX < 0 and originY bottom we anchor on left
    // if skewX < 0 and originY top we anchor on right
    // if skewX is 0, we look for mouse position to understand where are we going.
    var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;
    if (target.lockSkewingX) {
      return false;
    }
    if (currentSkew === 0) {
      var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);
      if (localPointFromCenter.x > 0) {
        // we are pulling right, anchor left;
        originX = LEFT;
      }
      else {
        // we are pulling right, anchor right
        originX = RIGHT;
      }
    }
    else {
      if (currentSkew > 0) {
        originX = originY === TOP ? LEFT : RIGHT;
      }
      if (currentSkew < 0) {
        originX = originY === TOP ? RIGHT : LEFT;
      }
      // is the object flipped on one side only? swap the origin.
      if (targetHasOneFlip(target)) {
        originX = originX === LEFT ? RIGHT : LEFT;
      }
    }

    // once we have the origin, we find the anchor point
    transform.originX = originX;
    var finalHandler = wrapWithFixedAnchor(skewObjectX);
    return finalHandler(eventData, transform, x, y);
  }

  /**
   * Wrapped Action handler for skewing on the Y axis, takes care of the
   * skew direction and determine the correct transform origin for the anchor point
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function skewHandlerY(eventData, transform, x, y) {
    // step1 figure out and change transform origin.
    // if skewY > 0 and originX left we anchor on top
    // if skewY > 0 and originX right we anchor on bottom
    // if skewY < 0 and originX left we anchor on bottom
    // if skewY < 0 and originX right we anchor on top
    // if skewY is 0, we look for mouse position to understand where are we going.
    var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;
    if (target.lockSkewingY) {
      return false;
    }
    if (currentSkew === 0) {
      var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);
      if (localPointFromCenter.y > 0) {
        // we are pulling down, anchor up;
        originY = TOP;
      }
      else {
        // we are pulling up, anchor down
        originY = BOTTOM;
      }
    }
    else {
      if (currentSkew > 0) {
        originY = originX === LEFT ? TOP : BOTTOM;
      }
      if (currentSkew < 0) {
        originY = originX === LEFT ? BOTTOM : TOP;
      }
      // is the object flipped on one side only? swap the origin.
      if (targetHasOneFlip(target)) {
        originY = originY === TOP ? BOTTOM : TOP;
      }
    }

    // once we have the origin, we find the anchor point
    transform.originY = originY;
    var finalHandler = wrapWithFixedAnchor(skewObjectY);
    return finalHandler(eventData, transform, x, y);
  }

  /**
   * Action handler for rotation and snapping, without anchor point.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   * @private
   */
  function rotationWithSnapping(eventData, transform, x, y) {
    var t = transform,
        target = t.target,
        pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);

    if (target.lockRotation) {
      return false;
    }

    var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x),
        curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x),
        angle = radiansToDegrees(curAngle - lastAngle + t.theta),
        hasRotated = true;

    if (target.snapAngle > 0) {
      var snapAngle  = target.snapAngle,
          snapThreshold  = target.snapThreshold || snapAngle,
          rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
          leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

      if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
        angle = leftAngleLocked;
      }
      else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
        angle = rightAngleLocked;
      }
    }

    // normalize angle to positive value
    if (angle < 0) {
      angle = 360 + angle;
    }
    angle %= 360;

    hasRotated = target.angle !== angle;
    target.angle = angle;
    if (hasRotated) {
      fireEvent('rotating', commonEventInfo(eventData, transform, x, y));
    }
    return hasRotated;
  }

  /**
   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @param {Object} options additional information for scaling
   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling
   * @return {Boolean} true if some change happened
   * @private
   */
  function scaleObject(eventData, transform, x, y, options) {
    options = options || {};
    var target = transform.target,
        lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY,
        by = options.by, newPoint, scaleX, scaleY, dim,
        scaleProportionally = scaleIsProportional(eventData, target),
        forbidScaling = scalingIsForbidden(target, by, scaleProportionally),
        signX, signY, gestureScale = transform.gestureScale;

    if (forbidScaling) {
      return false;
    }
    if (gestureScale) {
      scaleX = transform.scaleX * gestureScale;
      scaleY = transform.scaleY * gestureScale;
    }
    else {
      newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);
      // use of sign: We use sign to detect change of direction of an action. sign usually change when
      // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling
      // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily
      // cross many time the origin point and flip the object. so we need a way to filter out the noise.
      // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.
      signX = by !== 'y' ? sign(newPoint.x) : 1;
      signY = by !== 'x' ? sign(newPoint.y) : 1;
      if (!transform.signX) {
        transform.signX = signX;
      }
      if (!transform.signY) {
        transform.signY = signY;
      }

      if (target.lockScalingFlip &&
        (transform.signX !== signX || transform.signY !== signY)
      ) {
        return false;
      }

      dim = target._getTransformedDimensions();
      // missing detection of flip and logic to switch the origin
      if (scaleProportionally && !by) {
        // uniform scaling
        var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y),
            original = transform.original,
            originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) +
              Math.abs(dim.y * original.scaleY / target.scaleY),
            scale = distance / originalDistance, hasScaled;
        scaleX = original.scaleX * scale;
        scaleY = original.scaleY * scale;
      }
      else {
        scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);
        scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);
      }
      // if we are scaling by center, we need to double the scale
      if (isTransformCentered(transform)) {
        scaleX *= 2;
        scaleY *= 2;
      }
      if (transform.signX !== signX && by !== 'y') {
        transform.originX = opposite[transform.originX];
        scaleX *= -1;
        transform.signX = signX;
      }
      if (transform.signY !== signY && by !== 'x') {
        transform.originY = opposite[transform.originY];
        scaleY *= -1;
        transform.signY = signY;
      }
    }
    // minScale is taken are in the setter.
    var oldScaleX = target.scaleX, oldScaleY = target.scaleY;
    if (!by) {
      !lockScalingX && target.set('scaleX', scaleX);
      !lockScalingY && target.set('scaleY', scaleY);
    }
    else {
      // forbidden cases already handled on top here.
      by === 'x' && target.set('scaleX', scaleX);
      by === 'y' && target.set('scaleY', scaleY);
    }
    hasScaled = oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;
    if (hasScaled) {
      fireEvent('scaling', commonEventInfo(eventData, transform, x, y));
    }
    return hasScaled;
  }

  /**
   * Generic scaling logic, to scale from corners either equally or freely.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectFromCorner(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y);
  }

  /**
   * Scaling logic for the X axis.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectX(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y , { by: 'x' });
  }

  /**
   * Scaling logic for the Y axis.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectY(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y , { by: 'y' });
  }

  /**
   * Composed action handler to either scale Y or skew X
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scalingYOrSkewingX(eventData, transform, x, y) {
    // ok some safety needed here.
    if (eventData[transform.target.canvas.altActionKey]) {
      return controls.skewHandlerX(eventData, transform, x, y);
    }
    return controls.scalingY(eventData, transform, x, y);
  }

  /**
   * Composed action handler to either scale X or skew Y
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scalingXOrSkewingY(eventData, transform, x, y) {
    // ok some safety needed here.
    if (eventData[transform.target.canvas.altActionKey]) {
      return controls.skewHandlerY(eventData, transform, x, y);
    }
    return controls.scalingX(eventData, transform, x, y);
  }

  /**
   * Action handler to change textbox width
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function changeWidth(eventData, transform, x, y) {
    var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1),
        multiplier = isTransformCentered(transform) ? 2 : 1,
        oldWidth = target.width, hasResized,
        newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;
    target.set('width', Math.max(newWidth, 0));
    hasResized = oldWidth !== newWidth;
    if (hasResized) {
      fireEvent('resizing', commonEventInfo(eventData, transform, x, y));
    }
    return hasResized;
  }

  /**
   * Action handler
   * @private
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if the translation occurred
   */
  function dragHandler(eventData, transform, x, y) {
    var target = transform.target,
        newLeft = x - transform.offsetX,
        newTop = y - transform.offsetY,
        moveX = !target.get('lockMovementX') && target.left !== newLeft,
        moveY = !target.get('lockMovementY') && target.top !== newTop;
    moveX && target.set('left', newLeft);
    moveY && target.set('top', newTop);
    if (moveX || moveY) {
      fireEvent('moving', commonEventInfo(eventData, transform, x, y));
    }
    return moveX || moveY;
  }

  controls.scaleCursorStyleHandler = scaleCursorStyleHandler;
  controls.skewCursorStyleHandler = skewCursorStyleHandler;
  controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;
  controls.rotationWithSnapping = wrapWithFixedAnchor(rotationWithSnapping);
  controls.scalingEqually = wrapWithFixedAnchor(scaleObjectFromCorner);
  controls.scalingX = wrapWithFixedAnchor(scaleObjectX);
  controls.scalingY = wrapWithFixedAnchor(scaleObjectY);
  controls.scalingYOrSkewingX = scalingYOrSkewingX;
  controls.scalingXOrSkewingY = scalingXOrSkewingY;
  controls.changeWidth = wrapWithFixedAnchor(changeWidth);
  controls.skewHandlerX = skewHandlerX;
  controls.skewHandlerY = skewHandlerY;
  controls.dragHandler = dragHandler;
  controls.scaleOrSkewActionName = scaleOrSkewActionName;
  controls.rotationStyleHandler = rotationStyleHandler;
  controls.fireEvent = fireEvent;
  controls.wrapWithFixedAnchor = wrapWithFixedAnchor;
  controls.getLocalPoint = getLocalPoint;
  fabric.controlsUtils = controls;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      degreesToRadians = fabric.util.degreesToRadians,
      controls = fabric.controlsUtils;

  /**
   * Render a round control, as per fabric features.
   * This function is written to respect object properties like transparentCorners, cornerSize
   * cornerColor, cornerStrokeColor
   * plus the addition of offsetY and offsetX.
   * @param {CanvasRenderingContext2D} ctx context to render on
   * @param {Number} left x coordinate where the control center should be
   * @param {Number} top y coordinate where the control center should be
   * @param {Object} styleOverride override for fabric.Object controls style
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   */
  function renderCircleControl (ctx, left, top, styleOverride, fabricObject) {
    styleOverride = styleOverride || {};
    var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,
        ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,
        transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
          styleOverride.transparentCorners : this.transparentCorners,
        methodName = transparentCorners ? 'stroke' : 'fill',
        stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor),
        myLeft = left,
        myTop = top, size;
    ctx.save();
    ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
    ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
    // as soon as fabric react v5, remove ie11, use proper ellipse code.
    if (xSize > ySize) {
      size = xSize;
      ctx.scale(1.0, ySize / xSize);
      myTop = top * xSize / ySize;
    }
    else if (ySize > xSize) {
      size = ySize;
      ctx.scale(xSize / ySize, 1.0);
      myLeft = left * ySize / xSize;
    }
    else {
      size = xSize;
    }
    // this is still wrong
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);
    ctx[methodName]();
    if (stroke) {
      ctx.stroke();
    }
    ctx.restore();
  }

  /**
   * Render a square control, as per fabric features.
   * This function is written to respect object properties like transparentCorners, cornerSize
   * cornerColor, cornerStrokeColor
   * plus the addition of offsetY and offsetX.
   * @param {CanvasRenderingContext2D} ctx context to render on
   * @param {Number} left x coordinate where the control center should be
   * @param {Number} top y coordinate where the control center should be
   * @param {Object} styleOverride override for fabric.Object controls style
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   */
  function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {
    styleOverride = styleOverride || {};
    var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,
        ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,
        transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
          styleOverride.transparentCorners : fabricObject.transparentCorners,
        methodName = transparentCorners ? 'stroke' : 'fill',
        stroke = !transparentCorners && (
          styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor
        ), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;
    ctx.save();
    ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
    ctx.strokeStyle = styleOverride.strokeCornerColor || fabricObject.strokeCornerColor;
    // this is still wrong
    ctx.lineWidth = 1;
    ctx.translate(left, top);
    ctx.rotate(degreesToRadians(fabricObject.angle));
    // this does not work, and fixed with ( && ) does not make sense.
    // to have real transparent corners we need the controls on upperCanvas
    // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
    ctx[methodName + 'Rect'](-xSizeBy2, -ySizeBy2, xSize, ySize);
    if (stroke) {
      ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
    }
    ctx.restore();
  }

  controls.renderCircleControl = renderCircleControl;
  controls.renderSquareControl = renderSquareControl;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  function Control(options) {
    for (var i in options) {
      this[i] = options[i];
    }
  }

  fabric.Control = Control;

  fabric.Control.prototype = /** @lends fabric.Control.prototype */ {

    /**
     * keep track of control visibility.
     * mainly for backward compatibility.
     * if you do not want to see a control, you can remove it
     * from the controlset.
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * Name of the action that the control will likely execute.
     * This is optional. FabricJS uses to identify what the user is doing for some
     * extra optimizations. If you are writing a custom control and you want to know
     * somewhere else in the code what is going on, you can use this string here.
     * you can also provide a custom getActionName if your control run multiple actions
     * depending on some external state.
     * default to scale since is the most common, used on 4 corners by default
     * @type {String}
     * @default 'scale'
     */
    actionName: 'scale',

    /**
     * Drawing angle of the control.
     * NOT used for now, but name marked as needed for internal logic
     * example: to reuse the same drawing function for different rotated controls
     * @type {Number}
     * @default 0
     */
    angle: 0,

    /**
     * Relative position of the control. X
     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    x: 0,

    /**
     * Relative position of the control. Y
     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    y: 0,

    /**
     * Horizontal offset of the control from the defined position. In pixels
     * Positive offset moves the control to the right, negative to the left.
     * It used when you want to have position of control that does not scale with
     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on
     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will
     * stay 30 pixels no matter how the object is big. Another example is having 2
     * controls in the corner, that stay in the same position when the object scale.
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset of the control from the defined position. In pixels
     * Positive offset moves the control to the bottom, negative to the top.
     * @type {Number}
     * @default 0
     */
    offsetY: 0,

    /**
     * Sets the length of the control. If null, defaults to object's cornerSize.
     * Expects both sizeX and sizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    sizeX: null,

    /**
     * Sets the height of the control. If null, defaults to object's cornerSize.
     * Expects both sizeX and sizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    sizeY: null,

    /**
     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.
     * Expects both touchSizeX and touchSizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    touchSizeX: null,

    /**
     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.
     * Expects both touchSizeX and touchSizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    touchSizeY: null,

    /**
     * Css cursor style to display when the control is hovered.
     * if the method `cursorStyleHandler` is provided, this property is ignored.
     * @type {String}
     * @default 'crosshair'
     */
    cursorStyle: 'crosshair',

    /**
     * If controls has an offsetY or offsetX, draw a line that connects
     * the control to the bounding box
     * @type {Boolean}
     * @default false
     */
    withConnection: false,

    /**
     * The control actionHandler, provide one to handle action ( control being moved )
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    actionHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * The control handler for mouse down, provide one to handle mouse down on control
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    mouseDownHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * The control mouseUpHandler, provide one to handle an effect on mouse up.
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    mouseUpHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * Returns control actionHandler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getActionHandler: function(/* eventData, fabricObject, control */) {
      return this.actionHandler;
    },

    /**
     * Returns control mouseDown handler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getMouseDownHandler: function(/* eventData, fabricObject, control */) {
      return this.mouseDownHandler;
    },

    /**
     * Returns control mouseUp handler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getMouseUpHandler: function(/* eventData, fabricObject, control */) {
      return this.mouseUpHandler;
    },

    /**
     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate
     * function you can pass one in the constructor
     * the cursorStyle property
     * @param {Event} eventData the native mouse event
     * @param {fabric.Control} control the current control ( likely this)
     * @param {fabric.Object} object on which the control is displayed
     * @return {String}
     */
    cursorStyleHandler: function(eventData, control /* fabricObject */) {
      return control.cursorStyle;
    },

    /**
     * Returns the action name. The basic implementation just return the actionName property.
     * @param {Event} eventData the native mouse event
     * @param {fabric.Control} control the current control ( likely this)
     * @param {fabric.Object} object on which the control is displayed
     * @return {String}
     */
    getActionName: function(eventData, control /* fabricObject */) {
      return control.actionName;
    },

    /**
     * Returns controls visibility
     * @param {fabric.Object} object on which the control is displayed
     * @param {String} controlKey key where the control is memorized on the
     * @return {Boolean}
     */
    getVisibility: function(fabricObject, controlKey) {
      var objectVisibility = fabricObject._controlsVisibility;
      if (objectVisibility && typeof objectVisibility[controlKey] !== 'undefined') {
        return objectVisibility[controlKey];
      }
      return this.visible;
    },

    /**
     * Sets controls visibility
     * @param {Boolean} visibility for the object
     * @return {Void}
     */
    setVisibility: function(visibility /* name, fabricObject */) {
      this.visible = visibility;
    },


    positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */) {
      var point = fabric.util.transformPoint({
        x: this.x * dim.x + this.offsetX,
        y: this.y * dim.y + this.offsetY }, finalMatrix);
      return point;
    },

    /**
     * Returns the coords for this control based on object values.
     * @param {Number} objectAngle angle from the fabric object holding the control
     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if
     *   isTouch is true)
     * @param {Number} centerX x coordinate where the control center should be
     * @param {Number} centerY y coordinate where the control center should be
     * @param {boolean} isTouch true if touch corner, false if normal corner
     */
    calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {
      var cosHalfOffset,
          sinHalfOffset,
          cosHalfOffsetComp,
          sinHalfOffsetComp,
          xSize = (isTouch) ? this.touchSizeX : this.sizeX,
          ySize = (isTouch) ? this.touchSizeY : this.sizeY;
      if (xSize && ySize && xSize !== ySize) {
        // handle rectangular corners
        var controlTriangleAngle = Math.atan2(ySize, xSize);
        var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;
        var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);
        var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);
        cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);
        sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);
        // use complementary angle for two corners
        cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);
        sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);
      }
      else {
        // handle square corners
        // use default object corner size unless size is defined
        var cornerSize = (xSize && ySize) ? xSize : objectCornerSize;
        /* 0.7071067812 stands for sqrt(2)/2 */
        cornerHypotenuse = cornerSize * 0.7071067812;
        // complementary angles are equal since they're both 45 degrees
        var newTheta = fabric.util.degreesToRadians(45 - objectAngle);
        cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);
        sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);
      }

      return {
        tl: {
          x: centerX - sinHalfOffsetComp,
          y: centerY - cosHalfOffsetComp,
        },
        tr: {
          x: centerX + cosHalfOffset,
          y: centerY - sinHalfOffset,
        },
        bl: {
          x: centerX - cosHalfOffset,
          y: centerY + sinHalfOffset,
        },
        br: {
          x: centerX + sinHalfOffsetComp,
          y: centerY + cosHalfOffsetComp,
        },
      };
    },

    /**
    * Render function for the control.
    * When this function runs the context is unscaled. unrotate. Just retina scaled.
    * all the functions will have to translate to the point left,top before starting Drawing
    * if they want to draw a control where the position is detected.
    * left and top are the result of the positionHandler function
    * @param {RenderingContext2D} ctx the context where the control will be drawn
    * @param {Number} left position of the canvas where we are about to render the control.
    * @param {Number} top position of the canvas where we are about to render the control.
    * @param {Object} styleOverride
    * @param {fabric.Object} fabricObject the object where the control is about to be rendered
    */
    render: function(ctx, left, top, styleOverride, fabricObject) {
      styleOverride = styleOverride || {};
      switch (styleOverride.cornerStyle || fabricObject.cornerStyle) {
        case 'circle':
          fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);
          break;
        default:
          fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);
      }
    },
  };

})( true ? exports : 0);


(function() {

  /* _FROM_SVG_START_ */
  function getColorStop(el, multiplier) {
    var style = el.getAttribute('style'),
        offset = el.getAttribute('offset') || 0,
        color, colorAlpha, opacity, i;

    // convert percents to absolute values
    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
    if (style) {
      var keyValuePairs = style.split(/\s*;\s*/);

      if (keyValuePairs[keyValuePairs.length - 1] === '') {
        keyValuePairs.pop();
      }

      for (i = keyValuePairs.length; i--; ) {

        var split = keyValuePairs[i].split(/\s*:\s*/),
            key = split[0].trim(),
            value = split[1].trim();

        if (key === 'stop-color') {
          color = value;
        }
        else if (key === 'stop-opacity') {
          opacity = value;
        }
      }
    }

    if (!color) {
      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
    }
    if (!opacity) {
      opacity = el.getAttribute('stop-opacity');
    }

    color = new fabric.Color(color);
    colorAlpha = color.getAlpha();
    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
    opacity *= colorAlpha * multiplier;

    return {
      offset: offset,
      color: color.toRgb(),
      opacity: opacity
    };
  }

  function getLinearCoords(el) {
    return {
      x1: el.getAttribute('x1') || 0,
      y1: el.getAttribute('y1') || 0,
      x2: el.getAttribute('x2') || '100%',
      y2: el.getAttribute('y2') || 0
    };
  }

  function getRadialCoords(el) {
    return {
      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
      r1: 0,
      x2: el.getAttribute('cx') || '50%',
      y2: el.getAttribute('cy') || '50%',
      r2: el.getAttribute('r') || '50%'
    };
  }
  /* _FROM_SVG_END_ */

  var clone = fabric.util.object.clone;

  /**
   * Gradient class
   * @class fabric.Gradient
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
   * @see {@link fabric.Gradient#initialize} for constructor definition
   */
  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

    /**
     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetY: 0,

    /**
     * A transform matrix to apply to the gradient before painting.
     * Imported from svg gradients, is not applied with the current transform in the center.
     * Before this transform is applied, the origin point is at the top left corner of the object
     * plus the addition of offsetY and offsetX.
     * @type Number[]
     * @default null
     */
    gradientTransform: null,

    /**
     * coordinates units for coords.
     * If `pixels`, the number of coords are in the same unit of width / height.
     * If set as `percentage` the coords are still a number, but 1 means 100% of width
     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.
     * allowed values pixels or percentage.
     * @type String
     * @default 'pixels'
     */
    gradientUnits: 'pixels',

    /**
     * Gradient type linear or radial
     * @type String
     * @default 'pixels'
     */
    type: 'linear',

    /**
     * Constructor
     * @param {Object} options Options object with type, coords, gradientUnits and colorStops
     * @param {Object} [options.type] gradient type linear or radial
     * @param {Object} [options.gradientUnits] gradient units
     * @param {Object} [options.offsetX] SVG import compatibility
     * @param {Object} [options.offsetY] SVG import compatibility
     * @param {Object[]} options.colorStops contains the colorstops.
     * @param {Object} options.coords contains the coords of the gradient
     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial
     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial
     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial
     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial
     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle
     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle
     * @return {fabric.Gradient} thisArg
     */
    initialize: function(options) {
      options || (options = { });
      options.coords || (options.coords = { });

      var coords, _this = this;

      // sets everything, then coords and colorstops get sets again
      Object.keys(options).forEach(function(option) {
        _this[option] = options[option];
      });

      if (this.id) {
        this.id += '_' + fabric.Object.__uid++;
      }
      else {
        this.id = fabric.Object.__uid++;
      }

      coords = {
        x1: options.coords.x1 || 0,
        y1: options.coords.y1 || 0,
        x2: options.coords.x2 || 0,
        y2: options.coords.y2 || 0
      };

      if (this.type === 'radial') {
        coords.r1 = options.coords.r1 || 0;
        coords.r2 = options.coords.r2 || 0;
      }

      this.coords = coords;
      this.colorStops = options.colorStops.slice();
    },

    /**
     * Adds another colorStop
     * @param {Object} colorStop Object with offset and color
     * @return {fabric.Gradient} thisArg
     */
    addColorStop: function(colorStops) {
      for (var position in colorStops) {
        var color = new fabric.Color(colorStops[position]);
        this.colorStops.push({
          offset: parseFloat(position),
          color: color.toRgb(),
          opacity: color.getAlpha()
        });
      }
      return this;
    },

    /**
     * Returns object representation of a gradient
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object}
     */
    toObject: function(propertiesToInclude) {
      var object = {
        type: this.type,
        coords: this.coords,
        colorStops: this.colorStops,
        offsetX: this.offsetX,
        offsetY: this.offsetY,
        gradientUnits: this.gradientUnits,
        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an gradient
     * @param {Object} object Object to create a gradient for
     * @return {String} SVG representation of an gradient (linear/radial)
     */
    toSVG: function(object, options) {
      var coords = clone(this.coords, true), i, len, options = options || {},
          markup, commonAttributes, colorStops = clone(this.colorStops, true),
          needsSwap = coords.r1 > coords.r2,
          transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(),
          offsetX = -this.offsetX, offsetY = -this.offsetY,
          withViewport = !!options.additionalTransform,
          gradientUnits = this.gradientUnits === 'pixels' ? 'userSpaceOnUse' : 'objectBoundingBox';
      // colorStops must be sorted ascending
      colorStops.sort(function(a, b) {
        return a.offset - b.offset;
      });

      if (gradientUnits === 'objectBoundingBox') {
        offsetX /= object.width;
        offsetY /= object.height;
      }
      else {
        offsetX += object.width / 2;
        offsetY += object.height / 2;
      }
      if (object.type === 'path' && this.gradientUnits !== 'percentage') {
        offsetX -= object.pathOffset.x;
        offsetY -= object.pathOffset.y;
      }


      transform[4] -= offsetX;
      transform[5] -= offsetY;

      commonAttributes = 'id="SVGID_' + this.id +
                     '" gradientUnits="' + gradientUnits + '"';
      commonAttributes += ' gradientTransform="' + (withViewport ?
        options.additionalTransform + ' ' : '') + fabric.util.matrixToSVG(transform) + '" ';

      if (this.type === 'linear') {
        markup = [
          '<linearGradient ',
          commonAttributes,
          ' x1="', coords.x1,
          '" y1="', coords.y1,
          '" x2="', coords.x2,
          '" y2="', coords.y2,
          '">\n'
        ];
      }
      else if (this.type === 'radial') {
        // svg radial gradient has just 1 radius. the biggest.
        markup = [
          '<radialGradient ',
          commonAttributes,
          ' cx="', needsSwap ? coords.x1 : coords.x2,
          '" cy="', needsSwap ? coords.y1 : coords.y2,
          '" r="', needsSwap ? coords.r1 : coords.r2,
          '" fx="', needsSwap ? coords.x2 : coords.x1,
          '" fy="', needsSwap ? coords.y2 : coords.y1,
          '">\n'
        ];
      }

      if (this.type === 'radial') {
        if (needsSwap) {
          // svg goes from internal to external radius. if radius are inverted, swap color stops.
          colorStops = colorStops.concat();
          colorStops.reverse();
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset = 1 - colorStops[i].offset;
          }
        }
        var minRadius = Math.min(coords.r1, coords.r2);
        if (minRadius > 0) {
          // i have to shift all colorStops and add new one in 0.
          var maxRadius = Math.max(coords.r1, coords.r2),
              percentageShift = minRadius / maxRadius;
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
          }
        }
      }

      for (i = 0, len = colorStops.length; i < len; i++) {
        var colorStop = colorStops[i];
        markup.push(
          '<stop ',
          'offset="', (colorStop.offset * 100) + '%',
          '" style="stop-color:', colorStop.color,
          (typeof colorStop.opacity !== 'undefined' ? ';stop-opacity: ' + colorStop.opacity : ';'),
          '"/>\n'
        );
      }

      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

      return markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns an instance of CanvasGradient
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {CanvasGradient}
     */
    toLive: function(ctx) {
      var gradient, coords = fabric.util.object.clone(this.coords), i, len;

      if (!this.type) {
        return;
      }

      if (this.type === 'linear') {
        gradient = ctx.createLinearGradient(
          coords.x1, coords.y1, coords.x2, coords.y2);
      }
      else if (this.type === 'radial') {
        gradient = ctx.createRadialGradient(
          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
      }

      for (i = 0, len = this.colorStops.length; i < len; i++) {
        var color = this.colorStops[i].color,
            opacity = this.colorStops[i].opacity,
            offset = this.colorStops[i].offset;

        if (typeof opacity !== 'undefined') {
          color = new fabric.Color(color).setAlpha(opacity).toRgba();
        }
        gradient.addColorStop(offset, color);
      }

      return gradient;
    }
  });

  fabric.util.object.extend(fabric.Gradient, {

    /* _FROM_SVG_START_ */
    /**
     * Returns {@link fabric.Gradient} instance from an SVG element
     * @static
     * @memberOf fabric.Gradient
     * @param {SVGGradientElement} el SVG gradient element
     * @param {fabric.Object} instance
     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.
     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients
     * that uses gradientUnits as 'userSpaceOnUse' and percentages.
     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg
     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg
     * @param {Object.number} width width part of the svg tag if viewBox is not specified
     * @param {Object.number} height height part of the svg tag if viewBox is not specified
     * @return {fabric.Gradient} Gradient instance
     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
     */
    fromElement: function(el, instance, opacityAttr, svgOptions) {
      /**
       *  @example:
       *
       *  <linearGradient id="linearGrad1">
       *    <stop offset="0%" stop-color="white"/>
       *    <stop offset="100%" stop-color="black"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <linearGradient id="linearGrad2">
       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad1">
       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
       *  </radialGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad2">
       *    <stop offset="0" stop-color="rgb(255,255,255)" />
       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
       *    <stop offset="1" stop-color="rgb(255,255,255)" />
       *  </radialGradient>
       *
       */

      var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);
      multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;
      if (isNaN(multiplier)) {
        multiplier = 1;
      }

      var colorStopEls = el.getElementsByTagName('stop'),
          type,
          gradientUnits = el.getAttribute('gradientUnits') === 'userSpaceOnUse' ?
            'pixels' : 'percentage',
          gradientTransform = el.getAttribute('gradientTransform') || '',
          colorStops = [],
          coords, i, offsetX = 0, offsetY = 0,
          transformMatrix;
      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
        type = 'linear';
        coords = getLinearCoords(el);
      }
      else {
        type = 'radial';
        coords = getRadialCoords(el);
      }

      for (i = colorStopEls.length; i--; ) {
        colorStops.push(getColorStop(colorStopEls[i], multiplier));
      }

      transformMatrix = fabric.parseTransformAttribute(gradientTransform);

      __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);

      if (gradientUnits === 'pixels') {
        offsetX = -instance.left;
        offsetY = -instance.top;
      }

      var gradient = new fabric.Gradient({
        id: el.getAttribute('id'),
        type: type,
        coords: coords,
        colorStops: colorStops,
        gradientUnits: gradientUnits,
        gradientTransform: transformMatrix,
        offsetX: offsetX,
        offsetY: offsetY,
      });

      return gradient;
    }
    /* _FROM_SVG_END_ */
  });

  /**
   * @private
   */
  function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {
    var propValue, finalValue;
    Object.keys(options).forEach(function(prop) {
      propValue = options[prop];
      if (propValue === 'Infinity') {
        finalValue = 1;
      }
      else if (propValue === '-Infinity') {
        finalValue = 0;
      }
      else {
        finalValue = parseFloat(options[prop], 10);
        if (typeof propValue === 'string' && /^(\d+\.\d+)%|(\d+)%$/.test(propValue)) {
          finalValue *= 0.01;
          if (gradientUnits === 'pixels') {
            // then we need to fix those percentages here in svg parsing
            if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
              finalValue *= svgOptions.viewBoxWidth || svgOptions.width;
            }
            if (prop === 'y1' || prop === 'y2') {
              finalValue *= svgOptions.viewBoxHeight || svgOptions.height;
            }
          }
        }
      }
      options[prop] = finalValue;
    });
  }
})();


(function() {

  'use strict';

  var toFixed = fabric.util.toFixed;

  /**
   * Pattern class
   * @class fabric.Pattern
   * @see {@link http://fabricjs.com/patterns|Pattern demo}
   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
   * @see {@link fabric.Pattern#initialize} for constructor definition
   */


  fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

    /**
     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     * @type String
     * @default
     */
    repeat: 'repeat',

    /**
     * Pattern horizontal offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Pattern vertical offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @type String
     * @default
     */
    crossOrigin: '',

    /**
     * transform matrix to change the pattern, imported from svgs.
     * @type Array
     * @default
     */
    patternTransform: null,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @param {Function} [callback] function to invoke after callback init.
     * @return {fabric.Pattern} thisArg
     */
    initialize: function(options, callback) {
      options || (options = { });

      this.id = fabric.Object.__uid++;
      this.setOptions(options);
      if (!options.source || (options.source && typeof options.source !== 'string')) {
        callback && callback(this);
        return;
      }
      else {
        // img src string
        var _this = this;
        this.source = fabric.util.createImage();
        fabric.util.loadImage(options.source, function(img, isError) {
          _this.source = img;
          callback && callback(_this, isError);
        }, null, this.crossOrigin);
      }
    },

    /**
     * Returns object representation of a pattern
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of a pattern instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          source, object;

      // <img> element
      if (typeof this.source.src === 'string') {
        source = this.source.src;
      }
      // <canvas> element
      else if (typeof this.source === 'object' && this.source.toDataURL) {
        source = this.source.toDataURL();
      }

      object = {
        type: 'pattern',
        source: source,
        repeat: this.repeat,
        crossOrigin: this.crossOrigin,
        offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
        offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
        patternTransform: this.patternTransform ? this.patternTransform.concat() : null
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a pattern
     * @param {fabric.Object} object
     * @return {String} SVG representation of a pattern
     */
    toSVG: function(object) {
      var patternSource = typeof this.source === 'function' ? this.source() : this.source,
          patternWidth = patternSource.width / object.width,
          patternHeight = patternSource.height / object.height,
          patternOffsetX = this.offsetX / object.width,
          patternOffsetY = this.offsetY / object.height,
          patternImgSrc = '';
      if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
        patternHeight = 1;
        if (patternOffsetY) {
          patternHeight += Math.abs(patternOffsetY);
        }
      }
      if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
        patternWidth = 1;
        if (patternOffsetX) {
          patternWidth += Math.abs(patternOffsetX);
        }

      }
      if (patternSource.src) {
        patternImgSrc = patternSource.src;
      }
      else if (patternSource.toDataURL) {
        patternImgSrc = patternSource.toDataURL();
      }

      return '<pattern id="SVGID_' + this.id +
                    '" x="' + patternOffsetX +
                    '" y="' + patternOffsetY +
                    '" width="' + patternWidth +
                    '" height="' + patternHeight + '">\n' +
               '<image x="0" y="0"' +
                      ' width="' + patternSource.width +
                      '" height="' + patternSource.height +
                      '" xlink:href="' + patternImgSrc +
               '"></image>\n' +
             '</pattern>\n';
    },
    /* _TO_SVG_END_ */

    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Returns an instance of CanvasPattern
     * @param {CanvasRenderingContext2D} ctx Context to create pattern
     * @return {CanvasPattern}
     */
    toLive: function(ctx) {
      var source = this.source;
      // if the image failed to load, return, and allow rest to continue loading
      if (!source) {
        return '';
      }

      // if an image
      if (typeof source.src !== 'undefined') {
        if (!source.complete) {
          return '';
        }
        if (source.naturalWidth === 0 || source.naturalHeight === 0) {
          return '';
        }
      }
      return ctx.createPattern(source, this.repeat);
    }
  });
})();


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      toFixed = fabric.util.toFixed;

  if (fabric.Shadow) {
    fabric.warn('fabric.Shadow is already defined.');
    return;
  }

  /**
   * Shadow class
   * @class fabric.Shadow
   * @see {@link http://fabricjs.com/shadows|Shadow demo}
   * @see {@link fabric.Shadow#initialize} for constructor definition
   */
  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

    /**
     * Shadow color
     * @type String
     * @default
     */
    color: 'rgb(0,0,0)',

    /**
     * Shadow blur
     * @type Number
     */
    blur: 0,

    /**
     * Shadow horizontal offset
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Shadow vertical offset
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * Whether the shadow should affect stroke operations
     * @type Boolean
     * @default
     */
    affectStroke: false,

    /**
     * Indicates whether toObject should include default values
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * When `false`, the shadow will scale with the object.
     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.
     * default to false
     * @type Boolean
     * @default
     */
    nonScaling: false,

    /**
     * Constructor
     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
     * @return {fabric.Shadow} thisArg
     */
    initialize: function(options) {

      if (typeof options === 'string') {
        options = this._parseShadow(options);
      }

      for (var prop in options) {
        this[prop] = options[prop];
      }

      this.id = fabric.Object.__uid++;
    },

    /**
     * @private
     * @param {String} shadow Shadow value to parse
     * @return {Object} Shadow object with color, offsetX, offsetY and blur
     */
    _parseShadow: function(shadow) {
      var shadowStr = shadow.trim(),
          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

      return {
        color: color.trim(),
        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
        blur: parseInt(offsetsAndBlur[3], 10) || 0
      };
    },

    /**
     * Returns a string representation of an instance
     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
     * @return {String} Returns CSS3 text-shadow declaration
     */
    toString: function() {
      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a shadow
     * @param {fabric.Object} object
     * @return {String} SVG representation of a shadow
     */
    toSVG: function(object) {
      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          offset = fabric.util.rotateVector(
            { x: this.offsetX, y: this.offsetY },
            fabric.util.degreesToRadians(-object.angle)),
          BLUR_BOX = 20, color = new fabric.Color(this.color);

      if (object.width && object.height) {
        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
        // we add some extra space to filter box to contain the blur ( 20 )
        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
      }
      if (object.flipX) {
        offset.x *= -1;
      }
      if (object.flipY) {
        offset.y *= -1;
      }

      return (
        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
          '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
          '\t<feFlood flood-color="' + color.toRgb() + '" flood-opacity="' + color.getAlpha() + '"/>\n' +
          '\t<feComposite in2="oBlur" operator="in" />\n' +
          '\t<feMerge>\n' +
            '\t\t<feMergeNode></feMergeNode>\n' +
            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
          '\t</feMerge>\n' +
        '</filter>\n');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns object representation of a shadow
     * @return {Object} Object representation of a shadow instance
     */
    toObject: function() {
      if (this.includeDefaultValues) {
        return {
          color: this.color,
          blur: this.blur,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          affectStroke: this.affectStroke,
          nonScaling: this.nonScaling
        };
      }
      var obj = { }, proto = fabric.Shadow.prototype;

      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke', 'nonScaling'].forEach(function(prop) {
        if (this[prop] !== proto[prop]) {
          obj[prop] = this[prop];
        }
      }, this);

      return obj;
    }
  });

  /**
   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
   * @static
   * @field
   * @memberOf fabric.Shadow
   */
  // eslint-disable-next-line max-len
  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;

})( true ? exports : 0);


(function () {

  'use strict';

  if (fabric.StaticCanvas) {
    fabric.warn('fabric.StaticCanvas is already defined.');
    return;
  }

  // aliases for faster resolution
  var extend = fabric.util.object.extend,
      getElementOffset = fabric.util.getElementOffset,
      removeFromArray = fabric.util.removeFromArray,
      toFixed = fabric.util.toFixed,
      transformPoint = fabric.util.transformPoint,
      invertTransform = fabric.util.invertTransform,
      getNodeCanvas = fabric.util.getNodeCanvas,
      createCanvasElement = fabric.util.createCanvasElement,

      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

  /**
   * Static canvas class
   * @class fabric.StaticCanvas
   * @mixes fabric.Collection
   * @mixes fabric.Observable
   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
   * @fires before:render
   * @fires after:render
   * @fires canvas:cleared
   * @fires object:added
   * @fires object:removed
   */
  fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
    },

    /**
     * Background color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
     * @type {(String|fabric.Pattern)}
     * @default
     */
    backgroundColor: '',

    /**
     * Background image of canvas instance.
     * since 2.4.0 image caching is active, please when putting an image as background, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    backgroundImage: null,

    /**
     * Overlay color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
     * @since 1.3.9
     * @type {(String|fabric.Pattern)}
     * @default
     */
    overlayColor: '',

    /**
     * Overlay image of canvas instance.
     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    overlayImage: null,

    /**
     * Indicates whether toObject/toDatalessObject should include default values
     * if set to false, takes precedence over the object value.
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * Indicates whether objects' state should be saved
     * @type Boolean
     * @default
     */
    stateful: false,

    /**
     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
     * since the renders are quequed and executed one per frame.
     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
     * Left default to true to do not break documentation and old app, fiddles.
     * @type Boolean
     * @default
     */
    renderOnAddRemove: true,

    /**
     * Indicates whether object controls (borders/controls) are rendered above overlay image
     * @type Boolean
     * @default
     */
    controlsAboveOverlay: false,

    /**
     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
     * @type Boolean
     * @default
     */
    allowTouchScrolling: false,

    /**
     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
     * @type Boolean
     * @default
     */
    imageSmoothingEnabled: true,

    /**
     * The transformation (in the format of Canvas transform) which focuses the viewport
     * @type Array
     * @default
     */
    viewportTransform: fabric.iMatrix.concat(),

    /**
     * if set to false background image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    backgroundVpt: true,

    /**
     * if set to false overlya image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    overlayVpt: true,

    /**
     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
     * @type Boolean
     * @default
     */
    enableRetinaScaling: true,

    /**
     * Describe canvas element extension over design
     * properties are tl,tr,bl,br.
     * if canvas is not zoomed/panned those points are the four corner of canvas
     * if canvas is viewportTransformed you those points indicate the extension
     * of canvas element in plain untrasformed coordinates
     * The coordinates get updated with @method calcViewportBoundaries.
     * @memberOf fabric.StaticCanvas.prototype
     */
    vptCoords: { },

    /**
     * Based on vptCoords and object.aCoords, skip rendering of objects that
     * are not included in current viewport.
     * May greatly help in applications with crowded canvas and use of zoom/pan
     * If One of the corner of the bounding box of the object is on the canvas
     * the objects get rendered.
     * @memberOf fabric.StaticCanvas.prototype
     * @type Boolean
     * @default
     */
    skipOffscreen: true,

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the canvas has rendered, and the context is placed in the
     * top left corner of the canvas.
     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * @private
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     */
    _initStatic: function(el, options) {
      var cb = this.requestRenderAllBound;
      this._objects = [];
      this._createLowerCanvas(el);
      this._initOptions(options);
      // only initialize retina scaling once
      if (!this.interactive) {
        this._initRetinaScaling();
      }

      if (options.overlayImage) {
        this.setOverlayImage(options.overlayImage, cb);
      }
      if (options.backgroundImage) {
        this.setBackgroundImage(options.backgroundImage, cb);
      }
      if (options.backgroundColor) {
        this.setBackgroundColor(options.backgroundColor, cb);
      }
      if (options.overlayColor) {
        this.setOverlayColor(options.overlayColor, cb);
      }
      this.calcOffset();
    },

    /**
     * @private
     */
    _isRetinaScaling: function() {
      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
    },

    /**
     * @private
     * @return {Number} retinaScaling if applied, otherwise 1;
     */
    getRetinaScaling: function() {
      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
    },

    /**
     * @private
     */
    _initRetinaScaling: function() {
      if (!this._isRetinaScaling()) {
        return;
      }
      var scaleRatio = fabric.devicePixelRatio;
      this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);
      if (this.upperCanvasEl) {
        this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);
      }
    },

    __initRetinaScaling: function(scaleRatio, canvas, context) {
      canvas.setAttribute('width', this.width * scaleRatio);
      canvas.setAttribute('height', this.height * scaleRatio);
      context.scale(scaleRatio, scaleRatio);
    },


    /**
     * Calculates canvas element offset relative to the document
     * This method is also attached as "resize" event handler of window
     * @return {fabric.Canvas} instance
     * @chainable
     */
    calcOffset: function () {
      this._offset = getElementOffset(this.lowerCanvasEl);
      return this;
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
     * @example <caption>Normal overlayImage with left/top = 0</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage with different properties</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage loaded from cross-origin</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    setOverlayImage: function (image, callback, options) {
      return this.__setBgOverlayImage('overlayImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
     * @param {Function} callback Callback to invoke when image is loaded and set as background
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
     * @example <caption>Normal backgroundImage with left/top = 0</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage with different properties</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage loaded from cross-origin</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    // TODO: fix stretched examples
    setBackgroundImage: function (image, callback, options) {
      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
     * @param {Function} callback Callback to invoke when foreground color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
     * @example <caption>Normal overlayColor - color value</caption>
     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setOverlayColor: function(overlayColor, callback) {
      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
     * @param {Function} callback Callback to invoke when background color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
     * @example <caption>Normal backgroundColor - color value</caption>
     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setBackgroundColor: function(backgroundColor, callback) {
      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
     */
    __setBgOverlayImage: function(property, image, callback, options) {
      if (typeof image === 'string') {
        fabric.util.loadImage(image, function(img, isError) {
          if (img) {
            var instance = new fabric.Image(img, options);
            this[property] = instance;
            instance.canvas = this;
          }
          callback && callback(img, isError);
        }, this, options && options.crossOrigin);
      }
      else {
        options && image.setOptions(options);
        this[property] = image;
        image && (image.canvas = this);
        callback && callback(image, false);
      }

      return this;
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
     * @param {(Object|String|null)} color Object with pattern information, color value or null
     * @param {Function} [callback] Callback is invoked when color is set
     */
    __setBgOverlayColor: function(property, color, callback) {
      this[property] = color;
      this._initGradient(color, property);
      this._initPattern(color, property, callback);
      return this;
    },

    /**
     * @private
     */
    _createCanvasElement: function() {
      var element = createCanvasElement();
      if (!element) {
        throw CANVAS_INIT_ERROR;
      }
      if (!element.style) {
        element.style = { };
      }
      if (typeof element.getContext === 'undefined') {
        throw CANVAS_INIT_ERROR;
      }
      return element;
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initOptions: function (options) {
      var lowerCanvasEl = this.lowerCanvasEl;
      this._setOptions(options);

      this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;
      this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;

      if (!this.lowerCanvasEl.style) {
        return;
      }

      lowerCanvasEl.width = this.width;
      lowerCanvasEl.height = this.height;

      lowerCanvasEl.style.width = this.width + 'px';
      lowerCanvasEl.style.height = this.height + 'px';

      this.viewportTransform = this.viewportTransform.slice();
    },

    /**
     * Creates a bottom canvas
     * @private
     * @param {HTMLElement} [canvasEl]
     */
    _createLowerCanvas: function (canvasEl) {
      // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
      if (canvasEl && canvasEl.getContext) {
        this.lowerCanvasEl = canvasEl;
      }
      else {
        this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
      }

      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');

      if (this.interactive) {
        this._applyCanvasStyle(this.lowerCanvasEl);
      }

      this.contextContainer = this.lowerCanvasEl.getContext('2d');
    },

    /**
     * Returns canvas width (in px)
     * @return {Number}
     */
    getWidth: function () {
      return this.width;
    },

    /**
     * Returns canvas height (in px)
     * @return {Number}
     */
    getHeight: function () {
      return this.height;
    },

    /**
     * Sets width of this canvas instance
     * @param {Number|String} value                         Value to set width to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setWidth: function (value, options) {
      return this.setDimensions({ width: value }, options);
    },

    /**
     * Sets height of this canvas instance
     * @param {Number|String} value                         Value to set height to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setHeight: function (value, options) {
      return this.setDimensions({ height: value }, options);
    },

    /**
     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
     * @param {Object}        dimensions                    Object with width/height properties
     * @param {Number|String} [dimensions.width]            Width of canvas element
     * @param {Number|String} [dimensions.height]           Height of canvas element
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setDimensions: function (dimensions, options) {
      var cssValue;

      options = options || {};

      for (var prop in dimensions) {
        cssValue = dimensions[prop];

        if (!options.cssOnly) {
          this._setBackstoreDimension(prop, dimensions[prop]);
          cssValue += 'px';
          this.hasLostContext = true;
        }

        if (!options.backstoreOnly) {
          this._setCssDimension(prop, cssValue);
        }
      }
      if (this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles();
      }
      this._initRetinaScaling();
      this.calcOffset();

      if (!options.cssOnly) {
        this.requestRenderAll();
      }

      return this;
    },

    /**
     * Helper for setting width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {Number} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setBackstoreDimension: function (prop, value) {
      this.lowerCanvasEl[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl[prop] = value;
      }

      if (this.cacheCanvasEl) {
        this.cacheCanvasEl[prop] = value;
      }

      this[prop] = value;

      return this;
    },

    /**
     * Helper for setting css width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {String} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setCssDimension: function (prop, value) {
      this.lowerCanvasEl.style[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl.style[prop] = value;
      }

      if (this.wrapperEl) {
        this.wrapperEl.style[prop] = value;
      }

      return this;
    },

    /**
     * Returns canvas zoom level
     * @return {Number}
     */
    getZoom: function () {
      return this.viewportTransform[0];
    },

    /**
     * Sets viewport transform of this canvas instance
     * @param {Array} vpt the transform in the form of context.transform
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setViewportTransform: function (vpt) {
      var activeObject = this._activeObject,
          backgroundObject = this.backgroundImage,
          overlayObject = this.overlayImage,
          object, i, len;
      this.viewportTransform = vpt;
      for (i = 0, len = this._objects.length; i < len; i++) {
        object = this._objects[i];
        object.group || object.setCoords(true);
      }
      if (activeObject) {
        activeObject.setCoords();
      }
      if (backgroundObject) {
        backgroundObject.setCoords(true);
      }
      if (overlayObject) {
        overlayObject.setCoords(true);
      }
      this.calcViewportBoundaries();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Sets zoom level of this canvas instance, the zoom centered around point
     * meaning that following zoom to point with the same point will have the visual
     * effect of the zoom originating from that point. The point won't move.
     * It has nothing to do with canvas center or visual center of the viewport.
     * @param {fabric.Point} point to zoom with respect to
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    zoomToPoint: function (point, value) {
      // TODO: just change the scale, preserve other transformations
      var before = point, vpt = this.viewportTransform.slice(0);
      point = transformPoint(point, invertTransform(this.viewportTransform));
      vpt[0] = value;
      vpt[3] = value;
      var after = transformPoint(point, vpt);
      vpt[4] += before.x - after.x;
      vpt[5] += before.y - after.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Sets zoom level of this canvas instance
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setZoom: function (value) {
      this.zoomToPoint(new fabric.Point(0, 0), value);
      return this;
    },

    /**
     * Pan viewport so as to place point at top left corner of canvas
     * @param {fabric.Point} point to move to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    absolutePan: function (point) {
      var vpt = this.viewportTransform.slice(0);
      vpt[4] = -point.x;
      vpt[5] = -point.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Pans viewpoint relatively
     * @param {fabric.Point} point (position vector) to move by
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    relativePan: function (point) {
      return this.absolutePan(new fabric.Point(
        -point.x - this.viewportTransform[4],
        -point.y - this.viewportTransform[5]
      ));
    },

    /**
     * Returns &lt;canvas> element corresponding to this instance
     * @return {HTMLCanvasElement}
     */
    getElement: function () {
      return this.lowerCanvasEl;
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was added
     */
    _onObjectAdded: function(obj) {
      this.stateful && obj.setupState();
      obj._set('canvas', this);
      obj.setCoords();
      this.fire('object:added', { target: obj });
      obj.fire('added');
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      this.fire('object:removed', { target: obj });
      obj.fire('removed');
      delete obj.canvas;
    },

    /**
     * Clears specified context of canvas element
     * @param {CanvasRenderingContext2D} ctx Context to clear
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clearContext: function(ctx) {
      ctx.clearRect(0, 0, this.width, this.height);
      return this;
    },

    /**
     * Returns context of canvas where objects are drawn
     * @return {CanvasRenderingContext2D}
     */
    getContext: function () {
      return this.contextContainer;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      this._objects.length = 0;
      this.backgroundImage = null;
      this.overlayImage = null;
      this.backgroundColor = '';
      this.overlayColor = '';
      if (this._hasITextHandlers) {
        this.off('mouse:up', this._mouseUpITextHandler);
        this._iTextInstances = null;
        this._hasITextHandlers = false;
      }
      this.clearContext(this.contextContainer);
      this.fire('canvas:cleared');
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Renders the canvas
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._objects);
      return this;
    },

    /**
     * Function created to be instance bound at initialization
     * used in requestAnimationFrame rendering
     * Let the fabricJS call it. If you call it manually you could have more
     * animationFrame stacking on to of each other
     * for an imperative rendering, use canvas.renderAll
     * @private
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAndReset: function() {
      this.isRendering = 0;
      this.renderAll();
    },

    /**
     * Append a renderAll request to next animation frame.
     * unless one is already in progress, in that case nothing is done
     * a boolean flag will avoid appending more.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    requestRenderAll: function () {
      if (!this.isRendering) {
        this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
      }
      return this;
    },

    /**
     * Calculate the position of the 4 corner of canvas with current viewportTransform.
     * helps to determinate when an object is in the current rendering viewport using
     * object absolute coordinates ( aCoords )
     * @return {Object} points.tl
     * @chainable
     */
    calcViewportBoundaries: function() {
      var points = { }, width = this.width, height = this.height,
          iVpt = invertTransform(this.viewportTransform);
      points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
      points.br = transformPoint({ x: width, y: height }, iVpt);
      points.tr = new fabric.Point(points.br.x, points.tl.y);
      points.bl = new fabric.Point(points.tl.x, points.br.y);
      this.vptCoords = points;
      return points;
    },

    cancelRequestedRender: function() {
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
    },

    /**
     * Renders background, objects, overlay and controls.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array} objects to render
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderCanvas: function(ctx, objects) {
      var v = this.viewportTransform, path = this.clipPath;
      this.cancelRequestedRender();
      this.calcViewportBoundaries();
      this.clearContext(ctx);
      fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);
      this.fire('before:render', { ctx: ctx, });
      this._renderBackground(ctx);

      ctx.save();
      //apply viewport transform once for all rendering process
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      this._renderObjects(ctx, objects);
      ctx.restore();
      if (!this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      if (path) {
        path.canvas = this;
        // needed to setup a couple of variables
        path.shouldCache();
        path._transformDone = true;
        path.renderCache({ forClipping: true });
        this.drawClipPathOnCanvas(ctx);
      }
      this._renderOverlay(ctx);
      if (this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      this.fire('after:render', { ctx: ctx, });
    },

    /**
     * Paint the cached clipPath on the lowerCanvasEl
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawClipPathOnCanvas: function(ctx) {
      var v = this.viewportTransform, path = this.clipPath;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4;
      ctx.globalCompositeOperation = 'destination-in';
      path.transform(ctx);
      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} objects to render
     */
    _renderObjects: function(ctx, objects) {
      var i, len;
      for (i = 0, len = objects.length; i < len; ++i) {
        objects[i] && objects[i].render(ctx);
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {string} property 'background' or 'overlay'
     */
    _renderBackgroundOrOverlay: function(ctx, property) {
      var fill = this[property + 'Color'], object = this[property + 'Image'],
          v = this.viewportTransform, needsVpt = this[property + 'Vpt'];
      if (!fill && !object) {
        return;
      }
      if (fill) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.width, 0);
        ctx.lineTo(this.width, this.height);
        ctx.lineTo(0, this.height);
        ctx.closePath();
        ctx.fillStyle = fill.toLive
          ? fill.toLive(ctx, this)
          : fill;
        if (needsVpt) {
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        }
        ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);
        var m = fill.gradientTransform || fill.patternTransform;
        m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        ctx.fill();
        ctx.restore();
      }
      if (object) {
        ctx.save();
        if (needsVpt) {
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        }
        object.render(ctx);
        ctx.restore();
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'background');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderOverlay: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'overlay');
    },

    /**
     * Returns coordinates of a center of canvas.
     * Returned value is an object with top and left properties
     * @return {Object} object with "top" and "left" number values
     */
    getCenter: function () {
      return {
        top: this.height / 2,
        left: this.width / 2
      };
    },

    /**
     * Centers object horizontally in the canvas
     * @param {fabric.Object} object Object to center horizontally
     * @return {fabric.Canvas} thisArg
     */
    centerObjectH: function (object) {
      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
    },

    /**
     * Centers object vertically in the canvas
     * @param {fabric.Object} object Object to center vertically
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObjectV: function (object) {
      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
    },

    /**
     * Centers object vertically and horizontally in the canvas
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObject: function(object) {
      var center = this.getCenter();

      return this._centerObject(object, new fabric.Point(center.left, center.top));
    },

    /**
     * Centers object vertically and horizontally in the viewport
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObject: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, vpCenter);
    },

    /**
     * Centers object horizontally in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectH: function(object) {
      var vpCenter = this.getVpCenter();
      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
      return this;
    },

    /**
     * Centers object Vertically in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectV: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
    },

    /**
     * Calculate the point in canvas that correspond to the center of actual viewport.
     * @return {fabric.Point} vpCenter, viewport center
     * @chainable
     */
    getVpCenter: function() {
      var center = this.getCenter(),
          iVpt = invertTransform(this.viewportTransform);
      return transformPoint({ x: center.left, y: center.top }, iVpt);
    },

    /**
     * @private
     * @param {fabric.Object} object Object to center
     * @param {fabric.Point} center Center point
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    _centerObject: function(object, center) {
      object.setPositionByOrigin(center, 'center', 'center');
      object.setCoords();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Returns dataless JSON representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} json string
     */
    toDatalessJSON: function (propertiesToInclude) {
      return this.toDatalessObject(propertiesToInclude);
    },

    /**
     * Returns object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function (propertiesToInclude) {
      return this._toObjectMethod('toObject', propertiesToInclude);
    },

    /**
     * Returns dataless object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function (propertiesToInclude) {
      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
    },

    /**
     * @private
     */
    _toObjectMethod: function (methodName, propertiesToInclude) {

      var clipPath = this.clipPath, data = {
        version: fabric.version,
        objects: this._toObjects(methodName, propertiesToInclude),
      };
      if (clipPath) {
        data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);
      }
      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

      fabric.util.populateWithProperties(this, data, propertiesToInclude);

      return data;
    },

    /**
     * @private
     */
    _toObjects: function(methodName, propertiesToInclude) {
      return this._objects.filter(function(object) {
        return !object.excludeFromExport;
      }).map(function(instance) {
        return this._toObject(instance, methodName, propertiesToInclude);
      }, this);
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      var originalValue;

      if (!this.includeDefaultValues) {
        originalValue = instance.includeDefaultValues;
        instance.includeDefaultValues = false;
      }

      var object = instance[methodName](propertiesToInclude);
      if (!this.includeDefaultValues) {
        instance.includeDefaultValues = originalValue;
      }
      return object;
    },

    /**
     * @private
     */
    __serializeBgOverlay: function(methodName, propertiesToInclude) {
      var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;

      if (this.backgroundColor) {
        data.background = this.backgroundColor.toObject
          ? this.backgroundColor.toObject(propertiesToInclude)
          : this.backgroundColor;
      }

      if (this.overlayColor) {
        data.overlay = this.overlayColor.toObject
          ? this.overlayColor.toObject(propertiesToInclude)
          : this.overlayColor;
      }
      if (bgImage && !bgImage.excludeFromExport) {
        data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
      }
      if (overlay && !overlay.excludeFromExport) {
        data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);
      }

      return data;
    },

    /* _TO_SVG_START_ */
    /**
     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
     * a zoomed canvas will then produce zoomed SVG output.
     * @type Boolean
     * @default
     */
    svgViewportTransformation: true,

    /**
     * Returns SVG representation of canvas
     * @function
     * @param {Object} [options] Options object for SVG output
     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
     * @param {Object} [options.viewBox] SVG viewbox object
     * @param {Number} [options.viewBox.x] x-coordinate of viewbox
     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
     * @param {Number} [options.viewBox.width] Width of viewbox
     * @param {Number} [options.viewBox.height] Height of viewbox
     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
     * @param {String} [options.width] desired width of svg with or without units
     * @param {String} [options.height] desired height of svg with or without units
     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
     * @return {String} SVG string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
     * @example <caption>Normal SVG output</caption>
     * var svg = canvas.toSVG();
     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
     * var svg = canvas.toSVG({suppressPreamble: true});
     * @example <caption>SVG output with viewBox attribute</caption>
     * var svg = canvas.toSVG({
     *   viewBox: {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 300
     *   }
     * });
     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
     * @example <caption>Modify SVG output with reviver function</caption>
     * var svg = canvas.toSVG(null, function(svg) {
     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
     * });
     */
    toSVG: function(options, reviver) {
      options || (options = { });
      options.reviver = reviver;
      var markup = [];

      this._setSVGPreamble(markup, options);
      this._setSVGHeader(markup, options);
      if (this.clipPath) {
        markup.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n');
      }
      this._setSVGBgOverlayColor(markup, 'background');
      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);
      this._setSVGObjects(markup, reviver);
      if (this.clipPath) {
        markup.push('</g>\n');
      }
      this._setSVGBgOverlayColor(markup, 'overlay');
      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

      markup.push('</svg>');

      return markup.join('');
    },

    /**
     * @private
     */
    _setSVGPreamble: function(markup, options) {
      if (options.suppressPreamble) {
        return;
      }
      markup.push(
        '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
        '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
      );
    },

    /**
     * @private
     */
    _setSVGHeader: function(markup, options) {
      var width = options.width || this.width,
          height = options.height || this.height,
          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      if (options.viewBox) {
        viewBox = 'viewBox="' +
                options.viewBox.x + ' ' +
                options.viewBox.y + ' ' +
                options.viewBox.width + ' ' +
                options.viewBox.height + '" ';
      }
      else {
        if (this.svgViewportTransformation) {
          vpt = this.viewportTransform;
          viewBox = 'viewBox="' +
                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
        }
      }

      markup.push(
        '<svg ',
        'xmlns="http://www.w3.org/2000/svg" ',
        'xmlns:xlink="http://www.w3.org/1999/xlink" ',
        'version="1.1" ',
        'width="', width, '" ',
        'height="', height, '" ',
        viewBox,
        'xml:space="preserve">\n',
        '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
        '<defs>\n',
        this.createSVGFontFacesMarkup(),
        this.createSVGRefElementsMarkup(),
        this.createSVGClipPathMarkup(options),
        '</defs>\n'
      );
    },

    createSVGClipPathMarkup: function(options) {
      var clipPath = this.clipPath;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        return  '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          this.clipPath.toClipPathSVG(options.reviver) +
          '</clipPath>\n';
      }
      return '';
    },

    /**
     * Creates markup containing SVG referenced elements like patterns, gradients etc.
     * @return {String}
     */
    createSVGRefElementsMarkup: function() {
      var _this = this,
          markup = ['background', 'overlay'].map(function(prop) {
            var fill = _this[prop + 'Color'];
            if (fill && fill.toLive) {
              var shouldTransform = _this[prop + 'Vpt'], vpt = _this.viewportTransform,
                  object = {
                    width: _this.width / (shouldTransform ? vpt[0] : 1),
                    height: _this.height / (shouldTransform ? vpt[3] : 1)
                  };
              return fill.toSVG(
                object,
                { additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : '' }
              );
            }
          });
      return markup.join('');
    },

    /**
     * Creates markup containing SVG font faces,
     * font URLs for font faces must be collected by developers
     * and are not extracted from the DOM by fabricjs
     * @param {Array} objects Array of fabric objects
     * @return {String}
     */
    createSVGFontFacesMarkup: function() {
      var markup = '', fontList = { }, obj, fontFamily,
          style, row, rowIndex, _char, charIndex, i, len,
          fontPaths = fabric.fontPaths, objects = [];

      this._objects.forEach(function add(object) {
        objects.push(object);
        if (object._objects) {
          object._objects.forEach(add);
        }
      });

      for (i = 0, len = objects.length; i < len; i++) {
        obj = objects[i];
        fontFamily = obj.fontFamily;
        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
          continue;
        }
        fontList[fontFamily] = true;
        if (!obj.styles) {
          continue;
        }
        style = obj.styles;
        for (rowIndex in style) {
          row = style[rowIndex];
          for (charIndex in row) {
            _char = row[charIndex];
            fontFamily = _char.fontFamily;
            if (!fontList[fontFamily] && fontPaths[fontFamily]) {
              fontList[fontFamily] = true;
            }
          }
        }
      }

      for (var j in fontList) {
        markup += [
          '\t\t@font-face {\n',
          '\t\t\tfont-family: \'', j, '\';\n',
          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
          '\t\t}\n'
        ].join('');
      }

      if (markup) {
        markup = [
          '\t<style type="text/css">',
          '<![CDATA[\n',
          markup,
          ']]>',
          '</style>\n'
        ].join('');
      }

      return markup;
    },

    /**
     * @private
     */
    _setSVGObjects: function(markup, reviver) {
      var instance, i, len, objects = this._objects;
      for (i = 0, len = objects.length; i < len; i++) {
        instance = objects[i];
        if (instance.excludeFromExport) {
          continue;
        }
        this._setSVGObject(markup, instance, reviver);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      markup.push(instance.toSVG(reviver));
    },

    /**
     * @private
     */
    _setSVGBgOverlayImage: function(markup, property, reviver) {
      if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {
        markup.push(this[property].toSVG(reviver));
      }
    },

    /**
     * @private
     */
    _setSVGBgOverlayColor: function(markup, property) {
      var filler = this[property + 'Color'], vpt = this.viewportTransform, finalWidth = this.width,
          finalHeight = this.height;
      if (!filler) {
        return;
      }
      if (filler.toLive) {
        var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + 'Vpt'],
            additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : '';
        markup.push(
          '<rect transform="' + additionalTransform + ' translate(', finalWidth / 2, ',', finalHeight / 2, ')"',
          ' x="', filler.offsetX - finalWidth / 2,
          '" y="', filler.offsetY - finalHeight / 2, '" ',
          'width="',
          (repeat === 'repeat-y' || repeat === 'no-repeat'
            ? filler.source.width
            : finalWidth ),
          '" height="',
          (repeat === 'repeat-x' || repeat === 'no-repeat'
            ? filler.source.height
            : finalHeight),
          '" fill="url(#SVGID_' + filler.id + ')"',
          '></rect>\n'
        );
      }
      else {
        markup.push(
          '<rect x="0" y="0" width="100%" height="100%" ',
          'fill="', filler, '"',
          '></rect>\n'
        );
      }
    },
    /* _TO_SVG_END_ */

    /**
     * Moves an object or the objects of a multiple selection
     * to the bottom of the stack of drawn objects
     * @param {fabric.Object} object Object to send to back
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendToBack: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.unshift(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.unshift(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or the objects of a multiple selection
     * to the top of the stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringToFront: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.push(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.push(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or a selection down in stack of drawn objects
     * An optional parameter, intersecting allows to move the object in behind
     * the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendBackwards: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx > 0 + objsMoved) {
            newIdx = idx - 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== 0) {
          // if object is not on the bottom of stack
          newIdx = this._findNewLowerIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewLowerIndex: function(object, idx, intersecting) {
      var newIdx, i;

      if (intersecting) {
        newIdx = idx;

        // traverse down the stack looking for the nearest intersecting object
        for (i = idx - 1; i >= 0; --i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx - 1;
      }

      return newIdx;
    },

    /**
     * Moves an object or a selection up in stack of drawn objects
     * An optional parameter, intersecting allows to move the object in front
     * of the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringForward: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx < this._objects.length - 1 - objsMoved) {
            newIdx = idx + 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== this._objects.length - 1) {
          // if object is not on top of stack (last item in an array)
          newIdx = this._findNewUpperIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewUpperIndex: function(object, idx, intersecting) {
      var newIdx, i, len;

      if (intersecting) {
        newIdx = idx;

        // traverse up the stack looking for the nearest intersecting object
        for (i = idx + 1, len = this._objects.length; i < len; ++i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx + 1;
      }

      return newIdx;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @param {Number} index Position to move to
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    moveTo: function (object, index) {
      removeFromArray(this._objects, object);
      this._objects.splice(index, 0, object);
      return this.renderOnAddRemove && this.requestRenderAll();
    },

    /**
     * Clears a canvas element and dispose objects
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      // cancel eventually ongoing renders
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
      this.forEachObject(function(object) {
        object.dispose && object.dispose();
      });
      this._objects = [];
      if (this.backgroundImage && this.backgroundImage.dispose) {
        this.backgroundImage.dispose();
      }
      this.backgroundImage = null;
      if (this.overlayImage && this.overlayImage.dispose) {
        this.overlayImage.dispose();
      }
      this.overlayImage = null;
      this._iTextInstances = null;
      this.contextContainer = null;
      fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);
      this.lowerCanvasEl = undefined;
      return this;
    },

    /**
     * Returns a string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function () {
      return '#<fabric.Canvas (' + this.complexity() + '): ' +
               '{ objects: ' + this._objects.length + ' }>';
    }
  });

  extend(fabric.StaticCanvas.prototype, fabric.Observable);
  extend(fabric.StaticCanvas.prototype, fabric.Collection);
  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

    /**
     * @static
     * @type String
     * @default
     */
    EMPTY_JSON: '{"objects": [], "background": "white"}',

    /**
     * Provides a way to check support of some of the canvas methods
     * (either those of HTMLCanvasElement itself, or rendering context)
     *
     * @param {String} methodName Method to check support for;
     *                            Could be one of "setLineDash"
     * @return {Boolean | null} `true` if method is supported (or at least exists),
     *                          `null` if canvas element or context can not be initialized
     */
    supports: function (methodName) {
      var el = createCanvasElement();

      if (!el || !el.getContext) {
        return null;
      }

      var ctx = el.getContext('2d');
      if (!ctx) {
        return null;
      }

      switch (methodName) {

        case 'setLineDash':
          return typeof ctx.setLineDash !== 'undefined';

        default:
          return null;
      }
    }
  });

  /**
   * Returns Object representation of canvas
   * this alias is provided because if you call JSON.stringify on an instance,
   * the toJSON object will be invoked if it exists.
   * Having a toJSON method means you can do JSON.stringify(myCanvas)
   * @function
   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
   * @return {Object} JSON compatible object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
   * @example <caption>JSON without additional properties</caption>
   * var json = canvas.toJSON();
   * @example <caption>JSON with additional properties included</caption>
   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);
   * @example <caption>JSON without default values</caption>
   * canvas.includeDefaultValues = false;
   * var json = canvas.toJSON();
   */
  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

  if (fabric.isLikelyNode) {
    fabric.StaticCanvas.prototype.createPNGStream = function() {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createPNGStream();
    };
    fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createJPEGStream(opts);
    };
  }
})();


/**
 * BaseBrush class
 * @class fabric.BaseBrush
 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
 */
fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

  /**
   * Color of a brush
   * @type String
   * @default
   */
  color: 'rgb(0, 0, 0)',

  /**
   * Width of a brush, has to be a Number, no string literals
   * @type Number
   * @default
   */
  width: 1,

  /**
   * Shadow object representing shadow of this shape.
   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
   * @type fabric.Shadow
   * @default
   */
  shadow: null,

  /**
   * Line endings style of a brush (one of "butt", "round", "square")
   * @type String
   * @default
   */
  strokeLineCap: 'round',

  /**
   * Corner style of a brush (one of "bevel", "round", "miter")
   * @type String
   * @default
   */
  strokeLineJoin: 'round',

  /**
   * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
   * @type Number
   * @default
   */
  strokeMiterLimit:         10,

  /**
   * Stroke Dash Array.
   * @type Array
   * @default
   */
  strokeDashArray: null,

  /**
   * Sets brush styles
   * @private
   */
  _setBrushStyles: function() {
    var ctx = this.canvas.contextTop;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = this.width;
    ctx.lineCap = this.strokeLineCap;
    ctx.miterLimit = this.strokeMiterLimit;
    ctx.lineJoin = this.strokeLineJoin;
    if (fabric.StaticCanvas.supports('setLineDash')) {
      ctx.setLineDash(this.strokeDashArray || []);
    }
  },

  /**
   * Sets the transformation on given context
   * @param {RenderingContext2d} ctx context to render on
   * @private
   */
  _saveAndTransform: function(ctx) {
    var v = this.canvas.viewportTransform;
    ctx.save();
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
  },

  /**
   * Sets brush shadow styles
   * @private
   */
  _setShadow: function() {
    if (!this.shadow) {
      return;
    }

    var canvas = this.canvas,
        shadow = this.shadow,
        ctx = canvas.contextTop,
        zoom = canvas.getZoom();
    if (canvas && canvas._isRetinaScaling()) {
      zoom *= fabric.devicePixelRatio;
    }

    ctx.shadowColor = shadow.color;
    ctx.shadowBlur = shadow.blur * zoom;
    ctx.shadowOffsetX = shadow.offsetX * zoom;
    ctx.shadowOffsetY = shadow.offsetY * zoom;
  },

  needsFullRender: function() {
    var color = new fabric.Color(this.color);
    return color.getAlpha() < 1 || !!this.shadow;
  },

  /**
   * Removes brush shadow styles
   * @private
   */
  _resetShadow: function() {
    var ctx = this.canvas.contextTop;

    ctx.shadowColor = '';
    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
  }
});


(function() {
  /**
   * PencilBrush class
   * @class fabric.PencilBrush
   * @extends fabric.BaseBrush
   */
  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

    /**
     * Discard points that are less than `decimate` pixel distant from each other
     * @type Number
     * @default 0.4
     */
    decimate: 0.4,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.PencilBrush} Instance of a pencil brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this._points = [];
    },

    /**
     * Invoked inside on mouse down and mouse move
     * @param {Object} pointer
     */
    _drawSegment: function (ctx, p1, p2) {
      var midPoint = p1.midPointFrom(p2);
      ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
      return midPoint;
    },

    /**
     * Invoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer, options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return;
      }
      this._prepareForDrawing(pointer);
      // capture coordinates immediately
      // this allows to draw dots (when movement never occurs)
      this._captureDrawingPath(pointer);
      this._render();
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer, options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return;
      }
      if (this._captureDrawingPath(pointer) && this._points.length > 1) {
        if (this.needsFullRender()) {
          // redraw curve
          // clear top canvas
          this.canvas.clearContext(this.canvas.contextTop);
          this._render();
        }
        else {
          var points = this._points, length = points.length, ctx = this.canvas.contextTop;
          // draw the curve update
          this._saveAndTransform(ctx);
          if (this.oldEnd) {
            ctx.beginPath();
            ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
          }
          this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
          ctx.stroke();
          ctx.restore();
        }
      }
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function(options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return true;
      }
      this.oldEnd = undefined;
      this._finalizeAndAddPath();
      return false;
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _prepareForDrawing: function(pointer) {

      var p = new fabric.Point(pointer.x, pointer.y);

      this._reset();
      this._addPoint(p);
      this.canvas.contextTop.moveTo(p.x, p.y);
    },

    /**
     * @private
     * @param {fabric.Point} point Point to be added to points array
     */
    _addPoint: function(point) {
      if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
        return false;
      }
      this._points.push(point);
      return true;
    },

    /**
     * Clear points array and set contextTop canvas style.
     * @private
     */
    _reset: function() {
      this._points = [];
      this._setBrushStyles();
      this._setShadow();
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _captureDrawingPath: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
      return this._addPoint(pointerPoint);
    },

    /**
     * Draw a smooth path on the topCanvas using quadraticCurveTo
     * @private
     */
    _render: function() {
      var ctx  = this.canvas.contextTop, i, len,
          p1 = this._points[0],
          p2 = this._points[1];

      this._saveAndTransform(ctx);
      ctx.beginPath();
      //if we only have 2 points in the path and they are the same
      //it means that the user only clicked the canvas without moving the mouse
      //then we should be drawing a dot. A path isn't drawn between two identical dots
      //that's why we set them apart a bit
      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
        var width = this.width / 1000;
        p1 = new fabric.Point(p1.x, p1.y);
        p2 = new fabric.Point(p2.x, p2.y);
        p1.x -= width;
        p2.x += width;
      }
      ctx.moveTo(p1.x, p1.y);

      for (i = 1, len = this._points.length; i < len; i++) {
        // we pick the point between pi + 1 & pi + 2 as the
        // end point and p1 as our control point.
        this._drawSegment(ctx, p1, p2);
        p1 = this._points[i];
        p2 = this._points[i + 1];
      }
      // Draw last line as a straight line while
      // we wait for the next point to be able to calculate
      // the bezier control point
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * Converts points to SVG path
     * @param {Array} points Array of points
     * @return {String} SVG path
     */
    convertPointsToSVGPath: function(points) {
      var path = [], i, width = this.width / 1000,
          p1 = new fabric.Point(points[0].x, points[0].y),
          p2 = new fabric.Point(points[1].x, points[1].y),
          len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;

      if (manyPoints) {
        multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
        multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
      }
      path.push('M ', p1.x - multSignX * width, ' ', p1.y - multSignY * width, ' ');
      for (i = 1; i < len; i++) {
        if (!p1.eq(p2)) {
          var midPoint = p1.midPointFrom(p2);
          // p1 is our bezier control point
          // midpoint is our endpoint
          // start point is p(i-1) value.
          path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
        }
        p1 = points[i];
        if ((i + 1) < points.length) {
          p2 = points[i + 1];
        }
      }
      if (manyPoints) {
        multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
        multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
      }
      path.push('L ', p1.x + multSignX * width, ' ', p1.y + multSignY * width);
      return path;
    },

    /**
     * Creates fabric.Path object to add on canvas
     * @param {String} pathData Path data
     * @return {fabric.Path} Path to add on canvas
     */
    createPath: function(pathData) {
      var path = new fabric.Path(pathData, {
        fill: null,
        stroke: this.color,
        strokeWidth: this.width,
        strokeLineCap: this.strokeLineCap,
        strokeMiterLimit: this.strokeMiterLimit,
        strokeLineJoin: this.strokeLineJoin,
        strokeDashArray: this.strokeDashArray,
      });
      if (this.shadow) {
        this.shadow.affectStroke = true;
        path.shadow = new fabric.Shadow(this.shadow);
      }

      return path;
    },

    /**
     * Decimate points array with the decimate value
     */
    decimatePoints: function(points, distance) {
      if (points.length <= 2) {
        return points;
      }
      var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2),
          i, l = points.length - 1, lastPoint = points[0], newPoints = [lastPoint],
          cDistance;
      for (i = 1; i < l; i++) {
        cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);
        if (cDistance >= adjustedDistance) {
          lastPoint = points[i];
          newPoints.push(lastPoint);
        }
      }
      if (newPoints.length === 1) {
        newPoints.push(new fabric.Point(newPoints[0].x, newPoints[0].y));
      }
      return newPoints;
    },

    /**
     * On mouseup after drawing the path on contextTop canvas
     * we use the points captured to create an new fabric path object
     * and add it to the fabric canvas.
     */
    _finalizeAndAddPath: function() {
      var ctx = this.canvas.contextTop;
      ctx.closePath();
      if (this.decimate) {
        this._points = this.decimatePoints(this._points, this.decimate);
      }
      var pathData = this.convertPointsToSVGPath(this._points).join('');
      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
        // do not create 0 width/height paths, as they are
        // rendered inconsistently across browsers
        // Firefox 4, for example, renders a dot,
        // whereas Chrome 10 renders nothing
        this.canvas.requestRenderAll();
        return;
      }

      var path = this.createPath(pathData);
      this.canvas.clearContext(this.canvas.contextTop);
      this.canvas.fire('before:path:created', { path: path });
      this.canvas.add(path);
      this.canvas.requestRenderAll();
      path.setCoords();
      this._resetShadow();


      // fire event 'path' created
      this.canvas.fire('path:created', { path: path });
    }
  });
})();


/**
 * CircleBrush class
 * @class fabric.CircleBrush
 */
fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

  /**
   * Width of a brush
   * @type Number
   * @default
   */
  width: 10,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.CircleBrush} Instance of a circle brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.points = [];
  },

  /**
   * Invoked inside on mouse down and mouse move
   * @param {Object} pointer
   */
  drawDot: function(pointer) {
    var point = this.addPoint(pointer),
        ctx = this.canvas.contextTop;
    this._saveAndTransform(ctx);
    this.dot(ctx, point);
    ctx.restore();
  },

  dot: function(ctx, point) {
    ctx.fillStyle = point.fill;
    ctx.beginPath();
    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
    ctx.closePath();
    ctx.fill();
  },

  /**
   * Invoked on mouse down
   */
  onMouseDown: function(pointer) {
    this.points.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();
    this.drawDot(pointer);
  },

  /**
   * Render the full state of the brush
   * @private
   */
  _render: function() {
    var ctx  = this.canvas.contextTop, i, len,
        points = this.points;
    this._saveAndTransform(ctx);
    for (i = 0, len = points.length; i < len; i++) {
      this.dot(ctx, points[i]);
    }
    ctx.restore();
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    if (this.needsFullRender()) {
      this.canvas.clearContext(this.canvas.contextTop);
      this.addPoint(pointer);
      this._render();
    }
    else {
      this.drawDot(pointer);
    }
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
    this.canvas.renderOnAddRemove = false;

    var circles = [];

    for (i = 0, len = this.points.length; i < len; i++) {
      var point = this.points[i],
          circle = new fabric.Circle({
            radius: point.radius,
            left: point.x,
            top: point.y,
            originX: 'center',
            originY: 'center',
            fill: point.fill
          });

      this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));

      circles.push(circle);
    }
    var group = new fabric.Group(circles);
    group.canvas = this.canvas;

    this.canvas.fire('before:path:created', { path: group });
    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @param {Object} pointer
   * @return {fabric.Point} Just added pointer point
   */
  addPoint: function(pointer) {
    var pointerPoint = new fabric.Point(pointer.x, pointer.y),

        circleRadius = fabric.util.getRandomInt(
          Math.max(0, this.width - 20), this.width + 20) / 2,

        circleColor = new fabric.Color(this.color)
          .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
          .toRgba();

    pointerPoint.radius = circleRadius;
    pointerPoint.fill = circleColor;

    this.points.push(pointerPoint);

    return pointerPoint;
  }
});


/**
 * SprayBrush class
 * @class fabric.SprayBrush
 */
fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

  /**
   * Width of a spray
   * @type Number
   * @default
   */
  width:              10,

  /**
   * Density of a spray (number of dots per chunk)
   * @type Number
   * @default
   */
  density:            20,

  /**
   * Width of spray dots
   * @type Number
   * @default
   */
  dotWidth:           1,

  /**
   * Width variance of spray dots
   * @type Number
   * @default
   */
  dotWidthVariance:   1,

  /**
   * Whether opacity of a dot should be random
   * @type Boolean
   * @default
   */
  randomOpacity:        false,

  /**
   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
   * @type Boolean
   * @default
   */
  optimizeOverlapping:  true,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.SprayBrush} Instance of a spray brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.sprayChunks = [];
  },

  /**
   * Invoked on mouse down
   * @param {Object} pointer
   */
  onMouseDown: function(pointer) {
    this.sprayChunks.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();

    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;

    var rects = [];

    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      var sprayChunk = this.sprayChunks[i];

      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

        var rect = new fabric.Rect({
          width: sprayChunk[j].width,
          height: sprayChunk[j].width,
          left: sprayChunk[j].x + 1,
          top: sprayChunk[j].y + 1,
          originX: 'center',
          originY: 'center',
          fill: this.color
        });
        rects.push(rect);
      }
    }

    if (this.optimizeOverlapping) {
      rects = this._getOptimizedRects(rects);
    }

    var group = new fabric.Group(rects);
    this.shadow && group.set('shadow', new fabric.Shadow(this.shadow));
    this.canvas.fire('before:path:created', { path: group });
    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @private
   * @param {Array} rects
   */
  _getOptimizedRects: function(rects) {

    // avoid creating duplicate rects at the same coordinates
    var uniqueRects = { }, key, i, len;

    for (i = 0, len = rects.length; i < len; i++) {
      key = rects[i].left + '' + rects[i].top;
      if (!uniqueRects[key]) {
        uniqueRects[key] = rects[i];
      }
    }
    var uniqueRectsArray = [];
    for (key in uniqueRects) {
      uniqueRectsArray.push(uniqueRects[key]);
    }

    return uniqueRectsArray;
  },

  /**
   * Render new chunk of spray brush
   */
  render: function(sprayChunk) {
    var ctx = this.canvas.contextTop, i, len;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, len = sprayChunk.length; i < len; i++) {
      var point = sprayChunk[i];
      if (typeof point.opacity !== 'undefined') {
        ctx.globalAlpha = point.opacity;
      }
      ctx.fillRect(point.x, point.y, point.width, point.width);
    }
    ctx.restore();
  },

  /**
   * Render all spray chunks
   */
  _render: function() {
    var ctx = this.canvas.contextTop, i, ilen;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      this.render(this.sprayChunks[i]);
    }
    ctx.restore();
  },

  /**
   * @param {Object} pointer
   */
  addSprayChunk: function(pointer) {
    this.sprayChunkPoints = [];

    var x, y, width, radius = this.width / 2, i;

    for (i = 0; i < this.density; i++) {

      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

      if (this.dotWidthVariance) {
        width = fabric.util.getRandomInt(
          // bottom clamp width to 1
          Math.max(1, this.dotWidth - this.dotWidthVariance),
          this.dotWidth + this.dotWidthVariance);
      }
      else {
        width = this.dotWidth;
      }

      var point = new fabric.Point(x, y);
      point.width = width;

      if (this.randomOpacity) {
        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
      }

      this.sprayChunkPoints.push(point);
    }

    this.sprayChunks.push(this.sprayChunkPoints);
  }
});


/**
 * PatternBrush class
 * @class fabric.PatternBrush
 * @extends fabric.BaseBrush
 */
fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

  getPatternSrc: function() {

    var dotWidth = 20,
        dotDistance = 5,
        patternCanvas = fabric.util.createCanvasElement(),
        patternCtx = patternCanvas.getContext('2d');

    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

    patternCtx.fillStyle = this.color;
    patternCtx.beginPath();
    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
    patternCtx.closePath();
    patternCtx.fill();

    return patternCanvas;
  },

  getPatternSrcFunction: function() {
    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
  },

  /**
   * Creates "pattern" instance property
   */
  getPattern: function() {
    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
  },

  /**
   * Sets brush styles
   */
  _setBrushStyles: function() {
    this.callSuper('_setBrushStyles');
    this.canvas.contextTop.strokeStyle = this.getPattern();
  },

  /**
   * Creates path
   */
  createPath: function(pathData) {
    var path = this.callSuper('createPath', pathData),
        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

    path.stroke = new fabric.Pattern({
      source: this.source || this.getPatternSrcFunction(),
      offsetX: -topLeft.x,
      offsetY: -topLeft.y
    });
    return path;
  }
});


(function() {

  var getPointer = fabric.util.getPointer,
      degreesToRadians = fabric.util.degreesToRadians,
      abs = Math.abs,
      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),
      isTouchEvent = fabric.util.isTouchEvent,
      STROKE_OFFSET = 0.5;

  /**
   * Canvas class
   * @class fabric.Canvas
   * @extends fabric.StaticCanvas
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
   * @see {@link fabric.Canvas#initialize} for constructor definition
   *
   * @fires object:modified at the end of a transform or any change when statefull is true
   * @fires object:rotating while an object is being rotated from the control
   * @fires object:scaling while an object is being scaled by controls
   * @fires object:moving while an object is being dragged
   * @fires object:skewing while an object is being skewed from the controls
   *
   * @fires before:transform before a transform is is started
   * @fires before:selection:cleared
   * @fires selection:cleared
   * @fires selection:updated
   * @fires selection:created
   *
   * @fires path:created after a drawing operation ends and the path is added
   * @fires mouse:down
   * @fires mouse:move
   * @fires mouse:up
   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs
   * @fires mouse:move:before on mouse move, before the inner fabric logic runs
   * @fires mouse:up:before on mouse up, before the inner fabric logic runs
   * @fires mouse:over
   * @fires mouse:out
   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop
   * @fires after:render at the end of the render process, receives the context in the callback
   * @fires before:render at start the render process, receives the context in the callback
   *
   * the following events are deprecated:
   * @fires object:rotated at the end of a rotation transform
   * @fires object:scaled at the end of a scale transform
   * @fires object:moved at the end of translation transform
   * @fires object:skewed at the end of a skew transform
   */
  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
      this._initInteractive();
      this._createCacheCanvas();
    },

    /**
     * When true, objects can be transformed by one side (unproportionally)
     * when dragged on the corners that normally would not do that.
     * @type Boolean
     * @default
     * @since fabric 4.0 // changed name and default value
     */
    uniformScaling:      true,

    /**
     * Indicates which key switches uniform scaling.
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled.
     * totally wrong named. this sounds like `uniform scaling`
     * if Canvas.uniformScaling is true, pressing this will set it to false
     * and viceversa.
     * @since 1.6.2
     * @type String
     * @default
     */
    uniScaleKey:           'shiftKey',

    /**
     * When true, objects use center point as the origin of scale transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:        false,

    /**
     * When true, objects use center point as the origin of rotate transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:       false,

    /**
     * Indicates which key enable centered Transform
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    centeredKey:           'altKey',

    /**
     * Indicates which key enable alternate action on corner
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    altActionKey:           'shiftKey',

    /**
     * Indicates that canvas is interactive. This property should not be changed.
     * @type Boolean
     * @default
     */
    interactive:            true,

    /**
     * Indicates whether group selection should be enabled
     * @type Boolean
     * @default
     */
    selection:              true,

    /**
     * Indicates which key or keys enable multiple click selection
     * Pass value as a string or array of strings
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or empty or containing any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.2
     * @type String|Array
     * @default
     */
    selectionKey:           'shiftKey',

    /**
     * Indicates which key enable alternative selection
     * in case of target overlapping with active object
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * For a series of reason that come from the general expectations on how
     * things should work, this feature works only for preserveObjectStacking true.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.5
     * @type null|String
     * @default
     */
    altSelectionKey:           null,

    /**
     * Color of selection
     * @type String
     * @default
     */
    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

    /**
     * Default dash array pattern
     * If not empty the selection border is dashed
     * @type Array
     */
    selectionDashArray:     [],

    /**
     * Color of the border of selection (usually slightly darker than color of selection itself)
     * @type String
     * @default
     */
    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

    /**
     * Width of a line used in object/group selection
     * @type Number
     * @default
     */
    selectionLineWidth:     1,

    /**
     * Select only shapes that are fully contained in the dragged selection rectangle.
     * @type Boolean
     * @default
     */
    selectionFullyContained: false,

    /**
     * Default cursor value used when hovering over an object on canvas
     * @type String
     * @default
     */
    hoverCursor:            'move',

    /**
     * Default cursor value used when moving an object on canvas
     * @type String
     * @default
     */
    moveCursor:             'move',

    /**
     * Default cursor value used for the entire canvas
     * @type String
     * @default
     */
    defaultCursor:          'default',

    /**
     * Cursor value used during free drawing
     * @type String
     * @default
     */
    freeDrawingCursor:      'crosshair',

    /**
     * Cursor value used for rotation point
     * @type String
     * @default
     */
    rotationCursor:         'crosshair',

    /**
     * Cursor value used for disabled elements ( corners with disabled action )
     * @type String
     * @since 2.0.0
     * @default
     */
    notAllowedCursor:         'not-allowed',

    /**
     * Default element class that's given to wrapper (div) element of canvas
     * @type String
     * @default
     */
    containerClass:         'canvas-container',

    /**
     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:     false,

    /**
     * Number of pixels around target pixel to tolerate (consider active) during object detection
     * @type Number
     * @default
     */
    targetFindTolerance:    0,

    /**
     * When true, target detection is skipped. Target detection will return always undefined.
     * click selection won't work anymore, events will fire with no targets.
     * if something is selected before setting it to true, it will be deselected at the first click.
     * area selection will still work. check the `selection` property too.
     * if you deactivate both, you should look into staticCanvas.
     * @type Boolean
     * @default
     */
    skipTargetFind:         false,

    /**
     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
     * After mousedown, mousemove creates a shape,
     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
     * @type Boolean
     * @default
     */
    isDrawingMode:          false,

    /**
     * Indicates whether objects should remain in current stack position when selected.
     * When false objects are brought to top and rendered as part of the selection group
     * @type Boolean
     * @default
     */
    preserveObjectStacking: false,

    /**
     * Indicates the angle that an object will lock to while rotating.
     * @type Number
     * @since 1.6.7
     * @default
     */
    snapAngle: 0,

    /**
     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
     * When `null`, the snapThreshold will default to the snapAngle.
     * @type null|Number
     * @since 1.6.7
     * @default
     */
    snapThreshold: null,

    /**
     * Indicates if the right click on canvas can output the context menu or not
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    stopContextMenu: false,

    /**
     * Indicates if the canvas can fire right click events
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    fireRightClick: false,

    /**
     * Indicates if the canvas can fire middle click events
     * @type Boolean
     * @since 1.7.8
     * @default
     */
    fireMiddleClick: false,

    /**
     * Keep track of the subTargets for Mouse Events
     * @type fabric.Object[]
     */
    targets: [],

    /**
     * Keep track of the hovered target
     * @type fabric.Object
     * @private
     */
    _hoveredTarget: null,

    /**
     * hold the list of nested targets hovered
     * @type fabric.Object[]
     * @private
     */
    _hoveredTargets: [],

    /**
     * @private
     */
    _initInteractive: function() {
      this._currentTransform = null;
      this._groupSelector = null;
      this._initWrapperElement();
      this._createUpperCanvas();
      this._initEventListeners();

      this._initRetinaScaling();

      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

      this.calcOffset();
    },

    /**
     * Divides objects in two groups, one to render immediately
     * and one to render as activeGroup.
     * @return {Array} objects to render immediately and pushes the other in the activeGroup.
     */
    _chooseObjectsToRender: function() {
      var activeObjects = this.getActiveObjects(),
          object, objsToRender, activeGroupObjects;

      if (activeObjects.length > 0 && !this.preserveObjectStacking) {
        objsToRender = [];
        activeGroupObjects = [];
        for (var i = 0, length = this._objects.length; i < length; i++) {
          object = this._objects[i];
          if (activeObjects.indexOf(object) === -1 ) {
            objsToRender.push(object);
          }
          else {
            activeGroupObjects.push(object);
          }
        }
        if (activeObjects.length > 1) {
          this._activeObject._objects = activeGroupObjects;
        }
        objsToRender.push.apply(objsToRender, activeGroupObjects);
      }
      else {
        objsToRender = this._objects;
      }
      return objsToRender;
    },

    /**
     * Renders both the top canvas and the secondary container canvas.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
        this.clearContext(this.contextTop);
        this.contextTopDirty = false;
      }
      if (this.hasLostContext) {
        this.renderTopLayer(this.contextTop);
      }
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
      return this;
    },

    renderTopLayer: function(ctx) {
      ctx.save();
      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._render();
        this.contextTopDirty = true;
      }
      // we render the top context - last object
      if (this.selection && this._groupSelector) {
        this._drawSelection(ctx);
        this.contextTopDirty = true;
      }
      ctx.restore();
    },

    /**
     * Method to render only the top canvas.
     * Also used to render the group selection box.
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    renderTop: function () {
      var ctx = this.contextTop;
      this.clearContext(ctx);
      this.renderTopLayer(ctx);
      this.fire('after:render');
      return this;
    },

    /**
     * @private
     */
    _normalizePointer: function (object, pointer) {
      var m = object.calcTransformMatrix(),
          invertedM = fabric.util.invertTransform(m),
          vptPointer = this.restorePointerVpt(pointer);
      return fabric.util.transformPoint(vptPointer, invertedM);
    },

    /**
     * Returns true if object is transparent at a certain location
     * @param {fabric.Object} target Object to check
     * @param {Number} x Left coordinate
     * @param {Number} y Top coordinate
     * @return {Boolean}
     */
    isTargetTransparent: function (target, x, y) {
      // in case the target is the activeObject, we cannot execute this optimization
      // because we need to draw controls too.
      if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {
        var normalizedPointer = this._normalizePointer(target, {x: x, y: y}),
            targetRelativeX = Math.max(target.cacheTranslationX + (normalizedPointer.x * target.zoomX), 0),
            targetRelativeY = Math.max(target.cacheTranslationY + (normalizedPointer.y * target.zoomY), 0);

        var isTransparent = fabric.util.isTransparent(
          target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);

        return isTransparent;
      }

      var ctx = this.contextCache,
          originalColor = target.selectionBackgroundColor, v = this.viewportTransform;

      target.selectionBackgroundColor = '';

      this.clearContext(ctx);

      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      target.render(ctx);
      ctx.restore();

      target === this._activeObject && target._renderControls(ctx, {
        hasBorders: false,
        transparentCorners: false
      }, {
        hasBorders: false,
      });

      target.selectionBackgroundColor = originalColor;

      var isTransparent = fabric.util.isTransparent(
        ctx, x, y, this.targetFindTolerance);

      return isTransparent;
    },

    /**
     * takes an event and determines if selection key has been pressed
     * @private
     * @param {Event} e Event object
     */
    _isSelectionKeyPressed: function(e) {
      var selectionKeyPressed = false;

      if (Object.prototype.toString.call(this.selectionKey) === '[object Array]') {
        selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });
      }
      else {
        selectionKeyPressed = e[this.selectionKey];
      }

      return selectionKeyPressed;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _shouldClearSelection: function (e, target) {
      var activeObjects = this.getActiveObjects(),
          activeObject = this._activeObject;

      return (
        !target
        ||
        (target &&
          activeObject &&
          activeObjects.length > 1 &&
          activeObjects.indexOf(target) === -1 &&
          activeObject !== target &&
          !this._isSelectionKeyPressed(e))
        ||
        (target && !target.evented)
        ||
        (target &&
          !target.selectable &&
          activeObject &&
          activeObject !== target)
      );
    },

    /**
     * centeredScaling from object can't override centeredScaling from canvas.
     * this should be fixed, since object setting should take precedence over canvas.
     * also this should be something that will be migrated in the control properties.
     * as ability to define the origin of the transformation that the control provide.
     * @private
     * @param {fabric.Object} target
     * @param {String} action
     * @param {Boolean} altKey
     */
    _shouldCenterTransform: function (target, action, altKey) {
      if (!target) {
        return;
      }

      var centerTransform;

      if (action === 'scale' || action === 'scaleX' || action === 'scaleY' || action === 'resizing') {
        centerTransform = this.centeredScaling || target.centeredScaling;
      }
      else if (action === 'rotate') {
        centerTransform = this.centeredRotation || target.centeredRotation;
      }

      return centerTransform ? !altKey : altKey;
    },

    /**
     * should disappear before release 4.0
     * @private
     */
    _getOriginFromCorner: function(target, corner) {
      var origin = {
        x: target.originX,
        y: target.originY
      };

      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
        origin.x = 'right';
      }
      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
        origin.x = 'left';
      }

      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
        origin.y = 'bottom';
      }
      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
        origin.y = 'top';
      }
      return origin;
    },

    /**
     * @private
     * @param {Boolean} alreadySelected true if target is already selected
     * @param {String} corner a string representing the corner ml, mr, tl ...
     * @param {Event} e Event object
     * @param {fabric.Object} [target] inserted back to help overriding. Unused
     */
    _getActionFromCorner: function(alreadySelected, corner, e, target) {
      if (!corner || !alreadySelected) {
        return 'drag';
      }
      var control = target.controls[corner];
      return control.getActionName(e, control, target);
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _setupCurrentTransform: function (e, target, alreadySelected) {
      if (!target) {
        return;
      }

      var pointer = this.getPointer(e), corner = target.__corner,
          control = target.controls[corner],
          actionHandler = (alreadySelected && corner) ?
            control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler,
          action = this._getActionFromCorner(alreadySelected, corner, e, target),
          origin = this._getOriginFromCorner(target, corner),
          altKey = e[this.centeredKey],
          transform = {
            target: target,
            action: action,
            actionHandler: actionHandler,
            corner: corner,
            scaleX: target.scaleX,
            scaleY: target.scaleY,
            skewX: target.skewX,
            skewY: target.skewY,
            // used by transation
            offsetX: pointer.x - target.left,
            offsetY: pointer.y - target.top,
            originX: origin.x,
            originY: origin.y,
            ex: pointer.x,
            ey: pointer.y,
            lastX: pointer.x,
            lastY: pointer.y,
            // unsure they are useful anymore.
            // left: target.left,
            // top: target.top,
            theta: degreesToRadians(target.angle),
            // end of unsure
            width: target.width * target.scaleX,
            shiftKey: e.shiftKey,
            altKey: altKey,
            original: fabric.util.saveObjectTransform(target),
          };

      if (this._shouldCenterTransform(target, action, altKey)) {
        transform.originX = 'center';
        transform.originY = 'center';
      }
      transform.original.originX = origin.x;
      transform.original.originY = origin.y;
      this._currentTransform = transform;
      this._beforeTransform(e);
    },

    /**
     * Set the cursor type of the canvas element
     * @param {String} value Cursor type of the canvas element.
     * @see http://www.w3.org/TR/css3-ui/#cursor
     */
    setCursor: function (value) {
      this.upperCanvasEl.style.cursor = value;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx to draw the selection on
     */
    _drawSelection: function (ctx) {
      var groupSelector = this._groupSelector,
          left = groupSelector.left,
          top = groupSelector.top,
          aleft = abs(left),
          atop = abs(top);

      if (this.selectionColor) {
        ctx.fillStyle = this.selectionColor;

        ctx.fillRect(
          groupSelector.ex - ((left > 0) ? 0 : -left),
          groupSelector.ey - ((top > 0) ? 0 : -top),
          aleft,
          atop
        );
      }

      if (!this.selectionLineWidth || !this.selectionBorderColor) {
        return;
      }
      ctx.lineWidth = this.selectionLineWidth;
      ctx.strokeStyle = this.selectionBorderColor;

      // selection border
      if (this.selectionDashArray.length > 1 && !supportLineDash) {

        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);

        ctx.beginPath();

        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);

        ctx.closePath();
        ctx.stroke();
      }
      else {
        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
        ctx.strokeRect(
          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
          aleft,
          atop
        );
      }
    },

    /**
     * Method that determines what object we are clicking on
     * the skipGroup parameter is for internal use, is needed for shift+click action
     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target
     * or the outside part of the corner.
     * @param {Event} e mouse event
     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
     * @return {fabric.Object} the target found
     */
    findTarget: function (e, skipGroup) {
      if (this.skipTargetFind) {
        return;
      }

      var ignoreZoom = true,
          pointer = this.getPointer(e, ignoreZoom),
          activeObject = this._activeObject,
          aObjects = this.getActiveObjects(),
          activeTarget, activeTargetSubs,
          isTouch = isTouchEvent(e);

      // first check current group (if one exists)
      // active group does not check sub targets like normal groups.
      // if active group just exits.
      this.targets = [];

      if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        return activeObject;
      }
      // if we hit the corner of an activeObject, let's return that.
      if (aObjects.length === 1 && activeObject._findTargetCorner(pointer, isTouch)) {
        return activeObject;
      }
      if (aObjects.length === 1 &&
        activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        if (!this.preserveObjectStacking) {
          return activeObject;
        }
        else {
          activeTarget = activeObject;
          activeTargetSubs = this.targets;
          this.targets = [];
        }
      }
      var target = this._searchPossibleTargets(this._objects, pointer);
      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
        target = activeTarget;
        this.targets = activeTargetSubs;
      }
      return target;
    },

    /**
     * Checks point is inside the object.
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @param {fabric.Object} obj Object to test against
     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.
     * @return {Boolean} true if point is contained within an area of given object
     * @private
     */
    _checkTarget: function(pointer, obj, globalPointer) {
      if (obj &&
          obj.visible &&
          obj.evented &&
          // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
          // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
          (obj.containsPoint(pointer) || !!obj._findTargetCorner(pointer))
      ) {
        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
          var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);
          if (!isTransparent) {
            return true;
          }
        }
        else {
          return true;
        }
      }
    },

    /**
     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted
     * @param {Array} [objects] objects array to look into
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @return {fabric.Object} object that contains pointer
     * @private
     */
    _searchPossibleTargets: function(objects, pointer) {
      // Cache all targets where their bounding box contains point.
      var target, i = objects.length, subTarget;
      // Do not check for currently grouped objects, since we check the parent group itself.
      // until we call this function specifically to search inside the activeGroup
      while (i--) {
        var objToCheck = objects[i];
        var pointerToUse = objToCheck.group ?
          this._normalizePointer(objToCheck.group, pointer) : pointer;
        if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
          target = objects[i];
          if (target.subTargetCheck && target instanceof fabric.Group) {
            subTarget = this._searchPossibleTargets(target._objects, pointer);
            subTarget && this.targets.push(subTarget);
          }
          break;
        }
      }
      return target;
    },

    /**
     * Returns pointer coordinates without the effect of the viewport
     * @param {Object} pointer with "x" and "y" number values
     * @return {Object} object with "x" and "y" number values
     */
    restorePointerVpt: function(pointer) {
      return fabric.util.transformPoint(
        pointer,
        fabric.util.invertTransform(this.viewportTransform)
      );
    },

    /**
     * Returns pointer coordinates relative to canvas.
     * Can return coordinates with or without viewportTransform.
     * ignoreZoom false gives back coordinates that represent
     * the point clicked on canvas element.
     * ignoreZoom true gives back coordinates after being processed
     * by the viewportTransform ( sort of coordinates of what is displayed
     * on the canvas where you are clicking.
     * ignoreZoom true = HTMLElement coordinates relative to top,left
     * ignoreZoom false, default = fabric space coordinates, the same used for shape position
     * To interact with your shapes top and left you want to use ignoreZoom true
     * most of the time, while ignoreZoom false will give you coordinates
     * compatible with the object.oCoords system.
     * of the time.
     * @param {Event} e
     * @param {Boolean} ignoreZoom
     * @return {Object} object with "x" and "y" number values
     */
    getPointer: function (e, ignoreZoom) {
      // return cached values if we are in the event processing chain
      if (this._absolutePointer && !ignoreZoom) {
        return this._absolutePointer;
      }
      if (this._pointer && ignoreZoom) {
        return this._pointer;
      }

      var pointer = getPointer(e),
          upperCanvasEl = this.upperCanvasEl,
          bounds = upperCanvasEl.getBoundingClientRect(),
          boundsWidth = bounds.width || 0,
          boundsHeight = bounds.height || 0,
          cssScale;

      if (!boundsWidth || !boundsHeight ) {
        if ('top' in bounds && 'bottom' in bounds) {
          boundsHeight = Math.abs( bounds.top - bounds.bottom );
        }
        if ('right' in bounds && 'left' in bounds) {
          boundsWidth = Math.abs( bounds.right - bounds.left );
        }
      }

      this.calcOffset();
      pointer.x = pointer.x - this._offset.left;
      pointer.y = pointer.y - this._offset.top;
      if (!ignoreZoom) {
        pointer = this.restorePointerVpt(pointer);
      }

      var retinaScaling = this.getRetinaScaling();
      if (retinaScaling !== 1) {
        pointer.x /= retinaScaling;
        pointer.y /= retinaScaling;
      }

      if (boundsWidth === 0 || boundsHeight === 0) {
        // If bounds are not available (i.e. not visible), do not apply scale.
        cssScale = { width: 1, height: 1 };
      }
      else {
        cssScale = {
          width: upperCanvasEl.width / boundsWidth,
          height: upperCanvasEl.height / boundsHeight
        };
      }

      return {
        x: pointer.x * cssScale.width,
        y: pointer.y * cssScale.height
      };
    },

    /**
     * @private
     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
     */
    _createUpperCanvas: function () {
      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ''),
          lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;

      // there is no need to create a new upperCanvas element if we have already one.
      if (upperCanvasEl) {
        upperCanvasEl.className = '';
      }
      else {
        upperCanvasEl = this._createCanvasElement();
        this.upperCanvasEl = upperCanvasEl;
      }
      fabric.util.addClass(upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

      this.wrapperEl.appendChild(upperCanvasEl);

      this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);
      this._applyCanvasStyle(upperCanvasEl);
      this.contextTop = upperCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _createCacheCanvas: function () {
      this.cacheCanvasEl = this._createCanvasElement();
      this.cacheCanvasEl.setAttribute('width', this.width);
      this.cacheCanvasEl.setAttribute('height', this.height);
      this.contextCache = this.cacheCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _initWrapperElement: function () {
      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
        'class': this.containerClass
      });
      fabric.util.setStyle(this.wrapperEl, {
        width: this.width + 'px',
        height: this.height + 'px',
        position: 'relative'
      });
      fabric.util.makeElementUnselectable(this.wrapperEl);
    },

    /**
     * @private
     * @param {HTMLElement} element canvas element to apply styles on
     */
    _applyCanvasStyle: function (element) {
      var width = this.width || element.width,
          height = this.height || element.height;

      fabric.util.setStyle(element, {
        position: 'absolute',
        width: width + 'px',
        height: height + 'px',
        left: 0,
        top: 0,
        'touch-action': this.allowTouchScrolling ? 'manipulation' : 'none',
        '-ms-touch-action': this.allowTouchScrolling ? 'manipulation' : 'none'
      });
      element.width = width;
      element.height = height;
      fabric.util.makeElementUnselectable(element);
    },

    /**
     * Copy the entire inline style from one element (fromEl) to another (toEl)
     * @private
     * @param {Element} fromEl Element style is copied from
     * @param {Element} toEl Element copied style is applied to
     */
    _copyCanvasStyle: function (fromEl, toEl) {
      toEl.style.cssText = fromEl.style.cssText;
    },

    /**
     * Returns context of canvas where object selection is drawn
     * @return {CanvasRenderingContext2D}
     */
    getSelectionContext: function() {
      return this.contextTop;
    },

    /**
     * Returns &lt;canvas> element on which object selection is drawn
     * @return {HTMLCanvasElement}
     */
    getSelectionElement: function () {
      return this.upperCanvasEl;
    },

    /**
     * Returns currently active object
     * @return {fabric.Object} active object
     */
    getActiveObject: function () {
      return this._activeObject;
    },

    /**
     * Returns an array with the current selected objects
     * @return {fabric.Object} active object
     */
    getActiveObjects: function () {
      var active = this._activeObject;
      if (active) {
        if (active.type === 'activeSelection' && active._objects) {
          return active._objects.slice(0);
        }
        else {
          return [active];
        }
      }
      return [];
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      // removing active object should fire "selection:cleared" events
      if (obj === this._activeObject) {
        this.fire('before:selection:cleared', { target: obj });
        this._discardActiveObject();
        this.fire('selection:cleared', { target: obj });
        obj.fire('deselected');
      }
      if (obj === this._hoveredTarget){
        this._hoveredTarget = null;
        this._hoveredTargets = [];
      }
      this.callSuper('_onObjectRemoved', obj);
    },

    /**
     * @private
     * Compares the old activeObject with the current one and fires correct events
     * @param {fabric.Object} obj old activeObject
     */
    _fireSelectionEvents: function(oldObjects, e) {
      var somethingChanged = false, objects = this.getActiveObjects(),
          added = [], removed = [], opt = { e: e };
      oldObjects.forEach(function(oldObject) {
        if (objects.indexOf(oldObject) === -1) {
          somethingChanged = true;
          oldObject.fire('deselected', opt);
          removed.push(oldObject);
        }
      });
      objects.forEach(function(object) {
        if (oldObjects.indexOf(object) === -1) {
          somethingChanged = true;
          object.fire('selected', opt);
          added.push(object);
        }
      });
      if (oldObjects.length > 0 && objects.length > 0) {
        opt.selected = added;
        opt.deselected = removed;
        // added for backward compatibility
        opt.updated = added[0] || removed[0];
        opt.target = this._activeObject;
        somethingChanged && this.fire('selection:updated', opt);
      }
      else if (objects.length > 0) {
        opt.selected = added;
        // added for backward compatibility
        opt.target = this._activeObject;
        this.fire('selection:created', opt);
      }
      else if (oldObjects.length > 0) {
        opt.deselected = removed;
        this.fire('selection:cleared', opt);
      }
    },

    /**
     * Sets given object as the only active object on canvas
     * @param {fabric.Object} object Object to set as an active one
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setActiveObject: function (object, e) {
      var currentActives = this.getActiveObjects();
      this._setActiveObject(object, e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * @private
     * @param {Object} object to set as active
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {Boolean} true if the selection happened
     */
    _setActiveObject: function(object, e) {
      if (this._activeObject === object) {
        return false;
      }
      if (!this._discardActiveObject(e, object)) {
        return false;
      }
      if (object.onSelect({ e: e })) {
        return false;
      }
      this._activeObject = object;
      return true;
    },

    /**
     * @private
     */
    _discardActiveObject: function(e, object) {
      var obj = this._activeObject;
      if (obj) {
        // onDeselect return TRUE to cancel selection;
        if (obj.onDeselect({ e: e, object: object })) {
          return false;
        }
        this._activeObject = null;
      }
      return true;
    },

    /**
     * Discards currently active object and fire events. If the function is called by fabric
     * as a consequence of a mouse event, the event is passed as a parameter and
     * sent to the fire function for the custom events. When used as a method the
     * e param does not have any application.
     * @param {event} e
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    discardActiveObject: function (e) {
      var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();
      if (currentActives.length) {
        this.fire('before:selection:cleared', { target: activeObject, e: e });
      }
      this._discardActiveObject(e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * Clears a canvas element and removes all event listeners
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      var wrapper = this.wrapperEl;
      this.removeListeners();
      wrapper.removeChild(this.upperCanvasEl);
      wrapper.removeChild(this.lowerCanvasEl);
      this.contextCache = null;
      this.contextTop = null;
      ['upperCanvasEl', 'cacheCanvasEl'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
      if (wrapper.parentNode) {
        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
      }
      delete this.wrapperEl;
      fabric.StaticCanvas.prototype.dispose.call(this);
      return this;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      // this.discardActiveGroup();
      this.discardActiveObject();
      this.clearContext(this.contextTop);
      return this.callSuper('clear');
    },

    /**
     * Draws objects' controls (borders/controls)
     * @param {CanvasRenderingContext2D} ctx Context to render controls on
     */
    drawControls: function(ctx) {
      var activeObject = this._activeObject;

      if (activeObject) {
        activeObject._renderControls(ctx);
      }
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      //If the object is part of the current selection group, it should
      //be transformed appropriately
      //i.e. it should be serialised as it would appear if the selection group
      //were to be destroyed.
      var originalProperties = this._realizeGroupTransformOnObject(instance),
          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
      //Undo the damage we did by changing all of its properties
      this._unwindGroupTransformOnObject(instance, originalProperties);
      return object;
    },

    /**
     * Realises an object's group transformation on it
     * @private
     * @param {fabric.Object} [instance] the object to transform (gets mutated)
     * @returns the original values of instance which were changed
     */
    _realizeGroupTransformOnObject: function(instance) {
      if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
        var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
        //Copy all the positionally relevant properties across now
        var originalValues = {};
        layoutProps.forEach(function(prop) {
          originalValues[prop] = instance[prop];
        });
        this._activeObject.realizeTransform(instance);
        return originalValues;
      }
      else {
        return null;
      }
    },

    /**
     * Restores the changed properties of instance
     * @private
     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
     */
    _unwindGroupTransformOnObject: function(instance, originalValues) {
      if (originalValues) {
        instance.set(originalValues);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      //If the object is in a selection group, simulate what would happen to that
      //object when the group is deselected
      var originalProperties = this._realizeGroupTransformOnObject(instance);
      this.callSuper('_setSVGObject', markup, instance, reviver);
      this._unwindGroupTransformOnObject(instance, originalProperties);
    },

    setViewportTransform: function (vpt) {
      if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
        this._activeObject.clearContextTop();
      }
      fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
    }
  });

  // copying static properties manually to work around Opera's bug,
  // where "prototype" property is enumerable and overrides existing prototype
  for (var prop in fabric.StaticCanvas) {
    if (prop !== 'prototype') {
      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
    }
  }
})();


(function() {

  var addListener = fabric.util.addListener,
      removeListener = fabric.util.removeListener,
      RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1,
      addEventOptions = { passive: false };

  function checkClick(e, value) {
    return e.button && (e.button === value - 1);
  }

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * Contains the id of the touch event that owns the fabric transform
     * @type Number
     * @private
     */
    mainTouchId: null,

    /**
     * Adds mouse listeners to canvas
     * @private
     */
    _initEventListeners: function () {
      // in case we initialized the class twice. This should not happen normally
      // but in some kind of applications where the canvas element may be changed
      // this is a workaround to having double listeners.
      this.removeListeners();
      this._bindEvents();
      this.addOrRemove(addListener, 'add');
    },

    /**
     * return an event prefix pointer or mouse.
     * @private
     */
    _getEventPrefix: function () {
      return this.enablePointerEvents ? 'pointer' : 'mouse';
    },

    addOrRemove: function(functor, eventjsFunctor) {
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      functor(fabric.window, 'resize', this._onResize);
      functor(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
      functor(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      functor(canvasElement, eventTypePrefix + 'out', this._onMouseOut);
      functor(canvasElement, eventTypePrefix + 'enter', this._onMouseEnter);
      functor(canvasElement, 'wheel', this._onMouseWheel);
      functor(canvasElement, 'contextmenu', this._onContextMenu);
      functor(canvasElement, 'dblclick', this._onDoubleClick);
      functor(canvasElement, 'dragover', this._onDragOver);
      functor(canvasElement, 'dragenter', this._onDragEnter);
      functor(canvasElement, 'dragleave', this._onDragLeave);
      functor(canvasElement, 'drop', this._onDrop);
      if (!this.enablePointerEvents) {
        functor(canvasElement, 'touchstart', this._onTouchStart, addEventOptions);
      }
      if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {
        eventjs[eventjsFunctor](canvasElement, 'gesture', this._onGesture);
        eventjs[eventjsFunctor](canvasElement, 'drag', this._onDrag);
        eventjs[eventjsFunctor](canvasElement, 'orientation', this._onOrientationChange);
        eventjs[eventjsFunctor](canvasElement, 'shake', this._onShake);
        eventjs[eventjsFunctor](canvasElement, 'longpress', this._onLongPress);
      }
    },

    /**
     * Removes all event listeners
     */
    removeListeners: function() {
      this.addOrRemove(removeListener, 'remove');
      // if you dispose on a mouseDown, before mouse up, you need to clean document to...
      var eventTypePrefix = this._getEventPrefix();
      removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
      removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
    },

    /**
     * @private
     */
    _bindEvents: function() {
      if (this.eventsBound) {
        // for any reason we pass here twice we do not want to bind events twice.
        return;
      }
      this._onMouseDown = this._onMouseDown.bind(this);
      this._onTouchStart = this._onTouchStart.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      this._onMouseUp = this._onMouseUp.bind(this);
      this._onTouchEnd = this._onTouchEnd.bind(this);
      this._onResize = this._onResize.bind(this);
      this._onGesture = this._onGesture.bind(this);
      this._onDrag = this._onDrag.bind(this);
      this._onShake = this._onShake.bind(this);
      this._onLongPress = this._onLongPress.bind(this);
      this._onOrientationChange = this._onOrientationChange.bind(this);
      this._onMouseWheel = this._onMouseWheel.bind(this);
      this._onMouseOut = this._onMouseOut.bind(this);
      this._onMouseEnter = this._onMouseEnter.bind(this);
      this._onContextMenu = this._onContextMenu.bind(this);
      this._onDoubleClick = this._onDoubleClick.bind(this);
      this._onDragOver = this._onDragOver.bind(this);
      this._onDragEnter = this._simpleEventHandler.bind(this, 'dragenter');
      this._onDragLeave = this._simpleEventHandler.bind(this, 'dragleave');
      this._onDrop = this._simpleEventHandler.bind(this, 'drop');
      this.eventsBound = true;
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js gesture
     * @param {Event} [self] Inner Event object
     */
    _onGesture: function(e, self) {
      this.__onTransformGesture && this.__onTransformGesture(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js drag
     * @param {Event} [self] Inner Event object
     */
    _onDrag: function(e, self) {
      this.__onDrag && this.__onDrag(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on wheel event
     */
    _onMouseWheel: function(e) {
      this.__onMouseWheel(e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseOut: function(e) {
      var target = this._hoveredTarget;
      this.fire('mouse:out', { target: target, e: e });
      this._hoveredTarget = null;
      target && target.fire('mouseout', { e: e });

      var _this = this;
      this._hoveredTargets.forEach(function(_target){
        _this.fire('mouse:out', { target: target, e: e });
        _target && target.fire('mouseout', { e: e });
      });
      this._hoveredTargets = [];

      if (this._iTextInstances) {
        this._iTextInstances.forEach(function(obj) {
          if (obj.isEditing) {
            obj.hiddenTextarea.focus();
          }
        });
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseenter
     */
    _onMouseEnter: function(e) {
      // This find target and consequent 'mouse:over' is used to
      // clear old instances on hovered target.
      // calling findTarget has the side effect of killing target.__corner.
      // as a short term fix we are not firing this if we are currently transforming.
      // as a long term fix we need to separate the action of finding a target with the
      // side effects we added to it.
      if (!this._currentTransform && !this.findTarget(e)) {
        this.fire('mouse:over', { target: null, e: e });
        this._hoveredTarget = null;
        this._hoveredTargets = [];
      }
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js orientation change
     * @param {Event} [self] Inner Event object
     */
    _onOrientationChange: function(e, self) {
      this.__onOrientationChange && this.__onOrientationChange(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onShake: function(e, self) {
      this.__onShake && this.__onShake(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onLongPress: function(e, self) {
      this.__onLongPress && this.__onLongPress(e, self);
    },

    /**
     * prevent default to allow drop event to be fired
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     */
    _onDragOver: function(e) {
      e.preventDefault();
      var target = this._simpleEventHandler('dragover', e);
      this._fireEnterLeaveEvents(target, e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onContextMenu: function (e) {
      if (this.stopContextMenu) {
        e.stopPropagation();
        e.preventDefault();
      }
      return false;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onDoubleClick: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'dblclick');
      this._resetTransformEventData(e);
    },

    /**
     * Return a the id of an event.
     * returns either the pointerId or the identifier or 0 for the mouse event
     * @private
     * @param {Event} evt Event object
     */
    getPointerId: function(evt) {
      var changedTouches = evt.changedTouches;

      if (changedTouches) {
        return changedTouches[0] && changedTouches[0].identifier;
      }

      if (this.enablePointerEvents) {
        return evt.pointerId;
      }

      return -1;
    },

    /**
     * Determines if an event has the id of the event that is considered main
     * @private
     * @param {evt} event Event object
     */
    _isMainEvent: function(evt) {
      if (evt.isPrimary === true) {
        return true;
      }
      if (evt.isPrimary === false) {
        return false;
      }
      if (evt.type === 'touchend' && evt.touches.length === 0) {
        return true;
      }
      if (evt.changedTouches) {
        return evt.changedTouches[0].identifier === this.mainTouchId;
      }
      return true;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onTouchStart: function(e) {
      e.preventDefault();
      if (this.mainTouchId === null) {
        this.mainTouchId = this.getPointerId(e);
      }
      this.__onMouseDown(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      addListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      addListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      // Unbind mousedown to prevent double triggers from touch devices
      removeListener(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDown: function (e) {
      this.__onMouseDown(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      removeListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      addListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
      addListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onTouchEnd: function(e) {
      if (e.touches.length > 0) {
        // if there are still touches stop here
        return;
      }
      this.__onMouseUp(e);
      this._resetTransformEventData();
      this.mainTouchId = null;
      var eventTypePrefix = this._getEventPrefix();
      removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      var _this = this;
      if (this._willAddMouseDown) {
        clearTimeout(this._willAddMouseDown);
      }
      this._willAddMouseDown = setTimeout(function() {
        // Wait 400ms before rebinding mousedown to prevent double triggers
        // from touch devices
        addListener(_this.upperCanvasEl, eventTypePrefix + 'down', _this._onMouseDown);
        _this._willAddMouseDown = 0;
      }, 400);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUp: function (e) {
      this.__onMouseUp(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      if (this._isMainEvent(e)) {
        removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
        removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
        addListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMove: function (e) {
      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
      this.__onMouseMove(e);
    },

    /**
     * @private
     */
    _onResize: function () {
      this.calcOffset();
    },

    /**
     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
     * @private
     * @param {Object} target
     */
    _shouldRender: function(target) {
      var activeObject = this._activeObject;

      if (
        !!activeObject !== !!target ||
        (activeObject && target && (activeObject !== target))
      ) {
        // this covers: switch of target, from target to no target, selection of target
        // multiSelection with key and mouse
        return true;
      }
      else if (activeObject && activeObject.isEditing) {
        // if we mouse up/down over a editing textbox a cursor change,
        // there is no need to re render
        return false;
      }
      return false;
    },

    /**
     * Method that defines the actions when mouse is released on canvas.
     * The method resets the currentTransform parameters, store the image corner
     * position in the image object and render the canvas on top.
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseUp: function (e) {
      var target, transform = this._currentTransform,
          groupSelector = this._groupSelector, shouldRender = false,
          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
      this._cacheTransformEventData(e);
      target = this._target;
      this._handleEvent(e, 'up:before');
      // if right/middle click just fire events and return
      // target undefined will make the _handleEvent search the target
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'up', RIGHT_CLICK, isClick);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'up', MIDDLE_CLICK, isClick);
        }
        this._resetTransformEventData();
        return;
      }

      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this._onMouseUpInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }
      if (transform) {
        this._finalizeCurrentTransform(e);
        shouldRender = transform.actionPerformed;
      }
      if (!isClick) {
        var targetWasActive = target === this._activeObject;
        this._maybeGroupObjects(e);
        if (!shouldRender) {
          shouldRender = (
            this._shouldRender(target) ||
            (!targetWasActive && target === this._activeObject)
          );
        }
      }
      if (target) {
        var corner = target._findTargetCorner(
          this.getPointer(e, true),
          fabric.util.isTouchEvent(e)
        );
        var control = target.controls[corner],
            mouseUpHandler = control && control.getMouseUpHandler(e, target, control);
        if (mouseUpHandler) {
          var pointer = this.getPointer(e);
          mouseUpHandler(e, transform, pointer.x, pointer.y);
        }
        target.isMoving = false;
      }
      this._setCursorFromEvent(e, target);
      this._handleEvent(e, 'up', LEFT_CLICK, isClick);
      this._groupSelector = null;
      this._currentTransform = null;
      // reset the target information about which corner is selected
      target && (target.__corner = 0);
      if (shouldRender) {
        this.requestRenderAll();
      }
      else if (!isClick) {
        this.renderTop();
      }
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @return {Fabric.Object} target return the the target found, for internal reasons.
     */
    _simpleEventHandler: function(eventType, e) {
      var target = this.findTarget(e),
          targets = this.targets,
          options = {
            e: e,
            target: target,
            subTargets: targets,
          };
      this.fire(eventType, options);
      target && target.fire(eventType, options);
      if (!targets) {
        return target;
      }
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire(eventType, options);
      }
      return target;
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @param {fabric.Object} targetObj receiving event
     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
     */
    _handleEvent: function(e, eventType, button, isClick) {
      var target = this._target,
          targets = this.targets || [],
          options = {
            e: e,
            target: target,
            subTargets: targets,
            button: button || LEFT_CLICK,
            isClick: isClick || false,
            pointer: this._pointer,
            absolutePointer: this._absolutePointer,
            transform: this._currentTransform
          };
      if (eventType === 'up') {
        options.currentTarget = this.findTarget(e);
        options.currentSubTargets = this.targets;
      }
      this.fire('mouse:' + eventType, options);
      target && target.fire('mouse' + eventType, options);
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire('mouse' + eventType, options);
      }
    },

    /**
     * @private
     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
     */
    _finalizeCurrentTransform: function(e) {

      var transform = this._currentTransform,
          target = transform.target,
          eventName,
          options = {
            e: e,
            target: target,
            transform: transform,
            action: transform.action,
          };

      if (target._scaling) {
        target._scaling = false;
      }

      target.setCoords();

      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
        if (transform.actionPerformed) {
          // this is not friendly to the new control api.
          // is deprecated.
          eventName = this._addEventOptions(options, transform);
          this._fire(eventName, options);
        }
        this._fire('modified', options);
      }
    },

    /**
     * Mutate option object in order to add by property and give back the event name.
     * @private
     * @deprecated since 4.2.0
     * @param {Object} options to mutate
     * @param {Object} transform to inspect action from
     */
    _addEventOptions: function(options, transform) {
      // we can probably add more details at low cost
      // scale change, rotation changes, translation changes
      var eventName, by;
      switch (transform.action) {
        case 'scaleX':
          eventName = 'scaled';
          by = 'x';
          break;
        case 'scaleY':
          eventName = 'scaled';
          by = 'y';
          break;
        case 'skewX':
          eventName = 'skewed';
          by = 'x';
          break;
        case 'skewY':
          eventName = 'skewed';
          by = 'y';
          break;
        case 'scale':
          eventName = 'scaled';
          by = 'equally';
          break;
        case 'rotate':
          eventName = 'rotated';
          break;
        case 'drag':
          eventName = 'moved';
          break;
      }
      options.by = by;
      return eventName;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDownInDrawingMode: function(e) {
      this._isCurrentlyDrawing = true;
      if (this.getActiveObject()) {
        this.discardActiveObject(e).requestRenderAll();
      }
      var pointer = this.getPointer(e);
      this.freeDrawingBrush.onMouseDown(pointer, { e: e, pointer: pointer });
      this._handleEvent(e, 'down');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMoveInDrawingMode: function(e) {
      if (this._isCurrentlyDrawing) {
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseMove(pointer, { e: e, pointer: pointer });
      }
      this.setCursor(this.freeDrawingCursor);
      this._handleEvent(e, 'move');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUpInDrawingMode: function(e) {
      var pointer = this.getPointer(e);
      this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: e, pointer: pointer });
      this._handleEvent(e, 'up');
    },

    /**
     * Method that defines the actions when mouse is clicked on canvas.
     * The method inits the currentTransform parameters and renders all the
     * canvas so the current image can be placed on the top canvas and the rest
     * in on the container one.
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    __onMouseDown: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'down:before');
      var target = this._target;
      // if right click just fire events
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'down', RIGHT_CLICK);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'down', MIDDLE_CLICK);
        }
        return;
      }

      if (this.isDrawingMode) {
        this._onMouseDownInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }

      // ignore if some object is being transformed at this moment
      if (this._currentTransform) {
        return;
      }

      var pointer = this._pointer;
      // save pointer for check in __onMouseUp event
      this._previousPointer = pointer;
      var shouldRender = this._shouldRender(target),
          shouldGroup = this._shouldGroup(e, target);
      if (this._shouldClearSelection(e, target)) {
        this.discardActiveObject(e);
      }
      else if (shouldGroup) {
        this._handleGrouping(e, target);
        target = this._activeObject;
      }

      if (this.selection && (!target ||
        (!target.selectable && !target.isEditing && target !== this._activeObject))) {
        this._groupSelector = {
          ex: pointer.x,
          ey: pointer.y,
          top: 0,
          left: 0
        };
      }

      if (target) {
        var alreadySelected = target === this._activeObject;
        if (target.selectable) {
          this.setActiveObject(target, e);
        }
        var corner = target._findTargetCorner(
          this.getPointer(e, true),
          fabric.util.isTouchEvent(e)
        );
        target.__corner = corner;
        if (target === this._activeObject && (corner || !shouldGroup)) {
          this._setupCurrentTransform(e, target, alreadySelected);
          var control = target.controls[corner],
              pointer = this.getPointer(e),
              mouseDownHandler = control && control.getMouseDownHandler(e, target, control);
          if (mouseDownHandler) {
            mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);
          }
        }
      }
      this._handleEvent(e, 'down');
      // we must renderAll so that we update the visuals
      (shouldRender || shouldGroup) && this.requestRenderAll();
    },

    /**
     * reset cache form common information needed during event processing
     * @private
     */
    _resetTransformEventData: function() {
      this._target = null;
      this._pointer = null;
      this._absolutePointer = null;
    },

    /**
     * Cache common information needed during event processing
     * @private
     * @param {Event} e Event object fired on event
     */
    _cacheTransformEventData: function(e) {
      // reset in order to avoid stale caching
      this._resetTransformEventData();
      this._pointer = this.getPointer(e, true);
      this._absolutePointer = this.restorePointerVpt(this._pointer);
      this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;
    },

    /**
     * @private
     */
    _beforeTransform: function(e) {
      var t = this._currentTransform;
      this.stateful && t.target.saveState();
      this.fire('before:transform', {
        e: e,
        transform: t,
      });
    },

    /**
     * Method that defines the actions when mouse is hovering the canvas.
     * The currentTransform parameter will define whether the user is rotating/scaling/translating
     * an image or neither of them (only hovering). A group selection is also possible and would cancel
     * all any other type of action.
     * In case of an image transformation only the top canvas will be rendered.
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    __onMouseMove: function (e) {
      this._handleEvent(e, 'move:before');
      this._cacheTransformEventData(e);
      var target, pointer;

      if (this.isDrawingMode) {
        this._onMouseMoveInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }

      var groupSelector = this._groupSelector;

      // We initially clicked in an empty area, so we draw a box for multiple selection
      if (groupSelector) {
        pointer = this._pointer;

        groupSelector.left = pointer.x - groupSelector.ex;
        groupSelector.top = pointer.y - groupSelector.ey;

        this.renderTop();
      }
      else if (!this._currentTransform) {
        target = this.findTarget(e) || null;
        this._setCursorFromEvent(e, target);
        this._fireOverOutEvents(target, e);
      }
      else {
        this._transformObject(e);
      }
      this._handleEvent(e, 'move');
      this._resetTransformEventData();
    },

    /**
     * Manage the mouseout, mouseover events for the fabric object on the canvas
     * @param {Fabric.Object} target the target where the target from the mousemove event
     * @param {Event} e Event object fired on mousemove
     * @private
     */
    _fireOverOutEvents: function(target, e) {
      var _hoveredTarget = this._hoveredTarget,
          _hoveredTargets = this._hoveredTargets, targets = this.targets,
          length = Math.max(_hoveredTargets.length, targets.length);

      this.fireSyntheticInOutEvents(target, e, {
        oldTarget: _hoveredTarget,
        evtOut: 'mouseout',
        canvasEvtOut: 'mouse:out',
        evtIn: 'mouseover',
        canvasEvtIn: 'mouse:over',
      });
      for (var i = 0; i < length; i++){
        this.fireSyntheticInOutEvents(targets[i], e, {
          oldTarget: _hoveredTargets[i],
          evtOut: 'mouseout',
          evtIn: 'mouseover',
        });
      }
      this._hoveredTarget = target;
      this._hoveredTargets = this.targets.concat();
    },

    /**
     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the onDrag event
     * @param {Event} e Event object fired on ondrag
     * @private
     */
    _fireEnterLeaveEvents: function(target, e) {
      var _draggedoverTarget = this._draggedoverTarget,
          _hoveredTargets = this._hoveredTargets, targets = this.targets,
          length = Math.max(_hoveredTargets.length, targets.length);

      this.fireSyntheticInOutEvents(target, e, {
        oldTarget: _draggedoverTarget,
        evtOut: 'dragleave',
        evtIn: 'dragenter',
      });
      for (var i = 0; i < length; i++) {
        this.fireSyntheticInOutEvents(targets[i], e, {
          oldTarget: _hoveredTargets[i],
          evtOut: 'dragleave',
          evtIn: 'dragenter',
        });
      }
      this._draggedoverTarget = target;
    },

    /**
     * Manage the synthetic in/out events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the supported events
     * @param {Event} e Event object fired
     * @param {Object} config configuration for the function to work
     * @param {String} config.targetName property on the canvas where the old target is stored
     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
     * @param {String} config.evtOut name of the event to fire for out
     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
     * @param {String} config.evtIn name of the event to fire for in
     * @private
     */
    fireSyntheticInOutEvents: function(target, e, config) {
      var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires,
          targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
      if (targetChanged) {
        inOpt = { e: e, target: target, previousTarget: oldTarget };
        outOpt = { e: e, target: oldTarget, nextTarget: target };
      }
      inFires = target && targetChanged;
      outFires = oldTarget && targetChanged;
      if (outFires) {
        canvasEvtOut && this.fire(canvasEvtOut, outOpt);
        oldTarget.fire(config.evtOut, outOpt);
      }
      if (inFires) {
        canvasEvtIn && this.fire(canvasEvtIn, inOpt);
        target.fire(config.evtIn, inOpt);
      }
    },

    /**
     * Method that defines actions when an Event Mouse Wheel
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseWheel: function(e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'wheel');
      this._resetTransformEventData();
    },

    /**
     * @private
     * @param {Event} e Event fired on mousemove
     */
    _transformObject: function(e) {
      var pointer = this.getPointer(e),
          transform = this._currentTransform;

      transform.reset = false;
      transform.target.isMoving = true;
      transform.shiftKey = e.shiftKey;
      transform.altKey = e[this.centeredKey];

      this._performTransformAction(e, transform, pointer);
      transform.actionPerformed && this.requestRenderAll();
    },

    /**
     * @private
     */
    _performTransformAction: function(e, transform, pointer) {
      var x = pointer.x,
          y = pointer.y,
          action = transform.action,
          actionPerformed = false,
          actionHandler = transform.actionHandler;
          // this object could be created from the function in the control handlers


      if (actionHandler) {
        actionPerformed = actionHandler(e, transform, x, y);
      }
      if (action === 'drag' && actionPerformed) {
        this.setCursor(transform.target.moveCursor || this.moveCursor);
      }
      transform.actionPerformed = transform.actionPerformed || actionPerformed;
    },

    /**
     * @private
     */
    _fire: fabric.controlsUtils.fireEvent,

    /**
     * Sets the cursor depending on where the canvas is being hovered.
     * Note: very buggy in Opera
     * @param {Event} e Event object
     * @param {Object} target Object that the mouse is hovering, if so.
     */
    _setCursorFromEvent: function (e, target) {
      if (!target) {
        this.setCursor(this.defaultCursor);
        return false;
      }
      var hoverCursor = target.hoverCursor || this.hoverCursor,
          activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
            this._activeObject : null,
          // only show proper corner when group selection is not active
          corner = (!activeSelection || !activeSelection.contains(target))
          // here we call findTargetCorner always with undefined for the touch parameter.
          // we assume that if you are using a cursor you do not need to interact with
          // the bigger touch area.
                    && target._findTargetCorner(this.getPointer(e, true));

      if (!corner) {
        if (target.subTargetCheck){
          // hoverCursor should come from top-most subTarget,
          // so we walk the array backwards
          this.targets.concat().reverse().map(function(_target){
            hoverCursor = _target.hoverCursor || hoverCursor;
          });
        }
        this.setCursor(hoverCursor);
      }
      else {
        this.setCursor(this.getCornerCursor(corner, target, e));
      }
    },

    /**
     * @private
     */
    getCornerCursor: function(corner, target, e) {
      var control = target.controls[corner];
      return control.cursorStyleHandler(e, control, target);
    }
  });
})();


(function() {

  var min = Math.min,
      max = Math.max;

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     * @return {Boolean}
     */
    _shouldGroup: function(e, target) {
      var activeObject = this._activeObject;
      return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection &&
            (activeObject !== target || activeObject.type === 'activeSelection') && !target.onSelect({ e: e });
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _handleGrouping: function (e, target) {
      var activeObject = this._activeObject;
      // avoid multi select when shift click on a corner
      if (activeObject.__corner) {
        return;
      }
      if (target === activeObject) {
        // if it's a group, find target again, using activeGroup objects
        target = this.findTarget(e, true);
        // if even object is not found or we are on activeObjectCorner, bail out
        if (!target || !target.selectable) {
          return;
        }
      }
      if (activeObject && activeObject.type === 'activeSelection') {
        this._updateActiveSelection(target, e);
      }
      else {
        this._createActiveSelection(target, e);
      }
    },

    /**
     * @private
     */
    _updateActiveSelection: function(target, e) {
      var activeSelection = this._activeObject,
          currentActiveObjects = activeSelection._objects.slice(0);
      if (activeSelection.contains(target)) {
        activeSelection.removeWithUpdate(target);
        this._hoveredTarget = target;
        this._hoveredTargets = this.targets.concat();
        if (activeSelection.size() === 1) {
          // activate last remaining object
          this._setActiveObject(activeSelection.item(0), e);
        }
      }
      else {
        activeSelection.addWithUpdate(target);
        this._hoveredTarget = activeSelection;
        this._hoveredTargets = this.targets.concat();
      }
      this._fireSelectionEvents(currentActiveObjects, e);
    },

    /**
     * @private
     */
    _createActiveSelection: function(target, e) {
      var currentActives = this.getActiveObjects(), group = this._createGroup(target);
      this._hoveredTarget = group;
      // ISSUE 4115: should we consider subTargets here?
      // this._hoveredTargets = [];
      // this._hoveredTargets = this.targets.concat();
      this._setActiveObject(group, e);
      this._fireSelectionEvents(currentActives, e);
    },

    /**
     * @private
     * @param {Object} target
     */
    _createGroup: function(target) {
      var objects = this._objects,
          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
          groupObjects = isActiveLower
            ? [this._activeObject, target]
            : [target, this._activeObject];
      this._activeObject.isEditing && this._activeObject.exitEditing();
      return new fabric.ActiveSelection(groupObjects, {
        canvas: this
      });
    },

    /**
     * @private
     * @param {Event} e mouse event
     */
    _groupSelectedObjects: function (e) {

      var group = this._collectObjects(e),
          aGroup;

      // do not create group for 1 element only
      if (group.length === 1) {
        this.setActiveObject(group[0], e);
      }
      else if (group.length > 1) {
        aGroup = new fabric.ActiveSelection(group.reverse(), {
          canvas: this
        });
        this.setActiveObject(aGroup, e);
      }
    },

    /**
     * @private
     */
    _collectObjects: function(e) {
      var group = [],
          currentObject,
          x1 = this._groupSelector.ex,
          y1 = this._groupSelector.ey,
          x2 = x1 + this._groupSelector.left,
          y2 = y1 + this._groupSelector.top,
          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
          allowIntersect = !this.selectionFullyContained,
          isClick = x1 === x2 && y1 === y2;
      // we iterate reverse order to collect top first in case of click.
      for (var i = this._objects.length; i--; ) {
        currentObject = this._objects[i];

        if (!currentObject || !currentObject.selectable || !currentObject.visible) {
          continue;
        }

        if ((allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2)) ||
            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
            (allowIntersect && currentObject.containsPoint(selectionX1Y1)) ||
            (allowIntersect && currentObject.containsPoint(selectionX2Y2))
        ) {
          group.push(currentObject);
          // only add one object if it's a click
          if (isClick) {
            break;
          }
        }
      }

      if (group.length > 1) {
        group = group.filter(function(object) {
          return !object.onSelect({ e: e });
        });
      }

      return group;
    },

    /**
     * @private
     */
    _maybeGroupObjects: function(e) {
      if (this.selection && this._groupSelector) {
        this._groupSelectedObjects(e);
      }
      this.setCursor(this.defaultCursor);
      // clear selection and current transformation
      this._groupSelector = null;
    }
  });

})();


(function () {
  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
     * @param {Object} [options] Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
     * @example <caption>Generate jpeg dataURL with lower quality</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'jpeg',
     *   quality: 0.8
     * });
     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   left: 100,
     *   top: 100,
     *   width: 200,
     *   height: 200
     * });
     * @example <caption>Generate double scaled png dataURL</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   multiplier: 2
     * });
     */
    toDataURL: function (options) {
      options || (options = { });

      var format = options.format || 'png',
          quality = options.quality || 1,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1),
          canvasEl = this.toCanvasElement(multiplier, options);
      return fabric.util.toDataURL(canvasEl, format, quality);
    },

    /**
     * Create a new HTMLCanvas element painted with the current canvas content.
     * No need to resize the actual one or repaint it.
     * Will transfer object ownership to a new canvas, paint it, and set everything back.
     * This is an intermediary step used to get to a dataUrl but also it is useful to
     * create quick image copies of a canvas without passing for the dataUrl string
     * @param {Number} [multiplier] a zoom factor.
     * @param {Object} [cropping] Cropping informations
     * @param {Number} [cropping.left] Cropping left offset.
     * @param {Number} [cropping.top] Cropping top offset.
     * @param {Number} [cropping.width] Cropping width.
     * @param {Number} [cropping.height] Cropping height.
     */
    toCanvasElement: function(multiplier, cropping) {
      multiplier = multiplier || 1;
      cropping = cropping || { };
      var scaledWidth = (cropping.width || this.width) * multiplier,
          scaledHeight = (cropping.height || this.height) * multiplier,
          zoom = this.getZoom(),
          originalWidth = this.width,
          originalHeight = this.height,
          newZoom = zoom * multiplier,
          vp = this.viewportTransform,
          translateX = (vp[4] - (cropping.left || 0)) * multiplier,
          translateY = (vp[5] - (cropping.top || 0)) * multiplier,
          originalInteractive = this.interactive,
          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
          originalRetina = this.enableRetinaScaling,
          canvasEl = fabric.util.createCanvasElement(),
          originalContextTop = this.contextTop;
      canvasEl.width = scaledWidth;
      canvasEl.height = scaledHeight;
      this.contextTop = null;
      this.enableRetinaScaling = false;
      this.interactive = false;
      this.viewportTransform = newVp;
      this.width = scaledWidth;
      this.height = scaledHeight;
      this.calcViewportBoundaries();
      this.renderCanvas(canvasEl.getContext('2d'), this._objects);
      this.viewportTransform = vp;
      this.width = originalWidth;
      this.height = originalHeight;
      this.calcViewportBoundaries();
      this.interactive = originalInteractive;
      this.enableRetinaScaling = originalRetina;
      this.contextTop = originalContextTop;
      return canvasEl;
    },
  });

})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
  /**
   * Populates canvas with data from the specified JSON.
   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
   * @param {String|Object} json JSON string or object
   * @param {Function} callback Callback, invoked when json is parsed
   *                            and corresponding objects (e.g: {@link fabric.Image})
   *                            are initialized
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
   * @return {fabric.Canvas} instance
   * @chainable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
   * @example <caption>loadFromJSON</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
   * @example <caption>loadFromJSON with reviver</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
   *   // `o` = json object
   *   // `object` = fabric.Object instance
   *   // ... do some stuff ...
   * });
   */
  loadFromJSON: function (json, callback, reviver) {
    if (!json) {
      return;
    }

    // serialize if it wasn't already
    var serialized = (typeof json === 'string')
      ? JSON.parse(json)
      : fabric.util.object.clone(json);

    var _this = this,
        clipPath = serialized.clipPath,
        renderOnAddRemove = this.renderOnAddRemove;

    this.renderOnAddRemove = false;

    delete serialized.clipPath;

    this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
      _this.clear();
      _this._setBgOverlay(serialized, function () {
        if (clipPath) {
          _this._enlivenObjects([clipPath], function (enlivenedCanvasClip) {
            _this.clipPath = enlivenedCanvasClip[0];
            _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
          });
        }
        else {
          _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
        }
      });
    }, reviver);
    return this;
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Array} restored canvas objects
   * @param {Function} cached renderOnAddRemove callback
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {
    var _this = this;
    enlivenedObjects.forEach(function(obj, index) {
      // we splice the array just in case some custom classes restored from JSON
      // will add more object to canvas at canvas init.
      _this.insertAt(obj, index);
    });
    this.renderOnAddRemove = renderOnAddRemove;
    // remove parts i cannot set as options
    delete serialized.objects;
    delete serialized.backgroundImage;
    delete serialized.overlayImage;
    delete serialized.background;
    delete serialized.overlay;
    // this._initOptions does too many things to just
    // call it. Normally loading an Object from JSON
    // create the Object instance. Here the Canvas is
    // already an instance and we are just loading things over it
    this._setOptions(serialized);
    this.renderAll();
    callback && callback();
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  _setBgOverlay: function(serialized, callback) {
    var loaded = {
      backgroundColor: false,
      overlayColor: false,
      backgroundImage: false,
      overlayImage: false
    };

    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
      callback && callback();
      return;
    }

    var cbIfLoaded = function () {
      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
        callback && callback();
      }
    };

    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
  },

  /**
   * @private
   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
   * @param {(Object|String)} value Value to set
   * @param {Object} loaded Set loaded property to true if property is set
   * @param {Object} callback Callback function to invoke after property is set
   */
  __setBgOverlay: function(property, value, loaded, callback) {
    var _this = this;

    if (!value) {
      loaded[property] = true;
      callback && callback();
      return;
    }

    if (property === 'backgroundImage' || property === 'overlayImage') {
      fabric.util.enlivenObjects([value], function(enlivedObject){
        _this[property] = enlivedObject[0];
        loaded[property] = true;
        callback && callback();
      });
    }
    else {
      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
        loaded[property] = true;
        callback && callback();
      });
    }
  },

  /**
   * @private
   * @param {Array} objects
   * @param {Function} callback
   * @param {Function} [reviver]
   */
  _enlivenObjects: function (objects, callback, reviver) {
    if (!objects || objects.length === 0) {
      callback && callback([]);
      return;
    }

    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
      callback && callback(enlivenedObjects);
    }, null, reviver);
  },

  /**
   * @private
   * @param {String} format
   * @param {Function} callback
   */
  _toDataURL: function (format, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURL(format));
    });
  },

  /**
   * @private
   * @param {String} format
   * @param {Number} multiplier
   * @param {Function} callback
   */
  _toDataURLWithMultiplier: function (format, multiplier, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURLWithMultiplier(format, multiplier));
    });
  },

  /**
   * Clones canvas instance
   * @param {Object} [callback] Receives cloned instance as a first argument
   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
   */
  clone: function (callback, properties) {
    var data = JSON.stringify(this.toJSON(properties));
    this.cloneWithoutData(function(clone) {
      clone.loadFromJSON(data, function() {
        callback && callback(clone);
      });
    });
  },

  /**
   * Clones canvas instance without cloning existing data.
   * This essentially copies canvas dimensions, clipping properties, etc.
   * but leaves data empty (so that you can populate it with your own)
   * @param {Object} [callback] Receives cloned instance as a first argument
   */
  cloneWithoutData: function(callback) {
    var el = fabric.util.createCanvasElement();

    el.width = this.width;
    el.height = this.height;

    var clone = new fabric.Canvas(el);
    if (this.backgroundImage) {
      clone.setBackgroundImage(this.backgroundImage.src, function() {
        clone.renderAll();
        callback && callback(clone);
      });
      clone.backgroundImageOpacity = this.backgroundImageOpacity;
      clone.backgroundImageStretch = this.backgroundImageStretch;
    }
    else {
      callback && callback(clone);
    }
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      capitalize = fabric.util.string.capitalize,
      degreesToRadians = fabric.util.degreesToRadians,
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
      objectCaching = !fabric.isLikelyNode,
      ALIASING_LIMIT = 2;

  if (fabric.Object) {
    return;
  }

  /**
   * Root object class from which all 2d shape classes inherit from
   * @class fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
   * @see {@link fabric.Object#initialize} for constructor definition
   *
   * @fires added
   * @fires removed
   *
   * @fires selected
   * @fires deselected
   * @fires modified
   * @fires modified
   * @fires moved
   * @fires scaled
   * @fires rotated
   * @fires skewed
   *
   * @fires rotating
   * @fires scaling
   * @fires moving
   * @fires skewing
   *
   * @fires mousedown
   * @fires mouseup
   * @fires mouseover
   * @fires mouseout
   * @fires mousewheel
   * @fires mousedblclick
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop
   */
  fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

    /**
     * Type of an object (rect, circle, path, etc.).
     * Note that this property is meant to be read-only and not meant to be modified.
     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
     * @type String
     * @default
     */
    type:                     'object',

    /**
     * Horizontal origin of transformation of an object (one of "left", "right", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originX:                  'left',

    /**
     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originY:                  'top',

    /**
     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
     * @type Number
     * @default
     */
    top:                      0,

    /**
     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
     * @type Number
     * @default
     */
    left:                     0,

    /**
     * Object width
     * @type Number
     * @default
     */
    width:                    0,

    /**
     * Object height
     * @type Number
     * @default
     */
    height:                   0,

    /**
     * Object scale factor (horizontal)
     * @type Number
     * @default
     */
    scaleX:                   1,

    /**
     * Object scale factor (vertical)
     * @type Number
     * @default
     */
    scaleY:                   1,

    /**
     * When true, an object is rendered as flipped horizontally
     * @type Boolean
     * @default
     */
    flipX:                    false,

    /**
     * When true, an object is rendered as flipped vertically
     * @type Boolean
     * @default
     */
    flipY:                    false,

    /**
     * Opacity of an object
     * @type Number
     * @default
     */
    opacity:                  1,

    /**
     * Angle of rotation of an object (in degrees)
     * @type Number
     * @default
     */
    angle:                    0,

    /**
     * Angle of skew on x axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewX:                    0,

    /**
     * Angle of skew on y axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewY:                    0,

    /**
     * Size of object's controlling corners (in pixels)
     * @type Number
     * @default
     */
    cornerSize:               13,

    /**
     * Size of object's controlling corners when touch interaction is detected
     * @type Number
     * @default
     */
    touchCornerSize:               24,

    /**
     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
     * @type Boolean
     * @default
     */
    transparentCorners:       true,

    /**
     * Default cursor value used when hovering over this object on canvas
     * @type String
     * @default
     */
    hoverCursor:              null,

    /**
     * Default cursor value used when moving this object on canvas
     * @type String
     * @default
     */
    moveCursor:               null,

    /**
     * Padding between object and its controlling borders (in pixels)
     * @type Number
     * @default
     */
    padding:                  0,

    /**
     * Color of controlling borders of an object (when it's active)
     * @type String
     * @default
     */
    borderColor:              'rgb(178,204,255)',

    /**
     * Array specifying dash pattern of an object's borders (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    borderDashArray:          null,

    /**
     * Color of controlling corners of an object (when it's active)
     * @type String
     * @default
     */
    cornerColor:              'rgb(178,204,255)',

    /**
     * Color of controlling corners of an object (when it's active and transparentCorners false)
     * @since 1.6.2
     * @type String
     * @default
     */
    cornerStrokeColor:        null,

    /**
     * Specify style of control, 'rect' or 'circle'
     * @since 1.6.2
     * @type String
     */
    cornerStyle:          'rect',

    /**
     * Array specifying dash pattern of an object's control (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    cornerDashArray:          null,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being scaled via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:          false,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being rotated via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:         true,

    /**
     * Color of object's fill
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    fill:                     'rgb(0,0,0)',

    /**
     * Fill rule used to fill an object
     * accepted values are nonzero, evenodd
     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
     * @type String
     * @default
     */
    fillRule:                 'nonzero',

    /**
     * Composite rule used for canvas globalCompositeOperation
     * @type String
     * @default
     */
    globalCompositeOperation: 'source-over',

    /**
     * Background color of an object.
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    backgroundColor:          '',

    /**
     * Selection Background color of an object. colored layer behind the object when it is active.
     * does not mix good with globalCompositeOperation methods.
     * @type String
     * @default
     */
    selectionBackgroundColor:          '',

    /**
     * When defined, an object is rendered via stroke and this property specifies its color
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    stroke:                   null,

    /**
     * Width of a stroke used to render this object
     * @type Number
     * @default
     */
    strokeWidth:              1,

    /**
     * Array specifying dash pattern of an object's stroke (stroke must be defined)
     * @type Array
     */
    strokeDashArray:          null,

    /**
     * Line offset of an object's stroke
     * @type Number
     * @default
     */
    strokeDashOffset: 0,

    /**
     * Line endings style of an object's stroke (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap:            'butt',

    /**
     * Corner style of an object's stroke (one of "bevel", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin:           'miter',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
     * @type Number
     * @default
     */
    strokeMiterLimit:         4,

    /**
     * Shadow object representing shadow of this shape
     * @type fabric.Shadow
     * @default
     */
    shadow:                   null,

    /**
     * Opacity of object's controlling borders when object is active and moving
     * @type Number
     * @default
     */
    borderOpacityWhenMoving:  0.4,

    /**
     * Scale factor of object's controlling borders
     * bigger number will make a thicker border
     * border is 1, so this is basically a border thickness
     * since there is no way to change the border itself.
     * @type Number
     * @default
     */
    borderScaleFactor:        1,

    /**
     * Minimum allowed scale value of an object
     * @type Number
     * @default
     */
    minScaleLimit:            0,

    /**
     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
     * But events still fire on it.
     * @type Boolean
     * @default
     */
    selectable:               true,

    /**
     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
     * @type Boolean
     * @default
     */
    evented:                  true,

    /**
     * When set to `false`, an object is not rendered on canvas
     * @type Boolean
     * @default
     */
    visible:                  true,

    /**
     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
     * @type Boolean
     * @default
     */
    hasControls:              true,

    /**
     * When set to `false`, object's controlling borders are not rendered
     * @type Boolean
     * @default
     */
    hasBorders:               true,

    /**
     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:       false,

    /**
     * When `false`, default object's values are not included in its serialization
     * @type Boolean
     * @default
     */
    includeDefaultValues:     true,

    /**
     * When `true`, object horizontal movement is locked
     * @type Boolean
     * @default
     */
    lockMovementX:            false,

    /**
     * When `true`, object vertical movement is locked
     * @type Boolean
     * @default
     */
    lockMovementY:            false,

    /**
     * When `true`, object rotation is locked
     * @type Boolean
     * @default
     */
    lockRotation:             false,

    /**
     * When `true`, object horizontal scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingX:             false,

    /**
     * When `true`, object vertical scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingY:             false,

    /**
     * When `true`, object horizontal skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingX:             false,

    /**
     * When `true`, object vertical skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingY:             false,

    /**
     * When `true`, object cannot be flipped by scaling into negative values
     * @type Boolean
     * @default
     */
    lockScalingFlip:          false,

    /**
     * When `true`, object is not exported in OBJECT/JSON
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    excludeFromExport:        false,

    /**
     * When `true`, object is cached on an additional canvas.
     * When `false`, object is not cached unless necessary ( clipPath )
     * default to true
     * @since 1.7.0
     * @type Boolean
     * @default true
     */
    objectCaching:            objectCaching,

    /**
     * When `true`, object properties are checked for cache invalidation. In some particular
     * situation you may want this to be disabled ( spray brush, very big, groups)
     * or if your application does not allow you to modify properties for groups child you want
     * to disable it for groups.
     * default to false
     * since 1.7.0
     * @type Boolean
     * @default false
     */
    statefullCache:            false,

    /**
     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
     * too much and will be redrawn with correct details at the end of scaling.
     * this setting is performance and application dependant.
     * default to true
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    noScaleCache:              true,

    /**
     * When `false`, the stoke width will scale with the object.
     * When `true`, the stroke will always match the exact pixel size entered for stroke width.
     * default to false
     * @since 2.6.0
     * @type Boolean
     * @default false
     * @type Boolean
     * @default false
     */
    strokeUniform:              false,

    /**
     * When set to `true`, object's cache will be rerendered next render call.
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    dirty:                true,

    /**
     * keeps the value of the last hovered corner during mouse move.
     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
     * It should be private, but there is no harm in using it as
     * a read-only property.
     * @type number|string|any
     * @default 0
     */
    __corner: 0,

    /**
     * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
     * @type String
     * @default
     */
    paintFirst:           'fill',

    /**
     * List of properties to consider when checking if state
     * of an object is changed (fabric.Object#hasStateChanged)
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: (
      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
      'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit ' +
      'angle opacity fill globalCompositeOperation shadow visible backgroundColor ' +
      'skewX skewY fillRule paintFirst clipPath strokeUniform'
    ).split(' '),

    /**
     * List of properties to consider when checking if cache needs refresh
     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
     * and refreshed at the next render
     * @type Array
     */
    cacheProperties: (
      'fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform' +
      ' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath'
    ).split(' '),

    /**
     * List of properties to consider for animating colors.
     * @type Array
     */
    colorProperties: (
      'fill stroke backgroundColor'
    ).split(' '),

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the object has rendered, and the context is placed in the center
     * of the object cacheCanvas.
     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will make the object clip to the outside of the clipPath
     * since 2.4.0
     * @type boolean
     * @default false
     */
    inverted: false,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will have its top and left relative to canvas, and will
     * not be influenced by the object transform. This will make the clipPath relative
     * to the canvas, but clipping just a particular object.
     * WARNING this is beta, this feature may change or be renamed.
     * since 2.4.0
     * @type boolean
     * @default false
     */
    absolutePositioned: false,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Create a the canvas used to keep the cached copy of the object
     * @private
     */
    _createCacheCanvas: function() {
      this._cacheProperties = {};
      this._cacheCanvas = fabric.util.createCanvasElement();
      this._cacheContext = this._cacheCanvas.getContext('2d');
      this._updateCacheCanvas();
      // if canvas gets created, is empty, so dirty.
      this.dirty = true;
    },

    /**
     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
     * and each side do not cross fabric.cacheSideLimit
     * those numbers are configurable so that you can get as much detail as you want
     * making bargain with performances.
     * @param {Object} dims
     * @param {Object} dims.width width of canvas
     * @param {Object} dims.height height of canvas
     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _limitCacheSize: function(dims) {
      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
          width = dims.width, height = dims.height,
          max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
      if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
        if (width < min) {
          dims.width = min;
        }
        if (height < min) {
          dims.height = min;
        }
        return dims;
      }
      var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
          capValue = fabric.util.capValue,
          x = capValue(min, limitedDims.x, max),
          y = capValue(min, limitedDims.y, max);
      if (width > x) {
        dims.zoomX /= width / x;
        dims.width = x;
        dims.capped = true;
      }
      if (height > y) {
        dims.zoomY /= height / y;
        dims.height = y;
        dims.capped = true;
      }
      return dims;
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @return {Object}.x width of object to be cached
     * @return {Object}.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var objectScale = this.getTotalObjectScaling(),
          // caculate dimensions without skewing
          dim = this._getTransformedDimensions(0, 0),
          neededX = dim.x * objectScale.scaleX / this.scaleX,
          neededY = dim.y * objectScale.scaleY / this.scaleY;
      return {
        // for sure this ALIASING_LIMIT is slightly creating problem
        // in situation in which the cache canvas gets an upper limit
        // also objectScale contains already scaleX and scaleY
        width: neededX + ALIASING_LIMIT,
        height: neededY + ALIASING_LIMIT,
        zoomX: objectScale.scaleX,
        zoomY: objectScale.scaleY,
        x: neededX,
        y: neededY
      };
    },

    /**
     * Update width and height of the canvas for cache
     * returns true or false if canvas needed resize.
     * @private
     * @return {Boolean} true if the canvas has been resized
     */
    _updateCacheCanvas: function() {
      var targetCanvas = this.canvas;
      if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
        var target = targetCanvas._currentTransform.target,
            action = targetCanvas._currentTransform.action;
        if (this === target && action.slice && action.slice(0, 5) === 'scale') {
          return false;
        }
      }
      var canvas = this._cacheCanvas,
          dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          minCacheSize = fabric.minCacheSideLimit,
          width = dims.width, height = dims.height, drawingWidth, drawingHeight,
          zoomX = dims.zoomX, zoomY = dims.zoomY,
          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
          shouldRedraw = dimensionsChanged || zoomChanged,
          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
      if (dimensionsChanged) {
        var canvasWidth = this._cacheCanvas.width,
            canvasHeight = this._cacheCanvas.height,
            sizeGrowing = width > canvasWidth || height > canvasHeight,
            sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
              canvasWidth > minCacheSize && canvasHeight > minCacheSize;
        shouldResizeCanvas = sizeGrowing || sizeShrinking;
        if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
          additionalWidth = width * 0.1;
          additionalHeight = height * 0.1;
        }
      }
      if (shouldRedraw) {
        if (shouldResizeCanvas) {
          canvas.width = Math.ceil(width + additionalWidth);
          canvas.height = Math.ceil(height + additionalHeight);
        }
        else {
          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
          this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
        }
        drawingWidth = dims.x / 2;
        drawingHeight = dims.y / 2;
        this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
        this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
        this.cacheWidth = width;
        this.cacheHeight = height;
        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
        this._cacheContext.scale(zoomX, zoomY);
        this.zoomX = zoomX;
        this.zoomY = zoomY;
        return true;
      }
      return false;
    },

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      this._setOptions(options);
      this._initGradient(options.fill, 'fill');
      this._initGradient(options.stroke, 'stroke');
      this._initPattern(options.fill, 'fill');
      this._initPattern(options.stroke, 'stroke');
    },

    /**
     * Transforms context when rendering an object
     * @param {CanvasRenderingContext2D} ctx Context
     */
    transform: function(ctx) {
      var needFullTransform = (this.group && !this.group._transformDone) ||
         (this.group && this.canvas && ctx === this.canvas.contextTop);
      var m = this.calcTransformMatrix(!needFullTransform);
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    },

    /**
     * Returns an object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

          object = {
            type:                     this.type,
            version:                  fabric.version,
            originX:                  this.originX,
            originY:                  this.originY,
            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
            strokeLineCap:            this.strokeLineCap,
            strokeDashOffset:         this.strokeDashOffset,
            strokeLineJoin:           this.strokeLineJoin,
            strokeUniform:            this.strokeUniform,
            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
            flipX:                    this.flipX,
            flipY:                    this.flipY,
            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
            visible:                  this.visible,
            backgroundColor:          this.backgroundColor,
            fillRule:                 this.fillRule,
            paintFirst:               this.paintFirst,
            globalCompositeOperation: this.globalCompositeOperation,
            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS),
          };

      if (this.clipPath) {
        object.clipPath = this.clipPath.toObject(propertiesToInclude);
        object.clipPath.inverted = this.clipPath.inverted;
        object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
      }

      fabric.util.populateWithProperties(this, object, propertiesToInclude);
      if (!this.includeDefaultValues) {
        object = this._removeDefaultValues(object);
      }

      return object;
    },

    /**
     * Returns (dataless) object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      // will be overwritten by subclasses
      return this.toObject(propertiesToInclude);
    },

    /**
     * @private
     * @param {Object} object
     */
    _removeDefaultValues: function(object) {
      var prototype = fabric.util.getKlass(object.type).prototype,
          stateProperties = prototype.stateProperties;
      stateProperties.forEach(function(prop) {
        if (prop === 'left' || prop === 'top') {
          return;
        }
        if (object[prop] === prototype[prop]) {
          delete object[prop];
        }
        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';

        // basically a check for [] === []
        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
          delete object[prop];
        }
      });

      return object;
    },

    /**
     * Returns a string representation of an instance
     * @return {String}
     */
    toString: function() {
      return '#<fabric.' + capitalize(this.type) + '>';
    },

    /**
     * Return the object scale factor counting also the group scaling
     * @return {Object} object with scaleX and scaleY properties
     */
    getObjectScaling: function() {
      var options = fabric.util.qrDecompose(this.calcTransformMatrix());
      return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
    },

    /**
     * Return the object scale factor counting also the group scaling, zoom and retina
     * @return {Object} object with scaleX and scaleY properties
     */
    getTotalObjectScaling: function() {
      var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
      if (this.canvas) {
        var zoom = this.canvas.getZoom();
        var retina = this.canvas.getRetinaScaling();
        scaleX *= zoom * retina;
        scaleY *= zoom * retina;
      }
      return { scaleX: scaleX, scaleY: scaleY };
    },

    /**
     * Return the object opacity counting also the group property
     * @return {Number}
     */
    getObjectOpacity: function() {
      var opacity = this.opacity;
      if (this.group) {
        opacity *= this.group.getObjectOpacity();
      }
      return opacity;
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Object} thisArg
     */
    _set: function(key, value) {
      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
          isChanged = this[key] !== value, groupNeedsUpdate = false;

      if (shouldConstrainValue) {
        value = this._constrainScale(value);
      }
      if (key === 'scaleX' && value < 0) {
        this.flipX = !this.flipX;
        value *= -1;
      }
      else if (key === 'scaleY' && value < 0) {
        this.flipY = !this.flipY;
        value *= -1;
      }
      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
        value = new fabric.Shadow(value);
      }
      else if (key === 'dirty' && this.group) {
        this.group.set('dirty', value);
      }

      this[key] = value;

      if (isChanged) {
        groupNeedsUpdate = this.group && this.group.isOnACache();
        if (this.cacheProperties.indexOf(key) > -1) {
          this.dirty = true;
          groupNeedsUpdate && this.group.set('dirty', true);
        }
        else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
          this.group.set('dirty', true);
        }
      }
      return this;
    },

    /**
     * This callback function is called by the parent group of an object every
     * time a non-delegated property changes on the group. It is passed the key
     * and value as parameters. Not adding in this function's signature to avoid
     * Travis build error about unused variables.
     */
    setOnGroup: function() {
      // implemented by sub-classes, as needed.
    },

    /**
     * Retrieves viewportTransform from Object's canvas if possible
     * @method getViewportTransform
     * @memberOf fabric.Object.prototype
     * @return {Array}
     */
    getViewportTransform: function() {
      if (this.canvas && this.canvas.viewportTransform) {
        return this.canvas.viewportTransform;
      }
      return fabric.iMatrix.concat();
    },

    /*
     * @private
     * return if the object would be visible in rendering
     * @memberOf fabric.Object.prototype
     * @return {Boolean}
     */
    isNotVisible: function() {
      return this.opacity === 0 ||
        (!this.width && !this.height && this.strokeWidth === 0) ||
        !this.visible;
    },

    /**
     * Renders an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if width/height are zeros or object is not visible
      if (this.isNotVisible()) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      ctx.save();
      this._setupCompositeOperation(ctx);
      this.drawSelectionBackground(ctx);
      this.transform(ctx);
      this._setOpacity(ctx);
      this._setShadow(ctx, this);
      if (this.shouldCache()) {
        this.renderCache();
        this.drawCacheOnCanvas(ctx);
      }
      else {
        this._removeCacheCanvas();
        this.dirty = false;
        this.drawObject(ctx);
        if (this.objectCaching && this.statefullCache) {
          this.saveState({ propertySet: 'cacheProperties' });
        }
      }
      ctx.restore();
    },

    renderCache: function(options) {
      options = options || {};
      if (!this._cacheCanvas) {
        this._createCacheCanvas();
      }
      if (this.isCacheDirty()) {
        this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
        this.drawObject(this._cacheContext, options.forClipping);
        this.dirty = false;
      }
    },

    /**
     * Remove cacheCanvas and its dimensions from the objects
     */
    _removeCacheCanvas: function() {
      this._cacheCanvas = null;
      this.cacheWidth = 0;
      this.cacheHeight = 0;
    },

    /**
     * return true if the object will draw a stroke
     * Does not consider text styles. This is just a shortcut used at rendering time
     * We want it to be an approximation and be fast.
     * wrote to avoid extra caching, it has to return true when stroke happens,
     * can guess when it will not happen at 100% chance, does not matter if it misses
     * some use case where the stroke is invisible.
     * @since 3.0.0
     * @returns Boolean
     */
    hasStroke: function() {
      return this.stroke && this.stroke !== 'transparent' && this.strokeWidth !== 0;
    },

    /**
     * return true if the object will draw a fill
     * Does not consider text styles. This is just a shortcut used at rendering time
     * We want it to be an approximation and be fast.
     * wrote to avoid extra caching, it has to return true when fill happens,
     * can guess when it will not happen at 100% chance, does not matter if it misses
     * some use case where the fill is invisible.
     * @since 3.0.0
     * @returns Boolean
     */
    hasFill: function() {
      return this.fill && this.fill !== 'transparent';
    },

    /**
     * When set to `true`, force the object to have its own cache, even if it is inside a group
     * it may be needed when your object behave in a particular way on the cache and always needs
     * its own isolated canvas to render correctly.
     * Created to be overridden
     * since 1.7.12
     * @returns Boolean
     */
    needsItsOwnCache: function() {
      if (this.paintFirst === 'stroke' &&
        this.hasFill() && this.hasStroke() && typeof this.shadow === 'object') {
        return true;
      }
      if (this.clipPath) {
        return true;
      }
      return false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
     * @return {Boolean}
     */
    shouldCache: function() {
      this.ownCaching = this.needsItsOwnCache() || (
        this.objectCaching &&
        (!this.group || !this.group.isOnACache())
      );
      return this.ownCaching;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * used by Group.shouldCache to know if child has a shadow recursively
     * @return {Boolean}
     */
    willDrawShadow: function() {
      return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
    },

    /**
     * Execute the drawing operation for an object clipPath
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawClipPathOnCache: function(ctx) {
      var path = this.clipPath;
      ctx.save();
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4
      if (path.inverted) {
        ctx.globalCompositeOperation = 'destination-out';
      }
      else {
        ctx.globalCompositeOperation = 'destination-in';
      }
      //ctx.scale(1 / 2, 1 / 2);
      if (path.absolutePositioned) {
        var m = fabric.util.invertTransform(this.calcTransformMatrix());
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }
      path.transform(ctx);
      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
      ctx.restore();
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx, forClipping) {
      var originalFill = this.fill, originalStroke = this.stroke;
      if (forClipping) {
        this.fill = 'black';
        this.stroke = '';
        this._setClippingProperties(ctx);
      }
      else {
        this._renderBackground(ctx);
      }
      this._render(ctx);
      this._drawClipPath(ctx);
      this.fill = originalFill;
      this.stroke = originalStroke;
    },

    _drawClipPath: function(ctx) {
      var path = this.clipPath;
      if (!path) { return; }
      // needed to setup a couple of variables
      // path canvas gets overridden with this one.
      // TODO find a better solution?
      path.canvas = this.canvas;
      path.shouldCache();
      path._transformDone = true;
      path.renderCache({ forClipping: true });
      this.drawClipPathOnCache(ctx);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
    },

    /**
     * Check if cache is dirty
     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
     * on parent canvas.
     */
    isCacheDirty: function(skipCanvas) {
      if (this.isNotVisible()) {
        return false;
      }
      if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
        // in this case the context is already cleared.
        return true;
      }
      else {
        if (this.dirty ||
          (this.clipPath && this.clipPath.absolutePositioned) ||
          (this.statefullCache && this.hasStateChanged('cacheProperties'))
        ) {
          if (this._cacheCanvas && !skipCanvas) {
            var width = this.cacheWidth / this.zoomX;
            var height = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Draws a background for the object big as its untransformed dimensions
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      if (!this.backgroundColor) {
        return;
      }
      var dim = this._getNonTransformedDimensions();
      ctx.fillStyle = this.backgroundColor;

      ctx.fillRect(
        -dim.x / 2,
        -dim.y / 2,
        dim.x,
        dim.y
      );
      // if there is background color no other shadows
      // should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setOpacity: function(ctx) {
      if (this.group && !this.group._transformDone) {
        ctx.globalAlpha = this.getObjectOpacity();
      }
      else {
        ctx.globalAlpha *= this.opacity;
      }
    },

    _setStrokeStyles: function(ctx, decl) {
      var stroke = decl.stroke;
      if (stroke) {
        ctx.lineWidth = decl.strokeWidth;
        ctx.lineCap = decl.strokeLineCap;
        ctx.lineDashOffset = decl.strokeDashOffset;
        ctx.lineJoin = decl.strokeLineJoin;
        ctx.miterLimit = decl.strokeMiterLimit;
        if (stroke.toLive) {
          if (stroke.gradientUnits === 'percentage' || stroke.gradientTrasnform || stroke.patternTransform) {
            // need to transform gradient in a pattern.
            // this is a slow process. If you are hitting this codepath, and the object
            // is not using caching, you should consider switching it on.
            // we need a canvas as big as the current object caching canvas.
            this._applyPatternForTransformedGradient(ctx, stroke);
          }
          else {
            // is a simple gradient or pattern
            ctx.strokeStyle = stroke.toLive(ctx, this);
            this._applyPatternGradientTransform(ctx, stroke);
          }
        }
        else {
          // is a color
          ctx.strokeStyle = decl.stroke;
        }
      }
    },

    _setFillStyles: function(ctx, decl) {
      var fill = decl.fill;
      if (fill) {
        if (fill.toLive) {
          ctx.fillStyle = fill.toLive(ctx, this);
          this._applyPatternGradientTransform(ctx, decl.fill);
        }
        else {
          ctx.fillStyle = fill;
        }
      }
    },

    _setClippingProperties: function(ctx) {
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'transparent';
      ctx.fillStyle = '#000000';
    },

    /**
     * @private
     * Sets line dash
     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
     * @param {Array} dashArray array representing dashes
     * @param {Function} alternative function to call if browser does not support lineDash
     */
    _setLineDash: function(ctx, dashArray, alternative) {
      if (!dashArray || dashArray.length === 0) {
        return;
      }
      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
      if (1 & dashArray.length) {
        dashArray.push.apply(dashArray, dashArray);
      }
      if (supportsLineDash) {
        ctx.setLineDash(dashArray);
      }
      else {
        alternative && alternative(ctx);
      }
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     */
    _renderControls: function(ctx, styleOverride) {
      var vpt = this.getViewportTransform(),
          matrix = this.calcTransformMatrix(),
          options, drawBorders, drawControls;
      styleOverride = styleOverride || { };
      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
      options = fabric.util.qrDecompose(matrix);
      ctx.save();
      ctx.translate(options.translateX, options.translateY);
      ctx.lineWidth = 1 * this.borderScaleFactor;
      if (!this.group) {
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      }
      if (styleOverride.forActiveSelection) {
        ctx.rotate(degreesToRadians(options.angle));
        drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
      }
      else {
        ctx.rotate(degreesToRadians(this.angle));
        drawBorders && this.drawBorders(ctx, styleOverride);
      }
      drawControls && this.drawControls(ctx, styleOverride);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      var shadow = this.shadow, canvas = this.canvas, scaling,
          multX = (canvas && canvas.viewportTransform[0]) || 1,
          multY = (canvas && canvas.viewportTransform[3]) || 1;
      if (shadow.nonScaling) {
        scaling = { scaleX: 1, scaleY: 1 };
      }
      else {
        scaling = this.getObjectScaling();
      }
      if (canvas && canvas._isRetinaScaling()) {
        multX *= fabric.devicePixelRatio;
        multY *= fabric.devicePixelRatio;
      }
      ctx.shadowColor = shadow.color;
      ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant *
        (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
      ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
      ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _removeShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} filler fabric.Pattern or fabric.Gradient
     * @return {Object} offset.offsetX offset for text rendering
     * @return {Object} offset.offsetY offset for text rendering
     */
    _applyPatternGradientTransform: function(ctx, filler) {
      if (!filler || !filler.toLive) {
        return { offsetX: 0, offsetY: 0 };
      }
      var t = filler.gradientTransform || filler.patternTransform;
      var offsetX = -this.width / 2 + filler.offsetX || 0,
          offsetY = -this.height / 2 + filler.offsetY || 0;

      if (filler.gradientUnits === 'percentage') {
        ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
      }
      else {
        ctx.transform(1, 0, 0, 1, offsetX, offsetY);
      }
      if (t) {
        ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
      }
      return { offsetX: offsetX, offsetY: offsetY };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderPaintInOrder: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderStroke(ctx);
        this._renderFill(ctx);
      }
      else {
        this._renderFill(ctx);
        this._renderStroke(ctx);
      }
    },

    /**
     * @private
     * function that actually render something on the context.
     * empty here to allow Obects to work on tests to benchmark fabric functionalites
     * not related to rendering
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(/* ctx */) {

    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderFill: function(ctx) {
      if (!this.fill) {
        return;
      }

      ctx.save();
      this._setFillStyles(ctx, this);
      if (this.fillRule === 'evenodd') {
        ctx.fill('evenodd');
      }
      else {
        ctx.fill();
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderStroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      if (this.strokeUniform && this.group) {
        var scaling = this.getObjectScaling();
        ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
      }
      else if (this.strokeUniform) {
        ctx.scale(1 / this.scaleX, 1 / this.scaleY);
      }
      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
      this._setStrokeStyles(ctx, this);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * This function try to patch the missing gradientTransform on canvas gradients.
     * transforming a context to transform the gradient, is going to transform the stroke too.
     * we want to transform the gradient but not the stroke operation, so we create
     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
     * is limited.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {fabric.Gradient} filler a fabric gradient instance
     */
    _applyPatternForTransformedGradient: function(ctx, filler) {
      var dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(),
          width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
      pCanvas.width = width;
      pCanvas.height = height;
      pCtx = pCanvas.getContext('2d');
      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
      pCtx.lineTo(0, height); pCtx.closePath();
      pCtx.translate(width / 2, height / 2);
      pCtx.scale(
        dims.zoomX / this.scaleX / retinaScaling,
        dims.zoomY / this.scaleY / retinaScaling
      );
      this._applyPatternGradientTransform(pCtx, filler);
      pCtx.fillStyle = filler.toLive(ctx);
      pCtx.fill();
      ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
      ctx.scale(
        retinaScaling * this.scaleX / dims.zoomX,
        retinaScaling * this.scaleY / dims.zoomY
      );
      ctx.strokeStyle = pCtx.createPattern(pCanvas, 'no-repeat');
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
    },

    /**
     * This function is an helper for svg import. it decompose the transformMatrix
     * and assign properties to object.
     * untransformed coordinates
     * @private
     * @chainable
     */
    _assignTransformMatrixProps: function() {
      if (this.transformMatrix) {
        var options = fabric.util.qrDecompose(this.transformMatrix);
        this.flipX = false;
        this.flipY = false;
        this.set('scaleX', options.scaleX);
        this.set('scaleY', options.scaleY);
        this.angle = options.angle;
        this.skewX = options.skewX;
        this.skewY = 0;
      }
    },

    /**
     * This function is an helper for svg import. it removes the transform matrix
     * and set to object properties that fabricjs can handle
     * @private
     * @param {Object} preserveAspectRatioOptions
     * @return {thisArg}
     */
    _removeTransformMatrix: function(preserveAspectRatioOptions) {
      var center = this._findCenterFromElement();
      if (this.transformMatrix) {
        this._assignTransformMatrixProps();
        center = fabric.util.transformPoint(center, this.transformMatrix);
      }
      this.transformMatrix = null;
      if (preserveAspectRatioOptions) {
        this.scaleX *= preserveAspectRatioOptions.scaleX;
        this.scaleY *= preserveAspectRatioOptions.scaleY;
        this.cropX = preserveAspectRatioOptions.cropX;
        this.cropY = preserveAspectRatioOptions.cropY;
        center.x += preserveAspectRatioOptions.offsetLeft;
        center.y += preserveAspectRatioOptions.offsetTop;
        this.width = preserveAspectRatioOptions.width;
        this.height = preserveAspectRatioOptions.height;
      }
      this.setPositionByOrigin(center, 'center', 'center');
    },

    /**
     * Clones an instance, using a callback method will work for every object.
     * @param {Function} callback Callback is invoked with a clone as a first argument
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     */
    clone: function(callback, propertiesToInclude) {
      var objectForm = this.toObject(propertiesToInclude);
      if (this.constructor.fromObject) {
        this.constructor.fromObject(objectForm, callback);
      }
      else {
        fabric.Object._fromObject('Object', objectForm, callback);
      }
    },

    /**
     * Creates an instance of fabric.Image out of an object
     * makes use of toCanvasElement.
     * Once this method was based on toDataUrl and loadImage, so it also had a quality
     * and format option. toCanvasElement is faster and produce no loss of quality.
     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.
     * toCanvasElement and then toBlob from the obtained canvas is also a good option.
     * This method is sync now, but still support the callback because we did not want to break.
     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.
     * @param {Function} callback callback, invoked with an instance as a first argument
     * @param {Object} [options] for clone as image, passed to toDataURL
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {fabric.Object} thisArg
     */
    cloneAsImage: function(callback, options) {
      var canvasEl = this.toCanvasElement(options);
      if (callback) {
        callback(new fabric.Image(canvasEl));
      }
      return this;
    },

    /**
     * Converts an object into a HTMLCanvas element
     * @param {Object} options Options object
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
     */
    toCanvasElement: function(options) {
      options || (options = { });

      var utils = fabric.util, origParams = utils.saveObjectTransform(this),
          originalGroup = this.group,
          originalShadow = this.shadow, abs = Math.abs,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);
      delete this.group;
      if (options.withoutTransform) {
        utils.resetObjectTransform(this);
      }
      if (options.withoutShadow) {
        this.shadow = null;
      }

      var el = fabric.util.createCanvasElement(),
          // skip canvas zoom and calculate with setCoords now.
          boundingRect = this.getBoundingRect(true, true),
          shadow = this.shadow, scaling,
          shadowOffset = { x: 0, y: 0 }, shadowBlur,
          width, height;

      if (shadow) {
        shadowBlur = shadow.blur;
        if (shadow.nonScaling) {
          scaling = { scaleX: 1, scaleY: 1 };
        }
        else {
          scaling = this.getObjectScaling();
        }
        // consider non scaling shadow.
        shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * (abs(scaling.scaleX));
        shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * (abs(scaling.scaleY));
      }
      width = boundingRect.width + shadowOffset.x;
      height = boundingRect.height + shadowOffset.y;
      // if the current width/height is not an integer
      // we need to make it so.
      el.width = Math.ceil(width);
      el.height = Math.ceil(height);
      var canvas = new fabric.StaticCanvas(el, {
        enableRetinaScaling: false,
        renderOnAddRemove: false,
        skipOffscreen: false,
      });
      if (options.format === 'jpeg') {
        canvas.backgroundColor = '#fff';
      }
      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

      var originalCanvas = this.canvas;
      canvas.add(this);
      var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
      this.shadow = originalShadow;
      this.set('canvas', originalCanvas);
      if (originalGroup) {
        this.group = originalGroup;
      }
      this.set(origParams).setCoords();
      // canvas.dispose will call image.dispose that will nullify the elements
      // since this canvas is a simple element for the process, we remove references
      // to objects in this way in order to avoid object trashing.
      canvas._objects = [];
      canvas.dispose();
      canvas = null;

      return canvasEl;
    },

    /**
     * Converts an object into a data-url-like string
     * @param {Object} options Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     */
    toDataURL: function(options) {
      options || (options = { });
      return fabric.util.toDataURL(this.toCanvasElement(options), options.format || 'png', options.quality || 1);
    },

    /**
     * Returns true if specified type is identical to the type of an instance
     * @param {String} type Type to check against
     * @return {Boolean}
     */
    isType: function(type) {
      return this.type === type;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance (is 1 unless subclassed)
     */
    complexity: function() {
      return 1;
    },

    /**
     * Returns a JSON representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} JSON
     */
    toJSON: function(propertiesToInclude) {
      // delegate, not alias
      return this.toObject(propertiesToInclude);
    },

    /**
     * Sets "angle" of an instance with centered rotation
     * @param {Number} angle Angle value (in degrees)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    rotate: function(angle) {
      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

      if (shouldCenterOrigin) {
        this._setOriginToCenter();
      }

      this.set('angle', angle);

      if (shouldCenterOrigin) {
        this._resetOrigin();
      }

      return this;
    },

    /**
     * Centers object horizontally on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerH: function () {
      this.canvas && this.canvas.centerObjectH(this);
      return this;
    },

    /**
     * Centers object horizontally on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterH: function () {
      this.canvas && this.canvas.viewportCenterObjectH(this);
      return this;
    },

    /**
     * Centers object vertically on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerV: function () {
      this.canvas && this.canvas.centerObjectV(this);
      return this;
    },

    /**
     * Centers object vertically on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterV: function () {
      this.canvas && this.canvas.viewportCenterObjectV(this);
      return this;
    },

    /**
     * Centers object vertically and horizontally on canvas to which is was added last
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    center: function () {
      this.canvas && this.canvas.centerObject(this);
      return this;
    },

    /**
     * Centers object on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenter: function () {
      this.canvas && this.canvas.viewportCenterObject(this);
      return this;
    },

    /**
     * Returns coordinates of a pointer relative to an object
     * @param {Event} e Event to operate upon
     * @param {Object} [pointer] Pointer to operate upon (instead of event)
     * @return {Object} Coordinates of a pointer (x, y)
     */
    getLocalPointer: function(e, pointer) {
      pointer = pointer || this.canvas.getPointer(e);
      var pClicked = new fabric.Point(pointer.x, pointer.y),
          objectLeftTop = this._getLeftTopCoords();
      if (this.angle) {
        pClicked = fabric.util.rotatePoint(
          pClicked, objectLeftTop, degreesToRadians(-this.angle));
      }
      return {
        x: pClicked.x - objectLeftTop.x,
        y: pClicked.y - objectLeftTop.y
      };
    },

    /**
     * Sets canvas globalCompositeOperation for specific object
     * custom composition operation for the particular object can be specified using globalCompositeOperation property
     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
     */
    _setupCompositeOperation: function (ctx) {
      if (this.globalCompositeOperation) {
        ctx.globalCompositeOperation = this.globalCompositeOperation;
      }
    }
  });

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

  extend(fabric.Object.prototype, fabric.Observable);

  /**
   * Defines the number of fraction digits to use when serializing object values.
   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
   * @static
   * @memberOf fabric.Object
   * @constant
   * @type Number
   */
  fabric.Object.NUM_FRACTION_DIGITS = 2;

  fabric.Object._fromObject = function(className, object, callback, extraParam) {
    var klass = fabric[className];
    object = clone(object, true);
    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
      if (typeof patterns[0] !== 'undefined') {
        object.fill = patterns[0];
      }
      if (typeof patterns[1] !== 'undefined') {
        object.stroke = patterns[1];
      }
      fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
        object.clipPath = enlivedProps[0];
        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
        callback && callback(instance);
      });
    });
  };

  /**
   * Unique id used internally when creating SVG elements
   * @static
   * @memberOf fabric.Object
   * @type Number
   */
  fabric.Object.__uid = 0;
})( true ? exports : 0);


(function() {

  var degreesToRadians = fabric.util.degreesToRadians,
      originXOffset = {
        left: -0.5,
        center: 0,
        right: 0.5
      },
      originYOffset = {
        top: -0.5,
        center: 0,
        bottom: 0.5
      };

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Translates the coordinates from a set of origin to another (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
      var x = point.x,
          y = point.y,
          offsetX, offsetY, dim;

      if (typeof fromOriginX === 'string') {
        fromOriginX = originXOffset[fromOriginX];
      }
      else {
        fromOriginX -= 0.5;
      }

      if (typeof toOriginX === 'string') {
        toOriginX = originXOffset[toOriginX];
      }
      else {
        toOriginX -= 0.5;
      }

      offsetX = toOriginX - fromOriginX;

      if (typeof fromOriginY === 'string') {
        fromOriginY = originYOffset[fromOriginY];
      }
      else {
        fromOriginY -= 0.5;
      }

      if (typeof toOriginY === 'string') {
        toOriginY = originYOffset[toOriginY];
      }
      else {
        toOriginY -= 0.5;
      }

      offsetY = toOriginY - fromOriginY;

      if (offsetX || offsetY) {
        dim = this._getTransformedDimensions();
        x = point.x + offsetX * dim.x;
        y = point.y + offsetY * dim.y;
      }

      return new fabric.Point(x, y);
    },

    /**
     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToCenterPoint: function(point, originX, originY) {
      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
      if (this.angle) {
        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
     * @param {fabric.Point} center The point which corresponds to center of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToOriginPoint: function(center, originX, originY) {
      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      if (this.angle) {
        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Returns the real center coordinates of the object
     * @return {fabric.Point}
     */
    getCenterPoint: function() {
      var leftTop = new fabric.Point(this.left, this.top);
      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
    },

    /**
     * Returns the coordinates of the object based on center coordinates
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @return {fabric.Point}
     */
    // getOriginPoint: function(center) {
    //   return this.translateToOriginPoint(center, this.originX, this.originY);
    // },

    /**
     * Returns the coordinates of the object as if it has a different origin
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    getPointByOrigin: function(originX, originY) {
      var center = this.getCenterPoint();
      return this.translateToOriginPoint(center, originX, originY);
    },

    /**
     * Returns the point in local coordinates
     * @param {fabric.Point} point The point relative to the global coordinate system
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    toLocalPoint: function(point, originX, originY) {
      var center = this.getCenterPoint(),
          p, p2;

      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      }
      else {
        p = new fabric.Point(this.left, this.top);
      }

      p2 = new fabric.Point(point.x, point.y);
      if (this.angle) {
        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
      }
      return p2.subtractEquals(p);
    },

    /**
     * Returns the point in global coordinates
     * @param {fabric.Point} The point relative to the local coordinate system
     * @return {fabric.Point}
     */
    // toGlobalPoint: function(point) {
    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
    // },

    /**
     * Sets the position of the object taking into consideration the object's origin
     * @param {fabric.Point} pos The new position of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {void}
     */
    setPositionByOrigin: function(pos, originX, originY) {
      var center = this.translateToCenterPoint(pos, originX, originY),
          position = this.translateToOriginPoint(center, this.originX, this.originY);
      this.set('left', position.x);
      this.set('top', position.y);
    },

    /**
     * @param {String} to One of 'left', 'center', 'right'
     */
    adjustPosition: function(to) {
      var angle = degreesToRadians(this.angle),
          hypotFull = this.getScaledWidth(),
          xFull = fabric.util.cos(angle) * hypotFull,
          yFull = fabric.util.sin(angle) * hypotFull,
          offsetFrom, offsetTo;

      //TODO: this function does not consider mixed situation like top, center.
      if (typeof this.originX === 'string') {
        offsetFrom = originXOffset[this.originX];
      }
      else {
        offsetFrom = this.originX - 0.5;
      }
      if (typeof to === 'string') {
        offsetTo = originXOffset[to];
      }
      else {
        offsetTo = to - 0.5;
      }
      this.left += xFull * (offsetTo - offsetFrom);
      this.top += yFull * (offsetTo - offsetFrom);
      this.setCoords();
      this.originX = to;
    },

    /**
     * Sets the origin/position of the object to it's center point
     * @private
     * @return {void}
     */
    _setOriginToCenter: function() {
      this._originalOriginX = this.originX;
      this._originalOriginY = this.originY;

      var center = this.getCenterPoint();

      this.originX = 'center';
      this.originY = 'center';

      this.left = center.x;
      this.top = center.y;
    },

    /**
     * Resets the origin/position of the object to it's original origin
     * @private
     * @return {void}
     */
    _resetOrigin: function() {
      var originPoint = this.translateToOriginPoint(
        this.getCenterPoint(),
        this._originalOriginX,
        this._originalOriginY);

      this.originX = this._originalOriginX;
      this.originY = this._originalOriginY;

      this.left = originPoint.x;
      this.top = originPoint.y;

      this._originalOriginX = null;
      this._originalOriginY = null;
    },

    /**
     * @private
     */
    _getLeftTopCoords: function() {
      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
    },
  });

})();


(function() {

  function arrayFromCoords(coords) {
    return [
      new fabric.Point(coords.tl.x, coords.tl.y),
      new fabric.Point(coords.tr.x, coords.tr.y),
      new fabric.Point(coords.br.x, coords.br.y),
      new fabric.Point(coords.bl.x, coords.bl.y)
    ];
  }

  var util = fabric.util,
      degreesToRadians = util.degreesToRadians,
      multiplyMatrices = util.multiplyTransformMatrices,
      transformPoint = util.transformPoint;

  util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Describe object's corner position in canvas element coordinates.
     * properties are depending on control keys and padding the main controls.
     * each property is an object with x, y and corner.
     * The `corner` property contains in a similar manner the 4 points of the
     * interactive area of the corner.
     * The coordinates depends from the controls positionHandler and are used
     * to draw and locate controls
     * @memberOf fabric.Object.prototype
     */
    oCoords: null,

    /**
     * Describe object's corner position in canvas object absolute coordinates
     * properties are tl,tr,bl,br and describe the four main corner.
     * each property is an object with x, y, instance of Fabric.Point.
     * The coordinates depends from this properties: width, height, scaleX, scaleY
     * skewX, skewY, angle, strokeWidth, top, left.
     * Those coordinates are useful to understand where an object is. They get updated
     * with oCoords but they do not need to be updated when zoom or panning change.
     * The coordinates get updated with @method setCoords.
     * You can calculate them without updating with @method calcACoords();
     * @memberOf fabric.Object.prototype
     */
    aCoords: null,

    /**
     * Describe object's corner position in canvas element coordinates.
     * includes padding. Used of object detection.
     * set and refreshed with setCoords and calcCoords.
     * @memberOf fabric.Object.prototype
     */
    lineCoords: null,

    /**
     * storage for object transform matrix
     */
    ownMatrixCache: null,

    /**
     * storage for object full transform matrix
     */
    matrixCache: null,

    /**
     * custom controls interface
     * controls are added by default_controls.js
     */
    controls: { },

    /**
     * return correct set of coordinates for intersection
     * this will return either aCoords or lineCoords.
     * @param {Boolean} absolute will return aCoords if true or lineCoords
     * @return {Object} {tl, tr, br, bl} points
     */
    _getCoords: function(absolute, calculate) {
      if (calculate) {
        return (absolute ? this.calcACoords() : this.calcLineCoords());
      }
      if (!this.aCoords || !this.lineCoords) {
        this.setCoords(true);
      }
      return (absolute ? this.aCoords : this.lineCoords);
    },

    /**
     * return correct set of coordinates for intersection
     * this will return either aCoords or lineCoords.
     * The coords are returned in an array.
     * @return {Array} [tl, tr, br, bl] of points
     */
    getCoords: function(absolute, calculate) {
      return arrayFromCoords(this._getCoords(absolute, calculate));
    },

    /**
     * Checks if object intersects with an area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with an area formed by 2 points
     */
    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
      var coords = this.getCoords(absolute, calculate),
          intersection = fabric.Intersection.intersectPolygonRectangle(
            coords,
            pointTL,
            pointBR
          );
      return intersection.status === 'Intersection';
    },

    /**
     * Checks if object intersects with another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with another object
     */
    intersectsWithObject: function(other, absolute, calculate) {
      var intersection = fabric.Intersection.intersectPolygonPolygon(
        this.getCoords(absolute, calculate),
        other.getCoords(absolute, calculate)
      );

      return intersection.status === 'Intersection'
        || other.isContainedWithinObject(this, absolute, calculate)
        || this.isContainedWithinObject(other, absolute, calculate);
    },

    /**
     * Checks if object is fully contained within area of another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area of another object
     */
    isContainedWithinObject: function(other, absolute, calculate) {
      var points = this.getCoords(absolute, calculate),
          otherCoords = absolute ? other.aCoords : other.lineCoords,
          i = 0, lines = other._getImageLines(otherCoords);
      for (; i < 4; i++) {
        if (!other.containsPoint(points[i], lines)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Checks if object is fully contained within area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area formed by 2 points
     */
    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
      var boundingRect = this.getBoundingRect(absolute, calculate);

      return (
        boundingRect.left >= pointTL.x &&
        boundingRect.left + boundingRect.width <= pointBR.x &&
        boundingRect.top >= pointTL.y &&
        boundingRect.top + boundingRect.height <= pointBR.y
      );
    },

    /**
     * Checks if point is inside the object
     * @param {fabric.Point} point Point to check against
     * @param {Object} [lines] object returned from @method _getImageLines
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if point is inside the object
     */
    containsPoint: function(point, lines, absolute, calculate) {
      var coords = this._getCoords(absolute, calculate),
          lines = lines || this._getImageLines(coords),
          xPoints = this._findCrossPoints(point, lines);
      // if xPoints is odd then point is inside the object
      return (xPoints !== 0 && xPoints % 2 === 1);
    },

    /**
     * Checks if object is contained within the canvas with current viewportTransform
     * the check is done stopping at first point that appears on screen
     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
     * @return {Boolean} true if object is fully or partially contained within canvas
     */
    isOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      var points = this.getCoords(true, calculate);
      // if some point is on screen, the object is on screen.
      if (points.some(function(point) {
        return point.x <= pointBR.x && point.x >= pointTL.x &&
        point.y <= pointBR.y && point.y >= pointTL.y;
      })) {
        return true;
      }
      // no points on screen, check intersection with absolute coordinates
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Checks if the object contains the midpoint between canvas extremities
     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
     * @private
     * @param {Fabric.Point} pointTL Top Left point
     * @param {Fabric.Point} pointBR Top Right point
     * @param {Boolean} calculate use coordinates of current position instead of .oCoords
     * @return {Boolean} true if the object contains the point
     */
    _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
      // worst case scenario the object is so big that contains the screen
      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
      if (this.containsPoint(centerPoint, null, true, calculate)) {
        return true;
      }
      return false;
    },

    /**
     * Checks if object is partially contained within the canvas with current viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is partially contained within canvas
     */
    isPartiallyOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {
        return (point.x >= pointBR.x || point.x <= pointTL.x) &&
        (point.y >= pointBR.y || point.y <= pointTL.y);
      });
      return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Method that returns an object with the object edges in it, given the coordinates of the corners
     * @private
     * @param {Object} oCoords Coordinates of the object corners
     */
    _getImageLines: function(oCoords) {

      var lines = {
        topline: {
          o: oCoords.tl,
          d: oCoords.tr
        },
        rightline: {
          o: oCoords.tr,
          d: oCoords.br
        },
        bottomline: {
          o: oCoords.br,
          d: oCoords.bl
        },
        leftline: {
          o: oCoords.bl,
          d: oCoords.tl
        }
      };

      // // debugging
      // if (this.canvas.contextTop) {
      //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
      // }

      return lines;
    },

    /**
     * Helper method to determine how many cross points are between the 4 object edges
     * and the horizontal line determined by a point on canvas
     * @private
     * @param {fabric.Point} point Point to check
     * @param {Object} lines Coordinates of the object being evaluated
     */
    // remove yi, not used but left code here just in case.
    _findCrossPoints: function(point, lines) {
      var b1, b2, a1, a2, xi, // yi,
          xcount = 0,
          iLine;

      for (var lineKey in lines) {
        iLine = lines[lineKey];
        // optimisation 1: line below point. no cross
        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
          continue;
        }
        // optimisation 2: line above point. no cross
        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
          continue;
        }
        // optimisation 3: vertical line case
        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
          xi = iLine.o.x;
          // yi = point.y;
        }
        // calculate the intersection point
        else {
          b1 = 0;
          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
          a1 = point.y - b1 * point.x;
          a2 = iLine.o.y - b2 * iLine.o.x;

          xi = -(a1 - a2) / (b1 - b2);
          // yi = a1 + b1 * xi;
        }
        // dont count xi < point.x cases
        if (xi >= point.x) {
          xcount += 1;
        }
        // optimisation 4: specific for square images
        if (xcount === 2) {
          break;
        }
      }
      return xcount;
    },

    /**
     * Returns coordinates of object's bounding rectangle (left, top, width, height)
     * the box is intended as aligned to axis of canvas.
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
     * @return {Object} Object with left, top, width, height properties
     */
    getBoundingRect: function(absolute, calculate) {
      var coords = this.getCoords(absolute, calculate);
      return util.makeBoundingBoxFromPoints(coords);
    },

    /**
     * Returns width of an object's bounding box counting transformations
     * before 2.0 it was named getWidth();
     * @return {Number} width value
     */
    getScaledWidth: function() {
      return this._getTransformedDimensions().x;
    },

    /**
     * Returns height of an object bounding box counting transformations
     * before 2.0 it was named getHeight();
     * @return {Number} height value
     */
    getScaledHeight: function() {
      return this._getTransformedDimensions().y;
    },

    /**
     * Makes sure the scale is valid and modifies it if necessary
     * @private
     * @param {Number} value
     * @return {Number}
     */
    _constrainScale: function(value) {
      if (Math.abs(value) < this.minScaleLimit) {
        if (value < 0) {
          return -this.minScaleLimit;
        }
        else {
          return this.minScaleLimit;
        }
      }
      else if (value === 0) {
        return 0.0001;
      }
      return value;
    },

    /**
     * Scales an object (equally by x and y)
     * @param {Number} value Scale factor
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scale: function(value) {
      this._set('scaleX', value);
      this._set('scaleY', value);
      return this.setCoords();
    },

    /**
     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New width value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToWidth: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
      return this.scale(value / this.width / boundingRectFactor);
    },

    /**
     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New height value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToHeight: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
      return this.scale(value / this.height / boundingRectFactor);
    },

    /**
     * Calculates and returns the .coords of an object.
     * unused by the library, only for the end dev.
     * @return {Object} Object with tl, tr, br, bl ....
     * @chainable
     * @deprecated
     */
    calcCoords: function(absolute) {
      // this is a compatibility function to avoid removing calcCoords now.
      if (absolute) {
        return this.calcACoords();
      }
      return this.calcOCoords();
    },

    calcLineCoords: function() {
      var vpt = this.getViewportTransform(),
          padding = this.padding, angle = degreesToRadians(this.angle),
          cos = util.cos(angle), sin = util.sin(angle),
          cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
          cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();

      var lineCoords = {
        tl: transformPoint(aCoords.tl, vpt),
        tr: transformPoint(aCoords.tr, vpt),
        bl: transformPoint(aCoords.bl, vpt),
        br: transformPoint(aCoords.br, vpt),
      };

      if (padding) {
        lineCoords.tl.x -= cosPMinusSinP;
        lineCoords.tl.y -= cosPSinP;
        lineCoords.tr.x += cosPSinP;
        lineCoords.tr.y -= cosPMinusSinP;
        lineCoords.bl.x -= cosPSinP;
        lineCoords.bl.y += cosPMinusSinP;
        lineCoords.br.x += cosPMinusSinP;
        lineCoords.br.y += cosPSinP;
      }

      return lineCoords;
    },

    calcOCoords: function() {
      var rotateMatrix = this._calcRotateMatrix(),
          translateMatrix = this._calcTranslateMatrix(),
          vpt = this.getViewportTransform(),
          startMatrix = multiplyMatrices(vpt, translateMatrix),
          finalMatrix = multiplyMatrices(startMatrix, rotateMatrix),
          finalMatrix = multiplyMatrices(finalMatrix, [1 / vpt[0], 0, 0, 1 / vpt[3], 0, 0]),
          dim = this._calculateCurrentDimensions(),
          coords = {};
      this.forEachControl(function(control, key, fabricObject) {
        coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);
      });

      // debug code
      // var canvas = this.canvas;
      // setTimeout(function() {
      //   canvas.contextTop.clearRect(0, 0, 700, 700);
      //   canvas.contextTop.fillStyle = 'green';
      //   Object.keys(coords).forEach(function(key) {
      //     var control = coords[key];
      //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);
      //   });
      // }, 50);
      return coords;
    },

    calcACoords: function() {
      var rotateMatrix = this._calcRotateMatrix(),
          translateMatrix = this._calcTranslateMatrix(),
          finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
          dim = this._getTransformedDimensions(),
          w = dim.x / 2, h = dim.y / 2;
      return {
        // corners
        tl: transformPoint({ x: -w, y: -h }, finalMatrix),
        tr: transformPoint({ x: w, y: -h }, finalMatrix),
        bl: transformPoint({ x: -w, y: h }, finalMatrix),
        br: transformPoint({ x: w, y: h }, finalMatrix)
      };
    },

    /**
     * Sets corner and controls position coordinates based on current angle, width and height, left and top.
     * oCoords are used to find the corners
     * aCoords are used to quickly find an object on the canvas
     * lineCoords are used to quickly find object during pointer events.
     * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}
     * @param {Boolean} [skipCorners] skip calculation of oCoords.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setCoords: function(skipCorners) {
      this.aCoords = this.calcACoords();
      // in case we are in a group, for how the inner group target check works,
      // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.
      this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();
      if (skipCorners) {
        return this;
      }
      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
      this.oCoords = this.calcOCoords();
      this._setCornerCoords && this._setCornerCoords();
      return this;
    },

    /**
     * calculate rotation matrix of an object
     * @return {Array} rotation matrix for the object
     */
    _calcRotateMatrix: function() {
      return util.calcRotateMatrix(this);
    },

    /**
     * calculate the translation matrix for an object transform
     * @return {Array} rotation matrix for the object
     */
    _calcTranslateMatrix: function() {
      var center = this.getCenterPoint();
      return [1, 0, 0, 1, center.x, center.y];
    },

    transformMatrixKey: function(skipGroup) {
      var sep = '_', prefix = '';
      if (!skipGroup && this.group) {
        prefix = this.group.transformMatrixKey(skipGroup) + sep;
      };
      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
        sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
        sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
    },

    /**
     * calculate transform matrix that represents the current transformations from the
     * object's properties.
     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
     * There are some situation in which this is useful to avoid the fake rotation.
     * @return {Array} transform matrix for the object
     */
    calcTransformMatrix: function(skipGroup) {
      var matrix = this.calcOwnMatrix();
      if (skipGroup || !this.group) {
        return matrix;
      }
      var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      if (this.group) {
        matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);
      }
      cache.key = key;
      cache.value = matrix;
      return matrix;
    },

    /**
     * calculate transform matrix that represents the current transformations from the
     * object's properties, this matrix does not include the group transformation
     * @return {Array} transform matrix for the object
     */
    calcOwnMatrix: function() {
      var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      var tMatrix = this._calcTranslateMatrix(),
          options = {
            angle: this.angle,
            translateX: tMatrix[4],
            translateY: tMatrix[5],
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: this.skewX,
            skewY: this.skewY,
            flipX: this.flipX,
            flipY: this.flipY,
          };
      cache.key = key;
      cache.value = util.composeMatrix(options);
      return cache.value;
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     * @deprecated since 3.4.0, please use fabric.util._calcDimensionsTransformMatrix
     * not including or including flipX, flipY to emulate the flipping boolean
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
      return util.calcDimensionsMatrix({
        skewX: skewX,
        skewY: skewY,
        scaleX: this.scaleX * (flipping && this.flipX ? -1 : 1),
        scaleY: this.scaleY * (flipping && this.flipY ? -1 : 1)
      });
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getNonTransformedDimensions: function() {
      var strokeWidth = this.strokeWidth,
          w = this.width + strokeWidth,
          h = this.height + strokeWidth;
      return { x: w, y: h };
    },

    /*
     * Calculate object bounding box dimensions from its properties scale, skew.
     * @param {Number} skewX, a value to override current skewX
     * @param {Number} skewY, a value to override current skewY
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getTransformedDimensions: function(skewX, skewY) {
      if (typeof skewX === 'undefined') {
        skewX = this.skewX;
      }
      if (typeof skewY === 'undefined') {
        skewY = this.skewY;
      }
      var dimensions = this._getNonTransformedDimensions(), dimX, dimY,
          noSkew = skewX === 0 && skewY === 0;

      if (this.strokeUniform) {
        dimX = this.width;
        dimY = this.height;
      }
      else {
        dimX = dimensions.x;
        dimY = dimensions.y;
      }
      if (noSkew) {
        return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
      }
      var bbox = util.sizeAfterTransform(dimX, dimY, {
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        skewX: skewX,
        skewY: skewY,
      });
      return this._finalizeDimensions(bbox.x, bbox.y);
    },

    /*
     * Calculate object bounding box dimensions from its properties scale, skew.
     * @param Number width width of the bbox
     * @param Number height height of the bbox
     * @private
     * @return {Object} .x finalized width dimension
     * @return {Object} .y finalized height dimension
     */
    _finalizeDimensions: function(width, height) {
      return this.strokeUniform ?
        { x: width + this.strokeWidth, y: height + this.strokeWidth }
        :
        { x: width, y: height };
    },

    /*
     * Calculate object dimensions for controls box, including padding and canvas zoom.
     * and active selection
     * private
     */
    _calculateCurrentDimensions: function()  {
      var vpt = this.getViewportTransform(),
          dim = this._getTransformedDimensions(),
          p = transformPoint(dim, vpt, true);
      return p.scalarAdd(2 * this.padding);
    },
  });
})();


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * Moves an object to the bottom of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendToBack: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
    }
    else if (this.canvas) {
      this.canvas.sendToBack(this);
    }
    return this;
  },

  /**
   * Moves an object to the top of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringToFront: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
    }
    else if (this.canvas) {
      this.canvas.bringToFront(this);
    }
    return this;
  },

  /**
   * Moves an object down in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendBackwards: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
    }
    else if (this.canvas) {
      this.canvas.sendBackwards(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object up in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringForward: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
    }
    else if (this.canvas) {
      this.canvas.bringForward(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object to specified level in stack of drawn objects
   * @param {Number} index New position of object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  moveTo: function(index) {
    if (this.group && this.group.type !== 'activeSelection') {
      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
    }
    else if (this.canvas) {
      this.canvas.moveTo(this, index);
    }
    return this;
  }
});


/* _TO_SVG_START_ */
(function() {
  function getSvgColorString(prop, value) {
    if (!value) {
      return prop + ': none; ';
    }
    else if (value.toLive) {
      return prop + ': url(#SVGID_' + value.id + '); ';
    }
    else {
      var color = new fabric.Color(value),
          str = prop + ': ' + color.toRgb() + '; ',
          opacity = color.getAlpha();
      if (opacity !== 1) {
        //change the color in rgb + opacity
        str += prop + '-opacity: ' + opacity.toString() + '; ';
      }
      return str;
    }
  }

  var toFixed = fabric.util.toFixed;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {

      var fillRule = this.fillRule ? this.fillRule : 'nonzero',
          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
          strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : '0',
          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
          visibility = this.visible ? '' : ' visibility: hidden;',
          filter = skipShadow ? '' : this.getSvgFilter(),
          fill = getSvgColorString('fill', this.fill),
          stroke = getSvgColorString('stroke', this.stroke);

      return [
        stroke,
        'stroke-width: ', strokeWidth, '; ',
        'stroke-dasharray: ', strokeDashArray, '; ',
        'stroke-linecap: ', strokeLineCap, '; ',
        'stroke-dashoffset: ', strokeDashOffset, '; ',
        'stroke-linejoin: ', strokeLineJoin, '; ',
        'stroke-miterlimit: ', strokeMiterLimit, '; ',
        fill,
        'fill-rule: ', fillRule, '; ',
        'opacity: ', opacity, ';',
        filter,
        visibility
      ].join('');
    },

    /**
     * Returns styles-string for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
     * @return {String}
     */
    getSvgSpanStyles: function(style, useWhiteSpace) {
      var term = '; ';
      var fontFamily = style.fontFamily ?
        'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
          '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
      var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
          fontFamily = fontFamily,
          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
          fill = style.fill ? getSvgColorString('fill', style.fill) : '',
          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
          textDecoration = this.getSvgTextDecoration(style),
          deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
      if (textDecoration) {
        textDecoration = 'text-decoration: ' + textDecoration + term;
      }

      return [
        stroke,
        strokeWidth,
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight,
        textDecoration,
        fill,
        deltaY,
        useWhiteSpace ? 'white-space: pre; ' : ''
      ].join('');
    },

    /**
     * Returns text-decoration property for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @return {String}
     */
    getSvgTextDecoration: function(style) {
      return ['overline', 'underline', 'line-through'].filter(function(decoration) {
        return style[decoration.replace('-', '')];
      }).join(' ');
    },

    /**
     * Returns filter for svg shadow
     * @return {String}
     */
    getSvgFilter: function() {
      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
    },

    /**
     * Returns id attribute for svg output
     * @return {String}
     */
    getSvgCommons: function() {
      return [
        this.id ? 'id="' + this.id + '" ' : '',
        this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : '',
      ].join('');
    },

    /**
     * Returns transform-string for svg-export
     * @param {Boolean} use the full transform or the single object one.
     * @return {String}
     */
    getSvgTransform: function(full, additionalTransform) {
      var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(),
          svgTransform = 'transform="' + fabric.util.matrixToSVG(transform);
      return svgTransform +
        (additionalTransform || '') + '" ';
    },

    _setSVGBg: function(textBgRects) {
      if (this.backgroundColor) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        textBgRects.push(
          '\t\t<rect ',
          this._getFillAttributes(this.backgroundColor),
          ' x="',
          toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(this.width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(this.height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      }
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver: reviver });
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      return '\t' + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver: reviver });
    },

    /**
     * @private
     */
    _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var reviver = options.reviver,
          additionalTransform = options.additionalTransform || '',
          commonPieces = [
            this.getSvgTransform(true, additionalTransform),
            this.getSvgCommons(),
          ].join(''),
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS');
      objectMarkup[index] = commonPieces;
      return reviver ? reviver(objectMarkup.join('')) : objectMarkup.join('');
    },

    /**
     * @private
     */
    _createBaseSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var noStyle = options.noStyle,
          reviver = options.reviver,
          styleInfo = noStyle ? '' : 'style="' + this.getSvgStyles() + '" ',
          shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : '',
          clipPath = this.clipPath,
          vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : '',
          absoluteClipPath = clipPath && clipPath.absolutePositioned,
          stroke = this.stroke, fill = this.fill, shadow = this.shadow,
          commonPieces, markup = [], clipPathMarkup,
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS'),
          additionalTransform = options.additionalTransform;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          clipPath.toClipPathSVG(reviver) +
          '</clipPath>\n';
      }
      if (absoluteClipPath) {
        markup.push(
          '<g ', shadowInfo, this.getSvgCommons(), ' >\n'
        );
      }
      markup.push(
        '<g ',
        this.getSvgTransform(false),
        !absoluteClipPath ? shadowInfo + this.getSvgCommons() : '',
        ' >\n'
      );
      commonPieces = [
        styleInfo,
        vectorEffect,
        noStyle ? '' : this.addPaintOrder(), ' ',
        additionalTransform ? 'transform="' + additionalTransform + '" ' : '',
      ].join('');
      objectMarkup[index] = commonPieces;
      if (fill && fill.toLive) {
        markup.push(fill.toSVG(this));
      }
      if (stroke && stroke.toLive) {
        markup.push(stroke.toSVG(this));
      }
      if (shadow) {
        markup.push(shadow.toSVG(this));
      }
      if (clipPath) {
        markup.push(clipPathMarkup);
      }
      markup.push(objectMarkup.join(''));
      markup.push('</g>\n');
      absoluteClipPath && markup.push('</g>\n');
      return reviver ? reviver(markup.join('')) : markup.join('');
    },

    addPaintOrder: function() {
      return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
    }
  });
})();
/* _TO_SVG_END_ */


(function() {

  var extend = fabric.util.object.extend,
      originalSet = 'stateProperties';

  /*
    Depends on `stateProperties`
  */
  function saveProps(origin, destination, props) {
    var tmpObj = { }, deep = true;
    props.forEach(function(prop) {
      tmpObj[prop] = origin[prop];
    });

    extend(origin[destination], tmpObj, deep);
  }

  function _isEqual(origValue, currentValue, firstPass) {
    if (origValue === currentValue) {
      // if the objects are identical, return
      return true;
    }
    else if (Array.isArray(origValue)) {
      if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
        return false;
      }
      for (var i = 0, len = origValue.length; i < len; i++) {
        if (!_isEqual(origValue[i], currentValue[i])) {
          return false;
        }
      }
      return true;
    }
    else if (origValue && typeof origValue === 'object') {
      var keys = Object.keys(origValue), key;
      if (!currentValue ||
          typeof currentValue !== 'object' ||
          (!firstPass && keys.length !== Object.keys(currentValue).length)
      ) {
        return false;
      }
      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        // since clipPath is in the statefull cache list and the clipPath objects
        // would be iterated as an object, this would lead to possible infinite recursion
        // we do not want to compare those.
        if (key === 'canvas' || key === 'group') {
          continue;
        }
        if (!_isEqual(origValue[key], currentValue[key])) {
          return false;
        }
      }
      return true;
    }
  }


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Returns true if object state (one of its state properties) was changed
     * @param {String} [propertySet] optional name for the set of property we want to save
     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
     */
    hasStateChanged: function(propertySet) {
      propertySet = propertySet || originalSet;
      var dashedPropertySet = '_' + propertySet;
      if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
        return true;
      }
      return !_isEqual(this[dashedPropertySet], this, true);
    },

    /**
     * Saves state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    saveState: function(options) {
      var propertySet = options && options.propertySet || originalSet,
          destination = '_' + propertySet;
      if (!this[destination]) {
        return this.setupState(options);
      }
      saveProps(this, destination, this[propertySet]);
      if (options && options.stateProperties) {
        saveProps(this, destination, options.stateProperties);
      }
      return this;
    },

    /**
     * Setups state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    setupState: function(options) {
      options = options || { };
      var propertySet = options.propertySet || originalSet;
      options.propertySet = propertySet;
      this['_' + propertySet] = { };
      this.saveState(options);
      return this;
    }
  });
})();


(function() {

  var degreesToRadians = fabric.util.degreesToRadians;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Determines which corner has been clicked
     * @private
     * @param {Object} pointer The pointer indicating the mouse position
     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
     */
    _findTargetCorner: function(pointer, forTouch) {
      // objects in group, anykind, are not self modificable,
      // must not return an hovered corner.
      if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
        return false;
      }

      var ex = pointer.x,
          ey = pointer.y,
          xPoints,
          lines, keys = Object.keys(this.oCoords),
          j = keys.length - 1, i;
      this.__corner = 0;

      // cycle in reverse order so we pick first the one on top
      for (; j >= 0; j--) {
        i = keys[j];
        if (!this.isControlVisible(i)) {
          continue;
        }

        lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);
        // // debugging
        //
        // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
        if (xPoints !== 0 && xPoints % 2 === 1) {
          this.__corner = i;
          return i;
        }
      }
      return false;
    },

    /**
     * Calls a function for each control. The function gets called,
     * with the control, the object that is calling the iterator and the control's key
     * @param {Function} fn function to iterate over the controls over
     */
    forEachControl: function(fn) {
      for (var i in this.controls) {
        fn(this.controls[i], i, this);
      };
    },

    /**
     * Sets the coordinates of the draggable boxes in the corners of
     * the image used to scale/rotate it.
     * note: if we would switch to ROUND corner area, all of this would disappear.
     * everything would resolve to a single point and a pythagorean theorem for the distance
     * @private
     */
    _setCornerCoords: function() {
      var coords = this.oCoords;

      for (var control in coords) {
        var controlObject = this.controls[control];
        coords[control].corner = controlObject.calcCornerCoords(
          this.angle, this.cornerSize, coords[control].x, coords[control].y, false);
        coords[control].touchCorner = controlObject.calcCornerCoords(
          this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);
      }
    },

    /**
     * Draws a colored layer behind the object, inside its selection borders.
     * Requires public options: padding, selectionBackgroundColor
     * this function is called when the context is transformed
     * has checks to be skipped when the object is on a staticCanvas
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawSelectionBackground: function(ctx) {
      if (!this.selectionBackgroundColor ||
        (this.canvas && !this.canvas.interactive) ||
        (this.canvas && this.canvas._activeObject !== this)
      ) {
        return this;
      }
      ctx.save();
      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
          vpt = this.canvas.viewportTransform;
      ctx.translate(center.x, center.y);
      ctx.scale(1 / vpt[0], 1 / vpt[3]);
      ctx.rotate(degreesToRadians(this.angle));
      ctx.fillStyle = this.selectionBackgroundColor;
      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBorders: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      var wh = this._calculateCurrentDimensions(),
          strokeWidth = this.borderScaleFactor,
          width = wh.x + strokeWidth,
          height = wh.y + strokeWidth,
          hasControls = typeof styleOverride.hasControls !== 'undefined' ?
            styleOverride.hasControls : this.hasControls,
          shouldStroke = false;

      ctx.save();
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);

      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      if (hasControls) {
        ctx.beginPath();
        this.forEachControl(function(control, key, fabricObject) {
          // in this moment, the ctx is centered on the object.
          // width and height of the above function are the size of the bbox.
          if (control.withConnection && control.getVisibility(fabricObject, key)) {
            // reset movement for each control
            shouldStroke = true;
            ctx.moveTo(control.x * width, control.y * height);
            ctx.lineTo(
              control.x * width + control.offsetX,
              control.y * height + control.offsetY
            );
          }
        });
        if (shouldStroke) {
          ctx.stroke();
        }
      }
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box when it is inside a group.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {object} options object representing current object parameters
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBordersInGroup: function(ctx, options, styleOverride) {
      styleOverride = styleOverride || {};
      var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options),
          strokeWidth = this.strokeWidth,
          strokeUniform = this.strokeUniform,
          borderScaleFactor = this.borderScaleFactor,
          width =
            bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor,
          height =
            bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
      ctx.save();
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      ctx.restore();
      return this;
    },

    /**
     * Draws corners of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: cornerSize, padding
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawControls: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      ctx.save();
      ctx.setTransform(this.canvas.getRetinaScaling(), 0, 0, this.canvas.getRetinaScaling(), 0, 0);
      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
      if (!this.transparentCorners) {
        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
      }
      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);
      this.setCoords();
      this.forEachControl(function(control, key, fabricObject) {
        if (control.getVisibility(fabricObject, key)) {
          control.render(ctx,
            fabricObject.oCoords[key].x,
            fabricObject.oCoords[key].y, styleOverride, fabricObject);
        }
      });
      ctx.restore();

      return this;
    },

    /**
     * Returns true if the specified control is visible, false otherwise.
     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @returns {Boolean} true if the specified control is visible, false otherwise
     */
    isControlVisible: function(controlKey) {
      return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);
    },

    /**
     * Sets the visibility of the specified control.
     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @param {Boolean} visible true to set the specified control visible, false otherwise
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlVisible: function(controlKey, visible) {
      if (!this._controlsVisibility) {
        this._controlsVisibility = {};
      }
      this._controlsVisibility[controlKey] = visible;
      return this;
    },

    /**
     * Sets the visibility state of object controls.
     * @param {Object} [options] Options object
     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlsVisibility: function(options) {
      options || (options = { });

      for (var p in options) {
        this.setControlVisible(p, options[p]);
      }
      return this;
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to deselect this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onDeselect: function() {
      // implemented by sub-classes, as needed.
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to select this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onSelect: function() {
      // implemented by sub-classes, as needed.
    }
  });
})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Animation duration (in ms) for fx* methods
   * @type Number
   * @default
   */
  FX_DURATION: 500,

  /**
   * Centers object horizontally with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectH: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.left,
      endValue: this.getCenter().left,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('left', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Centers object vertically with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectV: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.top,
      endValue: this.getCenter().top,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('top', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Same as `fabric.Canvas#remove` but animated
   * @param {fabric.Object} object Object to remove
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxRemove: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.opacity,
      endValue: 0,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('opacity', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function () {
        _this.remove(object);
        onComplete();
      }
    });

    return this;
  }
});

fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
  /**
   * Animates object's properties
   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
   * @return {fabric.Object} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
   * @chainable
   *
   * As object — multiple properties
   *
   * object.animate({ left: ..., top: ... });
   * object.animate({ left: ..., top: ... }, { duration: ... });
   *
   * As string — one property
   *
   * object.animate('left', ...);
   * object.animate('left', { duration: ... });
   *
   */
  animate: function() {
    if (arguments[0] && typeof arguments[0] === 'object') {
      var propsToAnimate = [], prop, skipCallbacks;
      for (prop in arguments[0]) {
        propsToAnimate.push(prop);
      }
      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
        prop = propsToAnimate[i];
        skipCallbacks = i !== len - 1;
        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
      }
    }
    else {
      this._animate.apply(this, arguments);
    }
    return this;
  },

  /**
   * @private
   * @param {String} property Property to animate
   * @param {String} to Value to animate to
   * @param {Object} [options] Options object
   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
   */
  _animate: function(property, to, options, skipCallbacks) {
    var _this = this, propPair;

    to = to.toString();

    if (!options) {
      options = { };
    }
    else {
      options = fabric.util.object.clone(options);
    }

    if (~property.indexOf('.')) {
      propPair = property.split('.');
    }

    var propIsColor =
      _this.colorProperties.indexOf(property) > -1 ||
      (propPair && _this.colorProperties.indexOf(propPair[1]) > -1);

    var currentValue = propPair
      ? this.get(propPair[0])[propPair[1]]
      : this.get(property);

    if (!('from' in options)) {
      options.from = currentValue;
    }

    if (!propIsColor) {
      if (~to.indexOf('=')) {
        to = currentValue + parseFloat(to.replace('=', ''));
      }
      else {
        to = parseFloat(to);
      }
    }

    var _options = {
      startValue: options.from,
      endValue: to,
      byValue: options.by,
      easing: options.easing,
      duration: options.duration,
      abort: options.abort && function () {
        return options.abort.call(_this);
      },
      onChange: function (value, valueProgress, timeProgress) {
        if (propPair) {
          _this[propPair[0]][propPair[1]] = value;
        }
        else {
          _this.set(property, value);
        }
        if (skipCallbacks) {
          return;
        }
        options.onChange && options.onChange(value, valueProgress, timeProgress);
      },
      onComplete: function (value, valueProgress, timeProgress) {
        if (skipCallbacks) {
          return;
        }

        _this.setCoords();
        options.onComplete && options.onComplete(value, valueProgress, timeProgress);
      }
    };

    if (propIsColor) {
      fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);
    }
    else {
      fabric.util.animate(_options);
    }
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');

  if (fabric.Line) {
    fabric.warn('fabric.Line is already defined');
    return;
  }

  /**
   * Line class
   * @class fabric.Line
   * @extends fabric.Object
   * @see {@link fabric.Line#initialize} for constructor definition
   */
  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'line',

    /**
     * x value or first line edge
     * @type Number
     * @default
     */
    x1: 0,

    /**
     * y value or first line edge
     * @type Number
     * @default
     */
    y1: 0,

    /**
     * x value or second line edge
     * @type Number
     * @default
     */
    x2: 0,

    /**
     * y value or second line edge
     * @type Number
     * @default
     */
    y2: 0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),

    /**
     * Constructor
     * @param {Array} [points] Array of points
     * @param {Object} [options] Options object
     * @return {fabric.Line} thisArg
     */
    initialize: function(points, options) {
      if (!points) {
        points = [0, 0, 0, 0];
      }

      this.callSuper('initialize', options);

      this.set('x1', points[0]);
      this.set('y1', points[1]);
      this.set('x2', points[2]);
      this.set('y2', points[3]);

      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Object} [options] Options
     */
    _setWidthHeight: function(options) {
      options || (options = { });

      this.width = Math.abs(this.x2 - this.x1);
      this.height = Math.abs(this.y2 - this.y1);

      this.left = 'left' in options
        ? options.left
        : this._getLeftToOriginX();

      this.top = 'top' in options
        ? options.top
        : this._getTopToOriginY();
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      if (typeof coordProps[key] !== 'undefined') {
        this._setWidthHeight();
      }
      return this;
    },

    /**
     * @private
     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
     */
    _getLeftToOriginX: makeEdgeToOriginGetter(
      { // property names
        origin: 'originX',
        axis1: 'x1',
        axis2: 'x2',
        dimension: 'width'
      },
      { // possible values of origin
        nearest: 'left',
        center: 'center',
        farthest: 'right'
      }
    ),

    /**
     * @private
     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
     */
    _getTopToOriginY: makeEdgeToOriginGetter(
      { // property names
        origin: 'originY',
        axis1: 'y1',
        axis2: 'y2',
        dimension: 'height'
      },
      { // possible values of origin
        nearest: 'top',
        center: 'center',
        farthest: 'bottom'
      }
    ),

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();

      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
        // move from center (of virtual box) to its left/top corner
        // we can't assume x1, y1 is top left and x2, y2 is bottom right
        var p = this.calcLinePoints();
        ctx.moveTo(p.x1, p.y1);
        ctx.lineTo(p.x2, p.y2);
      }

      ctx.lineWidth = this.strokeWidth;

      // TODO: test this
      // make sure setting "fill" changes color of a line
      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
      var origStrokeStyle = ctx.strokeStyle;
      ctx.strokeStyle = this.stroke || ctx.fillStyle;
      this.stroke && this._renderStroke(ctx);
      ctx.strokeStyle = origStrokeStyle;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p = this.calcLinePoints();

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return {
        x: (this.x1 + this.x2) / 2,
        y: (this.y1 + this.y2) / 2,
      };
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     */
    _getNonTransformedDimensions: function() {
      var dim = this.callSuper('_getNonTransformedDimensions');
      if (this.strokeLineCap === 'butt') {
        if (this.width === 0) {
          dim.y -= this.strokeWidth;
        }
        if (this.height === 0) {
          dim.x -= this.strokeWidth;
        }
      }
      return dim;
    },

    /**
     * Recalculates line points given width and height
     * @private
     */
    calcLinePoints: function() {
      var xMult = this.x1 <= this.x2 ? -1 : 1,
          yMult = this.y1 <= this.y2 ? -1 : 1,
          x1 = (xMult * this.width * 0.5),
          y1 = (yMult * this.height * 0.5),
          x2 = (xMult * this.width * -0.5),
          y2 = (yMult * this.height * -0.5);

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2
      };
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var p = this.calcLinePoints();
      return [
        '<line ', 'COMMON_PARTS',
        'x1="', p.x1,
        '" y1="', p.y1,
        '" x2="', p.x2,
        '" y2="', p.y2,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
   * @static
   * @memberOf fabric.Line
   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
   */
  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

  /**
   * Returns fabric.Line instance from an SVG element
   * @static
   * @memberOf fabric.Line
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} [callback] callback function invoked after parsing
   */
  fabric.Line.fromElement = function(element, callback, options) {
    options = options || { };
    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
        points = [
          parsedAttributes.x1 || 0,
          parsedAttributes.y1 || 0,
          parsedAttributes.x2 || 0,
          parsedAttributes.y2 || 0
        ];
    callback(new fabric.Line(points, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Line instance from an object representation
   * @static
   * @memberOf fabric.Line
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Line.fromObject = function(object, callback) {
    function _callback(instance) {
      delete instance.points;
      callback && callback(instance);
    };
    var options = clone(object, true);
    options.points = [object.x1, object.y1, object.x2, object.y2];
    fabric.Object._fromObject('Line', options, _callback, 'points');
  };

  /**
   * Produces a function that calculates distance from canvas edge to Line origin.
   */
  function makeEdgeToOriginGetter(propertyNames, originValues) {
    var origin = propertyNames.origin,
        axis1 = propertyNames.axis1,
        axis2 = propertyNames.axis2,
        dimension = propertyNames.dimension,
        nearest = originValues.nearest,
        center = originValues.center,
        farthest = originValues.farthest;

    return function() {
      switch (this.get(origin)) {
        case nearest:
          return Math.min(this.get(axis1), this.get(axis2));
        case center:
          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
        case farthest:
          return Math.max(this.get(axis1), this.get(axis2));
      }
    };

  }

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      pi = Math.PI;

  if (fabric.Circle) {
    fabric.warn('fabric.Circle is already defined.');
    return;
  }

  /**
   * Circle class
   * @class fabric.Circle
   * @extends fabric.Object
   * @see {@link fabric.Circle#initialize} for constructor definition
   */
  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'circle',

    /**
     * Radius of this circle
     * @type Number
     * @default
     */
    radius: 0,

    /**
     * Start angle of the circle, moving clockwise
     * deprecated type, this should be in degree, this was an oversight.
     * probably will change to degrees in next major version
     * @type Number
     * @default 0
     */
    startAngle: 0,

    /**
     * End angle of the circle
     * deprecated type, this should be in degree, this was an oversight.
     * probably will change to degrees in next major version
     * @type Number
     * @default 2Pi
     */
    endAngle: pi * 2,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Circle} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);

      if (key === 'radius') {
        this.setRadius(value);
      }

      return this;
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */

    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString, x = 0, y = 0,
          angle = (this.endAngle - this.startAngle) % ( 2 * pi);

      if (angle === 0) {
        svgString = [
          '<circle ', 'COMMON_PARTS',
          'cx="' + x + '" cy="' + y + '" ',
          'r="', this.radius,
          '" />\n'
        ];
      }
      else {
        var startX = fabric.util.cos(this.startAngle) * this.radius,
            startY = fabric.util.sin(this.startAngle) * this.radius,
            endX = fabric.util.cos(this.endAngle) * this.radius,
            endY = fabric.util.sin(this.endAngle) * this.radius,
            largeFlag = angle > pi ? '1' : '0';
        svgString = [
          '<path d="M ' + startX + ' ' + startY,
          ' A ' + this.radius + ' ' + this.radius,
          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
          '" ', 'COMMON_PARTS', ' />\n'
        ];
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.arc(
        0,
        0,
        this.radius,
        this.startAngle,
        this.endAngle, false);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusX: function() {
      return this.get('radius') * this.get('scaleX');
    },

    /**
     * Returns vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusY: function() {
      return this.get('radius') * this.get('scaleY');
    },

    /**
     * Sets radius of an object (and updates width accordingly)
     * @return {fabric.Circle} thisArg
     */
    setRadius: function(value) {
      this.radius = value;
      return this.set('width', value * 2).set('height', value * 2);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
   * @static
   * @memberOf fabric.Circle
   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
   */
  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

  /**
   * Returns {@link fabric.Circle} instance from an SVG element
   * @static
   * @memberOf fabric.Circle
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @param {Object} [options] Options object
   * @throws {Error} If value of `r` attribute is missing or invalid
   */
  fabric.Circle.fromElement = function(element, callback) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

    if (!isValidRadius(parsedAttributes)) {
      throw new Error('value of `r` attribute is required and can not be negative');
    }

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
    callback(new fabric.Circle(parsedAttributes));
  };

  /**
   * @private
   */
  function isValidRadius(attributes) {
    return (('radius' in attributes) && (attributes.radius >= 0));
  }
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Circle} instance from an object representation
   * @static
   * @memberOf fabric.Circle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {Object} Instance of fabric.Circle
   */
  fabric.Circle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Circle', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Triangle) {
    fabric.warn('fabric.Triangle is already defined');
    return;
  }

  /**
   * Triangle class
   * @class fabric.Triangle
   * @extends fabric.Object
   * @return {fabric.Triangle} thisArg
   * @see {@link fabric.Triangle#initialize} for constructor definition
   */
  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'triangle',

    /**
     * Width is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    width: 100,

    /**
     * Height is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    height: 100,

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      ctx.moveTo(-widthBy2, heightBy2);
      ctx.lineTo(0, -heightBy2);
      ctx.lineTo(widthBy2, heightBy2);
      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
      ctx.closePath();
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2,
          points = [
            -widthBy2 + ' ' + heightBy2,
            '0 ' + -heightBy2,
            widthBy2 + ' ' + heightBy2
          ].join(',');
      return [
        '<polygon ', 'COMMON_PARTS',
        'points="', points,
        '" />'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Triangle} instance from an object representation
   * @static
   * @memberOf fabric.Triangle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Triangle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Triangle', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      piBy2   = Math.PI * 2;

  if (fabric.Ellipse) {
    fabric.warn('fabric.Ellipse is already defined.');
    return;
  }

  /**
   * Ellipse class
   * @class fabric.Ellipse
   * @extends fabric.Object
   * @return {fabric.Ellipse} thisArg
   * @see {@link fabric.Ellipse#initialize} for constructor definition
   */
  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'ellipse',

    /**
     * Horizontal radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {fabric.Ellipse} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this.set('rx', options && options.rx || 0);
      this.set('ry', options && options.ry || 0);
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Ellipse} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      switch (key) {

        case 'rx':
          this.rx = value;
          this.set('width', value * 2);
          break;

        case 'ry':
          this.ry = value;
          this.set('height', value * 2);
          break;

      }
      return this;
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRx: function() {
      return this.get('rx') * this.get('scaleX');
    },

    /**
     * Returns Vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRy: function() {
      return this.get('ry') * this.get('scaleY');
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      return [
        '<ellipse ', 'COMMON_PARTS',
        'cx="0" cy="0" ',
        'rx="', this.rx,
        '" ry="', this.ry,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.save();
      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
      ctx.arc(
        0,
        0,
        this.rx,
        0,
        piBy2,
        false);
      ctx.restore();
      this._renderPaintInOrder(ctx);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
   * @static
   * @memberOf fabric.Ellipse
   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
   */
  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

  /**
   * Returns {@link fabric.Ellipse} instance from an SVG element
   * @static
   * @memberOf fabric.Ellipse
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromElement = function(element, callback) {

    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
    callback(new fabric.Ellipse(parsedAttributes));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Ellipse} instance from an object representation
   * @static
   * @memberOf fabric.Ellipse
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Ellipse', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend;

  if (fabric.Rect) {
    fabric.warn('fabric.Rect is already defined');
    return;
  }

  /**
   * Rectangle class
   * @class fabric.Rect
   * @extends fabric.Object
   * @return {fabric.Rect} thisArg
   * @see {@link fabric.Rect#initialize} for constructor definition
   */
  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

    /**
     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'rect',

    /**
     * Horizontal border radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical border radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this._initRxRy();
    },

    /**
     * Initializes rx/ry attributes
     * @private
     */
    _initRxRy: function() {
      if (this.rx && !this.ry) {
        this.ry = this.rx;
      }
      else if (this.ry && !this.rx) {
        this.rx = this.ry;
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {

      // 1x1 case (used in spray brush) optimization was removed because
      // with caching and higher zoom level this makes more damage than help

      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
          w = this.width,
          h = this.height,
          x = -this.width / 2,
          y = -this.height / 2,
          isRounded = rx !== 0 || ry !== 0,
          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
          k = 1 - 0.5522847498;
      ctx.beginPath();

      ctx.moveTo(x + rx, y);

      ctx.lineTo(x + w - rx, y);
      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

      ctx.lineTo(x + w, y + h - ry);
      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

      ctx.lineTo(x + rx, y + h);
      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

      ctx.lineTo(x, y + ry);
      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var x = -this.width / 2, y = -this.height / 2;
      return [
        '<rect ', 'COMMON_PARTS',
        'x="', x, '" y="', y,
        '" rx="', this.rx, '" ry="', this.ry,
        '" width="', this.width, '" height="', this.height,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
   * @static
   * @memberOf fabric.Rect
   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
   */
  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

  /**
   * Returns {@link fabric.Rect} instance from an SVG element
   * @static
   * @memberOf fabric.Rect
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Rect.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }
    options = options || { };

    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
    parsedAttributes.left = parsedAttributes.left || 0;
    parsedAttributes.top  = parsedAttributes.top  || 0;
    parsedAttributes.height  = parsedAttributes.height || 0;
    parsedAttributes.width  = parsedAttributes.width || 0;
    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
    callback(rect);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Rect} instance from an object representation
   * @static
   * @memberOf fabric.Rect
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
   */
  fabric.Rect.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Rect', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      toFixed = fabric.util.toFixed;

  if (fabric.Polyline) {
    fabric.warn('fabric.Polyline is already defined');
    return;
  }

  /**
   * Polyline class
   * @class fabric.Polyline
   * @extends fabric.Object
   * @see {@link fabric.Polyline#initialize} for constructor definition
   */
  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polyline',

    /**
     * Points array
     * @type Array
     * @default
     */
    points: null,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),

    /**
     * Constructor
     * @param {Array} points Array of points (where each point is an object with x and y)
     * @param {Object} [options] Options object
     * @return {fabric.Polyline} thisArg
     * @example
     * var poly = new fabric.Polyline([
     *     { x: 10, y: 10 },
     *     { x: 50, y: 30 },
     *     { x: 40, y: 70 },
     *     { x: 60, y: 50 },
     *     { x: 100, y: 150 },
     *     { x: 40, y: 100 }
     *   ], {
     *   stroke: 'red',
     *   left: 100,
     *   top: 100
     * });
     */
    initialize: function(points, options) {
      options = options || {};
      this.points = points || [];
      this.callSuper('initialize', options);
      this._setPositionDimensions(options);
    },

    _setPositionDimensions: function(options) {
      var calcDim = this._calcDimensions(options), correctLeftTop;
      this.width = calcDim.width;
      this.height = calcDim.height;
      if (!options.fromSVG) {
        correctLeftTop = this.translateToGivenOrigin(
          { x: calcDim.left - this.strokeWidth / 2, y: calcDim.top - this.strokeWidth / 2 },
          'left',
          'top',
          this.originX,
          this.originY
        );
      }
      if (typeof options.left === 'undefined') {
        this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
      }
      if (typeof options.top === 'undefined') {
        this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
      }
      this.pathOffset = {
        x: calcDim.left + this.width / 2,
        y: calcDim.top + this.height / 2
      };
    },

    /**
     * Calculate the polygon min and max point from points array,
     * returning an object with left, top, width, height to measure the
     * polygon size
     * @return {Object} object.left X coordinate of the polygon leftmost point
     * @return {Object} object.top Y coordinate of the polygon topmost point
     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
     * @private
     */
    _calcDimensions: function() {

      var points = this.points,
          minX = min(points, 'x') || 0,
          minY = min(points, 'y') || 0,
          maxX = max(points, 'x') || 0,
          maxY = max(points, 'y') || 0,
          width = (maxX - minX),
          height = (maxY - minY);

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        points: this.points.concat()
      });
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      for (var i = 0, len = this.points.length; i < len; i++) {
        points.push(
          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
        );
      }
      return [
        '<' + this.type + ' ', 'COMMON_PARTS',
        'points="', points.join(''),
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */


    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    commonRender: function(ctx) {
      var point, len = this.points.length,
          x = this.pathOffset.x,
          y = this.pathOffset.y;

      if (!len || isNaN(this.points[len - 1].y)) {
        // do not draw if no points or odd points
        // NaN comes from parseFloat of a empty string in parser
        return false;
      }
      ctx.beginPath();
      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
      for (var i = 0; i < len; i++) {
        point = this.points[i];
        ctx.lineTo(point.x - x, point.y - y);
      }
      return true;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p1, p2;

      ctx.beginPath();
      for (var i = 0, len = this.points.length; i < len; i++) {
        p1 = this.points[i];
        p2 = this.points[i + 1] || p1;
        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
      }
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.get('points').length;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
   * @static
   * @memberOf fabric.Polyline
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
   */
  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns fabric.Polyline instance from an SVG element
   * @static
   * @memberOf fabric.Polyline
   * @param {SVGElement} element Element to parser
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polyline.fromElementGenerator = function(_class) {
    return function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options || (options = { });

      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
          parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);
      parsedAttributes.fromSVG = true;
      callback(new fabric[_class](points, extend(parsedAttributes, options)));
    };
  };

  fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator('Polyline');

  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polyline instance from an object representation
   * @static
   * @memberOf fabric.Polyline
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polyline.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polyline', object, callback, 'points');
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Polygon) {
    fabric.warn('fabric.Polygon is already defined');
    return;
  }

  /**
   * Polygon class
   * @class fabric.Polygon
   * @extends fabric.Polyline
   * @see {@link fabric.Polygon#initialize} for constructor definition
   */
  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polygon',

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      this.callSuper('_renderDashedStroke', ctx);
      ctx.closePath();
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
   * @static
   * @memberOf fabric.Polygon
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
   */
  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns {@link fabric.Polygon} instance from an SVG element
   * @static
   * @memberOf fabric.Polygon
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator('Polygon');
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polygon instance from an object representation
   * @static
   * @memberOf fabric.Polygon
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polygon.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polygon', object, callback, 'points');
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      extend = fabric.util.object.extend,
      _toString = Object.prototype.toString,
      toFixed = fabric.util.toFixed;

  if (fabric.Path) {
    fabric.warn('fabric.Path is already defined');
    return;
  }

  /**
   * Path class
   * @class fabric.Path
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
   * @see {@link fabric.Path#initialize} for constructor definition
   */
  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'path',

    /**
     * Array of path points
     * @type Array
     * @default
     */
    path: null,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),

    stateProperties: fabric.Object.prototype.stateProperties.concat('path'),

    /**
     * Constructor
     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
     * @param {Object} [options] Options object
     * @return {fabric.Path} thisArg
     */
    initialize: function(path, options) {
      options = options || { };
      this.callSuper('initialize', options);
      if (!path) {
        path = [];
      }

      var fromArray = _toString.call(path) === '[object Array]';

      this.path = fromArray
        ? fabric.util.makePathSimpler(path)

        : fabric.util.makePathSimpler(
          fabric.util.parsePath(path)
        );

      if (!this.path) {
        return;
      }
      fabric.Polyline.prototype._setPositionDimensions.call(this, options);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _renderPathCommands: function(ctx) {
      var current, // current instruction
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          controlX = 0, // current control point x
          controlY = 0, // current control point y
          l = -this.pathOffset.x,
          t = -this.pathOffset.y;

      ctx.beginPath();

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            ctx.lineTo(x + l, y + t);
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            ctx.moveTo(x + l, y + t);
            break;

          case 'C': // bezierCurveTo, absolute
            x = current[5];
            y = current[6];
            controlX = current[3];
            controlY = current[4];
            ctx.bezierCurveTo(
              current[1] + l,
              current[2] + t,
              controlX + l,
              controlY + t,
              x + l,
              y + t
            );
            break;

          case 'Q': // quadraticCurveTo, absolute
            ctx.quadraticCurveTo(
              current[1] + l,
              current[2] + t,
              current[3] + l,
              current[4] + t
            );
            x = current[3];
            y = current[4];
            controlX = current[1];
            controlY = current[2];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            ctx.closePath();
            break;
        }
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _render: function(ctx) {
      this._renderPathCommands(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function() {
      return '#<fabric.Path (' + this.complexity() +
        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        path: this.path.map(function(item) { return item.slice(); }),
      });
    },

    /**
     * Returns dataless object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
      if (o.sourcePath) {
        delete o.path;
      }
      return o;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var path = this.path.map(function(path) {
        return path.join(' ');
      }).join(' ');
      return [
        '<path ', 'COMMON_PARTS',
        'd="', path,
        '" stroke-linecap="round" ',
        '/>\n'
      ];
    },

    _getOffsetTransform: function() {
      var digits = fabric.Object.NUM_FRACTION_DIGITS;
      return ' translate(' + toFixed(-this.pathOffset.x, digits) + ', ' +
          toFixed(-this.pathOffset.y, digits) + ')';
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return '\t' + this._createBaseClipPathSVGMarkup(
        this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform }
      );
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform  });
    },
    /* _TO_SVG_END_ */

    /**
     * Returns number representation of an instance complexity
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.path.length;
    },

    /**
     * @private
     */
    _calcDimensions: function() {

      var aX = [],
          aY = [],
          current, // current instruction
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          bounds;

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            bounds = [];
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            bounds = [];
            break;

          case 'C': // bezierCurveTo, absolute
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6]
            );
            x = current[5];
            y = current[6];
            break;

          case 'Q': // quadraticCurveTo, absolute
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              current[1],
              current[2],
              current[3],
              current[4]
            );
            x = current[3];
            y = current[4];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            break;
        }
        bounds.forEach(function (point) {
          aX.push(point.x);
          aY.push(point.y);
        });
        aX.push(x);
        aY.push(y);
      }

      var minX = min(aX) || 0,
          minY = min(aY) || 0,
          maxX = max(aX) || 0,
          maxY = max(aY) || 0,
          deltaX = maxX - minX,
          deltaY = maxY - minY;

      return {
        left: minX,
        top: minY,
        width: deltaX,
        height: deltaY
      };
    }
  });

  /**
   * Creates an instance of fabric.Path from an object
   * @static
   * @memberOf fabric.Path
   * @param {Object} object
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Path.fromObject = function(object, callback) {
    if (typeof object.sourcePath === 'string') {
      var pathUrl = object.sourcePath;
      fabric.loadSVGFromURL(pathUrl, function (elements) {
        var path = elements[0];
        path.setOptions(object);
        callback && callback(path);
      });
    }
    else {
      fabric.Object._fromObject('Path', object, callback, 'path');
    }
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
   * @static
   * @memberOf fabric.Path
   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
   */
  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

  /**
   * Creates an instance of fabric.Path from an SVG <path> element
   * @static
   * @memberOf fabric.Path
   * @param {SVGElement} element to parse
   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
   * @param {Object} [options] Options object
   * @param {Function} [callback] Options callback invoked after parsing is finished
   */
  fabric.Path.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
    parsedAttributes.fromSVG = true;
    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max;

  if (fabric.Group) {
    return;
  }

  /**
   * Group class
   * @class fabric.Group
   * @extends fabric.Object
   * @mixes fabric.Collection
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.Group#initialize} for constructor definition
   */
  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'group',

    /**
     * Width of stroke
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
     * @type Boolean
     * @default
     */
    subTargetCheck: false,

    /**
     * Groups are container, do not render anything on theyr own, ence no cache properties
     * @type Array
     * @default
     */
    cacheProperties: [],

    /**
     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
     * available setting this boolean to true.
     * @type Boolean
     * @since 2.0.0
     * @default
     */
    useSetOnGroup: false,

    /**
     * Constructor
     * @param {Object} objects Group objects
     * @param {Object} [options] Options object
     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
     * @return {Object} thisArg
     */
    initialize: function(objects, options, isAlreadyGrouped) {
      options = options || {};
      this._objects = [];
      // if objects enclosed in a group have been grouped already,
      // we cannot change properties of objects.
      // Thus we need to set options to group without objects,
      isAlreadyGrouped && this.callSuper('initialize', options);
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (!isAlreadyGrouped) {
        var center = options && options.centerPoint;
        // we want to set origins before calculating the bounding box.
        // so that the topleft can be set with that in mind.
        // if specific top and left are passed, are overwritten later
        // with the callSuper('initialize', options)
        if (options.originX !== undefined) {
          this.originX = options.originX;
        }
        if (options.originY !== undefined) {
          this.originY = options.originY;
        }
        // if coming from svg i do not want to calc bounds.
        // i assume width and height are passed along options
        center || this._calcBounds();
        this._updateObjectsCoords(center);
        delete options.centerPoint;
        this.callSuper('initialize', options);
      }
      else {
        this._updateObjectsACoords();
      }

      this.setCoords();
    },

    /**
     * @private
     */
    _updateObjectsACoords: function() {
      var skipControls = true;
      for (var i = this._objects.length; i--; ){
        this._objects[i].setCoords(skipControls);
      }
    },

    /**
     * @private
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
     */
    _updateObjectsCoords: function(center) {
      var center = center || this.getCenterPoint();
      for (var i = this._objects.length; i--; ){
        this._updateObjectCoords(this._objects[i], center);
      }
    },

    /**
     * @private
     * @param {Object} object
     * @param {fabric.Point} center, current center of group.
     */
    _updateObjectCoords: function(object, center) {
      var objectLeft = object.left,
          objectTop = object.top,
          skipControls = true;

      object.set({
        left: objectLeft - center.x,
        top: objectTop - center.y
      });
      object.group = this;
      object.setCoords(skipControls);
    },

    /**
     * Returns string represenation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.Group: (' + this.complexity() + ')>';
    },

    /**
     * Adds an object to a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    addWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);
      if (object) {
        this._objects.push(object);
        object.group = this;
        object._set('canvas', this.canvas);
      }
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * Removes an object from a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    removeWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);

      this.remove(object);
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * @private
     */
    _onObjectAdded: function(object) {
      this.dirty = true;
      object.group = this;
      object._set('canvas', this.canvas);
    },

    /**
     * @private
     */
    _onObjectRemoved: function(object) {
      this.dirty = true;
      delete object.group;
    },

    /**
     * @private
     */
    _set: function(key, value) {
      var i = this._objects.length;
      if (this.useSetOnGroup) {
        while (i--) {
          this._objects[i].setOnGroup(key, value);
        }
      }
      if (key === 'canvas') {
        while (i--) {
          this._objects[i]._set(key, value);
        }
      }
      fabric.Object.prototype._set.call(this, key, value);
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var _includeDefaultValues = this.includeDefaultValues;
      var objsToObject = this._objects.map(function(obj) {
        var originalDefaults = obj.includeDefaultValues;
        obj.includeDefaultValues = _includeDefaultValues;
        var _obj = obj.toObject(propertiesToInclude);
        obj.includeDefaultValues = originalDefaults;
        return _obj;
      });
      var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Returns object representation of an instance, in dataless mode.
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var objsToObject, sourcePath = this.sourcePath;
      if (sourcePath) {
        objsToObject = sourcePath;
      }
      else {
        var _includeDefaultValues = this.includeDefaultValues;
        objsToObject = this._objects.map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = _includeDefaultValues;
          var _obj = obj.toDatalessObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
      }
      var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Renders instance on a given context
     * @param {CanvasRenderingContext2D} ctx context to render instance on
     */
    render: function(ctx) {
      this._transformDone = true;
      this.callSuper('render', ctx);
      this._transformDone = false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group is already cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      var ownCache = fabric.Object.prototype.shouldCache.call(this);
      if (ownCache) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            this.ownCaching = false;
            return false;
          }
        }
      }
      return ownCache;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * @return {Boolean}
     */
    willDrawShadow: function() {
      if (fabric.Object.prototype.willDrawShadow.call(this)) {
        return true;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].willDrawShadow()) {
          return true;
        }
      }
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return this.ownCaching || (this.group && this.group.isOnACache());
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx) {
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i].render(ctx);
      }
      this._drawClipPath(ctx);
    },

    /**
     * Check if cache is dirty
     */
    isCacheDirty: function(skipCanvas) {
      if (this.callSuper('isCacheDirty', skipCanvas)) {
        return true;
      }
      if (!this.statefullCache) {
        return false;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].isCacheDirty(true)) {
          if (this._cacheCanvas) {
            // if this group has not a cache canvas there is nothing to clean
            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Restores original state of each of group objects (original state is that which was before group was created).
     * @private
     * @return {fabric.Group} thisArg
     * @chainable
     */
    _restoreObjectsState: function() {
      this._objects.forEach(this._restoreObjectState, this);
      return this;
    },

    /**
     * Realises the transform from this group onto the supplied object
     * i.e. it tells you what would happen if the supplied object was in
     * the group, and then the group was destroyed. It mutates the supplied
     * object.
     * @param {fabric.Object} object
     * @return {fabric.Object} transformedObject
     */
    realizeTransform: function(object) {
      var matrix = object.calcTransformMatrix(),
          options = fabric.util.qrDecompose(matrix),
          center = new fabric.Point(options.translateX, options.translateY);
      object.flipX = false;
      object.flipY = false;
      object.set('scaleX', options.scaleX);
      object.set('scaleY', options.scaleY);
      object.skewX = options.skewX;
      object.skewY = options.skewY;
      object.angle = options.angle;
      object.setPositionByOrigin(center, 'center', 'center');
      return object;
    },

    /**
     * Restores original state of a specified object in group
     * @private
     * @param {fabric.Object} object
     * @return {fabric.Group} thisArg
     */
    _restoreObjectState: function(object) {
      this.realizeTransform(object);
      delete object.group;
      object.setCoords();
      return this;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    destroy: function() {
      // when group is destroyed objects needs to get a repaint to be eventually
      // displayed on canvas.
      this._objects.forEach(function(object) {
        object.set('dirty', true);
      });
      return this._restoreObjectsState();
    },

    /**
     * make a group an active selection, remove the group from canvas
     * the group has to be on canvas for this to work.
     * @return {fabric.ActiveSelection} thisArg
     * @chainable
     */
    toActiveSelection: function() {
      if (!this.canvas) {
        return;
      }
      var objects = this._objects, canvas = this.canvas;
      this._objects = [];
      var options = this.toObject();
      delete options.objects;
      var activeSelection = new fabric.ActiveSelection([]);
      activeSelection.set(options);
      activeSelection.type = 'activeSelection';
      canvas.remove(this);
      objects.forEach(function(object) {
        object.group = activeSelection;
        object.dirty = true;
        canvas.add(object);
      });
      activeSelection.canvas = canvas;
      activeSelection._objects = objects;
      canvas._activeObject = activeSelection;
      activeSelection.setCoords();
      return activeSelection;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    ungroupOnCanvas: function() {
      return this._restoreObjectsState();
    },

    /**
     * Sets coordinates of all objects inside group
     * @return {fabric.Group} thisArg
     * @chainable
     */
    setObjectsCoords: function() {
      var skipControls = true;
      this.forEachObject(function(object) {
        object.setCoords(skipControls);
      });
      return this;
    },

    /**
     * @private
     */
    _calcBounds: function(onlyWidthHeight) {
      var aX = [],
          aY = [],
          o, prop,
          props = ['tr', 'br', 'bl', 'tl'],
          i = 0, iLen = this._objects.length,
          j, jLen = props.length;

      for ( ; i < iLen; ++i) {
        o = this._objects[i];
        o.aCoords = o.calcACoords();
        for (j = 0; j < jLen; j++) {
          prop = props[j];
          aX.push(o.aCoords[prop].x);
          aY.push(o.aCoords[prop].y);
        }
      }

      this._getBounds(aX, aY, onlyWidthHeight);
    },

    /**
     * @private
     */
    _getBounds: function(aX, aY, onlyWidthHeight) {
      var minXY = new fabric.Point(min(aX), min(aY)),
          maxXY = new fabric.Point(max(aX), max(aY)),
          top = minXY.y || 0, left = minXY.x || 0,
          width = (maxXY.x - minXY.x) || 0,
          height = (maxXY.y - minXY.y) || 0;
      this.width = width;
      this.height = height;
      if (!onlyWidthHeight) {
        // the bounding box always finds the topleft most corner.
        // whatever is the group origin, we set up here the left/top position.
        this.setPositionByOrigin({ x: left, y: top }, 'left', 'top');
      }
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    _toSVG: function(reviver) {
      var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t\t', this._objects[i].toSVG(reviver));
      }
      svgString.push('</g>\n');
      return svgString;
    },

    /**
     * Returns styles-string for svg-export, specific version for group
     * @return {String}
     */
    getSvgStyles: function() {
      var opacity = typeof this.opacity !== 'undefined' && this.opacity !== 1 ?
            'opacity: ' + this.opacity + ';' : '',
          visibility = this.visible ? '' : ' visibility: hidden;';
      return [
        opacity,
        this.getSvgFilter(),
        visibility
      ].join('');
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var svgString = [];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
      }

      return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Group} instance from an object representation
   * @static
   * @memberOf fabric.Group
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an group instance is created
   */
  fabric.Group.fromObject = function(object, callback) {
    var objects = object.objects,
        options = fabric.util.object.clone(object, true);
    delete options.objects;
    if (typeof objects === 'string') {
      // it has to be an url or something went wrong.
      fabric.loadSVGFromURL(objects, function (elements) {
        var group = fabric.util.groupSVGElements(elements, object, objects);
        group.set(options);
        callback && callback(group);
      });
      return;
    }
    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
      fabric.util.enlivenObjects([object.clipPath], function(enlivedClipPath) {
        var options = fabric.util.object.clone(object, true);
        options.clipPath = enlivedClipPath[0];
        delete options.objects;
        callback && callback(new fabric.Group(enlivenedObjects, options, true));
      });
    });
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.ActiveSelection) {
    return;
  }

  /**
   * Group class
   * @class fabric.ActiveSelection
   * @extends fabric.Group
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.ActiveSelection#initialize} for constructor definition
   */
  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'activeSelection',

    /**
     * Constructor
     * @param {Object} objects ActiveSelection objects
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(objects, options) {
      options = options || {};
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (options.originX) {
        this.originX = options.originX;
      }
      if (options.originY) {
        this.originY = options.originY;
      }
      this._calcBounds();
      this._updateObjectsCoords();
      fabric.Object.prototype.initialize.call(this, options);
      this.setCoords();
    },

    /**
     * Change te activeSelection to a normal group,
     * High level function that automatically adds it to canvas as
     * active object. no events fired.
     * @since 2.0.0
     * @return {fabric.Group}
     */
    toGroup: function() {
      var objects = this._objects.concat();
      this._objects = [];
      var options = fabric.Object.prototype.toObject.call(this);
      var newGroup = new fabric.Group([]);
      delete options.type;
      newGroup.set(options);
      objects.forEach(function(object) {
        object.canvas.remove(object);
        object.group = newGroup;
      });
      newGroup._objects = objects;
      if (!this.canvas) {
        return newGroup;
      }
      var canvas = this.canvas;
      canvas.add(newGroup);
      canvas._activeObject = newGroup;
      newGroup.setCoords();
      return newGroup;
    },

    /**
     * If returns true, deselection is cancelled.
     * @since 2.0.0
     * @return {Boolean} [cancel]
     */
    onDeselect: function() {
      this.destroy();
      return false;
    },

    /**
     * Returns string representation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return false;
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     * @param {Object} [childrenOverride] properties to override the children overrides
     */
    _renderControls: function(ctx, styleOverride, childrenOverride) {
      ctx.save();
      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      this.callSuper('_renderControls', ctx, styleOverride);
      childrenOverride = childrenOverride || { };
      if (typeof childrenOverride.hasControls === 'undefined') {
        childrenOverride.hasControls = false;
      }
      childrenOverride.forActiveSelection = true;
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i]._renderControls(ctx, childrenOverride);
      }
      ctx.restore();
    },
  });

  /**
   * Returns {@link fabric.ActiveSelection} instance from an object representation
   * @static
   * @memberOf fabric.ActiveSelection
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
   */
  fabric.ActiveSelection.fromObject = function(object, callback) {
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
      delete object.objects;
      callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
    });
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var extend = fabric.util.object.extend;

  if (!global.fabric) {
    global.fabric = { };
  }

  if (global.fabric.Image) {
    fabric.warn('fabric.Image is already defined.');
    return;
  }

  /**
   * Image class
   * @class fabric.Image
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
   * @see {@link fabric.Image#initialize} for constructor definition
   */
  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'image',

    /**
     * Width of a stroke.
     * For image quality a stroke multiple of 2 gives better results.
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.
     * This allows for relative urls as image src.
     * @since 2.7.0
     * @type Boolean
     * @default
     */
    srcFromAttribute: false,

    /**
     * private
     * contains last value of scaleX to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleX: 1,

    /**
     * private
     * contains last value of scaleY to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleY: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingX: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingY: 1,

    /**
     * minimum scale factor under which any resizeFilter is triggered to resize the image
     * 0 will disable the automatic resize. 1 will trigger automatically always.
     * number bigger than 1 are not implemented yet.
     * @type Number
     */
    minimumScaleTrigger: 0.5,

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),

    /**
     * key used to retrieve the texture representing this image
     * @since 2.0.0
     * @type String
     * @default
     */
    cacheKey: '',

    /**
     * Image crop in pixels from original image size.
     * @since 2.0.0
     * @type Number
     * @default
     */
    cropX: 0,

    /**
     * Image crop in pixels from original image size.
     * @since 2.0.0
     * @type Number
     * @default
     */
    cropY: 0,

    /**
     * Indicates whether this canvas will use image smoothing when painting this image.
     * Also influence if the cacheCanvas for this image uses imageSmoothing
     * @since 4.0.0-beta.11
     * @type Boolean
     * @default
     */
    imageSmoothing: true,

    /**
     * Constructor
     * @param {HTMLImageElement | String} element Image element
     * @param {Object} [options] Options object
     * @param {function} [callback] callback function to call after eventual filters applied.
     * @return {fabric.Image} thisArg
     */
    initialize: function(element, options) {
      options || (options = { });
      this.filters = [];
      this.cacheKey = 'texture' + fabric.Object.__uid++;
      this.callSuper('initialize', options);
      this._initElement(element, options);
    },

    /**
     * Returns image element which this instance if based on
     * @return {HTMLImageElement} Image element
     */
    getElement: function() {
      return this._element || {};
    },

    /**
     * Sets image element for this instance to a specified one.
     * If filters defined they are applied to new image.
     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
     * @param {HTMLImageElement} element
     * @param {Object} [options] Options object
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setElement: function(element, options) {
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._element = element;
      this._originalElement = element;
      this._initConfig(options);
      if (this.filters.length !== 0) {
        this.applyFilters();
      }
      // resizeFilters work on the already filtered copy.
      // we need to apply resizeFilters AFTER normal filters.
      // applyResizeFilters is run more often than normal filters
      // and is triggered by user interactions rather than dev code
      if (this.resizeFilter) {
        this.applyResizeFilters();
      }
      return this;
    },

    /**
     * Delete a single texture if in webgl mode
     */
    removeTexture: function(key) {
      var backend = fabric.filterBackend;
      if (backend && backend.evictCachesForKey) {
        backend.evictCachesForKey(key);
      }
    },

    /**
     * Delete textures, reference to elements and eventually JSDOM cleanup
     */
    dispose: function() {
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._cacheContext = undefined;
      ['_originalElement', '_element', '_filteredEl', '_cacheCanvas'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
    },

    /**
     * Get the crossOrigin value (of the corresponding image element)
     */
    getCrossOrigin: function() {
      return this._originalElement && (this._originalElement.crossOrigin || null);
    },

    /**
     * Returns original size of an image
     * @return {Object} Object with "width" and "height" properties
     */
    getOriginalSize: function() {
      var element = this.getElement();
      return {
        width: element.naturalWidth || element.width,
        height: element.naturalHeight || element.height
      };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _stroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }
      var w = this.width / 2, h = this.height / 2;
      ctx.beginPath();
      ctx.moveTo(-w, -h);
      ctx.lineTo(w, -h);
      ctx.lineTo(w, h);
      ctx.lineTo(-w, h);
      ctx.lineTo(-w, -h);
      ctx.closePath();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.save();
      this._setStrokeStyles(ctx, this);

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
      ctx.restore();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var filters = [];

      this.filters.forEach(function(filterObj) {
        if (filterObj) {
          filters.push(filterObj.toObject());
        }
      });
      var object = extend(
        this.callSuper(
          'toObject',
          ['cropX', 'cropY'].concat(propertiesToInclude)
        ), {
          src: this.getSrc(),
          crossOrigin: this.getCrossOrigin(),
          filters: filters,
        });
      if (this.resizeFilter) {
        object.resizeFilter = this.resizeFilter.toObject();
      }
      return object;
    },

    /**
     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.
     * @return {Boolean}
     */
    hasCrop: function() {
      return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString = [], imageMarkup = [], strokeSvg, element = this._element,
          x = -this.width / 2, y = -this.height / 2, clipPath = '', imageRendering = '';
      if (!element) {
        return [];
      }
      if (this.hasCrop()) {
        var clipPathId = fabric.Object.__uid++;
        svgString.push(
          '<clipPath id="imageCrop_' + clipPathId + '">\n',
          '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
          '</clipPath>\n'
        );
        clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
      }
      if (!this.imageSmoothing) {
        imageRendering = '" image-rendering="optimizeSpeed';
      }
      imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(true),
        '" x="', x - this.cropX, '" y="', y - this.cropY,
        // we're essentially moving origin of transformation from top/left corner to the center of the shape
        // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
        // so that object's center aligns with container's left/top
        '" width="', element.width || element.naturalWidth,
        '" height="', element.height || element.height,
        imageRendering,
        '"', clipPath,
        '></image>\n');

      if (this.stroke || this.strokeDashArray) {
        var origFill = this.fill;
        this.fill = null;
        strokeSvg = [
          '\t<rect ',
          'x="', x, '" y="', y,
          '" width="', this.width, '" height="', this.height,
          '" style="', this.getSvgStyles(),
          '"/>\n'
        ];
        this.fill = origFill;
      }
      if (this.paintFirst !== 'fill') {
        svgString = svgString.concat(strokeSvg, imageMarkup);
      }
      else {
        svgString = svgString.concat(imageMarkup, strokeSvg);
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * Returns source of an image
     * @param {Boolean} filtered indicates if the src is needed for svg
     * @return {String} Source of an image
     */
    getSrc: function(filtered) {
      var element = filtered ? this._element : this._originalElement;
      if (element) {
        if (element.toDataURL) {
          return element.toDataURL();
        }

        if (this.srcFromAttribute) {
          return element.getAttribute('src');
        }
        else {
          return element.src;
        }
      }
      else {
        return this.src || '';
      }
    },

    /**
     * Sets source of an image
     * @param {String} src Source string (URL)
     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
     * @param {Object} [options] Options object
     * @param {String} [options.crossOrigin] crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setSrc: function(src, callback, options) {
      fabric.util.loadImage(src, function(img, isError) {
        this.setElement(img, options);
        this._setWidthHeight();
        callback && callback(this, isError);
      }, this, options && options.crossOrigin);
      return this;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of an instance
     */
    toString: function() {
      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
    },

    applyResizeFilters: function() {
      var filter = this.resizeFilter,
          minimumScale = this.minimumScaleTrigger,
          objectScale = this.getTotalObjectScaling(),
          scaleX = objectScale.scaleX,
          scaleY = objectScale.scaleY,
          elementToFilter = this._filteredEl || this._originalElement;
      if (this.group) {
        this.set('dirty', true);
      }
      if (!filter || (scaleX > minimumScale && scaleY > minimumScale)) {
        this._element = elementToFilter;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        this._lastScaleX = scaleX;
        this._lastScaleY = scaleY;
        return;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      var canvasEl = fabric.util.createCanvasElement(),
          cacheKey = this._filteredEl ? (this.cacheKey + '_filtered') : this.cacheKey,
          sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
      canvasEl.width = sourceWidth;
      canvasEl.height = sourceHeight;
      this._element = canvasEl;
      this._lastScaleX = filter.scaleX = scaleX;
      this._lastScaleY = filter.scaleY = scaleY;
      fabric.filterBackend.applyFilters(
        [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);
      this._filterScalingX = canvasEl.width / this._originalElement.width;
      this._filterScalingY = canvasEl.height / this._originalElement.height;
    },

    /**
     * Applies filters assigned to this image (from "filters" array) or from filter param
     * @method applyFilters
     * @param {Array} filters to be applied
     * @param {Boolean} forResizing specify if the filter operation is a resize operation
     * @return {thisArg} return the fabric.Image object
     * @chainable
     */
    applyFilters: function(filters) {

      filters = filters || this.filters || [];
      filters = filters.filter(function(filter) { return filter && !filter.isNeutralState(); });
      this.set('dirty', true);

      // needs to clear out or WEBGL will not resize correctly
      this.removeTexture(this.cacheKey + '_filtered');

      if (filters.length === 0) {
        this._element = this._originalElement;
        this._filteredEl = null;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        return this;
      }

      var imgElement = this._originalElement,
          sourceWidth = imgElement.naturalWidth || imgElement.width,
          sourceHeight = imgElement.naturalHeight || imgElement.height;

      if (this._element === this._originalElement) {
        // if the element is the same we need to create a new element
        var canvasEl = fabric.util.createCanvasElement();
        canvasEl.width = sourceWidth;
        canvasEl.height = sourceHeight;
        this._element = canvasEl;
        this._filteredEl = canvasEl;
      }
      else {
        // clear the existing element to get new filter data
        // also dereference the eventual resized _element
        this._element = this._filteredEl;
        this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
        // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y
        this._lastScaleX = 1;
        this._lastScaleY = 1;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      fabric.filterBackend.applyFilters(
        filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
      if (this._originalElement.width !== this._element.width ||
        this._originalElement.height !== this._element.height) {
        this._filterScalingX = this._element.width / this._originalElement.width;
        this._filterScalingY = this._element.height / this._originalElement.height;
      }
      return this;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
      if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
        this.applyResizeFilters();
      }
      this._stroke(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * it will set the imageSmoothing for the draw operation
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
      fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * This is the special image version where we would like to avoid caching where possible.
     * Essentially images do not benefit from caching. They may require caching, and in that
     * case we do it. Also caching an image usually ends in a loss of details.
     * A full performance audit should be done.
     * @return {Boolean}
     */
    shouldCache: function() {
      return this.needsItsOwnCache();
    },

    _renderFill: function(ctx) {
      var elementToDraw = this._element;
      if (!elementToDraw) {
        return;
      }
      var scaleX = this._filterScalingX, scaleY = this._filterScalingY,
          w = this.width, h = this.height, min = Math.min, max = Math.max,
          // crop values cannot be lesser than 0.
          cropX = max(this.cropX, 0), cropY = max(this.cropY, 0),
          elWidth = elementToDraw.naturalWidth || elementToDraw.width,
          elHeight = elementToDraw.naturalHeight || elementToDraw.height,
          sX = cropX * scaleX,
          sY = cropY * scaleY,
          // the width height cannot exceed element width/height, starting from the crop offset.
          sW = min(w * scaleX, elWidth - sX),
          sH = min(h * scaleY, elHeight - sY),
          x = -w / 2, y = -h / 2,
          maxDestW = min(w, elWidth / scaleX - cropX),
          maxDestH = min(h, elHeight / scaleX - cropY);

      elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);
    },

    /**
     * needed to check if image needs resize
     * @private
     */
    _needsResize: function() {
      var scale = this.getTotalObjectScaling();
      return (scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY);
    },

    /**
     * @private
     */
    _resetWidthHeight: function() {
      this.set(this.getOriginalSize());
    },

    /**
     * The Image class's initialization method. This method is automatically
     * called by the constructor.
     * @private
     * @param {HTMLImageElement|String} element The element representing the image
     * @param {Object} [options] Options object
     */
    _initElement: function(element, options) {
      this.setElement(fabric.util.getById(element), options);
      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initConfig: function(options) {
      options || (options = { });
      this.setOptions(options);
      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Array} filters to be initialized
     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
     */
    _initFilters: function(filters, callback) {
      if (filters && filters.length) {
        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
          callback && callback(enlivenedObjects);
        }, 'fabric.Image.filters');
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * Set the width and the height of the image object, using the element or the
     * options.
     * @param {Object} [options] Object with width/height properties
     */
    _setWidthHeight: function(options) {
      options || (options = { });
      var el = this.getElement();
      this.width = options.width || el.naturalWidth || el.width || 0;
      this.height = options.height || el.naturalHeight || el.height || 0;
    },

    /**
     * Calculate offset for center and scale factor for the image in order to respect
     * the preserveAspectRatio attribute
     * @private
     * @return {Object}
     */
    parsePreserveAspectRatioAttribute: function() {
      var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),
          rWidth = this._element.width, rHeight = this._element.height,
          scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,
          offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
      if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
        if (pAR.meetOrSlice === 'meet') {
          scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
          offset = (pWidth - rWidth * scaleX) / 2;
          if (pAR.alignX === 'Min') {
            offsetLeft = -offset;
          }
          if (pAR.alignX === 'Max') {
            offsetLeft = offset;
          }
          offset = (pHeight - rHeight * scaleY) / 2;
          if (pAR.alignY === 'Min') {
            offsetTop = -offset;
          }
          if (pAR.alignY === 'Max') {
            offsetTop = offset;
          }
        }
        if (pAR.meetOrSlice === 'slice') {
          scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
          offset = rWidth - pWidth / scaleX;
          if (pAR.alignX === 'Mid') {
            cropX = offset / 2;
          }
          if (pAR.alignX === 'Max') {
            cropX = offset;
          }
          offset = rHeight - pHeight / scaleY;
          if (pAR.alignY === 'Mid') {
            cropY = offset / 2;
          }
          if (pAR.alignY === 'Max') {
            cropY = offset;
          }
          rWidth = pWidth / scaleX;
          rHeight = pHeight / scaleY;
        }
      }
      else {
        scaleX = pWidth / rWidth;
        scaleY = pHeight / rHeight;
      }
      return {
        width: rWidth,
        height: rHeight,
        scaleX: scaleX,
        scaleY: scaleY,
        offsetLeft: offsetLeft,
        offsetTop: offsetTop,
        cropX: cropX,
        cropY: cropY
      };
    }
  });

  /**
   * Default CSS class name for canvas
   * @static
   * @type String
   * @default
   */
  fabric.Image.CSS_CANVAS = 'canvas-img';

  /**
   * Alias for getSrc
   * @static
   */
  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

  /**
   * Creates an instance of fabric.Image from its object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} callback Callback to invoke when an image instance is created
   */
  fabric.Image.fromObject = function(_object, callback) {
    var object = fabric.util.object.clone(_object);
    fabric.util.loadImage(object.src, function(img, isError) {
      if (isError) {
        callback && callback(null, true);
        return;
      }
      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
        object.filters = filters || [];
        fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
          object.resizeFilter = resizeFilters[0];
          fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
            object.clipPath = enlivedProps[0];
            var image = new fabric.Image(img, object);
            callback(image, false);
          });
        });
      });
    }, null, object.crossOrigin);
  };

  /**
   * Creates an instance of fabric.Image from an URL string
   * @static
   * @param {String} url URL to create an image from
   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.
   * @param {Object} [imgOptions] Options object
   */
  fabric.Image.fromURL = function(url, callback, imgOptions) {
    fabric.util.loadImage(url, function(img, isError) {
      callback && callback(new fabric.Image(img, imgOptions), isError);
    }, null, imgOptions && imgOptions.crossOrigin);
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
   * @static
   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
   */
  fabric.Image.ATTRIBUTE_NAMES =
    fabric.SHARED_ATTRIBUTES.concat(
      'x y width height preserveAspectRatio xlink:href crossOrigin image-rendering'.split(' ')
    );

  /**
   * Returns {@link fabric.Image} instance from an SVG element
   * @static
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} callback Callback to execute when fabric.Image object is created
   * @return {fabric.Image} Instance of fabric.Image
   */
  fabric.Image.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : 0);


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * @private
   * @return {Number} angle value
   */
  _getAngleValueForStraighten: function() {
    var angle = this.angle % 360;
    if (angle > 0) {
      return Math.round((angle - 1) / 90) * 90;
    }
    return Math.round(angle / 90) * 90;
  },

  /**
   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  straighten: function() {
    this.rotate(this._getAngleValueForStraighten());
    return this;
  },

  /**
   * Same as {@link fabric.Object.prototype.straighten} but with animation
   * @param {Object} callbacks Object with callback functions
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Object} thisArg
   * @chainable
   */
  fxStraighten: function(callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: this.get('angle'),
      endValue: this._getAngleValueForStraighten(),
      duration: this.FX_DURATION,
      onChange: function(value) {
        _this.rotate(value);
        onChange();
      },
      onComplete: function() {
        _this.setCoords();
        onComplete();
      },
    });

    return this;
  }
});

fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Straightens object, then rerenders canvas
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  straightenObject: function (object) {
    object.straighten();
    this.requestRenderAll();
    return this;
  },

  /**
   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxStraightenObject: function (object) {
    object.fxStraighten({
      onChange: this.requestRenderAllBound
    });
    return this;
  }
});


(function() {

  'use strict';

  /**
   * Tests if webgl supports certain precision
   * @param {WebGL} Canvas WebGL context to test on
   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'
   * @returns {Boolean} Whether the user's browser WebGL supports given precision.
   */
  function testPrecision(gl, precision){
    var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    return true;
  }

  /**
   * Indicate whether this filtering backend is supported by the user's browser.
   * @param {Number} tileSize check if the tileSize is supported
   * @returns {Boolean} Whether the user's browser supports WebGL.
   */
  fabric.isWebglSupported = function(tileSize) {
    if (fabric.isLikelyNode) {
      return false;
    }
    tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    var isSupported = false;
    // eslint-disable-next-line
    if (gl) {
      fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      isSupported = fabric.maxTextureSize >= tileSize;
      var precisions = ['highp', 'mediump', 'lowp'];
      for (var i = 0; i < 3; i++){
        if (testPrecision(gl, precisions[i])){
          fabric.webGlPrecision = precisions[i];
          break;
        };
      }
    }
    this.isSupported = isSupported;
    return isSupported;
  };

  fabric.WebglFilterBackend = WebglFilterBackend;

  /**
   * WebGL filter backend.
   */
  function WebglFilterBackend(options) {
    if (options && options.tileSize) {
      this.tileSize = options.tileSize;
    }
    this.setupGLContext(this.tileSize, this.tileSize);
    this.captureGPUInfo();
  };

  WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

    tileSize: 2048,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
     */
    setupGLContext: function(width, height) {
      this.dispose();
      this.createWebGLCanvas(width, height);
      // eslint-disable-next-line
      this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
      this.chooseFastestCopyGLTo2DMethod(width, height);
    },

    /**
     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
     * putImageData is faster than drawImage for that specific operation.
     */
    chooseFastestCopyGLTo2DMethod: function(width, height) {
      var canMeasurePerf = typeof window.performance !== 'undefined', canUseImageData;
      try {
        new ImageData(1, 1);
        canUseImageData = true;
      }
      catch (e) {
        canUseImageData = false;
      }
      // eslint-disable-next-line no-undef
      var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
      // eslint-disable-next-line no-undef
      var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

      if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
        return;
      }

      var targetCanvas = fabric.util.createCanvasElement();
      // eslint-disable-next-line no-undef
      var imageBuffer = new ArrayBuffer(width * height * 4);
      if (fabric.forceGLPutImageData) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
        return;
      }
      var testContext = {
        imageBuffer: imageBuffer,
        destinationWidth: width,
        destinationHeight: height,
        targetCanvas: targetCanvas
      };
      var startTime, drawImageTime, putImageDataTime;
      targetCanvas.width = width;
      targetCanvas.height = height;

      startTime = window.performance.now();
      copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
      drawImageTime = window.performance.now() - startTime;

      startTime = window.performance.now();
      copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
      putImageDataTime = window.performance.now() - startTime;

      if (drawImageTime > putImageDataTime) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
      }
      else {
        this.copyGLTo2D = copyGLTo2DDrawImage;
      }
    },

    /**
     * Create a canvas element and associated WebGL context and attaches them as
     * class properties to the GLFilterBackend class.
     */
    createWebGLCanvas: function(width, height) {
      var canvas = fabric.util.createCanvasElement();
      canvas.width = width;
      canvas.height = height;
      var glOptions = {
            alpha: true,
            premultipliedAlpha: false,
            depth: false,
            stencil: false,
            antialias: false
          },
          gl = canvas.getContext('webgl', glOptions);
      if (!gl) {
        gl = canvas.getContext('experimental-webgl', glOptions);
      }
      if (!gl) {
        return;
      }
      gl.clearColor(0, 0, 0, 0);
      // this canvas can fire webglcontextlost and webglcontextrestored
      this.canvas = canvas;
      this.gl = gl;
    },

    /**
     * Attempts to apply the requested filters to the source provided, drawing the filtered output
     * to the provided target canvas.
     *
     * @param {Array} filters The filters to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
     * @param {Number} width The width of the source input.
     * @param {Number} height The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
     * omitted, caching will be skipped.
     */
    applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
      var gl = this.gl;
      var cachedTexture;
      if (cacheKey) {
        cachedTexture = this.getCachedTexture(cacheKey, source);
      }
      var pipelineState = {
        originalWidth: source.width || source.originalWidth,
        originalHeight: source.height || source.originalHeight,
        sourceWidth: width,
        sourceHeight: height,
        destinationWidth: width,
        destinationHeight: height,
        context: gl,
        sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
        targetTexture: this.createTexture(gl, width, height),
        originalTexture: cachedTexture ||
          this.createTexture(gl, width, height, !cachedTexture && source),
        passes: filters.length,
        webgl: true,
        aPosition: this.aPosition,
        programCache: this.programCache,
        pass: 0,
        filterBackend: this,
        targetCanvas: targetCanvas
      };
      var tempFbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
      filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
      resizeCanvasIfNeeded(pipelineState);
      this.copyGLTo2D(gl, pipelineState);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.deleteTexture(pipelineState.sourceTexture);
      gl.deleteTexture(pipelineState.targetTexture);
      gl.deleteFramebuffer(tempFbo);
      targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
      return pipelineState;
    },

    /**
     * Detach event listeners, remove references, and clean up caches.
     */
    dispose: function() {
      if (this.canvas) {
        this.canvas = null;
        this.gl = null;
      }
      this.clearWebGLCaches();
    },

    /**
     * Wipe out WebGL-related caches.
     */
    clearWebGLCaches: function() {
      this.programCache = {};
      this.textureCache = {};
    },

    /**
     * Create a WebGL texture object.
     *
     * Accepts specific dimensions to initialize the texture to or a source image.
     *
     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
     * @param {Number} width The width to initialize the texture at.
     * @param {Number} height The height to initialize the texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
     * @returns {WebGLTexture}
     */
    createTexture: function(gl, width, height, textureImageSource) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (textureImageSource) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
      }
      else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      return texture;
    },

    /**
     * Can be optionally used to get a texture from the cache array
     *
     * If an existing texture is not found, a new texture is created and cached.
     *
     * @param {String} uniqueId A cache key to use to find an existing texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
     * texture cache entry if one does not already exist.
     */
    getCachedTexture: function(uniqueId, textureImageSource) {
      if (this.textureCache[uniqueId]) {
        return this.textureCache[uniqueId];
      }
      else {
        var texture = this.createTexture(
          this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
        this.textureCache[uniqueId] = texture;
        return texture;
      }
    },

    /**
     * Clear out cached resources related to a source image that has been
     * filtered previously.
     *
     * @param {String} cacheKey The cache key provided when the source image was filtered.
     */
    evictCachesForKey: function(cacheKey) {
      if (this.textureCache[cacheKey]) {
        this.gl.deleteTexture(this.textureCache[cacheKey]);
        delete this.textureCache[cacheKey];
      }
    },

    copyGLTo2D: copyGLTo2DDrawImage,

    /**
     * Attempt to extract GPU information strings from a WebGL context.
     *
     * Useful information when debugging or blacklisting specific GPUs.
     *
     * @returns {Object} A GPU info object with renderer and vendor strings.
     */
    captureGPUInfo: function() {
      if (this.gpuInfo) {
        return this.gpuInfo;
      }
      var gl = this.gl, gpuInfo = { renderer: '', vendor: '' };
      if (!gl) {
        return gpuInfo;
      }
      var ext = gl.getExtension('WEBGL_debug_renderer_info');
      if (ext) {
        var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
        var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
        if (renderer) {
          gpuInfo.renderer = renderer.toLowerCase();
        }
        if (vendor) {
          gpuInfo.vendor = vendor.toLowerCase();
        }
      }
      this.gpuInfo = gpuInfo;
      return gpuInfo;
    },
  };
})();

function resizeCanvasIfNeeded(pipelineState) {
  var targetCanvas = pipelineState.targetCanvas,
      width = targetCanvas.width, height = targetCanvas.height,
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight;

  if (width !== dWidth || height !== dHeight) {
    targetCanvas.width = dWidth;
    targetCanvas.height = dHeight;
  }
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas.
 *
 * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
 * desired output image appearing in the bottom-left corner of the WebGL canvas.
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DDrawImage(gl, pipelineState) {
  var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,
      ctx = targetCanvas.getContext('2d');
  ctx.translate(0, targetCanvas.height); // move it down again
  ctx.scale(1, -1); // vertical flip
  // where is my image on the big glcanvas?
  var sourceY = glCanvas.height - targetCanvas.height;
  ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
    targetCanvas.width, targetCanvas.height);
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
 * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DPutImageData(gl, pipelineState) {
  var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight,
      numBytes = dWidth * dHeight * 4;

  // eslint-disable-next-line no-undef
  var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
  // eslint-disable-next-line no-undef
  var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);

  gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
  var imgData = new ImageData(u8Clamped, dWidth, dHeight);
  ctx.putImageData(imgData, 0, 0);
}


(function() {

  'use strict';

  var noop = function() {};

  fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

  /**
   * Canvas 2D filter backend.
   */
  function Canvas2dFilterBackend() {};

  Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
    evictCachesForKey: noop,
    dispose: noop,
    clearWebGLCaches: noop,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Apply a set of filters against a source image and draw the filtered output
     * to the provided destination canvas.
     *
     * @param {EnhancedFilter} filters The filter to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
     * @param {Number} sourceWidth The width of the source input.
     * @param {Number} sourceHeight The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     */
    applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
      var ctx = targetCanvas.getContext('2d');
      ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
      var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var pipelineState = {
        sourceWidth: sourceWidth,
        sourceHeight: sourceHeight,
        imageData: imageData,
        originalEl: sourceElement,
        originalImageData: originalImageData,
        canvasEl: targetCanvas,
        ctx: ctx,
        filterBackend: this,
      };
      filters.forEach(function(filter) { filter.applyTo(pipelineState); });
      if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
        targetCanvas.width = pipelineState.imageData.width;
        targetCanvas.height = pipelineState.imageData.height;
      }
      ctx.putImageData(pipelineState.imageData, 0, 0);
      return pipelineState;
    },

  };
})();


/**
 * @namespace fabric.Image.filters
 * @memberOf fabric.Image
 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
 */
fabric.Image = fabric.Image || { };
fabric.Image.filters = fabric.Image.filters || { };

/**
 * Root filter class from which all filter classes inherit from
 * @class fabric.Image.filters.BaseFilter
 * @memberOf fabric.Image.filters
 */
fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

  /**
   * Filter type
   * @param {String} type
   * @default
   */
  type: 'BaseFilter',

  /**
   * Array of attributes to send with buffers. do not modify
   * @private
   */

  vertexSource: 'attribute vec2 aPosition;\n' +
    'varying vec2 vTexCoord;\n' +
    'void main() {\n' +
      'vTexCoord = aPosition;\n' +
      'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
    '}',

  fragmentSource: 'precision highp float;\n' +
    'varying vec2 vTexCoord;\n' +
    'uniform sampler2D uTexture;\n' +
    'void main() {\n' +
      'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
    '}',

  /**
   * Constructor
   * @param {Object} [options] Options object
   */
  initialize: function(options) {
    if (options) {
      this.setOptions(options);
    }
  },

  /**
   * Sets filter's properties from options
   * @param {Object} [options] Options object
   */
  setOptions: function(options) {
    for (var prop in options) {
      this[prop] = options[prop];
    }
  },

  /**
   * Compile this filter's shader program.
   *
   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
   * @param {String} fragmentSource fragmentShader source for compilation
   * @param {String} vertexSource vertexShader source for compilation
   */
  createProgram: function(gl, fragmentSource, vertexSource) {
    fragmentSource = fragmentSource || this.fragmentSource;
    vertexSource = vertexSource || this.vertexSource;
    if (fabric.webGlPrecision !== 'highp'){
      fragmentSource = fragmentSource.replace(
        /precision highp float/g,
        'precision ' + fabric.webGlPrecision + ' float'
      );
    }
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Vertex shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(vertexShader)
      );
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Fragment shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(fragmentShader)
      );
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Shader link error for "${this.type}" ' +
        gl.getProgramInfoLog(program)
      );
    }

    var attributeLocations = this.getAttributeLocations(gl, program);
    var uniformLocations = this.getUniformLocations(gl, program) || { };
    uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
    uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
    return {
      program: program,
      attributeLocations: attributeLocations,
      uniformLocations: uniformLocations
    };
  },

  /**
   * Return a map of attribute names to WebGLAttributeLocation objects.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
   * @returns {Object} A map of attribute names to attribute locations.
   */
  getAttributeLocations: function(gl, program) {
    return {
      aPosition: gl.getAttribLocation(program, 'aPosition'),
    };
  },

  /**
   * Return a map of uniform names to WebGLUniformLocation objects.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
   * @returns {Object} A map of uniform names to uniform locations.
   */
  getUniformLocations: function (/* gl, program */) {
    // in case i do not need any special uniform i need to return an empty object
    return { };
  },

  /**
   * Send attribute data from this filter to its shader program on the GPU.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} attributeLocations A map of shader attribute names to their locations.
   */
  sendAttributeData: function(gl, attributeLocations, aPositionData) {
    var attributeLocation = attributeLocations.aPosition;
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(attributeLocation);
    gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
  },

  _setupFrameBuffer: function(options) {
    var gl = options.context, width, height;
    if (options.passes > 1) {
      width = options.destinationWidth;
      height = options.destinationHeight;
      if (options.sourceWidth !== width || options.sourceHeight !== height) {
        gl.deleteTexture(options.targetTexture);
        options.targetTexture = options.filterBackend.createTexture(gl, width, height);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        options.targetTexture, 0);
    }
    else {
      // draw last filter on canvas and not to framebuffer.
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.finish();
    }
  },

  _swapTextures: function(options) {
    options.passes--;
    options.pass++;
    var temp = options.targetTexture;
    options.targetTexture = options.sourceTexture;
    options.sourceTexture = temp;
  },

  /**
   * Generic isNeutral implementation for one parameter based filters.
   * Used only in image applyFilters to discard filters that will not have an effect
   * on the image
   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )
   * @param {Object} options
   **/
  isNeutralState: function(/* options */) {
    var main = this.mainParameter,
        _class = fabric.Image.filters[this.type].prototype;
    if (main) {
      if (Array.isArray(_class[main])) {
        for (var i = _class[main].length; i--;) {
          if (this[main][i] !== _class[main][i]) {
            return false;
          }
        }
        return true;
      }
      else {
        return _class[main] === this[main];
      }
    }
    else {
      return false;
    }
  },

  /**
   * Apply this filter to the input image data provided.
   *
   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyTo: function(options) {
    if (options.webgl) {
      this._setupFrameBuffer(options);
      this.applyToWebGL(options);
      this._swapTextures(options);
    }
    else {
      this.applyTo2d(options);
    }
  },

  /**
   * Retrieves the cached shader.
   * @param {Object} options
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  retrieveShader: function(options) {
    if (!options.programCache.hasOwnProperty(this.type)) {
      options.programCache[this.type] = this.createProgram(options.context);
    }
    return options.programCache[this.type];
  },

  /**
   * Apply this filter using webgl.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.originalTexture The texture of the original input image.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyToWebGL: function(options) {
    var gl = options.context;
    var shader = this.retrieveShader(options);
    if (options.pass === 0 && options.originalTexture) {
      gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
    }
    else {
      gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
    }
    gl.useProgram(shader.program);
    this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);

    gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
    gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

    this.sendUniformData(gl, shader.uniformLocations);
    gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  },

  bindAdditionalTexture: function(gl, texture, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // reset active texture to 0 as usual
    gl.activeTexture(gl.TEXTURE0);
  },

  unbindAdditionalTexture: function(gl, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.activeTexture(gl.TEXTURE0);
  },

  getMainParameter: function() {
    return this[this.mainParameter];
  },

  setMainParameter: function(value) {
    this[this.mainParameter] = value;
  },

  /**
   * Send uniform data from this filter to its shader program on the GPU.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} uniformLocations A map of shader uniform names to their locations.
   */
  sendUniformData: function(/* gl, uniformLocations */) {
    // Intentionally left blank.  Override me in subclasses.
  },

  /**
   * If needed by a 2d filter, this functions can create an helper canvas to be used
   * remember that options.targetCanvas is available for use till end of chain.
   */
  createHelpLayer: function(options) {
    if (!options.helpLayer) {
      var helpLayer = document.createElement('canvas');
      helpLayer.width = options.sourceWidth;
      helpLayer.height = options.sourceHeight;
      options.helpLayer = helpLayer;
    }
  },

  /**
   * Returns object representation of an instance
   * @return {Object} Object representation of an instance
   */
  toObject: function() {
    var object = { type: this.type }, mainP = this.mainParameter;
    if (mainP) {
      object[mainP] = this[mainP];
    }
    return object;
  },

  /**
   * Returns a JSON representation of an instance
   * @return {Object} JSON
   */
  toJSON: function() {
    // delegate, not alias
    return this.toObject();
  }
});

fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
  var filter = new fabric.Image.filters[object.type](object);
  callback && callback(filter);
  return filter;
};


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Matrix filter class
   * @class fabric.Image.filters.ColorMatrix
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
   * @example <caption>Kodachrome filter</caption>
   * var filter = new fabric.Image.filters.ColorMatrix({
   *  matrix: [
       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
       0, 0, 0, 1, 0
      ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'ColorMatrix',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform mat4 uColorMatrix;\n' +
      'uniform vec4 uConstants;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color *= uColorMatrix;\n' +
        'color += uConstants;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Colormatrix for pixels.
     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
     * outside the -1, 1 range.
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Array} matrix array of 20 numbers.
     * @default
     */
    matrix: [
      1, 0, 0, 0, 0,
      0, 1, 0, 0, 0,
      0, 0, 1, 0, 0,
      0, 0, 0, 1, 0
    ],

    mainParameter: 'matrix',

    /**
     * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario
     * to save some calculation
     */
    colorsOnly: true,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.matrix = this.matrix.slice(0);
    },

    /**
     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = data.length,
          m = this.matrix,
          r, g, b, a, i, colorsOnly = this.colorsOnly;

      for (i = 0; i < iLen; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        if (colorsOnly) {
          data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
        }
        else {
          a = data[i + 3];
          data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
          data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
        uConstants: gl.getUniformLocation(program, 'uConstants'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var m = this.matrix,
          matrix = [
            m[0], m[1], m[2], m[3],
            m[5], m[6], m[7], m[8],
            m[10], m[11], m[12], m[13],
            m[15], m[16], m[17], m[18]
          ],
          constants = [m[4], m[9], m[14], m[19]];
      gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
      gl.uniform4fv(uniformLocations.uConstants, constants);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] function to invoke after filter creation
   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
   */
  fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Brightness filter class
   * @class fabric.Image.filters.Brightness
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Brightness({
   *   brightness: 0.05
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Brightness',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBrightness;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += uBrightness;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Brightness value, from -1 to 1.
     * translated to -255 to 255 for 2d
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Number} brightness
     * @default
     */
    brightness: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'brightness',

    /**
    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
    *
    * @param {Object} options
    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
    */
    applyTo2d: function(options) {
      if (this.brightness === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          brightness = Math.round(this.brightness * 255);
      for (i = 0; i < len; i += 4) {
        data[i] = data[i] + brightness;
        data[i + 1] = data[i + 1] + brightness;
        data[i + 2] = data[i + 2] + brightness;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBrightness: gl.getUniformLocation(program, 'uBrightness'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBrightness, this.brightness);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
   */
  fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
   * @class fabric.Image.filters.Convolute
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example <caption>Sharpen filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 0, -1,  0,
   *            -1,  5, -1,
   *             0, -1,  0 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Blur filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter with opaqueness</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   opaque: true,
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Convolute',

    /*
     * Opaque value (true/false)
     */
    opaque: false,

    /*
     * matrix for the filter, max 9x9
     */
    matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: {
      Convolute_3_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_3_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_5_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_5_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_7_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_7_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_9_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_9_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
    },

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Convolute.prototype
     * @param {Object} [options] Options object
     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
     * @param {Array} [options.matrix] Filter matrix
     */


    /**
    * Retrieves the cached shader.
    * @param {Object} options
    * @param {WebGLRenderingContext} options.context The GL context used for rendering.
    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
    */
    retrieveShader: function(options) {
      var size = Math.sqrt(this.matrix.length);
      var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);
      var shaderSource = this.fragmentSource[cacheKey];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          weights = this.matrix,
          side = Math.round(Math.sqrt(weights.length)),
          halfSide = Math.floor(side / 2),
          sw = imageData.width,
          sh = imageData.height,
          output = options.ctx.createImageData(sw, sh),
          dst = output.data,
          // go through the destination image pixels
          alphaFac = this.opaque ? 1 : 0,
          r, g, b, a, dstOff,
          scx, scy, srcOff, wt,
          x, y, cx, cy;

      for (y = 0; y < sh; y++) {
        for (x = 0; x < sw; x++) {
          dstOff = (y * sw + x) * 4;
          // calculate the weighed sum of the source image pixels that
          // fall under the convolution matrix
          r = 0; g = 0; b = 0; a = 0;

          for (cy = 0; cy < side; cy++) {
            for (cx = 0; cx < side; cx++) {
              scy = y + cy - halfSide;
              scx = x + cx - halfSide;

              // eslint-disable-next-line max-depth
              if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {
                continue;
              }

              srcOff = (scy * sw + scx) * 4;
              wt = weights[cy * side + cx];

              r += data[srcOff] * wt;
              g += data[srcOff + 1] * wt;
              b += data[srcOff + 2] * wt;
              // eslint-disable-next-line max-depth
              if (!alphaFac) {
                a += data[srcOff + 3] * wt;
              }
            }
          }
          dst[dstOff] = r;
          dst[dstOff + 1] = g;
          dst[dstOff + 2] = b;
          if (!alphaFac) {
            dst[dstOff + 3] = a;
          }
          else {
            dst[dstOff + 3] = data[dstOff + 3];
          }
        }
      }
      options.imageData = output;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMatrix: gl.getUniformLocation(program, 'uMatrix'),
        uOpaque: gl.getUniformLocation(program, 'uOpaque'),
        uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
        uSize: gl.getUniformLocation(program, 'uSize'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        opaque: this.opaque,
        matrix: this.matrix
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
   */
  fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Grayscale image filter class
   * @class fabric.Image.filters.Grayscale
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Grayscale();
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Grayscale',

    fragmentSource: {
      average: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float average = (color.r + color.b + color.g) / 3.0;\n' +
          'gl_FragColor = vec4(average, average, average, color.a);\n' +
        '}',
      lightness: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
      luminosity: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
    },


    /**
     * Grayscale mode, between 'average', 'lightness', 'luminosity'
     * @param {String} type
     * @default
     */
    mode: 'average',

    mainParameter: 'mode',

    /**
     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length, value,
          mode = this.mode;
      for (i = 0; i < len; i += 4) {
        if (mode === 'average') {
          value = (data[i] + data[i + 1] + data[i + 2]) / 3;
        }
        else if (mode === 'lightness') {
          value = (Math.min(data[i], data[i + 1], data[i + 2]) +
            Math.max(data[i], data[i + 1], data[i + 2])) / 2;
        }
        else if (mode === 'luminosity') {
          value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
        }
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var shaderSource = this.fragmentSource[this.mode];
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMode: gl.getUniformLocation(program, 'uMode'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      // default average mode.
      var mode = 1;
      gl.uniform1i(uniformLocations.uMode, mode);
    },

    /**
     * Grayscale filter isNeutralState implementation
     * The filter is never neutral
     * on the image
     **/
    isNeutralState: function() {
      return false;
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
   */
  fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Invert filter class
   * @class fabric.Image.filters.Invert
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Invert();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Invert',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform int uInvert;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'if (uInvert == 1) {\n' +
          'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
        '} else {\n' +
          'gl_FragColor = color;\n' +
        '}\n' +
      '}',

    /**
     * Filter invert. if false, does nothing
     * @param {Boolean} invert
     * @default
     */
    invert: true,

    mainParameter: 'invert',

    /**
     * Apply the Invert operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length;
      for (i = 0; i < len; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
      }
    },

    /**
     * Invert filter isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function() {
      return !this.invert;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uInvert: gl.getUniformLocation(program, 'uInvert'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1i(uniformLocations.uInvert, this.invert);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
   */
  fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Noise filter class
   * @class fabric.Image.filters.Noise
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Noise({
   *   noise: 700
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Noise',

    /**
     * Fragment source for the noise program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uStepH;\n' +
      'uniform float uNoise;\n' +
      'uniform float uSeed;\n' +
      'varying vec2 vTexCoord;\n' +
      'float rand(vec2 co, float seed, float vScale) {\n' +
        'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'noise',

    /**
     * Noise value, from
     * @param {Number} noise
     * @default
     */
    noise: 0,

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.noise === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          noise = this.noise, rand;

      for (i = 0, len = data.length; i < len; i += 4) {

        rand = (0.5 - Math.random()) * noise;

        data[i] += rand;
        data[i + 1] += rand;
        data[i + 2] += rand;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uNoise: gl.getUniformLocation(program, 'uNoise'),
        uSeed: gl.getUniformLocation(program, 'uSeed'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
      gl.uniform1f(uniformLocations.uSeed, Math.random());
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        noise: this.noise
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
   */
  fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Pixelate filter class
   * @class fabric.Image.filters.Pixelate
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Pixelate({
   *   blocksize: 8
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Pixelate',

    blocksize: 4,

    mainParameter: 'blocksize',

    /**
     * Fragment source for the Pixelate program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBlocksize;\n' +
      'uniform float uStepW;\n' +
      'uniform float uStepH;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'float blockW = uBlocksize * uStepW;\n' +
        'float blockH = uBlocksize * uStepW;\n' +
        'int posX = int(vTexCoord.x / blockW);\n' +
        'int posY = int(vTexCoord.y / blockH);\n' +
        'float fposX = float(posX);\n' +
        'float fposY = float(posY);\n' +
        'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
        'vec4 color = texture2D(uTexture, squareCoords);\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = imageData.height,
          jLen = imageData.width,
          index, i, j, r, g, b, a,
          _i, _j, _iLen, _jLen;

      for (i = 0; i < iLen; i += this.blocksize) {
        for (j = 0; j < jLen; j += this.blocksize) {

          index = (i * 4) * jLen + (j * 4);

          r = data[index];
          g = data[index + 1];
          b = data[index + 2];
          a = data[index + 3];

          _iLen = Math.min(i + this.blocksize, iLen);
          _jLen = Math.min(j + this.blocksize, jLen);
          for (_i = i; _i < _iLen; _i++) {
            for (_j = j; _j < _jLen; _j++) {
              index = (_i * 4) * jLen + (_j * 4);
              data[index] = r;
              data[index + 1] = g;
              data[index + 2] = b;
              data[index + 3] = a;
            }
          }
        }
      }
    },

    /**
     * Indicate when the filter is not gonna apply changes to the image
     **/
    isNeutralState: function() {
      return this.blocksize === 1;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
        uStepW: gl.getUniformLocation(program, 'uStepW'),
        uStepH: gl.getUniformLocation(program, 'uStepH'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
   */
  fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Remove white filter class
   * @class fabric.Image.filters.RemoveColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.RemoveColor({
   *   threshold: 0.2,
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'RemoveColor',

    /**
     * Color to remove, in any format understood by fabric.Color.
     * @param {String} type
     * @default
     */
    color: '#FFFFFF',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec4 uLow;\n' +
      'uniform vec4 uHigh;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
        'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
          'gl_FragColor.a = 0.0;\n' +
        '}\n' +
      '}',

    /**
     * distance to actual color, as value up or down from each r,g,b
     * between 0 and 1
     **/
    distance: 0.02,

    /**
     * For color to remove inside distance, use alpha channel for a smoother deletion
     * NOT IMPLEMENTED YET
     **/
    useAlpha: false,

    /**
     * Constructor
     * @memberOf fabric.Image.filters.RemoveWhite.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.color=#RRGGBB] Threshold value
     * @param {Number} [options.distance=10] Distance value
     */

    /**
     * Applies filter to canvas element
     * @param {Object} canvasEl Canvas element to apply filter to
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          distance = this.distance * 255,
          r, g, b,
          source = new fabric.Color(this.color).getSource(),
          lowC = [
            source[0] - distance,
            source[1] - distance,
            source[2] - distance,
          ],
          highC = [
            source[0] + distance,
            source[1] + distance,
            source[2] + distance,
          ];


      for (i = 0; i < data.length; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        if (r > lowC[0] &&
            g > lowC[1] &&
            b > lowC[2] &&
            r < highC[0] &&
            g < highC[1] &&
            b < highC[2]) {
          data[i + 3] = 0;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uLow: gl.getUniformLocation(program, 'uLow'),
        uHigh: gl.getUniformLocation(program, 'uHigh'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource(),
          distance = parseFloat(this.distance),
          lowC = [
            0 + source[0] / 255 - distance,
            0 + source[1] / 255 - distance,
            0 + source[2] / 255 - distance,
            1
          ],
          highC = [
            source[0] / 255 + distance,
            source[1] / 255 + distance,
            source[2] / 255 + distance,
            1
          ];
      gl.uniform4fv(uniformLocations.uLow, lowC);
      gl.uniform4fv(uniformLocations.uHigh, highC);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        color: this.color,
        distance: this.distance
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
   */
  fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  var matrices = {
    Brownie: [
      0.59970,0.34553,-0.27082,0,0.186,
      -0.03770,0.86095,0.15059,0,-0.1449,
      0.24113,-0.07441,0.44972,0,-0.02965,
      0,0,0,1,0
    ],
    Vintage: [
      0.62793,0.32021,-0.03965,0,0.03784,
      0.02578,0.64411,0.03259,0,0.02926,
      0.04660,-0.08512,0.52416,0,0.02023,
      0,0,0,1,0
    ],
    Kodachrome: [
      1.12855,-0.39673,-0.03992,0,0.24991,
      -0.16404,1.08352,-0.05498,0,0.09698,
      -0.16786,-0.56034,1.60148,0,0.13972,
      0,0,0,1,0
    ],
    Technicolor: [
      1.91252,-0.85453,-0.09155,0,0.04624,
      -0.30878,1.76589,-0.10601,0,-0.27589,
      -0.23110,-0.75018,1.84759,0,0.12137,
      0,0,0,1,0
    ],
    Polaroid: [
      1.438,-0.062,-0.062,0,0,
      -0.122,1.378,-0.122,0,0,
      -0.016,-0.016,1.483,0,0,
      0,0,0,1,0
    ],
    Sepia: [
      0.393, 0.769, 0.189, 0, 0,
      0.349, 0.686, 0.168, 0, 0,
      0.272, 0.534, 0.131, 0, 0,
      0, 0, 0, 1, 0
    ],
    BlackWhite: [
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      0, 0, 0, 1, 0,
    ]
  };

  for (var key in matrices) {
    filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: key,

      /**
       * Colormatrix for the effect
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: matrices[key],

      /**
       * Lock the matrix export for this kind of static, parameter less filters.
       */
      mainParameter: false,
      /**
       * Lock the colormatrix on the color part, skipping alpha
       */
      colorsOnly: true,

    });
    fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
  }
})( true ? exports : 0);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Blend filter class
   * @class fabric.Image.filter.BlendColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
    type: 'BlendColor',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    color: '#F95C63',

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend color operation.
     **/
    alpha: 1,

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'gl_FragColor.rgb *= uColor.rgb;\n',
      screen: 'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n',
      add: 'gl_FragColor.rgb += uColor.rgb;\n',
      diff: 'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n',
      subtract: 'gl_FragColor.rgb -= uColor.rgb;\n',
      lighten: 'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n',
      darken: 'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n',
      exclusion: 'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n',
      overlay: 'if (uColor.r < 0.5) {\n' +
          'gl_FragColor.r *= 2.0 * uColor.r;\n' +
        '} else {\n' +
          'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
        '}\n' +
        'if (uColor.g < 0.5) {\n' +
          'gl_FragColor.g *= 2.0 * uColor.g;\n' +
        '} else {\n' +
          'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
        '}\n' +
        'if (uColor.b < 0.5) {\n' +
          'gl_FragColor.b *= 2.0 * uColor.b;\n' +
        '} else {\n' +
          'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
        '}\n',
      tint: 'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
        'gl_FragColor.rgb += uColor.rgb;\n',
    },

    /**
     * build the fragment source for the filters, joining the common part with
     * the specific one.
     * @param {String} mode the mode of the filter, a key of this.fragmentSource
     * @return {String} the source to be compiled
     * @private
     */
    buildSource: function(mode) {
      return 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor = color;\n' +
          'if (color.a > 0.0) {\n' +
            this.fragmentSource[mode] +
          '}\n' +
        '}';
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode, shaderSource;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        shaderSource = this.buildSource(this.mode);
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, iLen = data.length,
          tr, tg, tb,
          r, g, b,
          source, alpha1 = 1 - this.alpha;

      source = new fabric.Color(this.color).getSource();
      tr = source[0] * this.alpha;
      tg = source[1] * this.alpha;
      tb = source[2] * this.alpha;

      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            break;
          case 'screen':
            data[i] = 255 - (255 - r) * (255 - tr) / 255;
            data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
            data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
            break;
          case 'add':
            data[i] = r + tr;
            data[i + 1] = g + tg;
            data[i + 2] = b + tb;
            break;
          case 'diff':
          case 'difference':
            data[i] = Math.abs(r - tr);
            data[i + 1] = Math.abs(g - tg);
            data[i + 2] = Math.abs(b - tb);
            break;
          case 'subtract':
            data[i] = r - tr;
            data[i + 1] = g - tg;
            data[i + 2] = b - tb;
            break;
          case 'darken':
            data[i] = Math.min(r, tr);
            data[i + 1] = Math.min(g, tg);
            data[i + 2] = Math.min(b, tb);
            break;
          case 'lighten':
            data[i] = Math.max(r, tr);
            data[i + 1] = Math.max(g, tg);
            data[i + 2] = Math.max(b, tb);
            break;
          case 'overlay':
            data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
            data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
            data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
            break;
          case 'exclusion':
            data[i] = tr + r - ((2 * tr * r) / 255);
            data[i + 1] = tg + g - ((2 * tg * g) / 255);
            data[i + 2] = tb + b - ((2 * tb * b) / 255);
            break;
          case 'tint':
            data[i] = tr + r * alpha1;
            data[i + 1] = tg + g * alpha1;
            data[i + 2] = tb + b * alpha1;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColor: gl.getUniformLocation(program, 'uColor'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource();
      source[0] = this.alpha * source[0] / 255;
      source[1] = this.alpha * source[1] / 255;
      source[2] = this.alpha * source[2] / 255;
      source[3] = this.alpha;
      gl.uniform4fv(uniformLocations.uColor, source);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        color: this.color,
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
   */
  fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Image Blend filter class
   * @class fabric.Image.filter.BlendImage
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
    type: 'BlendImage',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    image: null,

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend image operation.
     * not implemented.
     **/
    alpha: 1,

    vertexSource: 'attribute vec2 aPosition;\n' +
      'varying vec2 vTexCoord;\n' +
      'varying vec2 vTexCoord2;\n' +
      'uniform mat3 uTransformMatrix;\n' +
      'void main() {\n' +
        'vTexCoord = aPosition;\n' +
        'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.rgba *= color2.rgba;\n' +
          'gl_FragColor = color;\n' +
        '}',
      mask: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.a = color2.a;\n' +
          'gl_FragColor = color;\n' +
        '}',
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      var shaderSource = this.fragmentSource[this.mode];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    applyToWebGL: function(options) {
      // load texture to blend.
      var gl = options.context,
          texture = this.createTexture(options.filterBackend, this.image);
      this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
      this.callSuper('applyToWebGL', options);
      this.unbindAdditionalTexture(gl, gl.TEXTURE1);
    },

    createTexture: function(backend, image) {
      return backend.getCachedTexture(image.cacheKey, image._element);
    },

    /**
     * Calculate a transformMatrix to adapt the image to blend over
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    calculateMatrix: function() {
      var image = this.image,
          width = image._element.width,
          height = image._element.height;
      return [
        1 / image.scaleX, 0, 0,
        0, 1 / image.scaleY, 0,
        -image.left / width, -image.top / height, 1
      ];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          resources = options.filterBackend.resources,
          data = imageData.data, iLen = data.length,
          width = imageData.width,
          height = imageData.height,
          tr, tg, tb, ta,
          r, g, b, a,
          canvas1, context, image = this.image, blendData;

      if (!resources.blendImage) {
        resources.blendImage = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blendImage;
      context = canvas1.getContext('2d');
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas1.width = width;
        canvas1.height = height;
      }
      else {
        context.clearRect(0, 0, width, height);
      }
      context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
      context.drawImage(image._element, 0, 0, width, height);
      blendData = context.getImageData(0, 0, width, height).data;
      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];

        tr = blendData[i];
        tg = blendData[i + 1];
        tb = blendData[i + 2];
        ta = blendData[i + 3];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            data[i + 3] = a * ta / 255;
            break;
          case 'mask':
            data[i + 3] = ta;
            break;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
        uImage: gl.getUniformLocation(program, 'uImage'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var matrix = this.calculateMatrix();
      gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
      gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        image: this.image && this.image.toObject(),
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} callback to be invoked after filter creation
   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
   */
  fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
    fabric.Image.fromObject(object.image, function(image) {
      var options = fabric.util.object.clone(object);
      options.image = image;
      callback(new fabric.Image.filters.BlendImage(options));
    });
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
      sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
      ceil = Math.ceil,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Resize image filter class
   * @class fabric.Image.filters.Resize
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Resize();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Resize',

    /**
     * Resize type
     * for webgl resizeType is just lanczos, for canvas2d can be:
     * bilinear, hermite, sliceHack, lanczos.
     * @param {String} resizeType
     * @default
     */
    resizeType: 'hermite',

    /**
     * Scale factor for resizing, x axis
     * @param {Number} scaleX
     * @default
     */
    scaleX: 1,

    /**
     * Scale factor for resizing, y axis
     * @param {Number} scaleY
     * @default
     */
    scaleY: 1,

    /**
     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos
     * @param {Number} lanczosLobes
     * @default
     */
    lanczosLobes: 3,


    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uDelta: gl.getUniformLocation(program, 'uDelta'),
        uTaps: gl.getUniformLocation(program, 'uTaps'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
      gl.uniform1fv(uniformLocations.uTaps, this.taps);
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var fragmentShader = this.generateShader(filterWindow);
        options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
      }
      return options.programCache[cacheKey];
    },

    getFilterWindow: function() {
      var scale = this.tempScale;
      return Math.ceil(this.lanczosLobes / scale);
    },

    getTaps: function() {
      var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,
          filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
      for (var i = 1; i <= filterWindow; i++) {
        taps[i - 1] = lobeFunction(i * scale);
      }
      return taps;
    },

    /**
     * Generate vertex and shader sources from the necessary steps numbers
     * @param {Number} filterWindow
     */
    generateShader: function(filterWindow) {
      var offsets = new Array(filterWindow),
          fragmentShader = this.fragmentSourceTOP, filterWindow;

      for (var i = 1; i <= filterWindow; i++) {
        offsets[i - 1] = i + '.0 * uDelta';
      }

      fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';
      fragmentShader += 'void main() {\n';
      fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';
      fragmentShader += '  float sum = 1.0;\n';

      offsets.forEach(function(offset, i) {
        fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';
      });
      fragmentShader += '  gl_FragColor = color / sum;\n';
      fragmentShader += '}';
      return fragmentShader;
    },

    fragmentSourceTOP: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n',

    /**
     * Apply the resize filter to the image
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      if (options.webgl) {
        options.passes++;
        this.width = options.sourceWidth;
        this.horizontal = true;
        this.dW = Math.round(this.width * this.scaleX);
        this.dH = options.sourceHeight;
        this.tempScale = this.dW / this.width;
        this.taps = this.getTaps();
        options.destinationWidth = this.dW;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceWidth = options.destinationWidth;

        this.height = options.sourceHeight;
        this.horizontal = false;
        this.dH = Math.round(this.height * this.scaleY);
        this.tempScale = this.dH / this.height;
        this.taps = this.getTaps();
        options.destinationHeight = this.dH;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceHeight = options.destinationHeight;
      }
      else {
        this.applyTo2d(options);
      }
    },

    isNeutralState: function() {
      return this.scaleX === 1 && this.scaleY === 1;
    },

    lanczosCreate: function(lobes) {
      return function(x) {
        if (x >= lobes || x <= -lobes) {
          return 0.0;
        }
        if (x < 1.19209290E-07 && x > -1.19209290E-07) {
          return 1.0;
        }
        x *= Math.PI;
        var xx = x / lobes;
        return (sin(x) / x) * sin(xx) / xx;
      };
    },

    /**
     * Applies filter to canvas element
     * @memberOf fabric.Image.filters.Resize.prototype
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} scaleX
     * @param {Number} scaleY
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          scaleX = this.scaleX,
          scaleY = this.scaleY;

      this.rcpScaleX = 1 / scaleX;
      this.rcpScaleY = 1 / scaleY;

      var oW = imageData.width, oH = imageData.height,
          dW = round(oW * scaleX), dH = round(oH * scaleY),
          newData;

      if (this.resizeType === 'sliceHack') {
        newData = this.sliceByTwo(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'hermite') {
        newData = this.hermiteFastResize(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'bilinear') {
        newData = this.bilinearFiltering(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'lanczos') {
        newData = this.lanczosResize(options, oW, oH, dW, dH);
      }
      options.imageData = newData;
    },

    /**
     * Filter sliceByTwo
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    sliceByTwo: function(options, oW, oH, dW, dH) {
      var imageData = options.imageData,
          mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
          stepH = oH * mult, resources = fabric.filterBackend.resources,
          tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
      if (!resources.sliceByTwo) {
        resources.sliceByTwo = document.createElement('canvas');
      }
      tmpCanvas = resources.sliceByTwo;
      if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
        tmpCanvas.width = oW * 1.5;
        tmpCanvas.height = oH;
      }
      ctx = tmpCanvas.getContext('2d');
      ctx.clearRect(0, 0, oW * 1.5, oH);
      ctx.putImageData(imageData, 0, 0);

      dW = floor(dW);
      dH = floor(dH);

      while (!doneW || !doneH) {
        oW = stepW;
        oH = stepH;
        if (dW < floor(stepW * mult)) {
          stepW = floor(stepW * mult);
        }
        else {
          stepW = dW;
          doneW = true;
        }
        if (dH < floor(stepH * mult)) {
          stepH = floor(stepH * mult);
        }
        else {
          stepH = dH;
          doneH = true;
        }
        ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
        sX = dX;
        sY = dY;
        dY += stepH;
      }
      return ctx.getImageData(sX, sY, dW, dH);
    },

    /**
     * Filter lanczosResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    lanczosResize: function(options, oW, oH, dW, dH) {

      function process(u) {
        var v, i, weight, idx, a, red, green,
            blue, alpha, fX, fY;
        center.x = (u + 0.5) * ratioX;
        icenter.x = floor(center.x);
        for (v = 0; v < dH; v++) {
          center.y = (v + 0.5) * ratioY;
          icenter.y = floor(center.y);
          a = 0; red = 0; green = 0; blue = 0; alpha = 0;
          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
            if (i < 0 || i >= oW) {
              continue;
            }
            fX = floor(1000 * abs(i - center.x));
            if (!cacheLanc[fX]) {
              cacheLanc[fX] = { };
            }
            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
              if (j < 0 || j >= oH) {
                continue;
              }
              fY = floor(1000 * abs(j - center.y));
              if (!cacheLanc[fX][fY]) {
                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
              }
              weight = cacheLanc[fX][fY];
              if (weight > 0) {
                idx = (j * oW + i) * 4;
                a += weight;
                red += weight * srcData[idx];
                green += weight * srcData[idx + 1];
                blue += weight * srcData[idx + 2];
                alpha += weight * srcData[idx + 3];
              }
            }
          }
          idx = (v * dW + u) * 4;
          destData[idx] = red / a;
          destData[idx + 1] = green / a;
          destData[idx + 2] = blue / a;
          destData[idx + 3] = alpha / a;
        }

        if (++u < dW) {
          return process(u);
        }
        else {
          return destImg;
        }
      }

      var srcData = options.imageData.data,
          destImg = options.ctx.createImageData(dW, dH),
          destData = destImg.data,
          lanczos = this.lanczosCreate(this.lanczosLobes),
          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
          range2X = ceil(ratioX * this.lanczosLobes / 2),
          range2Y = ceil(ratioY * this.lanczosLobes / 2),
          cacheLanc = { }, center = { }, icenter = { };

      return process(0);
    },

    /**
     * bilinearFiltering
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    bilinearFiltering: function(options, oW, oH, dW, dH) {
      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
          color, offset = 0, origPix, ratioX = this.rcpScaleX,
          ratioY = this.rcpScaleY,
          w4 = 4 * (oW - 1), img = options.imageData,
          pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
          destPixels = destImage.data;
      for (i = 0; i < dH; i++) {
        for (j = 0; j < dW; j++) {
          x = floor(ratioX * j);
          y = floor(ratioY * i);
          xDiff = ratioX * j - x;
          yDiff = ratioY * i - y;
          origPix = 4 * (y * oW + x);

          for (chnl = 0; chnl < 4; chnl++) {
            a = pixels[origPix + chnl];
            b = pixels[origPix + 4 + chnl];
            c = pixels[origPix + w4 + chnl];
            d = pixels[origPix + w4 + 4 + chnl];
            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
            destPixels[offset++] = color;
          }
        }
      }
      return destImage;
    },

    /**
     * hermiteFastResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    hermiteFastResize: function(options, oW, oH, dW, dH) {
      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
          ratioWHalf = ceil(ratioW / 2),
          ratioHHalf = ceil(ratioH / 2),
          img = options.imageData, data = img.data,
          img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
      for (var j = 0; j < dH; j++) {
        for (var i = 0; i < dW; i++) {
          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                  w = sqrt(w0 + dx * dx);
              /* eslint-disable max-depth */
              if (w > 1 && w < -1) {
                continue;
              }
              //hermite filter
              weight = 2 * w * w * w - 3 * w * w + 1;
              if (weight > 0) {
                dx = 4 * (xx + yy * oW);
                //alpha
                gxA += weight * data[dx + 3];
                weightsAlpha += weight;
                //colors
                if (data[dx + 3] < 255) {
                  weight = weight * data[dx + 3] / 250;
                }
                gxR += weight * data[dx];
                gxG += weight * data[dx + 1];
                gxB += weight * data[dx + 2];
                weights += weight;
              }
              /* eslint-enable max-depth */
            }
          }
          data2[x2] = gxR / weights;
          data2[x2 + 1] = gxG / weights;
          data2[x2 + 2] = gxB / weights;
          data2[x2 + 3] = gxA / weightsAlpha;
        }
      }
      return img2;
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        resizeType: this.resizeType,
        lanczosLobes: this.lanczosLobes
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
   */
  fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Contrast filter class
   * @class fabric.Image.filters.Contrast
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Contrast({
   *   contrast: 0.25
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Contrast',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uContrast;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
        'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * contrast value, range from -1 to 1.
     * @param {Number} contrast
     * @default 0
     */
    contrast: 0,

    mainParameter: 'contrast',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Contrast.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
     */

    /**
      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8Array to be filtered.
      */
    applyTo2d: function(options) {
      if (this.contrast === 0) {
        return;
      }
      var imageData = options.imageData, i, len,
          data = imageData.data, len = data.length,
          contrast = Math.floor(this.contrast * 255),
          contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

      for (i = 0; i < len; i += 4) {
        data[i] = contrastF * (data[i] - 128) + 128;
        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uContrast: gl.getUniformLocation(program, 'uContrast'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uContrast, this.contrast);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
   */
  fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Saturate filter class
   * @class fabric.Image.filters.Saturation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Saturation({
   *   saturation: 100
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Saturation',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uSaturation;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float rgMax = max(color.r, color.g);\n' +
        'float rgbMax = max(rgMax, color.b);\n' +
        'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
        'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
        'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
        'gl_FragColor = color;\n' +
      '}',

    saturation: 0,

    mainParameter: 'saturation',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Saturate.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
     */

    /**
     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.saturation === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, len = data.length,
          adjust = -this.saturation, i, max;

      for (i = 0; i < len; i += 4) {
        max = Math.max(data[i], data[i + 1], data[i + 2]);
        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uSaturation: gl.getUniformLocation(program, 'uSaturation'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
   */
  fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Blur filter class
   * @class fabric.Image.filters.Blur
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Blur({
   *   blur: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

    type: 'Blur',

    /*
'gl_FragColor = vec4(0.0);',
'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
*/

    /* eslint-disable max-len */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n' +
      'const float nSamples = 15.0;\n' +
      'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
      'float random(vec3 scale) {\n' +
        /* use the fragment position for a different seed per-pixel */
        'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = vec4(0.0);\n' +
        'float total = 0.0;\n' +
        'float offset = random(v3offset);\n' +
        'for (float t = -nSamples; t <= nSamples; t++) {\n' +
          'float percent = (t + offset - 0.5) / nSamples;\n' +
          'float weight = 1.0 - abs(percent);\n' +
          'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
          'total += weight;\n' +
        '}\n' +
        'gl_FragColor = color / total;\n' +
      '}',
    /* eslint-enable max-len */

    /**
     * blur value, in percentage of image dimensions.
     * specific to keep the image blur constant at different resolutions
     * range between 0 and 1.
     */
    blur: 0,

    mainParameter: 'blur',

    applyTo: function(options) {
      if (options.webgl) {
        // this aspectRatio is used to give the same blur to vertical and horizontal
        this.aspectRatio = options.sourceWidth / options.sourceHeight;
        options.passes++;
        this._setupFrameBuffer(options);
        this.horizontal = true;
        this.applyToWebGL(options);
        this._swapTextures(options);
        this._setupFrameBuffer(options);
        this.horizontal = false;
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else {
        this.applyTo2d(options);
      }
    },

    applyTo2d: function(options) {
      // paint canvasEl with current image data.
      //options.ctx.putImageData(options.imageData, 0, 0);
      options.imageData = this.simpleBlur(options);
    },

    simpleBlur: function(options) {
      var resources = options.filterBackend.resources, canvas1, canvas2,
          width = options.imageData.width,
          height = options.imageData.height;

      if (!resources.blurLayer1) {
        resources.blurLayer1 = fabric.util.createCanvasElement();
        resources.blurLayer2 = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blurLayer1;
      canvas2 = resources.blurLayer2;
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas2.width = canvas1.width = width;
        canvas2.height = canvas1.height = height;
      }
      var ctx1 = canvas1.getContext('2d'),
          ctx2 = canvas2.getContext('2d'),
          nSamples = 15,
          random, percent, j, i,
          blur = this.blur * 0.06 * 0.5;

      // load first canvas
      ctx1.putImageData(options.imageData, 0, 0);
      ctx2.clearRect(0, 0, width, height);

      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * width + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, j, random);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * height + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, random, j);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      options.ctx.drawImage(canvas1, 0, 0);
      var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
      ctx1.globalAlpha = 1;
      ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
      return newImageData;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        delta: gl.getUniformLocation(program, 'uDelta'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var delta = this.chooseRightDelta();
      gl.uniform2fv(uniformLocations.delta, delta);
    },

    /**
     * choose right value of image percentage to blur with
     * @returns {Array} a numeric array with delta values
     */
    chooseRightDelta: function() {
      var blurScale = 1, delta = [0, 0], blur;
      if (this.horizontal) {
        if (this.aspectRatio > 1) {
          // image is wide, i want to shrink radius horizontal
          blurScale = 1 / this.aspectRatio;
        }
      }
      else {
        if (this.aspectRatio < 1) {
          // image is tall, i want to shrink radius vertical
          blurScale = this.aspectRatio;
        }
      }
      blur = blurScale * this.blur * 0.12;
      if (this.horizontal) {
        delta[0] = blur;
      }
      else {
        delta[1] = blur;
      }
      return delta;
    },
  });

  /**
   * Deserialize a JSON definition of a BlurFilter into a concrete instance.
   */
  filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Gamma filter class
   * @class fabric.Image.filters.Gamma
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Gamma({
   *   gamma: [1, 0.5, 2.1]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Gamma',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec3 uGamma;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'vec3 correction = (1.0 / uGamma);\n' +
        'color.r = pow(color.r, correction.r);\n' +
        'color.g = pow(color.g, correction.g);\n' +
        'color.b = pow(color.b, correction.b);\n' +
        'gl_FragColor = color;\n' +
        'gl_FragColor.rgb *= color.a;\n' +
      '}',

    /**
     * Gamma array value, from 0.01 to 2.2.
     * @param {Array} gamma
     * @default
     */
    gamma: [1, 1, 1],

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'gamma',

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.gamma = [1, 1, 1];
      filters.BaseFilter.prototype.initialize.call(this, options);
    },

    /**
     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData, data = imageData.data,
          gamma = this.gamma, len = data.length,
          rInv = 1 / gamma[0], gInv = 1 / gamma[1],
          bInv = 1 / gamma[2], i;

      if (!this.rVals) {
        // eslint-disable-next-line
        this.rVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.gVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.bVals = new Uint8Array(256);
      }

      // This is an optimization - pre-compute a look-up table for each color channel
      // instead of performing these pow calls for each pixel in the image.
      for (i = 0, len = 256; i < len; i++) {
        this.rVals[i] = Math.pow(i / 255, rInv) * 255;
        this.gVals[i] = Math.pow(i / 255, gInv) * 255;
        this.bVals[i] = Math.pow(i / 255, bInv) * 255;
      }
      for (i = 0, len = data.length; i < len; i += 4) {
        data[i] = this.rVals[data[i]];
        data[i + 1] = this.gVals[data[i + 1]];
        data[i + 2] = this.bVals[data[i + 2]];
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uGamma: gl.getUniformLocation(program, 'uGamma'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform3fv(uniformLocations.uGamma, this.gamma);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
   */
  fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * A container class that knows how to apply a sequence of filters to an input image.
   */
  filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

    type: 'Composed',

    /**
     * A non sparse array of filters to apply
     */
    subFilters: [],

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.subFilters = this.subFilters.slice(0);
    },

    /**
     * Apply this container's filters to the input image provided.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be applied.
     */
    applyTo: function(options) {
      options.passes += this.subFilters.length - 1;
      this.subFilters.forEach(function(filter) {
        filter.applyTo(options);
      });
    },

    /**
     * Serialize this filter into JSON.
     *
     * @returns {Object} A JSON representation of this filter.
     */
    toObject: function() {
      return fabric.util.object.extend(this.callSuper('toObject'), {
        subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
      });
    },

    isNeutralState: function() {
      return !this.subFilters.some(function(filter) { return !filter.isNeutralState(); });
    }
  });

  /**
   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
   */
  fabric.Image.filters.Composed.fromObject = function(object, callback) {
    var filters = object.subFilters || [],
        subFilters = filters.map(function(filter) {
          return new fabric.Image.filters[filter.type](filter);
        }),
        instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
    callback && callback(instance);
    return instance;
  };
})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * HueRotation filter class
   * @class fabric.Image.filters.HueRotation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.HueRotation({
   *   rotation: -0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'HueRotation',

    /**
     * HueRotation value, from -1 to 1.
     * the unit is radians
     * @param {Number} myParameter
     * @default
     */
    rotation: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'rotation',

    calculateMatrix: function() {
      var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad),
          aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
      this.matrix = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ];
      this.matrix[0] = cos + OneMinusCos / 3;
      this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[6] = cos + aThird * OneMinusCos;
      this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[12] = cos + aThird * OneMinusCos;
    },

    /**
     * HueRotation isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function(options) {
      this.calculateMatrix();
      return filters.BaseFilter.prototype.isNeutralState.call(this, options);
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      this.calculateMatrix();
      filters.BaseFilter.prototype.applyTo.call(this, options);
    },

  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
   */
  fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      clone = fabric.util.object.clone;

  if (fabric.Text) {
    fabric.warn('fabric.Text is already defined');
    return;
  }

  var additionalProps =
    ('fontFamily fontWeight fontSize text underline overline linethrough' +
    ' textAlign fontStyle lineHeight textBackgroundColor charSpacing styles path').split(' ');

  /**
   * Text class
   * @class fabric.Text
   * @extends fabric.Object
   * @return {fabric.Text} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
   * @see {@link fabric.Text#initialize} for constructor definition
   */
  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

    /**
     * Properties which when set cause object to change dimensions
     * @type Array
     * @private
     */
    _dimensionAffectingProps: [
      'fontSize',
      'fontWeight',
      'fontFamily',
      'fontStyle',
      'lineHeight',
      'text',
      'charSpacing',
      'textAlign',
      'styles',
      'path'
    ],

    /**
     * @private
     */
    _reNewline: /\r?\n/,

    /**
     * Use this regular expression to filter for whitespaces that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpacesAndTabs: /[ \t\r]/g,

    /**
     * Use this regular expression to filter for whitespace that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpaceAndTab: /[ \t\r]/,

    /**
     * Use this regular expression to filter consecutive groups of non spaces.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reWords: /\S+/g,

    /**
     * Type of an object
     * @type String
     * @default
     */
    type:                 'text',

    /**
     * Font size (in pixels)
     * @type Number
     * @default
     */
    fontSize:             40,

    /**
     * Font weight (e.g. bold, normal, 400, 600, 800)
     * @type {(Number|String)}
     * @default
     */
    fontWeight:           'normal',

    /**
     * Font family
     * @type String
     * @default
     */
    fontFamily:           'Times New Roman',

    /**
     * Text decoration underline.
     * @type Boolean
     * @default
     */
    underline:       false,

    /**
     * Text decoration overline.
     * @type Boolean
     * @default
     */
    overline:       false,

    /**
     * Text decoration linethrough.
     * @type Boolean
     * @default
     */
    linethrough:       false,

    /**
     * Text alignment. Possible values: "left", "center", "right", "justify",
     * "justify-left", "justify-center" or "justify-right".
     * @type String
     * @default
     */
    textAlign:            'left',

    /**
     * Font style . Possible values: "", "normal", "italic" or "oblique".
     * @type String
     * @default
     */
    fontStyle:            'normal',

    /**
     * Line height
     * @type Number
     * @default
     */
    lineHeight:           1.16,

    /**
     * Superscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    superscript: {
      size:      0.60, // fontSize factor
      baseline: -0.35  // baseline-shift factor (upwards)
    },

    /**
     * Subscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    subscript: {
      size:      0.60, // fontSize factor
      baseline:  0.11  // baseline-shift factor (downwards)
    },

    /**
     * Background color of text lines
     * @type String
     * @default
     */
    textBackgroundColor:  '',

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),

    /**
     * List of properties to consider when checking if cache needs refresh
     * @type Array
     */
    cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),

    /**
     * When defined, an object is rendered via stroke and this property specifies its color.
     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
     * @type String
     * @default
     */
    stroke:               null,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
     * @type fabric.Shadow
     * @default
     */
    shadow:               null,

    /**
     * @private
     */
    _fontSizeFraction: 0.222,

    /**
     * @private
     */
    offsets: {
      underline: 0.10,
      linethrough: -0.315,
      overline: -0.88
    },

    /**
     * Text Line proportion to font Size (in pixels)
     * @type Number
     * @default
     */
    _fontSizeMult:             1.13,

    /**
     * additional space between characters
     * expressed in thousands of em unit
     * @type Number
     * @default
     */
    charSpacing:             0,

    /**
     * Object containing character styles - top-level properties -> line numbers,
     * 2nd-level properties - character numbers
     * @type Object
     * @default
     */
    styles: null,

    /**
     * Reference to a context to measure text char or couple of chars
     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every
     * text object created.
     * @type {CanvasRenderingContext2D}
     * @default
     */
    _measuringContext: null,

    /**
     * Baseline shift, styles only, keep at 0 for the main text object
     * @type {Number}
     * @default
     */
    deltaY: 0,

    /**
     * Array of properties that define a style unit (of 'styles').
     * @type {Array}
     * @default
     */
    _styleProperties: [
      'stroke',
      'strokeWidth',
      'fill',
      'fontFamily',
      'fontSize',
      'fontWeight',
      'fontStyle',
      'underline',
      'overline',
      'linethrough',
      'deltaY',
      'textBackgroundColor',
    ],

    /**
     * contains characters bounding boxes
     */
    __charBounds: [],

    /**
     * use this size when measuring text. To avoid IE11 rounding errors
     * @type {Number}
     * @default
     * @readonly
     * @private
     */
    CACHE_FONT_SIZE: 400,

    /**
     * contains the min text width to avoid getting 0
     * @type {Number}
     * @default
     */
    MIN_TEXT_WIDTH: 2,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    initialize: function(text, options) {
      this.styles = options ? (options.styles || { }) : { };
      this.text = text;
      this.__skipDimension = true;
      this.callSuper('initialize', options);
      if (this.path) {
        this.setPathInfo();
      }
      this.__skipDimension = false;
      this.initDimensions();
      this.setCoords();
      this.setupState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * If text has a path, it will add the extra information needed
     * for path and text calculations
     * @return {fabric.Text} thisArg
     */
    setPathInfo: function() {
      var path = this.path;
      if (path) {
        path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);
      }
    },

    /**
     * Return a context for measurement of text string.
     * if created it gets stored for reuse
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    getMeasuringContext: function() {
      // if we did not return we have to measure something.
      if (!fabric._measuringContext) {
        fabric._measuringContext = this.canvas && this.canvas.contextCache ||
          fabric.util.createCanvasElement().getContext('2d');
      }
      return fabric._measuringContext;
    },

    /**
     * @private
     * Divides text into lines of text and lines of graphemes.
     */
    _splitText: function() {
      var newLines = this._splitTextIntoLines(this.text);
      this.textLines = newLines.lines;
      this._textLines = newLines.graphemeLines;
      this._unwrappedTextLines = newLines._unwrappedLines;
      this._text = newLines.graphemeText;
      return newLines;
    },

    /**
     * Initialize or update text dimensions.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this._splitText();
      this._clearCache();
      if (this.path) {
        this.width = this.path.width;
        this.height = this.path.height;
      }
      else {
        this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
        this.height = this.calcTextHeight();
      }
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Enlarge space boxes and shift the others
     */
    enlargeSpaces: function() {
      var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        if (this.textAlign !== 'justify' && (i === len - 1 || this.isEndOfWrapping(i))) {
          continue;
        }
        accumulatedSpace = 0;
        line = this._textLines[i];
        currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
          numberOfSpaces = spaces.length;
          diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
          for (var j = 0, jlen = line.length; j <= jlen; j++) {
            charBound = this.__charBounds[i][j];
            if (this._reSpaceAndTab.test(line[j])) {
              charBound.width += diffSpace;
              charBound.kernedWidth += diffSpace;
              charBound.left += accumulatedSpace;
              accumulatedSpace += diffSpace;
            }
            else {
              charBound.left += accumulatedSpace;
            }
          }
        }
      }
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      return lineIndex === this._textLines.length - 1;
    },

    /**
     * Detect if a line has a linebreak and so we need to account for it when moving
     * and counting style.
     * It return always for text and Itext.
     * @return Number
     */
    missingNewlineOffset: function() {
      return 1;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of text object
     */
    toString: function() {
      return '#<fabric.Text (' + this.complexity() +
        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @param {Object} dim.x width of object to be cached
     * @param {Object} dim.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var dims = this.callSuper('_getCacheCanvasDimensions');
      var fontSize = this.fontSize;
      dims.width += fontSize * dims.zoomX;
      dims.height += fontSize * dims.zoomY;
      return dims;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this._setTextStyles(ctx);
      this._renderTextLinesBackground(ctx);
      this._renderTextDecoration(ctx, 'underline');
      this._renderText(ctx);
      this._renderTextDecoration(ctx, 'overline');
      this._renderTextDecoration(ctx, 'linethrough');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderText: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderTextStroke(ctx);
        this._renderTextFill(ctx);
      }
      else {
        this._renderTextFill(ctx);
        this._renderTextStroke(ctx);
      }
    },

    /**
     * Set the font parameter of the context with the object properties or with charStyle
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [charStyle] object with font style properties
     * @param {String} [charStyle.fontFamily] Font Family
     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
     * @param {String} [charStyle.fontWeight] Font weight
     * @param {String} [charStyle.fontStyle] Font style (italic|normal)
     */
    _setTextStyles: function(ctx, charStyle, forMeasuring) {
      ctx.textBaseline = 'alphabetic';
      ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
    },

    /**
     * calculate and return the text Width measuring each line.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {Number} Maximum width of fabric.Text object
     */
    calcTextWidth: function() {
      var maxWidth = this.getLineWidth(0);

      for (var i = 1, len = this._textLines.length; i < len; i++) {
        var currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth > maxWidth) {
          maxWidth = currentLineWidth;
        }
      }
      return maxWidth;
    },

    /**
     * @private
     * @param {String} method Method name ("fillText" or "strokeText")
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} line Text to render
     * @param {Number} left Left position of text
     * @param {Number} top Top position of text
     * @param {Number} lineIndex Index of a line in a text
     */
    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
      this._renderChars(method, ctx, line, left, top, lineIndex);
    },

    /**
     * Renders the text background for lines, taking care of style
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextLinesBackground: function(ctx) {
      if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
        return;
      }
      var heightOfLine,
          lineLeftOffset, originalFill = ctx.fillStyle,
          line, lastColor,
          leftOffset = this._getLeftOffset(),
          lineTopOffset = this._getTopOffset(),
          boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
          lineTopOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        lineLeftOffset = this._getLineLeftOffset(i);
        boxWidth = 0;
        boxStart = 0;
        lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (path) {
            ctx.save();
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            ctx.fillStyle = currentColor;
            currentColor && ctx.fillRect(
              -charBox.width / 2,
              -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction),
              charBox.width,
              heightOfLine / this.lineHeight
            );
            ctx.restore();
          }
          else if (currentColor !== lastColor) {
            ctx.fillStyle = lastColor;
            lastColor && ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        if (currentColor && !path) {
          ctx.fillStyle = currentColor;
          ctx.fillRect(
            leftOffset + lineLeftOffset + boxStart,
            lineTopOffset,
            boxWidth,
            heightOfLine / this.lineHeight
          );
        }
        lineTopOffset += heightOfLine;
      }
      ctx.fillStyle = originalFill;
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {Object} decl style declaration for cache
     * @param {String} decl.fontFamily fontFamily
     * @param {String} decl.fontStyle fontStyle
     * @param {String} decl.fontWeight fontWeight
     * @return {Object} reference to cache
     */
    getFontCache: function(decl) {
      var fontFamily = decl.fontFamily.toLowerCase();
      if (!fabric.charWidthsCache[fontFamily]) {
        fabric.charWidthsCache[fontFamily] = { };
      }
      var cache = fabric.charWidthsCache[fontFamily],
          cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
      if (!cache[cacheProp]) {
        cache[cacheProp] = { };
      }
      return cache[cacheProp];
    },

    /**
     * measure and return the width of a single character.
     * possibly overridden to accommodate different measure logic or
     * to hook some external lib for character measurement
     * @private
     * @param {String} _char, char to be measured
     * @param {Object} charStyle style of char to be measured
     * @param {String} [previousChar] previous char
     * @param {Object} [prevCharStyle] style of previous char
     */
    _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
      // first i try to return from cache
      var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
          previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
          stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
          fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;

      if (previousChar && fontCache[previousChar] !== undefined) {
        previousWidth = fontCache[previousChar];
      }
      if (fontCache[_char] !== undefined) {
        kernedWidth = width = fontCache[_char];
      }
      if (stylesAreEqual && fontCache[couple] !== undefined) {
        coupleWidth = fontCache[couple];
        kernedWidth = coupleWidth - previousWidth;
      }
      if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {
        var ctx = this.getMeasuringContext();
        // send a TRUE to specify measuring font size CACHE_FONT_SIZE
        this._setTextStyles(ctx, charStyle, true);
      }
      if (width === undefined) {
        kernedWidth = width = ctx.measureText(_char).width;
        fontCache[_char] = width;
      }
      if (previousWidth === undefined && stylesAreEqual && previousChar) {
        previousWidth = ctx.measureText(previousChar).width;
        fontCache[previousChar] = previousWidth;
      }
      if (stylesAreEqual && coupleWidth === undefined) {
        // we can measure the kerning couple and subtract the width of the previous character
        coupleWidth = ctx.measureText(couple).width;
        fontCache[couple] = coupleWidth;
        kernedWidth = coupleWidth - previousWidth;
      }
      return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
    },

    /**
     * Computes height of character at given position
     * @param {Number} line the line index number
     * @param {Number} _char the character index number
     * @return {Number} fontSize of the character
     */
    getHeightOfChar: function(line, _char) {
      return this.getValueOfPropertyAt(line, _char, 'fontSize');
    },

    /**
     * measure a text line measuring all characters.
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    measureLine: function(lineIndex) {
      var lineInfo = this._measureLine(lineIndex);
      if (this.charSpacing !== 0) {
        lineInfo.width -= this._getWidthOfCharSpacing();
      }
      if (lineInfo.width < 0) {
        lineInfo.width = 0;
      }
      return lineInfo;
    },

    /**
     * measure every grapheme of a line, populating __charBounds
     * @param {Number} lineIndex
     * @return {Object} object.width total width of characters
     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
     */
    _measureLine: function(lineIndex) {
      var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
          graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length),
          positionInPath = 0, startingPoint, totalPathLength, path = this.path;

      this.__charBounds[lineIndex] = lineBounds;
      if (path) {
        startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);
        totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;
        startingPoint.x += path.pathOffset.x;
        startingPoint.y += path.pathOffset.y;
      }
      for (i = 0; i < line.length; i++) {
        grapheme = line[i];
        graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
        if (path) {
          if (positionInPath > totalPathLength) {
            positionInPath %= totalPathLength;
          }
          // it would probably much fater to send all the grapheme position for a line
          // and calculate path position/angle at once.
          this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);
        }
        lineBounds[i] = graphemeInfo;
        width += graphemeInfo.kernedWidth;
        positionInPath += graphemeInfo.kernedWidth;
        prevGrapheme = grapheme;
      }
      // this latest bound box represent the last character of the line
      // to simplify cursor handling in interactive mode.
      lineBounds[i] = {
        left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
        width: 0,
        kernedWidth: 0,
        height: this.fontSize
      };
      return { width: width, numOfSpaces: numOfSpaces };
    },

    /**
     * Calculate the angle  and the left,top position of the char that follow a path.
     * It appends it to graphemeInfo to be reused later at rendering
     * @private
     * @param {Number} positionInPath to be measured
     * @param {Object} graphemeInfo current grapheme box information
     * @param {Object} startingPoint position of the point
     */
    _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {
      var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2,
          path = this.path;

      // we are at currentPositionOnPath. we want to know what point on the path is.
      var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);
      graphemeInfo.renderLeft = info.x - startingPoint.x;
      graphemeInfo.renderTop = info.y - startingPoint.y;
      graphemeInfo.angle = info.angle;
    },

    /**
     * Measure and return the info of a single grapheme.
     * needs the the info of previous graphemes already filled
     * @private
     * @param {String} grapheme to be measured
     * @param {Number} lineIndex index of the line where the char is
     * @param {Number} charIndex position in the line
     * @param {String} [prevGrapheme] character preceding the one to be measured
     */
    _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
      var style = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
          info = this._measureChar(grapheme, style, prevGrapheme, prevStyle),
          kernedWidth = info.kernedWidth,
          width = info.width, charSpacing;

      if (this.charSpacing !== 0) {
        charSpacing = this._getWidthOfCharSpacing();
        width += charSpacing;
        kernedWidth += charSpacing;
      }

      var box = {
        width: width,
        left: 0,
        height: style.fontSize,
        kernedWidth: kernedWidth,
        deltaY: style.deltaY,
      };
      if (charIndex > 0 && !skipLeft) {
        var previousBox = this.__charBounds[lineIndex][charIndex - 1];
        box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
      }
      return box;
    },

    /**
     * Calculate height of line at 'lineIndex'
     * @param {Number} lineIndex index of line to calculate
     * @return {Number}
     */
    getHeightOfLine: function(lineIndex) {
      if (this.__lineHeights[lineIndex]) {
        return this.__lineHeights[lineIndex];
      }

      var line = this._textLines[lineIndex],
          // char 0 is measured before the line cycle because it nneds to char
          // emptylines
          maxHeight = this.getHeightOfChar(lineIndex, 0);
      for (var i = 1, len = line.length; i < len; i++) {
        maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
      }

      return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
    },

    /**
     * Calculate text box height
     */
    calcTextHeight: function() {
      var lineHeight, height = 0;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineHeight = this.getHeightOfLine(i);
        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
      }
      return height;
    },

    /**
     * @private
     * @return {Number} Left offset
     */
    _getLeftOffset: function() {
      return -this.width / 2;
    },

    /**
     * @private
     * @return {Number} Top offset
     */
    _getTopOffset: function() {
      return -this.height / 2;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} method Method name ("fillText" or "strokeText")
     */
    _renderTextCommon: function(ctx, method) {
      ctx.save();
      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        var heightOfLine = this.getHeightOfLine(i),
            maxHeight = heightOfLine / this.lineHeight,
            leftOffset = this._getLineLeftOffset(i);
        this._renderTextLine(
          method,
          ctx,
          this._textLines[i],
          left + leftOffset,
          top + lineHeights + maxHeight,
          i
        );
        lineHeights += heightOfLine;
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextFill: function(ctx) {
      if (!this.fill && !this.styleHas('fill')) {
        return;
      }

      this._renderTextCommon(ctx, 'fillText');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextStroke: function(ctx) {
      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      this._setLineDash(ctx, this.strokeDashArray);
      ctx.beginPath();
      this._renderTextCommon(ctx, 'strokeText');
      ctx.closePath();
      ctx.restore();
    },

    /**
     * @private
     * @param {String} method fillText or strokeText.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} line Content of the line, splitted in an array by grapheme
     * @param {Number} left
     * @param {Number} top
     * @param {Number} lineIndex
     */
    _renderChars: function(method, ctx, line, left, top, lineIndex) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox,
          boxWidth = 0,
          timeToRender,
          path = this.path,
          shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path;

      ctx.save();
      top -= lineHeight * this._fontSizeFraction / this.lineHeight;
      if (shortCut) {
        // render all the line in one pass without checking
        this._renderChar(method, ctx, lineIndex, 0, line.join(''), left, top, lineHeight);
        ctx.restore();
        return;
      }
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing || path;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          left += charBox.kernedWidth - charBox.width;
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
        }
        if (timeToRender) {
          if (path) {
            ctx.save();
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);
            ctx.restore();
          }
          else {
            this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);
          }
          charsToRender = '';
          actualStyle = nextStyle;
          left += boxWidth;
          boxWidth = 0;
        }
      }
      ctx.restore();
    },

    /**
     * This function try to patch the missing gradientTransform on canvas gradients.
     * transforming a context to transform the gradient, is going to transform the stroke too.
     * we want to transform the gradient but not the stroke operation, so we create
     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size
     * is limited.
     * @private
     * @param {fabric.Gradient} filler a fabric gradient instance
     * @return {CanvasPattern} a pattern to use as fill/stroke style
     */
    _applyPatternGradientTransformText: function(filler) {
      var pCanvas = fabric.util.createCanvasElement(), pCtx,
          // TODO: verify compatibility with strokeUniform
          width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;
      pCanvas.width = width;
      pCanvas.height = height;
      pCtx = pCanvas.getContext('2d');
      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
      pCtx.lineTo(0, height); pCtx.closePath();
      pCtx.translate(width / 2, height / 2);
      pCtx.fillStyle = filler.toLive(pCtx);
      this._applyPatternGradientTransform(pCtx, filler);
      pCtx.fill();
      return pCtx.createPattern(pCanvas, 'no-repeat');
    },

    handleFiller: function(ctx, property, filler) {
      var offsetX, offsetY;
      if (filler.toLive) {
        if (filler.gradientUnits === 'percentage' || filler.gradientTrasnform || filler.patternTransform) {
          // need to transform gradient in a pattern.
          // this is a slow process. If you are hitting this codepath, and the object
          // is not using caching, you should consider switching it on.
          // we need a canvas as big as the current object caching canvas.
          offsetX = -this.width / 2;
          offsetY = -this.height / 2;
          ctx.translate(offsetX, offsetY);
          ctx[property] = this._applyPatternGradientTransformText(filler);
          return { offsetX: offsetX, offsetY: offsetY };
        }
        else {
          // is a simple gradient or pattern
          ctx[property] = filler.toLive(ctx, this);
          return this._applyPatternGradientTransform(ctx, filler);
        }
      }
      else {
        // is a color
        ctx[property] = filler;
      }
      return { offsetX: 0, offsetY: 0 };
    },

    _setStrokeStyles: function(ctx, decl) {
      ctx.lineWidth = decl.strokeWidth;
      ctx.lineCap = this.strokeLineCap;
      ctx.lineDashOffset = this.strokeDashOffset;
      ctx.lineJoin = this.strokeLineJoin;
      ctx.miterLimit = this.strokeMiterLimit;
      return this.handleFiller(ctx, 'strokeStyle', decl.stroke);
    },

    _setFillStyles: function(ctx, decl) {
      return this.handleFiller(ctx, 'fillStyle', decl.fill);
    },

    /**
     * @private
     * @param {String} method
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {String} _char
     * @param {Number} left Left coordinate
     * @param {Number} top Top coordinate
     * @param {Number} lineHeight Height of the line
     */
    _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
      var decl = this._getStyleDeclaration(lineIndex, charIndex),
          fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          shouldFill = method === 'fillText' && fullDecl.fill,
          shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth,
          fillOffsets, strokeOffsets;

      if (!shouldStroke && !shouldFill) {
        return;
      }
      ctx.save();

      shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));
      shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));

      ctx.font = this._getFontDeclaration(fullDecl);


      if (decl && decl.textBackgroundColor) {
        this._removeShadow(ctx);
      }
      if (decl && decl.deltaY) {
        top += decl.deltaY;
      }
      shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);
      shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);
      ctx.restore();
    },

    /**
     * Turns the character into a 'superior figure' (i.e. 'superscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSuperscript: function(start, end) {
      return this._setScript(start, end, this.superscript);
    },

    /**
     * Turns the character into an 'inferior figure' (i.e. 'subscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSubscript: function(start, end) {
      return this._setScript(start, end, this.subscript);
    },

    /**
     * Applies 'schema' at given position
     * @private
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @param {Number} schema
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    _setScript: function(start, end, schema) {
      var loc = this.get2DCursorLocation(start, true),
          fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'fontSize'),
          dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),
          style = { fontSize: fontSize * schema.size, deltaY: dy + fontSize * schema.baseline };
      this.setSelectionStyles(style, start, end);
      return this;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChanged: function(prevStyle, thisStyle) {
      return prevStyle.fill !== thisStyle.fill ||
              prevStyle.stroke !== thisStyle.stroke ||
              prevStyle.strokeWidth !== thisStyle.strokeWidth ||
              prevStyle.fontSize !== thisStyle.fontSize ||
              prevStyle.fontFamily !== thisStyle.fontFamily ||
              prevStyle.fontWeight !== thisStyle.fontWeight ||
              prevStyle.fontStyle !== thisStyle.fontStyle ||
              prevStyle.deltaY !== thisStyle.deltaY;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
      return this._hasStyleChanged(prevStyle, thisStyle) ||
        prevStyle.overline !== thisStyle.overline ||
        prevStyle.underline !== thisStyle.underline ||
        prevStyle.linethrough !== thisStyle.linethrough;
    },

    /**
     * @private
     * @param {Number} lineIndex index text line
     * @return {Number} Line left offset
     */
    _getLineLeftOffset: function(lineIndex) {
      var lineWidth = this.getLineWidth(lineIndex);
      if (this.textAlign === 'center') {
        return (this.width - lineWidth) / 2;
      }
      if (this.textAlign === 'right') {
        return this.width - lineWidth;
      }
      if (this.textAlign === 'justify-center' && this.isEndOfWrapping(lineIndex)) {
        return (this.width - lineWidth) / 2;
      }
      if (this.textAlign === 'justify-right' && this.isEndOfWrapping(lineIndex)) {
        return this.width - lineWidth;
      }
      return 0;
    },

    /**
     * @private
     */
    _clearCache: function() {
      this.__lineWidths = [];
      this.__lineHeights = [];
      this.__charBounds = [];
    },

    /**
     * @private
     */
    _shouldClearDimensionCache: function() {
      var shouldClear = this._forceClearCache;
      shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
      if (shouldClear) {
        this.dirty = true;
        this._forceClearCache = false;
      }
      return shouldClear;
    },

    /**
     * Measure a single line given its index. Used to calculate the initial
     * text bounding box. The values are calculated and stored in __lineWidths cache.
     * @private
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    getLineWidth: function(lineIndex) {
      if (this.__lineWidths[lineIndex]) {
        return this.__lineWidths[lineIndex];
      }

      var width, line = this._textLines[lineIndex], lineInfo;

      if (line === '') {
        width = 0;
      }
      else {
        lineInfo = this.measureLine(lineIndex);
        width = lineInfo.width;
      }
      this.__lineWidths[lineIndex] = width;
      return width;
    },

    _getWidthOfCharSpacing: function() {
      if (this.charSpacing !== 0) {
        return this.fontSize * this.charSpacing / 1000;
      }
      return 0;
    },

    /**
     * Retrieves the value of property at given character position
     * @param {Number} lineIndex the line number
     * @param {Number} charIndex the character number
     * @param {String} property the property name
     * @returns the value of 'property'
     */
    getValueOfPropertyAt: function(lineIndex, charIndex, property) {
      var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
      if (charStyle && typeof charStyle[property] !== 'undefined') {
        return charStyle[property];
      }
      return this[property];
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextDecoration: function(ctx, type) {
      if (!this[type] && !this.styleHas(type)) {
        return;
      }
      var heightOfLine, size, _size,
          lineLeftOffset, dy, _dy,
          line, lastDecoration,
          leftOffset = this._getLeftOffset(),
          topOffset = this._getTopOffset(), top,
          boxStart, boxWidth, charBox, currentDecoration,
          maxHeight, currentFill, lastFill, path = this.path,
          charSpacing = this._getWidthOfCharSpacing();

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this[type] && !this.styleHas(type, i)) {
          topOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        maxHeight = heightOfLine / this.lineHeight;
        lineLeftOffset = this._getLineLeftOffset(i);
        boxStart = 0;
        boxWidth = 0;
        lastDecoration = this.getValueOfPropertyAt(i, 0, type);
        lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
        top = topOffset + maxHeight * (1 - this._fontSizeFraction);
        size = this.getHeightOfChar(i, 0);
        dy = this.getValueOfPropertyAt(i, 0, 'deltaY');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentDecoration = this.getValueOfPropertyAt(i, j, type);
          currentFill = this.getValueOfPropertyAt(i, j, 'fill');
          _size = this.getHeightOfChar(i, j);
          _dy = this.getValueOfPropertyAt(i, j, 'deltaY');
          if (path && currentDecoration && currentFill) {
            ctx.save();
            ctx.fillStyle = lastFill;
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            ctx.fillRect(
              -charBox.kernedWidth / 2,
              this.offsets[type] * _size + _dy,
              charBox.kernedWidth,
              this.fontSize / 15
            );
            ctx.restore();
          }
          else if (
            (currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy)
            && boxWidth > 0
          ) {
            lastDecoration && lastFill &&
              ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                top + this.offsets[type] * size + dy,
                boxWidth,
                this.fontSize / 15
              );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastDecoration = currentDecoration;
            lastFill = currentFill;
            size = _size;
            dy = _dy;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        ctx.fillStyle = currentFill;
        currentDecoration && currentFill && ctx.fillRect(
          leftOffset + lineLeftOffset + boxStart,
          top + this.offsets[type] * size + dy,
          boxWidth - charSpacing,
          this.fontSize / 15
        );
        topOffset += heightOfLine;
      }
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * return font declaration string for canvas context
     * @param {Object} [styleObject] object
     * @returns {String} font declaration formatted for canvas context.
     */
    _getFontDeclaration: function(styleObject, forMeasuring) {
      var style = styleObject || this, family = this.fontFamily,
          fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
      var fontFamily = family === undefined ||
      family.indexOf('\'') > -1 || family.indexOf(',') > -1 ||
      family.indexOf('"') > -1 || fontIsGeneric
        ? style.fontFamily : '"' + style.fontFamily + '"';
      return [
        // node-canvas needs "weight style", while browsers need "style weight"
        // verify if this can be fixed in JSDOM
        (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
        (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
        forMeasuring ? this.CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
        fontFamily
      ].join(' ');
    },

    /**
     * Renders text instance on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if object is not visible
      if (!this.visible) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
      }
      this.callSuper('render', ctx);
    },

    /**
     * Returns the text as an array of lines.
     * @param {String} text text to split
     * @returns {Array} Lines in the text
     */
    _splitTextIntoLines: function(text) {
      var lines = text.split(this._reNewline),
          newLines = new Array(lines.length),
          newLine = ['\n'],
          newText = [];
      for (var i = 0; i < lines.length; i++) {
        newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
        newText = newText.concat(newLines[i], newLine);
      }
      newText.pop();
      return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var additionalProperties = [
        'text',
        'fontSize',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'lineHeight',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'textBackgroundColor',
        'charSpacing',
      ].concat(propertiesToInclude);
      var obj = this.callSuper('toObject', additionalProperties);
      obj.styles = clone(this.styles, true);
      return obj;
    },

    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(key, value) {
      this.callSuper('set', key, value);
      var needsDims = false;
      var isAddingPath = false;
      if (typeof key === 'object') {
        for (var _key in key) {
          if (_key === 'path') {
            this.setPathInfo();
          }
          needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
          isAddingPath = isAddingPath || _key === 'path';
        }
      }
      else {
        needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
        isAddingPath = key === 'path';
      }
      if (isAddingPath) {
        this.setPathInfo();
      }
      if (needsDims) {
        this.initDimensions();
        this.setCoords();
      }
      return this;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity
     */
    complexity: function() {
      return 1;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
   * @static
   * @memberOf fabric.Text
   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
   */
  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
    'x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));

  /**
   * Default SVG font size
   * @static
   * @memberOf fabric.Text
   */
  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

  /**
   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
   * @static
   * @memberOf fabric.Text
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Text.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }

    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
        parsedAnchor = parsedAttributes.textAnchor || 'left';
    options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

    options.top = options.top || 0;
    options.left = options.left || 0;
    if (parsedAttributes.textDecoration) {
      var textDecoration = parsedAttributes.textDecoration;
      if (textDecoration.indexOf('underline') !== -1) {
        options.underline = true;
      }
      if (textDecoration.indexOf('overline') !== -1) {
        options.overline = true;
      }
      if (textDecoration.indexOf('line-through') !== -1) {
        options.linethrough = true;
      }
      delete options.textDecoration;
    }
    if ('dx' in parsedAttributes) {
      options.left += parsedAttributes.dx;
    }
    if ('dy' in parsedAttributes) {
      options.top += parsedAttributes.dy;
    }
    if (!('fontSize' in options)) {
      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
    }

    var textContent = '';

    // The XML is not properly parsed in IE9 so a workaround to get
    // textContent is through firstChild.data. Another workaround would be
    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
    if (!('textContent' in element)) {
      if ('firstChild' in element && element.firstChild !== null) {
        if ('data' in element.firstChild && element.firstChild.data !== null) {
          textContent = element.firstChild.data;
        }
      }
    }
    else {
      textContent = element.textContent;
    }

    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
    var originalStrokeWidth = options.strokeWidth;
    options.strokeWidth = 0;

    var text = new fabric.Text(textContent, options),
        textHeightScaleFactor = text.getScaledHeight() / text.height,
        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
        scaledDiff = lineHeightDiff * textHeightScaleFactor,
        textHeight = text.getScaledHeight() + scaledDiff,
        offX = 0;
    /*
      Adjust positioning:
        x/y attributes in SVG correspond to the bottom-left corner of text bounding box
        fabric output by default at top, left.
    */
    if (parsedAnchor === 'center') {
      offX = text.getScaledWidth() / 2;
    }
    if (parsedAnchor === 'right') {
      offX = text.getScaledWidth();
    }
    text.set({
      left: text.left - offX,
      top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
      strokeWidth: typeof originalStrokeWidth !== 'undefined' ? originalStrokeWidth : 1,
    });
    callback(text);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Text instance from an object representation
   * @static
   * @memberOf fabric.Text
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
   */
  fabric.Text.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Text', object, callback, 'text');
  };

  fabric.Text.genericFonts = ['sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'];

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

})( true ? exports : 0);


(function() {
  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return true;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          // eslint-disable-next-line no-unused-vars
          for (var p3 in obj[p1][p2]) {
            return false;
          }
        }
      }
      return true;
    },

    /**
     * Returns true if object has a style property or has it ina specified line
     * This function is used to detect if a text will use a particular property or not.
     * @param {String} property to check for
     * @param {Number} lineIndex to check the style on
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return false;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { 0: this.styles[lineIndex] };
      // eslint-disable-next-line
      for (var p1 in obj) {
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          if (typeof obj[p1][p2][property] !== 'undefined') {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Check if characters in a text have a value for a property
     * whose value matches the textbox's value for that property.  If so,
     * the character-level property is deleted.  If the character
     * has no other properties, then it is also deleted.  Finally,
     * if the line containing that character has no other characters
     * then it also is deleted.
     *
     * @param {string} property The property to compare between characters and text.
     */
    cleanStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue,
          allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
      // eslint-disable-next-line
      for (var p1 in obj) {
        letterCount = 0;
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          var styleObject = obj[p1][p2],
              stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);

          stylesCount++;

          if (stylePropertyHasBeenSet) {
            if (!stylePropertyValue) {
              stylePropertyValue = styleObject[property];
            }
            else if (styleObject[property] !== stylePropertyValue) {
              allStyleObjectPropertiesMatch = false;
            }

            if (styleObject[property] === this[property]) {
              delete styleObject[property];
            }
          }
          else {
            allStyleObjectPropertiesMatch = false;
          }

          if (Object.keys(styleObject).length !== 0) {
            letterCount++;
          }
          else {
            delete obj[p1][p2];
          }
        }

        if (letterCount === 0) {
          delete obj[p1];
        }
      }
      // if every grapheme has the same style set then
      // delete those styles and set it on the parent
      for (var i = 0; i < this._textLines.length; i++) {
        graphemeCount += this._textLines[i].length;
      }
      if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
        this[property] = stylePropertyValue;
        this.removeStyle(property);
      }
    },

    /**
     * Remove a style property or properties from all individual character styles
     * in a text object.  Deletes the character style object if it contains no other style
     * props.  Deletes a line style object if it contains no other character styles.
     *
     * @param {String} props The property to remove from character styles.
     */
    removeStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return;
      }
      var obj = this.styles, line, lineNum, charNum;
      for (lineNum in obj) {
        line = obj[lineNum];
        for (charNum in line) {
          delete line[charNum][property];
          if (Object.keys(line[charNum]).length === 0) {
            delete line[charNum];
          }
        }
        if (Object.keys(line).length === 0) {
          delete obj[lineNum];
        }
      }
    },

    /**
     * @private
     */
    _extendStyles: function(index, styles) {
      var loc = this.get2DCursorLocation(index);

      if (!this._getLineStyle(loc.lineIndex)) {
        this._setLineStyle(loc.lineIndex);
      }

      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
      }

      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
    },

    /**
     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.
     */
    get2DCursorLocation: function(selectionStart, skipWrapping) {
      if (typeof selectionStart === 'undefined') {
        selectionStart = this.selectionStart;
      }
      var lines = skipWrapping ? this._unwrappedTextLines : this._textLines,
          len = lines.length;
      for (var i = 0; i < len; i++) {
        if (selectionStart <= lines[i].length) {
          return {
            lineIndex: i,
            charIndex: selectionStart
          };
        }
        selectionStart -= lines[i].length + this.missingNewlineOffset(i);
      }
      return {
        lineIndex: i - 1,
        charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
      };
    },

    /**
     * Gets style of a current selection/cursor (at the start position)
     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @param {Boolean} [complete] get full style or not
     * @return {Array} styles an array with one, zero or more Style objects
     */
    getSelectionStyles: function(startIndex, endIndex, complete) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      var styles = [];
      for (var i = startIndex; i < endIndex; i++) {
        styles.push(this.getStyleAtPosition(i, complete));
      }
      return styles;
    },

    /**
     * Gets style of a current selection/cursor position
     * @param {Number} position  to get styles at
     * @param {Boolean} [complete] full style if true
     * @return {Object} style Style object at a specified index
     * @private
     */
    getStyleAtPosition: function(position, complete) {
      var loc = this.get2DCursorLocation(position),
          style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
            this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
      return style || {};
    },

    /**
     * Sets style of a current selection, if no selection exist, do not set anything.
     * @param {Object} [styles] Styles object
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @return {fabric.IText} thisArg
     * @chainable
     */
    setSelectionStyles: function(styles, startIndex, endIndex) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      for (var i = startIndex; i < endIndex; i++) {
        this._extendStyles(i, styles);
      }
      /* not included in _extendStyles to avoid clearing cache more than once */
      this._forceClearCache = true;
      return this;
    },

    /**
     * get the reference, not a clone, of the style object for a given character
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Object} style object
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      var lineStyle = this.styles && this.styles[lineIndex];
      if (!lineStyle) {
        return null;
      }
      return lineStyle[charIndex];
    },

    /**
     * return a new object that contains all the style property for a character
     * the object returned is newly created
     * @param {Number} lineIndex of the line where the character is
     * @param {Number} charIndex position of the character on the line
     * @return {Object} style object
     */
    getCompleteStyleDeclaration: function(lineIndex, charIndex) {
      var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
          styleObject = { }, prop;
      for (var i = 0; i < this._styleProperties.length; i++) {
        prop = this._styleProperties[i];
        styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
      }
      return styleObject;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      this.styles[lineIndex][charIndex] = style;
    },

    /**
     *
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * @param {Number} lineIndex
     * @return {Boolean} if the line exists or not
     * @private
     */
    _getLineStyle: function(lineIndex) {
      return !!this.styles[lineIndex];
    },

    /**
     * Set the line style to an empty object so that is initialized
     * @param {Number} lineIndex
     * @private
     */
    _setLineStyle: function(lineIndex) {
      this.styles[lineIndex] = {};
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _deleteLineStyle: function(lineIndex) {
      delete this.styles[lineIndex];
    }
  });
})();


(function() {

  function parseDecoration(object) {
    if (object.textDecoration) {
      object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
      object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
      object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
      delete object.textDecoration;
    }
  }

  /**
   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
   * prefix when observing canvas.
   * @class fabric.IText
   * @extends fabric.Text
   * @mixes fabric.Observable
   *
   * @fires changed
   * @fires selection:changed
   * @fires editing:entered
   * @fires editing:exited
   *
   * @return {fabric.IText} thisArg
   * @see {@link fabric.IText#initialize} for constructor definition
   *
   * <p>Supported key combinations:</p>
   * <pre>
   *   Move cursor:                    left, right, up, down
   *   Select character:               shift + left, shift + right
   *   Select text vertically:         shift + up, shift + down
   *   Move cursor by word:            alt + left, alt + right
   *   Select words:                   shift + alt + left, shift + alt + right
   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
   *   Jump to start/end of text:      cmd + up, cmd + down
   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
   *   Delete character:               backspace
   *   Delete word:                    alt + backspace
   *   Delete line:                    cmd + backspace
   *   Forward delete:                 delete
   *   Copy text:                      ctrl/cmd + c
   *   Paste text:                     ctrl/cmd + v
   *   Cut text:                       ctrl/cmd + x
   *   Select entire text:             ctrl/cmd + a
   *   Quit editing                    tab or esc
   * </pre>
   *
   * <p>Supported mouse/touch combination</p>
   * <pre>
   *   Position cursor:                click/touch
   *   Create selection:               click/touch & drag
   *   Create selection:               click & shift + click
   *   Select word:                    double click
   *   Select line:                    triple click
   * </pre>
   */
  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'i-text',

    /**
     * Index where text selection starts (or where cursor is when there is no selection)
     * @type Number
     * @default
     */
    selectionStart: 0,

    /**
     * Index where text selection ends
     * @type Number
     * @default
     */
    selectionEnd: 0,

    /**
     * Color of text selection
     * @type String
     * @default
     */
    selectionColor: 'rgba(17,119,255,0.3)',

    /**
     * Indicates whether text is in editing mode
     * @type Boolean
     * @default
     */
    isEditing: false,

    /**
     * Indicates whether a text can be edited
     * @type Boolean
     * @default
     */
    editable: true,

    /**
     * Border color of text object while it's in editing mode
     * @type String
     * @default
     */
    editingBorderColor: 'rgba(102,153,255,0.25)',

    /**
     * Width of cursor (in px)
     * @type Number
     * @default
     */
    cursorWidth: 2,

    /**
     * Color of text cursor color in editing mode.
     * if not set (default) will take color from the text.
     * if set to a color value that fabric can understand, it will
     * be used instead of the color of the text at the current position.
     * @type String
     * @default
     */
    cursorColor: '',

    /**
     * Delay between cursor blink (in ms)
     * @type Number
     * @default
     */
    cursorDelay: 1000,

    /**
     * Duration of cursor fadein (in ms)
     * @type Number
     * @default
     */
    cursorDuration: 600,

    /**
     * Indicates whether internal text char widths can be cached
     * @type Boolean
     * @default
     */
    caching: true,

    /**
     * @private
     */
    _reSpace: /\s|\n/,

    /**
     * @private
     */
    _currentCursorOpacity: 0,

    /**
     * @private
     */
    _selectionDirection: null,

    /**
     * @private
     */
    _abortCursorAnimation: false,

    /**
     * @private
     */
    __widthOfSpace: [],

    /**
     * Helps determining when the text is in composition, so that the cursor
     * rendering is altered.
     */
    inCompositionMode: false,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.IText} thisArg
     */
    initialize: function(text, options) {
      this.callSuper('initialize', text, options);
      this.initBehavior();
    },

    /**
     * Sets selection start (left boundary of a selection)
     * @param {Number} index Index to set selection start to
     */
    setSelectionStart: function(index) {
      index = Math.max(index, 0);
      this._updateAndFire('selectionStart', index);
    },

    /**
     * Sets selection end (right boundary of a selection)
     * @param {Number} index Index to set selection end to
     */
    setSelectionEnd: function(index) {
      index = Math.min(index, this.text.length);
      this._updateAndFire('selectionEnd', index);
    },

    /**
     * @private
     * @param {String} property 'selectionStart' or 'selectionEnd'
     * @param {Number} index new position of property
     */
    _updateAndFire: function(property, index) {
      if (this[property] !== index) {
        this._fireSelectionChanged();
        this[property] = index;
      }
      this._updateTextarea();
    },

    /**
     * Fires the even of selection changed
     * @private
     */
    _fireSelectionChanged: function() {
      this.fire('selection:changed');
      this.canvas && this.canvas.fire('text:selection:changed', { target: this });
    },

    /**
     * Initialize text dimensions. Render all text on given context
     * or on a offscreen canvas to get the text width with measureText.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     * @private
     */
    initDimensions: function() {
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this.callSuper('initDimensions');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      this.clearContextTop();
      this.callSuper('render', ctx);
      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
      // the correct position but not at every cursor animation.
      this.cursorOffsetCache = { };
      this.renderCursorOrSelection();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this.callSuper('_render', ctx);
    },

    /**
     * Prepare and clean the contextTop
     */
    clearContextTop: function(skipRestore) {
      if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
        return;
      }
      var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      this.transform(ctx);
      this._clearTextArea(ctx);
      skipRestore || ctx.restore();
    },
    /**
     * Renders cursor or selection (depending on what exists)
     * it does on the contextTop. If contextTop is not available, do nothing.
     */
    renderCursorOrSelection: function() {
      if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
        return;
      }
      var boundaries = this._getCursorBoundaries(),
          ctx = this.canvas.contextTop;
      this.clearContextTop(true);
      if (this.selectionStart === this.selectionEnd) {
        this.renderCursor(boundaries, ctx);
      }
      else {
        this.renderSelection(boundaries, ctx);
      }
      ctx.restore();
    },

    _clearTextArea: function(ctx) {
      // we add 4 pixel, to be sure to do not leave any pixel out
      var width = this.width + 4, height = this.height + 4;
      ctx.clearRect(-width / 2, -height / 2, width, height);
    },

    /**
     * Returns cursor boundaries (left, top, leftOffset, topOffset)
     * @private
     * @param {Array} chars Array of characters
     * @param {String} typeOfBoundaries
     */
    _getCursorBoundaries: function(position) {

      // left/top are left/top of entire text box
      // leftOffset/topOffset are offset from that left/top point of a text box

      if (typeof position === 'undefined') {
        position = this.selectionStart;
      }

      var left = this._getLeftOffset(),
          top = this._getTopOffset(),
          offsets = this._getCursorBoundariesOffsets(position);

      return {
        left: left,
        top: top,
        leftOffset: offsets.left,
        topOffset: offsets.top
      };
    },

    /**
     * @private
     */
    _getCursorBoundariesOffsets: function(position) {
      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
        return this.cursorOffsetCache;
      }
      var lineLeftOffset,
          lineIndex,
          charIndex,
          topOffset = 0,
          leftOffset = 0,
          boundaries,
          cursorPosition = this.get2DCursorLocation(position);
      charIndex = cursorPosition.charIndex;
      lineIndex = cursorPosition.lineIndex;
      for (var i = 0; i < lineIndex; i++) {
        topOffset += this.getHeightOfLine(i);
      }
      lineLeftOffset = this._getLineLeftOffset(lineIndex);
      var bound = this.__charBounds[lineIndex][charIndex];
      bound && (leftOffset = bound.left);
      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
        leftOffset -= this._getWidthOfCharSpacing();
      }
      boundaries = {
        top: topOffset,
        left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
      };
      this.cursorOffsetCache = boundaries;
      return this.cursorOffsetCache;
    },

    /**
     * Renders cursor
     * @param {Object} boundaries
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderCursor: function(boundaries, ctx) {
      var cursorLocation = this.get2DCursorLocation(),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
          multiplier = this.scaleX * this.canvas.getZoom(),
          cursorWidth = this.cursorWidth / multiplier,
          topOffset = boundaries.topOffset,
          dy = this.getValueOfPropertyAt(lineIndex, charIndex, 'deltaY');

      topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
        - charHeight * (1 - this._fontSizeFraction);

      if (this.inCompositionMode) {
        this.renderSelection(boundaries, ctx);
      }

      ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
      ctx.fillRect(
        boundaries.left + boundaries.leftOffset - cursorWidth / 2,
        topOffset + boundaries.top + dy,
        cursorWidth,
        charHeight);
    },

    /**
     * Renders text selection
     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderSelection: function(boundaries, ctx) {

      var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
          selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
          isJustify = this.textAlign.indexOf('justify') !== -1,
          start = this.get2DCursorLocation(selectionStart),
          end = this.get2DCursorLocation(selectionEnd),
          startLine = start.lineIndex,
          endLine = end.lineIndex,
          startChar = start.charIndex < 0 ? 0 : start.charIndex,
          endChar = end.charIndex < 0 ? 0 : end.charIndex;

      for (var i = startLine; i <= endLine; i++) {
        var lineOffset = this._getLineLeftOffset(i) || 0,
            lineHeight = this.getHeightOfLine(i),
            realLineHeight = 0, boxStart = 0, boxEnd = 0;

        if (i === startLine) {
          boxStart = this.__charBounds[startLine][startChar].left;
        }
        if (i >= startLine && i < endLine) {
          boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?
        }
        else if (i === endLine) {
          if (endChar === 0) {
            boxEnd = this.__charBounds[endLine][endChar].left;
          }
          else {
            var charSpacing = this._getWidthOfCharSpacing();
            boxEnd = this.__charBounds[endLine][endChar - 1].left
              + this.__charBounds[endLine][endChar - 1].width - charSpacing;
          }
        }
        realLineHeight = lineHeight;
        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
          lineHeight /= this.lineHeight;
        }
        if (this.inCompositionMode) {
          ctx.fillStyle = this.compositionColor || 'black';
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset + lineHeight,
            boxEnd - boxStart,
            1);
        }
        else {
          ctx.fillStyle = this.selectionColor;
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset,
            boxEnd - boxStart,
            lineHeight);
        }


        boundaries.topOffset += realLineHeight;
      }
    },

    /**
     * High level function to know the height of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns fontSize of char at the current cursor
     * Unused from the library, is for the end user
     * @return {Number} Character font size
     */
    getCurrentCharFontSize: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
    },

    /**
     * High level function to know the color of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns color (fill) of char at the current cursor
     * Unused from the library, is for the end user
     * @return {String} Character color (fill)
     */
    getCurrentCharColor: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
    },

    /**
     * Returns the cursor position for the getCurrent.. functions
     * @private
     */
    _getCurrentCharIndex: function() {
      var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
          charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
      return { l: cursorPosition.lineIndex, c: charIndex };
    }
  });

  /**
   * Returns fabric.IText instance from an object representation
   * @static
   * @memberOf fabric.IText
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as argument
   */
  fabric.IText.fromObject = function(object, callback) {
    parseDecoration(object);
    if (object.styles) {
      for (var i in object.styles) {
        for (var j in object.styles[i]) {
          parseDecoration(object.styles[i][j]);
        }
      }
    }
    fabric.Object._fromObject('IText', object, callback, 'text');
  };
})();


(function() {

  var clone = fabric.util.object.clone;

  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes all the interactive behavior of IText
     */
    initBehavior: function() {
      this.initAddedHandler();
      this.initRemovedHandler();
      this.initCursorSelectionHandlers();
      this.initDoubleClickSimulation();
      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
    },

    onDeselect: function() {
      this.isEditing && this.exitEditing();
      this.selected = false;
    },

    /**
     * Initializes "added" event handler
     */
    initAddedHandler: function() {
      var _this = this;
      this.on('added', function() {
        var canvas = _this.canvas;
        if (canvas) {
          if (!canvas._hasITextHandlers) {
            canvas._hasITextHandlers = true;
            _this._initCanvasHandlers(canvas);
          }
          canvas._iTextInstances = canvas._iTextInstances || [];
          canvas._iTextInstances.push(_this);
        }
      });
    },

    initRemovedHandler: function() {
      var _this = this;
      this.on('removed', function() {
        var canvas = _this.canvas;
        if (canvas) {
          canvas._iTextInstances = canvas._iTextInstances || [];
          fabric.util.removeFromArray(canvas._iTextInstances, _this);
          if (canvas._iTextInstances.length === 0) {
            canvas._hasITextHandlers = false;
            _this._removeCanvasHandlers(canvas);
          }
        }
      });
    },

    /**
     * register canvas event to manage exiting on other instances
     * @private
     */
    _initCanvasHandlers: function(canvas) {
      canvas._mouseUpITextHandler = function() {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.__isMousedown = false;
          });
        }
      };
      canvas.on('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * remove canvas event to manage exiting on other instances
     * @private
     */
    _removeCanvasHandlers: function(canvas) {
      canvas.off('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * @private
     */
    _tick: function() {
      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
    },

    /**
     * @private
     */
    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

      var tickState;

      tickState = {
        isAborted: false,
        abort: function() {
          this.isAborted = true;
        },
      };

      obj.animate('_currentCursorOpacity', targetOpacity, {
        duration: duration,
        onComplete: function() {
          if (!tickState.isAborted) {
            obj[completeMethod]();
          }
        },
        onChange: function() {
          // we do not want to animate a selection, only cursor
          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
            obj.renderCursorOrSelection();
          }
        },
        abort: function() {
          return tickState.isAborted;
        }
      });
      return tickState;
    },

    /**
     * @private
     */
    _onTickComplete: function() {

      var _this = this;

      if (this._cursorTimeout1) {
        clearTimeout(this._cursorTimeout1);
      }
      this._cursorTimeout1 = setTimeout(function() {
        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
      }, 100);
    },

    /**
     * Initializes delayed cursor
     */
    initDelayedCursor: function(restart) {
      var _this = this,
          delay = restart ? 0 : this.cursorDelay;

      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this._cursorTimeout2 = setTimeout(function() {
        _this._tick();
      }, delay);
    },

    /**
     * Aborts cursor animation and clears all timeouts
     */
    abortCursorAnimation: function() {
      var shouldClear = this._currentTickState || this._currentTickCompleteState,
          canvas = this.canvas;
      this._currentTickState && this._currentTickState.abort();
      this._currentTickCompleteState && this._currentTickCompleteState.abort();

      clearTimeout(this._cursorTimeout1);
      clearTimeout(this._cursorTimeout2);

      this._currentCursorOpacity = 0;
      // to clear just itext area we need to transform the context
      // it may not be worth it
      if (shouldClear && canvas) {
        canvas.clearContext(canvas.contextTop || canvas.contextContainer);
      }

    },

    /**
     * Selects entire text
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectAll: function() {
      this.selectionStart = 0;
      this.selectionEnd = this._text.length;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Returns selected text
     * @return {String}
     */
    getSelectedText: function() {
      return this._text.slice(this.selectionStart, this.selectionEnd).join('');
    },

    /**
     * Find new selection index representing start of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      // remove space before cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index--;
        }
      }
      while (/\S/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      // remove space after cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index++;
        }
      }
      while (/\S/.test(this._text[index]) && index < this._text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Find new selection index representing start of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      while (!/\n/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      while (!/\n/.test(this._text[index]) && index < this._text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Finds index corresponding to beginning or end of a word
     * @param {Number} selectionStart Index of a character
     * @param {Number} direction 1 or -1
     * @return {Number} Index of the beginning or end of a word
     */
    searchWordBoundary: function(selectionStart, direction) {
      var text = this._text,
          index     = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart,
          _char     = text[index],
          // wrong
          reNonWord = fabric.reNonWord;

      while (!reNonWord.test(_char) && index > 0 && index < text.length) {
        index += direction;
        _char = text[index];
      }
      if (reNonWord.test(_char)) {
        index += direction === 1 ? 0 : 1;
      }
      return index;
    },

    /**
     * Selects a word based on the index
     * @param {Number} selectionStart Index of a character
     */
    selectWord: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      this.renderCursorOrSelection();
    },

    /**
     * Selects a line based on the index
     * @param {Number} selectionStart Index of a character
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectLine: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
          newSelectionEnd = this.findLineBoundaryRight(selectionStart);

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Enters editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    enterEditing: function(e) {
      if (this.isEditing || !this.editable) {
        return;
      }

      if (this.canvas) {
        this.canvas.calcOffset();
        this.exitEditingOnOthers(this.canvas);
      }

      this.isEditing = true;

      this.initHiddenTextarea(e);
      this.hiddenTextarea.focus();
      this.hiddenTextarea.value = this.text;
      this._updateTextarea();
      this._saveEditingProps();
      this._setEditingProps();
      this._textBeforeEdit = this.text;

      this._tick();
      this.fire('editing:entered');
      this._fireSelectionChanged();
      if (!this.canvas) {
        return this;
      }
      this.canvas.fire('text:editing:entered', { target: this });
      this.initMouseMoveHandler();
      this.canvas.requestRenderAll();
      return this;
    },

    exitEditingOnOthers: function(canvas) {
      if (canvas._iTextInstances) {
        canvas._iTextInstances.forEach(function(obj) {
          obj.selected = false;
          if (obj.isEditing) {
            obj.exitEditing();
          }
        });
      }
    },

    /**
     * Initializes "mousemove" event handler
     */
    initMouseMoveHandler: function() {
      this.canvas.on('mouse:move', this.mouseMoveHandler);
    },

    /**
     * @private
     */
    mouseMoveHandler: function(options) {
      if (!this.__isMousedown || !this.isEditing) {
        return;
      }

      var newSelectionStart = this.getSelectionStartFromPointer(options.e),
          currentStart = this.selectionStart,
          currentEnd = this.selectionEnd;
      if (
        (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
        &&
        (currentStart === newSelectionStart || currentEnd === newSelectionStart)
      ) {
        return;
      }
      if (newSelectionStart > this.__selectionStartOnMouseDown) {
        this.selectionStart = this.__selectionStartOnMouseDown;
        this.selectionEnd = newSelectionStart;
      }
      else {
        this.selectionStart = newSelectionStart;
        this.selectionEnd = this.__selectionStartOnMouseDown;
      }
      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
        this.restartCursorIfNeeded();
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      }
    },

    /**
     * @private
     */
    _setEditingProps: function() {
      this.hoverCursor = 'text';

      if (this.canvas) {
        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
      }

      this.borderColor = this.editingBorderColor;
      this.hasControls = this.selectable = false;
      this.lockMovementX = this.lockMovementY = true;
    },

    /**
     * convert from textarea to grapheme indexes
     */
    fromStringToGraphemeSelection: function(start, end, text) {
      var smallerTextStart = text.slice(0, start),
          graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = text.slice(start, end),
          graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * convert from fabric to textarea values
     */
    fromGraphemeToStringSelection: function(start, end, _text) {
      var smallerTextStart = _text.slice(0, start),
          graphemeStart = smallerTextStart.join('').length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = _text.slice(start, end),
          graphemeEnd = smallerTextEnd.join('').length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * @private
     */
    _updateTextarea: function() {
      this.cursorOffsetCache = { };
      if (!this.hiddenTextarea) {
        return;
      }
      if (!this.inCompositionMode) {
        var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = newSelection.selectionStart;
        this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateFromTextArea: function() {
      if (!this.hiddenTextarea) {
        return;
      }
      this.cursorOffsetCache = { };
      this.text = this.hiddenTextarea.value;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      var newSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
      this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
      if (!this.inCompositionMode) {
        this.selectionStart = newSelection.selectionStart;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateTextareaPosition: function() {
      if (this.selectionStart === this.selectionEnd) {
        var style = this._calcTextareaPosition();
        this.hiddenTextarea.style.left = style.left;
        this.hiddenTextarea.style.top = style.top;
      }
    },

    /**
     * @private
     * @return {Object} style contains style for hiddenTextarea
     */
    _calcTextareaPosition: function() {
      if (!this.canvas) {
        return { x: 1, y: 1 };
      }
      var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart,
          boundaries = this._getCursorBoundaries(desiredPosition),
          cursorLocation = this.get2DCursorLocation(desiredPosition),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
          leftOffset = boundaries.leftOffset,
          m = this.calcTransformMatrix(),
          p = {
            x: boundaries.left + leftOffset,
            y: boundaries.top + boundaries.topOffset + charHeight
          },
          retinaScaling = this.canvas.getRetinaScaling(),
          upperCanvas = this.canvas.upperCanvasEl,
          upperCanvasWidth = upperCanvas.width / retinaScaling,
          upperCanvasHeight = upperCanvas.height / retinaScaling,
          maxWidth = upperCanvasWidth - charHeight,
          maxHeight = upperCanvasHeight - charHeight,
          scaleX = upperCanvas.clientWidth / upperCanvasWidth,
          scaleY = upperCanvas.clientHeight / upperCanvasHeight;

      p = fabric.util.transformPoint(p, m);
      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
      p.x *= scaleX;
      p.y *= scaleY;
      if (p.x < 0) {
        p.x = 0;
      }
      if (p.x > maxWidth) {
        p.x = maxWidth;
      }
      if (p.y < 0) {
        p.y = 0;
      }
      if (p.y > maxHeight) {
        p.y = maxHeight;
      }

      // add canvas offset on document
      p.x += this.canvas._offset.left;
      p.y += this.canvas._offset.top;

      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
    },

    /**
     * @private
     */
    _saveEditingProps: function() {
      this._savedProps = {
        hasControls: this.hasControls,
        borderColor: this.borderColor,
        lockMovementX: this.lockMovementX,
        lockMovementY: this.lockMovementY,
        hoverCursor: this.hoverCursor,
        selectable: this.selectable,
        defaultCursor: this.canvas && this.canvas.defaultCursor,
        moveCursor: this.canvas && this.canvas.moveCursor
      };
    },

    /**
     * @private
     */
    _restoreEditingProps: function() {
      if (!this._savedProps) {
        return;
      }

      this.hoverCursor = this._savedProps.hoverCursor;
      this.hasControls = this._savedProps.hasControls;
      this.borderColor = this._savedProps.borderColor;
      this.selectable = this._savedProps.selectable;
      this.lockMovementX = this._savedProps.lockMovementX;
      this.lockMovementY = this._savedProps.lockMovementY;

      if (this.canvas) {
        this.canvas.defaultCursor = this._savedProps.defaultCursor;
        this.canvas.moveCursor = this._savedProps.moveCursor;
      }
    },

    /**
     * Exits from editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    exitEditing: function() {
      var isTextChanged = (this._textBeforeEdit !== this.text);
      var hiddenTextarea = this.hiddenTextarea;
      this.selected = false;
      this.isEditing = false;

      this.selectionEnd = this.selectionStart;

      if (hiddenTextarea) {
        hiddenTextarea.blur && hiddenTextarea.blur();
        hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
      }
      this.hiddenTextarea = null;
      this.abortCursorAnimation();
      this._restoreEditingProps();
      this._currentCursorOpacity = 0;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this.fire('editing:exited');
      isTextChanged && this.fire('modified');
      if (this.canvas) {
        this.canvas.off('mouse:move', this.mouseMoveHandler);
        this.canvas.fire('text:editing:exited', { target: this });
        isTextChanged && this.canvas.fire('object:modified', { target: this });
      }
      return this;
    },

    /**
     * @private
     */
    _removeExtraneousStyles: function() {
      for (var prop in this.styles) {
        if (!this._textLines[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * remove and reflow a style block from start to end.
     * @param {Number} start linear start position for removal (included in removal)
     * @param {Number} end linear end position for removal ( excluded from removal )
     */
    removeStyleFromTo: function(start, end) {
      var cursorStart = this.get2DCursorLocation(start, true),
          cursorEnd = this.get2DCursorLocation(end, true),
          lineStart = cursorStart.lineIndex,
          charStart = cursorStart.charIndex,
          lineEnd = cursorEnd.lineIndex,
          charEnd = cursorEnd.charIndex,
          i, styleObj;
      if (lineStart !== lineEnd) {
        // step1 remove the trailing of lineStart
        if (this.styles[lineStart]) {
          for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
            delete this.styles[lineStart][i];
          }
        }
        // step2 move the trailing of lineEnd to lineStart if needed
        if (this.styles[lineEnd]) {
          for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
            styleObj = this.styles[lineEnd][i];
            if (styleObj) {
              this.styles[lineStart] || (this.styles[lineStart] = { });
              this.styles[lineStart][charStart + i - charEnd] = styleObj;
            }
          }
        }
        // step3 detects lines will be completely removed.
        for (i = lineStart + 1; i <= lineEnd; i++) {
          delete this.styles[i];
        }
        // step4 shift remaining lines.
        this.shiftLineStyles(lineEnd, lineStart - lineEnd);
      }
      else {
        // remove and shift left on the same line
        if (this.styles[lineStart]) {
          styleObj = this.styles[lineStart];
          var diff = charEnd - charStart, numericChar, _char;
          for (i = charStart; i < charEnd; i++) {
            delete styleObj[i];
          }
          for (_char in this.styles[lineStart]) {
            numericChar = parseInt(_char, 10);
            if (numericChar >= charEnd) {
              styleObj[numericChar - diff] = styleObj[_char];
              delete styleObj[_char];
            }
          }
        }
      }
    },

    /**
     * Shifts line styles up or down
     * @param {Number} lineIndex Index of a line
     * @param {Number} offset Can any number?
     */
    shiftLineStyles: function(lineIndex, offset) {
      // shift all line styles by offset upward or downward
      // do not clone deep. we need new array, not new style objects
      var clonedStyles = clone(this.styles);
      for (var line in this.styles) {
        var numericLine = parseInt(line, 10);
        if (numericLine > lineIndex) {
          this.styles[numericLine + offset] = clonedStyles[numericLine];
          if (!clonedStyles[numericLine - offset]) {
            delete this.styles[numericLine];
          }
        }
      }
    },

    restartCursorIfNeeded: function() {
      if (!this._currentTickState || this._currentTickState.isAborted
        || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
      ) {
        this.initDelayedCursor();
      }
    },

    /**
     * Handle insertion of more consecutive style lines for when one or more
     * newlines gets added to the text. Since current style needs to be shifted
     * first we shift the current style of the number lines needed, then we add
     * new lines from the last to the first.
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} qty number of lines to add
     * @param {Array} copiedStyle Array of objects styles
     */
    insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
      var currentCharStyle,
          newLineStyles = {},
          somethingAdded = false,
          isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;

      qty || (qty = 1);
      this.shiftLineStyles(lineIndex, qty);
      if (this.styles[lineIndex]) {
        currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
      }
      // we clone styles of all chars
      // after cursor onto the current line
      for (var index in this.styles[lineIndex]) {
        var numIndex = parseInt(index, 10);
        if (numIndex >= charIndex) {
          somethingAdded = true;
          newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
          // remove lines from the previous line since they're on a new line now
          if (!(isEndOfLine && charIndex === 0)) {
            delete this.styles[lineIndex][index];
          }
        }
      }
      var styleCarriedOver = false;
      if (somethingAdded && !isEndOfLine) {
        // if is end of line, the extra style we copied
        // is probably not something we want
        this.styles[lineIndex + qty] = newLineStyles;
        styleCarriedOver = true;
      }
      if (styleCarriedOver) {
        // skip the last line of since we already prepared it.
        qty--;
      }
      // for the all the lines or all the other lines
      // we clone current char style onto the next (otherwise empty) line
      while (qty > 0) {
        if (copiedStyle && copiedStyle[qty - 1]) {
          this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty - 1]) };
        }
        else if (currentCharStyle) {
          this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
        }
        else {
          delete this.styles[lineIndex + qty];
        }
        qty--;
      }
      this._forceClearCache = true;
    },

    /**
     * Inserts style object for a given line/char index
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} quantity number Style object to insert, if given
     * @param {Array} copiedStyle array of style objects
     */
    insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
      if (!this.styles) {
        this.styles = {};
      }
      var currentLineStyles       = this.styles[lineIndex],
          currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

      quantity || (quantity = 1);
      // shift all char styles by quantity forward
      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
      for (var index in currentLineStylesCloned) {
        var numericIndex = parseInt(index, 10);
        if (numericIndex >= charIndex) {
          currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
          // only delete the style if there was nothing moved there
          if (!currentLineStylesCloned[numericIndex - quantity]) {
            delete currentLineStyles[numericIndex];
          }
        }
      }
      this._forceClearCache = true;
      if (copiedStyle) {
        while (quantity--) {
          if (!Object.keys(copiedStyle[quantity]).length) {
            continue;
          }
          if (!this.styles[lineIndex]) {
            this.styles[lineIndex] = {};
          }
          this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
        }
        return;
      }
      if (!currentLineStyles) {
        return;
      }
      var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
      while (newStyle && quantity--) {
        this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
      }
    },

    /**
     * Inserts style object(s)
     * @param {Array} insertedText Characters at the location where style is inserted
     * @param {Number} start cursor index for inserting style
     * @param {Array} [copiedStyle] array of style objects to insert.
     */
    insertNewStyleBlock: function(insertedText, start, copiedStyle) {
      var cursorLoc = this.get2DCursorLocation(start, true),
          addedLines = [0], linesLength = 0;
      // get an array of how many char per lines are being added.
      for (var i = 0; i < insertedText.length; i++) {
        if (insertedText[i] === '\n') {
          linesLength++;
          addedLines[linesLength] = 0;
        }
        else {
          addedLines[linesLength]++;
        }
      }
      // for the first line copy the style from the current char position.
      if (addedLines[0] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
      }
      linesLength && this.insertNewlineStyleObject(
        cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);
      for (var i = 1; i < linesLength; i++) {
        if (addedLines[i] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        }
        else if (copiedStyle) {
          this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
        }
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
      }
      // we use i outside the loop to get it like linesLength
      if (addedLines[i] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
      }
    },

    /**
     * Set the selectionStart and selectionEnd according to the new position of cursor
     * mimic the key - mouse navigation when shift is pressed.
     */
    setSelectionStartEndWithShift: function(start, end, newSelection) {
      if (newSelection <= start) {
        if (end === start) {
          this._selectionDirection = 'left';
        }
        else if (this._selectionDirection === 'right') {
          this._selectionDirection = 'left';
          this.selectionEnd = start;
        }
        this.selectionStart = newSelection;
      }
      else if (newSelection > start && newSelection < end) {
        if (this._selectionDirection === 'right') {
          this.selectionEnd = newSelection;
        }
        else {
          this.selectionStart = newSelection;
        }
      }
      else {
        // newSelection is > selection start and end
        if (end === start) {
          this._selectionDirection = 'right';
        }
        else if (this._selectionDirection === 'left') {
          this._selectionDirection = 'right';
          this.selectionStart = end;
        }
        this.selectionEnd = newSelection;
      }
    },

    setSelectionInBoundaries: function() {
      var length = this.text.length;
      if (this.selectionStart > length) {
        this.selectionStart = length;
      }
      else if (this.selectionStart < 0) {
        this.selectionStart = 0;
      }
      if (this.selectionEnd > length) {
        this.selectionEnd = length;
      }
      else if (this.selectionEnd < 0) {
        this.selectionEnd = 0;
      }
    }
  });
})();


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
  /**
   * Initializes "dbclick" event handler
   */
  initDoubleClickSimulation: function() {

    // for double click
    this.__lastClickTime = +new Date();

    // for triple click
    this.__lastLastClickTime = +new Date();

    this.__lastPointer = { };

    this.on('mousedown', this.onMouseDown);
  },

  /**
   * Default event handler to simulate triple click
   * @private
   */
  onMouseDown: function(options) {
    if (!this.canvas) {
      return;
    }
    this.__newClickTime = +new Date();
    var newPointer = options.pointer;
    if (this.isTripleClick(newPointer)) {
      this.fire('tripleclick', options);
      this._stopEvent(options.e);
    }
    this.__lastLastClickTime = this.__lastClickTime;
    this.__lastClickTime = this.__newClickTime;
    this.__lastPointer = newPointer;
    this.__lastIsEditing = this.isEditing;
    this.__lastSelected = this.selected;
  },

  isTripleClick: function(newPointer) {
    return this.__newClickTime - this.__lastClickTime < 500 &&
        this.__lastClickTime - this.__lastLastClickTime < 500 &&
        this.__lastPointer.x === newPointer.x &&
        this.__lastPointer.y === newPointer.y;
  },

  /**
   * @private
   */
  _stopEvent: function(e) {
    e.preventDefault && e.preventDefault();
    e.stopPropagation && e.stopPropagation();
  },

  /**
   * Initializes event handlers related to cursor or selection
   */
  initCursorSelectionHandlers: function() {
    this.initMousedownHandler();
    this.initMouseupHandler();
    this.initClicks();
  },

  /**
   * Default handler for double click, select a word
   */
  doubleClickHandler: function(options) {
    if (!this.isEditing) {
      return;
    }
    this.selectWord(this.getSelectionStartFromPointer(options.e));
  },

  /**
   * Default handler for triple click, select a line
   */
  tripleClickHandler: function(options) {
    if (!this.isEditing) {
      return;
    }
    this.selectLine(this.getSelectionStartFromPointer(options.e));
  },

  /**
   * Initializes double and triple click event handlers
   */
  initClicks: function() {
    this.on('mousedblclick', this.doubleClickHandler);
    this.on('tripleclick', this.tripleClickHandler);
  },

  /**
   * Default event handler for the basic functionalities needed on _mouseDown
   * can be overridden to do something different.
   * Scope of this implementation is: find the click position, set selectionStart
   * find selectionEnd, initialize the drawing of either cursor or selection area
   * initializing a mousedDown on a text area will cancel fabricjs knowledge of
   * current compositionMode. It will be set to false.
   */
  _mouseDownHandler: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }

    this.__isMousedown = true;

    if (this.selected) {
      this.inCompositionMode = false;
      this.setCursorByClick(options.e);
    }

    if (this.isEditing) {
      this.__selectionStartOnMouseDown = this.selectionStart;
      if (this.selectionStart === this.selectionEnd) {
        this.abortCursorAnimation();
      }
      this.renderCursorOrSelection();
    }
  },

  /**
   * Default event handler for the basic functionalities needed on mousedown:before
   * can be overridden to do something different.
   * Scope of this implementation is: verify the object is already selected when mousing down
   */
  _mouseDownHandlerBefore: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }
    // we want to avoid that an object that was selected and then becomes unselectable,
    // may trigger editing mode in some way.
    this.selected = this === this.canvas._activeObject;
  },

  /**
   * Initializes "mousedown" event handler
   */
  initMousedownHandler: function() {
    this.on('mousedown', this._mouseDownHandler);
    this.on('mousedown:before', this._mouseDownHandlerBefore);
  },

  /**
   * Initializes "mouseup" event handler
   */
  initMouseupHandler: function() {
    this.on('mouseup', this.mouseUpHandler);
  },

  /**
   * standard handler for mouse up, overridable
   * @private
   */
  mouseUpHandler: function(options) {
    this.__isMousedown = false;
    if (!this.editable || this.group ||
      (options.transform && options.transform.actionPerformed) ||
      (options.e.button && options.e.button !== 1)) {
      return;
    }

    if (this.canvas) {
      var currentActive = this.canvas._activeObject;
      if (currentActive && currentActive !== this) {
        // avoid running this logic when there is an active object
        // this because is possible with shift click and fast clicks,
        // to rapidly deselect and reselect this object and trigger an enterEdit
        return;
      }
    }

    if (this.__lastSelected && !this.__corner) {
      this.selected = false;
      this.__lastSelected = false;
      this.enterEditing(options.e);
      if (this.selectionStart === this.selectionEnd) {
        this.initDelayedCursor(true);
      }
      else {
        this.renderCursorOrSelection();
      }
    }
    else {
      this.selected = true;
    }
  },

  /**
   * Changes cursor location in a text depending on passed pointer (x/y) object
   * @param {Event} e Event object
   */
  setCursorByClick: function(e) {
    var newSelection = this.getSelectionStartFromPointer(e),
        start = this.selectionStart, end = this.selectionEnd;
    if (e.shiftKey) {
      this.setSelectionStartEndWithShift(start, end, newSelection);
    }
    else {
      this.selectionStart = newSelection;
      this.selectionEnd = newSelection;
    }
    if (this.isEditing) {
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Returns index of a character corresponding to where an object was clicked
   * @param {Event} e Event object
   * @return {Number} Index of a character
   */
  getSelectionStartFromPointer: function(e) {
    var mouseOffset = this.getLocalPointer(e),
        prevWidth = 0,
        width = 0,
        height = 0,
        charIndex = 0,
        lineIndex = 0,
        lineLeftOffset,
        line;

    for (var i = 0, len = this._textLines.length; i < len; i++) {
      if (height <= mouseOffset.y) {
        height += this.getHeightOfLine(i) * this.scaleY;
        lineIndex = i;
        if (i > 0) {
          charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);
        }
      }
      else {
        break;
      }
    }
    lineLeftOffset = this._getLineLeftOffset(lineIndex);
    width = lineLeftOffset * this.scaleX;
    line = this._textLines[lineIndex];
    for (var j = 0, jlen = line.length; j < jlen; j++) {
      prevWidth = width;
      // i removed something about flipX here, check.
      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
      if (width <= mouseOffset.x) {
        charIndex++;
      }
      else {
        break;
      }
    }
    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
  },

  /**
   * @private
   */
  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
    // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
        distanceBtwNextCharAndCursor = width - mouseOffset.x,
        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
          distanceBtwNextCharAndCursor < 0 ? 0 : 1,
        newSelectionStart = index + offset;
    // if object is horizontally flipped, mirror cursor location from the end
    if (this.flipX) {
      newSelectionStart = jlen - newSelectionStart;
    }

    if (newSelectionStart > this._text.length) {
      newSelectionStart = this._text.length;
    }

    return newSelectionStart;
  }
});


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

  /**
   * Initializes hidden textarea (needed to bring up keyboard in iOS)
   */
  initHiddenTextarea: function() {
    this.hiddenTextarea = fabric.document.createElement('textarea');
    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
    this.hiddenTextarea.setAttribute('autocorrect', 'off');
    this.hiddenTextarea.setAttribute('autocomplete', 'off');
    this.hiddenTextarea.setAttribute('spellcheck', 'false');
    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
    this.hiddenTextarea.setAttribute('wrap', 'off');
    var style = this._calcTextareaPosition();
    // line-height: 1px; was removed from the style to fix this:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=870966
    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
    ' paddingｰtop: ' + style.fontSize + ';';
    fabric.document.body.appendChild(this.hiddenTextarea);

    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

    if (!this._clickHandlerInitialized && this.canvas) {
      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
      this._clickHandlerInitialized = true;
    }
  },

  /**
   * For functionalities on keyDown
   * Map a special key to a function of the instance/prototype
   * If you need different behaviour for ESC or TAB or arrows, you have to change
   * this map setting the name of a function that you build on the fabric.Itext or
   * your prototype.
   * the map change will affect all Instances unless you need for only some text Instances
   * in that case you have to clone this object and assign your Instance.
   * this.keysMap = fabric.util.object.clone(this.keysMap);
   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
   */
  keysMap: {
    9:  'exitEditing',
    27: 'exitEditing',
    33: 'moveCursorUp',
    34: 'moveCursorDown',
    35: 'moveCursorRight',
    36: 'moveCursorLeft',
    37: 'moveCursorLeft',
    38: 'moveCursorUp',
    39: 'moveCursorRight',
    40: 'moveCursorDown',
  },

  /**
   * For functionalities on keyUp + ctrl || cmd
   */
  ctrlKeysMapUp: {
    67: 'copy',
    88: 'cut'
  },

  /**
   * For functionalities on keyDown + ctrl || cmd
   */
  ctrlKeysMapDown: {
    65: 'selectAll'
  },

  onClick: function() {
    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
    this.hiddenTextarea && this.hiddenTextarea.focus();
  },

  /**
   * Handles keydown event
   * only used for arrows and combination of modifier keys.
   * @param {Event} e Event object
   */
  onKeyDown: function(e) {
    if (!this.isEditing) {
      return;
    }
    if (e.keyCode in this.keysMap) {
      this[this.keysMap[e.keyCode]](e);
    }
    else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    if (e.keyCode >= 33 && e.keyCode <= 40) {
      // if i press an arrow key just update selection
      this.inCompositionMode = false;
      this.clearContextTop();
      this.renderCursorOrSelection();
    }
    else {
      this.canvas && this.canvas.requestRenderAll();
    }
  },

  /**
   * Handles keyup event
   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
   * if a copy/cut event fired, keyup is dismissed
   * @param {Event} e Event object
   */
  onKeyUp: function(e) {
    if (!this.isEditing || this._copyDone || this.inCompositionMode) {
      this._copyDone = false;
      return;
    }
    if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapUp[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.canvas && this.canvas.requestRenderAll();
  },

  /**
   * Handles onInput event
   * @param {Event} e Event object
   */
  onInput: function(e) {
    var fromPaste = this.fromPaste;
    this.fromPaste = false;
    e && e.stopPropagation();
    if (!this.isEditing) {
      return;
    }
    // decisions about style changes.
    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
        charCount = this._text.length,
        nextCharCount = nextText.length,
        removedText, insertedText,
        charDiff = nextCharCount - charCount,
        selectionStart = this.selectionStart, selectionEnd = this.selectionEnd,
        selection = selectionStart !== selectionEnd,
        copiedStyle, removeFrom, removeTo;
    if (this.hiddenTextarea.value === '') {
      this.styles = { };
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
      return;
    }

    var textareaSelection = this.fromStringToGraphemeSelection(
      this.hiddenTextarea.selectionStart,
      this.hiddenTextarea.selectionEnd,
      this.hiddenTextarea.value
    );
    var backDelete = selectionStart > textareaSelection.selectionStart;

    if (selection) {
      removedText = this._text.slice(selectionStart, selectionEnd);
      charDiff += selectionEnd - selectionStart;
    }
    else if (nextCharCount < charCount) {
      if (backDelete) {
        removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);
      }
      else {
        removedText = this._text.slice(selectionStart, selectionStart - charDiff);
      }
    }
    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
    if (removedText && removedText.length) {
      if (insertedText.length) {
        // let's copy some style before deleting.
        // we want to copy the style before the cursor OR the style at the cursor if selection
        // is bigger than 0.
        copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);
        // now duplicate the style one for each inserted text.
        copiedStyle = insertedText.map(function() {
          // this return an array of references, but that is fine since we are
          // copying the style later.
          return copiedStyle[0];
        });
      }
      if (selection) {
        removeFrom = selectionStart;
        removeTo = selectionEnd;
      }
      else if (backDelete) {
        // detect differences between forwardDelete and backDelete
        removeFrom = selectionEnd - removedText.length;
        removeTo = selectionEnd;
      }
      else {
        removeFrom = selectionEnd;
        removeTo = selectionEnd + removedText.length;
      }
      this.removeStyleFromTo(removeFrom, removeTo);
    }
    if (insertedText.length) {
      if (fromPaste && insertedText.join('') === fabric.copiedText && !fabric.disableStyleCopyPaste) {
        copiedStyle = fabric.copiedTextStyle;
      }
      this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);
    }
    this.updateFromTextArea();
    this.fire('changed');
    if (this.canvas) {
      this.canvas.fire('text:changed', { target: this });
      this.canvas.requestRenderAll();
    }
  },
  /**
   * Composition start
   */
  onCompositionStart: function() {
    this.inCompositionMode = true;
  },

  /**
   * Composition end
   */
  onCompositionEnd: function() {
    this.inCompositionMode = false;
  },

  // /**
  //  * Composition update
  //  */
  onCompositionUpdate: function(e) {
    this.compositionStart = e.target.selectionStart;
    this.compositionEnd = e.target.selectionEnd;
    this.updateTextareaPosition();
  },

  /**
   * Copies selected text
   * @param {Event} e Event object
   */
  copy: function() {
    if (this.selectionStart === this.selectionEnd) {
      //do not cut-copy if no selection
      return;
    }

    fabric.copiedText = this.getSelectedText();
    if (!fabric.disableStyleCopyPaste) {
      fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
    }
    else {
      fabric.copiedTextStyle = null;
    }
    this._copyDone = true;
  },

  /**
   * Pastes text
   * @param {Event} e Event object
   */
  paste: function() {
    this.fromPaste = true;
  },

  /**
   * @private
   * @param {Event} e Event object
   * @return {Object} Clipboard data object
   */
  _getClipboardData: function(e) {
    return (e && e.clipboardData) || fabric.window.clipboardData;
  },

  /**
   * Finds the width in pixels before the cursor on the same line
   * @private
   * @param {Number} lineIndex
   * @param {Number} charIndex
   * @return {Number} widthBeforeCursor width before cursor
   */
  _getWidthBeforeCursor: function(lineIndex, charIndex) {
    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

    if (charIndex > 0) {
      bound = this.__charBounds[lineIndex][charIndex - 1];
      widthBeforeCursor += bound.left + bound.width;
    }
    return widthBeforeCursor;
  },

  /**
   * Gets start offset of a selection
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getDownCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    // if on last line, down cursor goes to end of line
    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
      // move to the end of a text
      return this._text.length - selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
    return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
  },

  /**
   * private
   * Helps finding if the offset should be counted from Start or End
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  _getSelectionForOffset: function(e, isRight) {
    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
      return this.selectionEnd;
    }
    else {
      return this.selectionStart;
    }
  },

  /**
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getUpCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
      // if on first line, up cursor goes to start of line
      return -selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
        missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
    // return a negative offset
    return -this._textLines[lineIndex - 1].length
     + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
  },

  /**
   * for a given width it founds the matching character.
   * @private
   */
  _getIndexOnLine: function(lineIndex, width) {

    var line = this._textLines[lineIndex],
        lineLeftOffset = this._getLineLeftOffset(lineIndex),
        widthOfCharsOnLine = lineLeftOffset,
        indexOnLine = 0, charWidth, foundMatch;

    for (var j = 0, jlen = line.length; j < jlen; j++) {
      charWidth = this.__charBounds[lineIndex][j].width;
      widthOfCharsOnLine += charWidth;
      if (widthOfCharsOnLine > width) {
        foundMatch = true;
        var leftEdge = widthOfCharsOnLine - charWidth,
            rightEdge = widthOfCharsOnLine,
            offsetFromLeftEdge = Math.abs(leftEdge - width),
            offsetFromRightEdge = Math.abs(rightEdge - width);

        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
        break;
      }
    }

    // reached end
    if (!foundMatch) {
      indexOnLine = line.length - 1;
    }

    return indexOnLine;
  },


  /**
   * Moves cursor down
   * @param {Event} e Event object
   */
  moveCursorDown: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorUpOrDown('Down', e);
  },

  /**
   * Moves cursor up
   * @param {Event} e Event object
   */
  moveCursorUp: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorUpOrDown('Up', e);
  },

  /**
   * Moves cursor up or down, fires the events
   * @param {String} direction 'Up' or 'Down'
   * @param {Event} e Event object
   */
  _moveCursorUpOrDown: function(direction, e) {
    // getUpCursorOffset
    // getDownCursorOffset
    var action = 'get' + direction + 'CursorOffset',
        offset = this[action](e, this._selectionDirection === 'right');
    if (e.shiftKey) {
      this.moveCursorWithShift(offset);
    }
    else {
      this.moveCursorWithoutShift(offset);
    }
    if (offset !== 0) {
      this.setSelectionInBoundaries();
      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor with shift
   * @param {Number} offset
   */
  moveCursorWithShift: function(offset) {
    var newSelection = this._selectionDirection === 'left'
      ? this.selectionStart + offset
      : this.selectionEnd + offset;
    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
    return offset !== 0;
  },

  /**
   * Moves cursor up without shift
   * @param {Number} offset
   */
  moveCursorWithoutShift: function(offset) {
    if (offset < 0) {
      this.selectionStart += offset;
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionEnd += offset;
      this.selectionStart = this.selectionEnd;
    }
    return offset !== 0;
  },

  /**
   * Moves cursor left
   * @param {Event} e Event object
   */
  moveCursorLeft: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorLeftOrRight('Left', e);
  },

  /**
   * @private
   * @return {Boolean} true if a change happened
   */
  _move: function(e, prop, direction) {
    var newValue;
    if (e.altKey) {
      newValue = this['findWordBoundary' + direction](this[prop]);
    }
    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
      newValue = this['findLineBoundary' + direction](this[prop]);
    }
    else {
      this[prop] += direction === 'Left' ? -1 : 1;
      return true;
    }
    if (typeof newValue !== undefined && this[prop] !== newValue) {
      this[prop] = newValue;
      return true;
    }
  },

  /**
   * @private
   */
  _moveLeft: function(e, prop) {
    return this._move(e, prop, 'Left');
  },

  /**
   * @private
   */
  _moveRight: function(e, prop) {
    return this._move(e, prop, 'Right');
  },

  /**
   * Moves cursor left without keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithoutShift: function(e) {
    var change = true;
    this._selectionDirection = 'left';

    // only move cursor when there is no selection,
    // otherwise we discard it, and leave cursor on same place
    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
      change = this._moveLeft(e, 'selectionStart');

    }
    this.selectionEnd = this.selectionStart;
    return change;
  },

  /**
   * Moves cursor left while keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithShift: function(e) {
    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
      return this._moveLeft(e, 'selectionEnd');
    }
    else if (this.selectionStart !== 0){
      this._selectionDirection = 'left';
      return this._moveLeft(e, 'selectionStart');
    }
  },

  /**
   * Moves cursor right
   * @param {Event} e Event object
   */
  moveCursorRight: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorLeftOrRight('Right', e);
  },

  /**
   * Moves cursor right or Left, fires event
   * @param {String} direction 'Left', 'Right'
   * @param {Event} e Event object
   */
  _moveCursorLeftOrRight: function(direction, e) {
    var actionName = 'moveCursor' + direction + 'With';
    this._currentCursorOpacity = 1;

    if (e.shiftKey) {
      actionName += 'Shift';
    }
    else {
      actionName += 'outShift';
    }
    if (this[actionName](e)) {
      this.abortCursorAnimation();
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor right while keeping selection
   * @param {Event} e
   */
  moveCursorRightWithShift: function(e) {
    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
      return this._moveRight(e, 'selectionStart');
    }
    else if (this.selectionEnd !== this._text.length) {
      this._selectionDirection = 'right';
      return this._moveRight(e, 'selectionEnd');
    }
  },

  /**
   * Moves cursor right without keeping selection
   * @param {Event} e Event object
   */
  moveCursorRightWithoutShift: function(e) {
    var changed = true;
    this._selectionDirection = 'right';

    if (this.selectionStart === this.selectionEnd) {
      changed = this._moveRight(e, 'selectionStart');
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionStart = this.selectionEnd;
    }
    return changed;
  },

  /**
   * Removes characters from start/end
   * start/end ar per grapheme position in _text array.
   *
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  removeChars: function(start, end) {
    if (typeof end === 'undefined') {
      end = start + 1;
    }
    this.removeStyleFromTo(start, end);
    this._text.splice(start, end - start);
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

  /**
   * insert characters at start position, before start position.
   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
   * if style array is provided, it must be as the same length of text in graphemes
   * if end is provided and is bigger than start, old text is replaced.
   * start/end ar per grapheme position in _text array.
   *
   * @param {String} text text to insert
   * @param {Array} style array of style objects
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  insertChars: function(text, style, start, end) {
    if (typeof end === 'undefined') {
      end = start;
    }
    if (end > start) {
      this.removeStyleFromTo(start, end);
    }
    var graphemes = fabric.util.string.graphemeSplit(text);
    this.insertNewStyleBlock(graphemes, start, style);
    this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

});


/* _TO_SVG_START_ */
(function() {
  var toFixed = fabric.util.toFixed,
      multipleSpacesRegex = /  +/g;

  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    _toSVG: function() {
      var offsets = this._getSVGLeftTopOffsets(),
          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
      return this._wrapSVGTextAndBg(textAndBg);
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      return this._createBaseSVGMarkup(
        this._toSVG(),
        { reviver: reviver, noStyle: true, withShadow: true }
      );
    },

    /**
     * @private
     */
    _getSVGLeftTopOffsets: function() {
      return {
        textLeft: -this.width / 2,
        textTop: -this.height / 2,
        lineTop: this.getHeightOfLine(0)
      };
    },

    /**
     * @private
     */
    _wrapSVGTextAndBg: function(textAndBg) {
      var noShadow = true,
          textDecoration = this.getSvgTextDecoration(this);
      return [
        textAndBg.textBgRects.join(''),
        '\t\t<text xml:space="preserve" ',
        (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
        (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
        (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
        (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
        (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
        'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
        textAndBg.textSpans.join(''),
        '</text>\n'
      ];
    },

    /**
     * @private
     * @param {Number} textTopOffset Text top offset
     * @param {Number} textLeftOffset Text left offset
     * @return {Object}
     */
    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
      var textSpans = [],
          textBgRects = [],
          height = textTopOffset, lineOffset;
      // bounding-box background
      this._setSVGBg(textBgRects);

      // text and text-background
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineOffset = this._getLineLeftOffset(i);
        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
        }
        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
        height += this.getHeightOfLine(i);
      }

      return {
        textSpans: textSpans,
        textBgRects: textBgRects
      };
    },

    /**
     * @private
     */
    _createTextCharSpan: function(_char, styleDecl, left, top) {
      var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
          styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
          fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
          dy = styleDecl.deltaY, dySpan = '',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      if (dy) {
        dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
      }
      return [
        '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
        toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
        fillStyles, '>',
        fabric.util.string.escapeXml(_char),
        '</tspan>'
      ].join('');
    },

    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox, style,
          boxWidth = 0,
          line = this._textLines[lineIndex],
          timeToRender;

      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          textLeftOffset += charBox.kernedWidth - charBox.width;
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
        }
        if (timeToRender) {
          style = this._getStyleDeclaration(lineIndex, i) || { };
          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
          charsToRender = '';
          actualStyle = nextStyle;
          textLeftOffset += boxWidth;
          boxWidth = 0;
        }
      }
    },

    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      textBgRects.push(
        '\t\t<rect ',
        this._getFillAttributes(color),
        ' x="',
        toFixed(left, NUM_FRACTION_DIGITS),
        '" y="',
        toFixed(top, NUM_FRACTION_DIGITS),
        '" width="',
        toFixed(width, NUM_FRACTION_DIGITS),
        '" height="',
        toFixed(height, NUM_FRACTION_DIGITS),
        '"></rect>\n');
    },

    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
      var line = this._textLines[i],
          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
          boxWidth = 0,
          boxStart = 0,
          charBox, currentColor,
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charBox = this.__charBounds[i][j];
        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
        if (currentColor !== lastColor) {
          lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
            textTopOffset, boxWidth, heightOfLine);
          boxStart = charBox.left;
          boxWidth = charBox.width;
          lastColor = currentColor;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
      }
      currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
        textTopOffset, boxWidth, heightOfLine);
    },

    /**
     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
     *
     * @private
     * @param {*} value
     * @return {String}
     */
    _getFillAttributes: function(value) {
      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
        return 'fill="' + value + '"';
      }
      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
    },

    /**
     * @private
     */
    _getSVGLineTopOffset: function(lineIndex) {
      var lineTopOffset = 0, lastHeight = 0;
      for (var j = 0; j < lineIndex; j++) {
        lineTopOffset += this.getHeightOfLine(j);
      }
      lastHeight = this.getHeightOfLine(j);
      return {
        lineTop: lineTopOffset,
        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
      };
    },

    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {
      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
      return svgStyle + ' white-space: pre;';
    },
  });
})();
/* _TO_SVG_END_ */


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = {});

  /**
   * Textbox class, based on IText, allows the user to resize the text rectangle
   * and wraps lines automatically. Textboxes have their Y scaling locked, the
   * user can only change width. Height is adjusted automatically based on the
   * wrapping of lines.
   * @class fabric.Textbox
   * @extends fabric.IText
   * @mixes fabric.Observable
   * @return {fabric.Textbox} thisArg
   * @see {@link fabric.Textbox#initialize} for constructor definition
   */
  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'textbox',

    /**
     * Minimum width of textbox, in pixels.
     * @type Number
     * @default
     */
    minWidth: 20,

    /**
     * Minimum calculated width of a textbox, in pixels.
     * fixed to 2 so that an empty textbox cannot go to 0
     * and is still selectable without text.
     * @type Number
     * @default
     */
    dynamicMinWidth: 2,

    /**
     * Cached array of text wrapping.
     * @type Array
     */
    __cachedLines: null,

    /**
     * Override standard Object class values
     */
    lockScalingFlip: true,

    /**
     * Override standard Object class values
     * Textbox needs this on false
     */
    noScaleCache: false,

    /**
     * Properties which when set cause object to change dimensions
     * @type Object
     * @private
     */
    _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),

    /**
     * Use this regular expression to split strings in breakable lines
     * @private
     */
    _wordJoiners: /[ \t\r]/,

    /**
     * Use this boolean property in order to split strings that have no white space concept.
     * this is a cheap way to help with chinese/japanese
     * @type Boolean
     * @since 2.6.0
     */
    splitByGrapheme: false,

    /**
     * Unlike superclass's version of this function, Textbox does not update
     * its width.
     * @private
     * @override
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this._clearCache();
      // clear dynamicMinWidth as it will be different after we re-wrap line
      this.dynamicMinWidth = 0;
      // wrap lines
      this._styleMap = this._generateStyleMap(this._splitText());
      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
      if (this.dynamicMinWidth > this.width) {
        this._set('width', this.dynamicMinWidth);
      }
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      // clear cache and re-calculate height
      this.height = this.calcTextHeight();
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Generate an object that translates the style object so that it is
     * broken up by visual lines (new lines and automatic wrapping).
     * The original text styles object is broken up by actual lines (new lines only),
     * which is only sufficient for Text / IText
     * @private
     */
    _generateStyleMap: function(textInfo) {
      var realLineCount     = 0,
          realLineCharCount = 0,
          charCount         = 0,
          map               = {};

      for (var i = 0; i < textInfo.graphemeLines.length; i++) {
        if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
          realLineCharCount = 0;
          charCount++;
          realLineCount++;
        }
        else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
          // this case deals with space's that are removed from end of lines when wrapping
          realLineCharCount++;
          charCount++;
        }

        map[i] = { line: realLineCount, offset: realLineCharCount };

        charCount += textInfo.graphemeLines[i].length;
        realLineCharCount += textInfo.graphemeLines[i].length;
      }

      return map;
    },

    /**
     * Returns true if object has a style property or has it on a specified line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (map) {
          lineIndex = map.line;
        }
      }
      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
    },

    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false,
          map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
      if (map) {
        lineIndex = map.line;
        offset = map.offset;
      }
      if (mapNextLine) {
        nextLineIndex = mapNextLine.line;
        shouldLimit = nextLineIndex === lineIndex;
        nextOffset = mapNextLine.offset;
      }
      obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
            // eslint-disable-next-line no-unused-vars
            for (var p3 in obj[p1][p2]) {
              return false;
            }
          }
        }
      }
      return true;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (!map) {
          return null;
        }
        lineIndex = map.line;
        charIndex = map.offset + charIndex;
      }
      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;

      this.styles[lineIndex][charIndex] = style;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * probably broken need a fix
     * Returns the real style line that correspond to the wrapped lineIndex line
     * Used just to verify if the line does exist or not.
     * @param {Number} lineIndex
     * @returns {Boolean} if the line exists or not
     * @private
     */
    _getLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      return !!this.styles[map.line];
    },

    /**
     * Set the line style to an empty object so that is initialized
     * @param {Number} lineIndex
     * @param {Object} style
     * @private
     */
    _setLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      this.styles[map.line] = {};
    },

    /**
     * Wraps text using the 'width' property of Textbox. First this function
     * splits text on newlines, so we preserve newlines entered by the user.
     * Then it wraps each line using the width of the Textbox by calling
     * _wrapLine().
     * @param {Array} lines The string array of text that is split into lines
     * @param {Number} desiredWidth width you want to wrap to
     * @returns {Array} Array of lines
     */
    _wrapText: function(lines, desiredWidth) {
      var wrapped = [], i;
      this.isWrapping = true;
      for (i = 0; i < lines.length; i++) {
        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
      }
      this.isWrapping = false;
      return wrapped;
    },

    /**
     * Helper function to measure a string of text, given its lineIndex and charIndex offset
     * it gets called when charBounds are not available yet.
     * @param {CanvasRenderingContext2D} ctx
     * @param {String} text
     * @param {number} lineIndex
     * @param {number} charOffset
     * @returns {number}
     * @private
     */
    _measureWord: function(word, lineIndex, charOffset) {
      var width = 0, prevGrapheme, skipLeft = true;
      charOffset = charOffset || 0;
      for (var i = 0, len = word.length; i < len; i++) {
        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
        width += box.kernedWidth;
        prevGrapheme = word[i];
      }
      return width;
    },

    /**
     * Wraps a line of text using the width of the Textbox and a context.
     * @param {Array} line The grapheme array that represent the line
     * @param {Number} lineIndex
     * @param {Number} desiredWidth width you want to wrap the line to
     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
     * @returns {Array} Array of line(s) into which the given text is wrapped
     * to.
     */
    _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
      var lineWidth = 0,
          splitByGrapheme = this.splitByGrapheme,
          graphemeLines = [],
          line = [],
          // spaces in different languages?
          words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners),
          word = '',
          offset = 0,
          infix = splitByGrapheme ? '' : ' ',
          wordWidth = 0,
          infixWidth = 0,
          largestWordWidth = 0,
          lineJustStarted = true,
          additionalSpace = this._getWidthOfCharSpacing(),
          reservedSpace = reservedSpace || 0;
      // fix a difference between split and graphemeSplit
      if (words.length === 0) {
        words.push([]);
      }
      desiredWidth -= reservedSpace;
      for (var i = 0; i < words.length; i++) {
        // if using splitByGrapheme words are already in graphemes.
        word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);
        wordWidth = this._measureWord(word, lineIndex, offset);
        offset += word.length;

        lineWidth += infixWidth + wordWidth - additionalSpace;
        if (lineWidth > desiredWidth && !lineJustStarted) {
          graphemeLines.push(line);
          line = [];
          lineWidth = wordWidth;
          lineJustStarted = true;
        }
        else {
          lineWidth += additionalSpace;
        }

        if (!lineJustStarted && !splitByGrapheme) {
          line.push(infix);
        }
        line = line.concat(word);

        infixWidth = splitByGrapheme ? 0 : this._measureWord([infix], lineIndex, offset);
        offset++;
        lineJustStarted = false;
        // keep track of largest word
        if (wordWidth > largestWordWidth) {
          largestWordWidth = wordWidth;
        }
      }

      i && graphemeLines.push(line);

      if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
        this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
      }
      return graphemeLines;
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @param {Number} lineIndex text to split
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      if (!this._styleMap[lineIndex + 1]) {
        // is last line, return true;
        return true;
      }
      if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
        // this is last line before a line break, return true;
        return true;
      }
      return false;
    },

    /**
     * Detect if a line has a linebreak and so we need to account for it when moving
     * and counting style.
     * @return Number
     */
    missingNewlineOffset: function(lineIndex) {
      if (this.splitByGrapheme) {
        return this.isEndOfWrapping(lineIndex) ? 1 : 0;
      }
      return 1;
    },

    /**
    * Gets lines of text to render in the Textbox. This function calculates
    * text wrapping on the fly every time it is called.
    * @param {String} text text to split
    * @returns {Array} Array of lines in the Textbox.
    * @override
    */
    _splitTextIntoLines: function(text) {
      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
          graphemeLines = this._wrapText(newText.lines, this.width),
          lines = new Array(graphemeLines.length);
      for (var i = 0; i < graphemeLines.length; i++) {
        lines[i] = graphemeLines[i].join('');
      }
      newText.lines = lines;
      newText.graphemeLines = graphemeLines;
      return newText;
    },

    getMinWidth: function() {
      return Math.max(this.minWidth, this.dynamicMinWidth);
    },

    _removeExtraneousStyles: function() {
      var linesToKeep = {};
      for (var prop in this._styleMap) {
        if (this._textLines[prop]) {
          linesToKeep[this._styleMap[prop].line] = 1;
        }
      }
      for (var prop in this.styles) {
        if (!linesToKeep[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['minWidth', 'splitByGrapheme'].concat(propertiesToInclude));
    }
  });

  /**
   * Returns fabric.Textbox instance from an object representation
   * @static
   * @memberOf fabric.Textbox
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
   */
  fabric.Textbox.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Textbox', object, callback, 'text');
  };
})( true ? exports : 0);


(function() {

  var controlsUtils = fabric.controlsUtils,
      scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler,
      scaleStyleHandler = controlsUtils.scaleCursorStyleHandler,
      scalingEqually = controlsUtils.scalingEqually,
      scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX,
      scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY,
      scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName,
      objectControls = fabric.Object.prototype.controls;

  objectControls.ml = new fabric.Control({
    x: -0.5,
    y: 0,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingXOrSkewingY,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mr = new fabric.Control({
    x: 0.5,
    y: 0,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingXOrSkewingY,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mb = new fabric.Control({
    x: 0,
    y: 0.5,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingYOrSkewingX,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mt = new fabric.Control({
    x: 0,
    y: -0.5,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingYOrSkewingX,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.tl = new fabric.Control({
    x: -0.5,
    y: -0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.tr = new fabric.Control({
    x: 0.5,
    y: -0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.bl = new fabric.Control({
    x: -0.5,
    y: 0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.br = new fabric.Control({
    x: 0.5,
    y: 0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.mtr = new fabric.Control({
    x: 0,
    y: -0.5,
    actionHandler: controlsUtils.rotationWithSnapping,
    cursorStyleHandler: controlsUtils.rotationStyleHandler,
    offsetY: -40,
    withConnection: true,
    actionName: 'rotate',
  });

  if (fabric.Textbox) {
    // this is breaking the prototype inheritance, no time / ideas to fix it.
    // is important to document that if you want to have all objects to have a
    // specific custom control, you have to add it to Object prototype and to Textbox
    // prototype. The controls are shared as references. So changes to control `tr`
    // can still apply to all objects if needed.
    var textBoxControls = fabric.Textbox.prototype.controls = { };

    textBoxControls.mtr = objectControls.mtr;
    textBoxControls.tr = objectControls.tr;
    textBoxControls.br = objectControls.br;
    textBoxControls.tl = objectControls.tl;
    textBoxControls.bl = objectControls.bl;
    textBoxControls.mt = objectControls.mt;
    textBoxControls.mb = objectControls.mb;

    textBoxControls.mr = new fabric.Control({
      x: 0.5,
      y: 0,
      actionHandler: controlsUtils.changeWidth,
      cursorStyleHandler: scaleSkewStyleHandler,
      actionName: 'resizing',
    });

    textBoxControls.ml = new fabric.Control({
      x: -0.5,
      y: 0,
      actionHandler: controlsUtils.changeWidth,
      cursorStyleHandler: scaleSkewStyleHandler,
      actionName: 'resizing',
    });
  }
})();



/***/ }),

/***/ "./node_modules/nouislider/distribute/nouislider.css":
/*!***********************************************************!*\
  !*** ./node_modules/nouislider/distribute/nouislider.css ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/nouislider/distribute/nouislider.js":
/*!**********************************************************!*\
  !*** ./node_modules/nouislider/distribute/nouislider.js ***!
  \**********************************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 14.6.3 - 11/19/2020 */
(function(factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
})(function() {
    "use strict";

    var VERSION = "14.6.3";

    //region Helper Methods

    function isValidFormatter(entry) {
        return typeof entry === "object" && typeof entry.to === "function" && typeof entry.from === "function";
    }

    function removeElement(el) {
        el.parentElement.removeChild(el);
    }

    function isSet(value) {
        return value !== null && value !== undefined;
    }

    // Bindable version
    function preventDefault(e) {
        e.preventDefault();
    }

    // Removes duplicates from an array.
    function unique(array) {
        return array.filter(function(a) {
            return !this[a] ? (this[a] = true) : false;
        }, {});
    }

    // Round a value to the closest 'to'.
    function closest(value, to) {
        return Math.round(value / to) * to;
    }

    // Current position of an element relative to the document.
    function offset(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);

        // getBoundingClientRect contains left scroll in Chrome on Android.
        // I haven't found a feature detection that proves this. Worst case
        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
            pageOffset.x = 0;
        }

        return orientation
            ? rect.top + pageOffset.y - docElem.clientTop
            : rect.left + pageOffset.x - docElem.clientLeft;
    }

    // Checks whether a value is numerical.
    function isNumeric(a) {
        return typeof a === "number" && !isNaN(a) && isFinite(a);
    }

    // Sets a class and removes it after [duration] ms.
    function addClassFor(element, className, duration) {
        if (duration > 0) {
            addClass(element, className);
            setTimeout(function() {
                removeClass(element, className);
            }, duration);
        }
    }

    // Limits a value to 0 - 100
    function limit(a) {
        return Math.max(Math.min(a, 100), 0);
    }

    // Wraps a variable as an array, if it isn't one yet.
    // Note that an input array is returned by reference!
    function asArray(a) {
        return Array.isArray(a) ? a : [a];
    }

    // Counts decimals
    function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
    }

    // http://youmightnotneedjquery.com/#add_class
    function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
            el.classList.add(className);
        } else {
            el.className += " " + className;
        }
    }

    // http://youmightnotneedjquery.com/#remove_class
    function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
            el.classList.remove(className);
        } else {
            el.className = el.className.replace(
                new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"),
                " "
            );
        }
    }

    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/
    function hasClass(el, className) {
        return el.classList
            ? el.classList.contains(className)
            : new RegExp("\\b" + className + "\\b").test(el.className);
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
    function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== undefined;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x = supportPageOffset
            ? window.pageXOffset
            : isCSS1Compat
                ? doc.documentElement.scrollLeft
                : doc.body.scrollLeft;
        var y = supportPageOffset
            ? window.pageYOffset
            : isCSS1Compat
                ? doc.documentElement.scrollTop
                : doc.body.scrollTop;

        return {
            x: x,
            y: y
        };
    }

    // we provide a function to compute constants instead
    // of accessing window.* as soon as the module needs it
    // so that we do not compute anything if not needed
    function getActions() {
        // Determine the events to bind. IE11 implements pointerEvents without
        // a prefix, which breaks compatibility with the IE10 implementation.
        return window.navigator.pointerEnabled
            ? {
                  start: "pointerdown",
                  move: "pointermove",
                  end: "pointerup"
              }
            : window.navigator.msPointerEnabled
                ? {
                      start: "MSPointerDown",
                      move: "MSPointerMove",
                      end: "MSPointerUp"
                  }
                : {
                      start: "mousedown touchstart",
                      move: "mousemove touchmove",
                      end: "mouseup touchend"
                  };
    }

    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // Issue #785
    function getSupportsPassive() {
        var supportsPassive = false;

        /* eslint-disable */
        try {
            var opts = Object.defineProperty({}, "passive", {
                get: function() {
                    supportsPassive = true;
                }
            });

            window.addEventListener("test", null, opts);
        } catch (e) {}
        /* eslint-enable */

        return supportsPassive;
    }

    function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
    }

    //endregion

    //region Range Calculation

    // Determine the size of a sub-range in relation to a full range.
    function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
    }

    // (percentage) How many percent is this value of this range?
    function fromPercentage(range, value, startRange) {
        return (value * 100) / (range[startRange + 1] - range[startRange]);
    }

    // (percentage) Where is this value on this range?
    function toPercentage(range, value) {
        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
    }

    // (value) How much is this percentage on this range?
    function isPercentage(range, value) {
        return (value * (range[1] - range[0])) / 100 + range[0];
    }

    function getJ(value, arr) {
        var j = 1;

        while (value >= arr[j]) {
            j += 1;
        }

        return j;
    }

    // (percentage) Input a value, find where, on a scale of 0-100, it applies.
    function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
            return 100;
        }

        var j = getJ(value, xVal);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];

        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
    }

    // (value) Input a percentage, find where it is on the specified range.
    function fromStepping(xVal, xPct, value) {
        // There is no range group that fits 100
        if (value >= 100) {
            return xVal.slice(-1)[0];
        }

        var j = getJ(value, xPct);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];

        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
    }

    // (percentage) Get the step that applies at a certain value.
    function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
            return value;
        }

        var j = getJ(value, xPct);
        var a = xPct[j - 1];
        var b = xPct[j];

        // If 'snap' is set, steps are used as fixed points on the slider.
        if (snap) {
            // Find the closest position, a or b.
            if (value - a > (b - a) / 2) {
                return b;
            }

            return a;
        }

        if (!xSteps[j - 1]) {
            return value;
        }

        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
    }

    function handleEntryPoint(index, value, that) {
        var percentage;

        // Wrap numerical input in an array.
        if (typeof value === "number") {
            value = [value];
        }

        // Reject any invalid input, by testing whether value is an array.
        if (!Array.isArray(value)) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
        }

        // Covert min/max syntax to 0 and 100.
        if (index === "min") {
            percentage = 0;
        } else if (index === "max") {
            percentage = 100;
        } else {
            percentage = parseFloat(index);
        }

        // Check for correct input.
        if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
        }

        // Store values.
        that.xPct.push(percentage);
        that.xVal.push(value[0]);

        // NaN will evaluate to false too, but to keep
        // logging clear, set step explicitly. Make sure
        // not to override the 'step' setting with false.
        if (!percentage) {
            if (!isNaN(value[1])) {
                that.xSteps[0] = value[1];
            }
        } else {
            that.xSteps.push(isNaN(value[1]) ? false : value[1]);
        }

        that.xHighestCompleteStep.push(0);
    }

    function handleStepPoint(i, n, that) {
        // Ignore 'false' stepping.
        if (!n) {
            return;
        }

        // Step over zero-length ranges (#948);
        if (that.xVal[i] === that.xVal[i + 1]) {
            that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];

            return;
        }

        // Factor to range ratio
        that.xSteps[i] =
            fromPercentage([that.xVal[i], that.xVal[i + 1]], n, 0) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);

        var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];
        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
        var step = that.xVal[i] + that.xNumSteps[i] * highestStep;

        that.xHighestCompleteStep[i] = step;
    }

    //endregion

    //region Spectrum

    function Spectrum(entry, snap, singleStep) {
        this.xPct = [];
        this.xVal = [];
        this.xSteps = [singleStep || false];
        this.xNumSteps = [false];
        this.xHighestCompleteStep = [];

        this.snap = snap;

        var index;
        var ordered = []; // [0, 'min'], [1, '50%'], [2, 'max']

        // Map the object keys to an array.
        for (index in entry) {
            if (entry.hasOwnProperty(index)) {
                ordered.push([entry[index], index]);
            }
        }

        // Sort all entries by value (numeric sort).
        if (ordered.length && typeof ordered[0][0] === "object") {
            ordered.sort(function(a, b) {
                return a[0][0] - b[0][0];
            });
        } else {
            ordered.sort(function(a, b) {
                return a[0] - b[0];
            });
        }

        // Convert all entries to subranges.
        for (index = 0; index < ordered.length; index++) {
            handleEntryPoint(ordered[index][1], ordered[index][0], this);
        }

        // Store the actual step values.
        // xSteps is sorted in the same order as xPct and xVal.
        this.xNumSteps = this.xSteps.slice(0);

        // Convert all numeric steps to the percentage of the subrange they represent.
        for (index = 0; index < this.xNumSteps.length; index++) {
            handleStepPoint(index, this.xNumSteps[index], this);
        }
    }

    Spectrum.prototype.getDistance = function(value) {
        var index;
        var distances = [];

        for (index = 0; index < this.xNumSteps.length - 1; index++) {
            // last "range" can't contain step size as it is purely an endpoint.
            var step = this.xNumSteps[index];

            if (step && (value / step) % 1 !== 0) {
                throw new Error(
                    "noUiSlider (" +
                        VERSION +
                        "): 'limit', 'margin' and 'padding' of " +
                        this.xPct[index] +
                        "% range must be divisible by step."
                );
            }

            // Calculate percentual distance in current range of limit, margin or padding
            distances[index] = fromPercentage(this.xVal, value, index);
        }

        return distances;
    };

    // Calculate the percentual distance over the whole scale of ranges.
    // direction: 0 = backwards / 1 = forwards
    Spectrum.prototype.getAbsoluteDistance = function(value, distances, direction) {
        var xPct_index = 0;

        // Calculate range where to start calculation
        if (value < this.xPct[this.xPct.length - 1]) {
            while (value > this.xPct[xPct_index + 1]) {
                xPct_index++;
            }
        } else if (value === this.xPct[this.xPct.length - 1]) {
            xPct_index = this.xPct.length - 2;
        }

        // If looking backwards and the value is exactly at a range separator then look one range further
        if (!direction && value === this.xPct[xPct_index + 1]) {
            xPct_index++;
        }

        var start_factor;
        var rest_factor = 1;

        var rest_rel_distance = distances[xPct_index];

        var range_pct = 0;

        var rel_range_distance = 0;
        var abs_distance_counter = 0;
        var range_counter = 0;

        // Calculate what part of the start range the value is
        if (direction) {
            start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
        } else {
            start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
        }

        // Do until the complete distance across ranges is calculated
        while (rest_rel_distance > 0) {
            // Calculate the percentage of total range
            range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];

            // Detect if the margin, padding or limit is larger then the current range and calculate
            if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                // If larger then take the percentual distance of the whole range
                rel_range_distance = range_pct * start_factor;
                // Rest factor of relative percentual distance still to be calculated
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                // Set start factor to 1 as for next range it does not apply.
                start_factor = 1;
            } else {
                // If smaller or equal then take the percentual distance of the calculate percentual part of that range
                rel_range_distance = ((distances[xPct_index + range_counter] * range_pct) / 100) * rest_factor;
                // No rest left as the rest fits in current range
                rest_factor = 0;
            }

            if (direction) {
                abs_distance_counter = abs_distance_counter - rel_range_distance;
                // Limit range to first range when distance becomes outside of minimum range
                if (this.xPct.length + range_counter >= 1) {
                    range_counter--;
                }
            } else {
                abs_distance_counter = abs_distance_counter + rel_range_distance;
                // Limit range to last range when distance becomes outside of maximum range
                if (this.xPct.length - range_counter >= 1) {
                    range_counter++;
                }
            }

            // Rest of relative percentual distance still to be calculated
            rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
        }

        return value + abs_distance_counter;
    };

    Spectrum.prototype.toStepping = function(value) {
        value = toStepping(this.xVal, this.xPct, value);

        return value;
    };

    Spectrum.prototype.fromStepping = function(value) {
        return fromStepping(this.xVal, this.xPct, value);
    };

    Spectrum.prototype.getStep = function(value) {
        value = getStep(this.xPct, this.xSteps, this.snap, value);

        return value;
    };

    Spectrum.prototype.getDefaultStep = function(value, isDown, size) {
        var j = getJ(value, this.xPct);

        // When at the top or stepping down, look at the previous sub-range
        if (value === 100 || (isDown && value === this.xPct[j - 1])) {
            j = Math.max(j - 1, 1);
        }

        return (this.xVal[j] - this.xVal[j - 1]) / size;
    };

    Spectrum.prototype.getNearbySteps = function(value) {
        var j = getJ(value, this.xPct);

        return {
            stepBefore: {
                startValue: this.xVal[j - 2],
                step: this.xNumSteps[j - 2],
                highestStep: this.xHighestCompleteStep[j - 2]
            },
            thisStep: {
                startValue: this.xVal[j - 1],
                step: this.xNumSteps[j - 1],
                highestStep: this.xHighestCompleteStep[j - 1]
            },
            stepAfter: {
                startValue: this.xVal[j],
                step: this.xNumSteps[j],
                highestStep: this.xHighestCompleteStep[j]
            }
        };
    };

    Spectrum.prototype.countStepDecimals = function() {
        var stepDecimals = this.xNumSteps.map(countDecimals);
        return Math.max.apply(null, stepDecimals);
    };

    // Outside testing
    Spectrum.prototype.convert = function(value) {
        return this.getStep(this.toStepping(value));
    };

    //endregion

    //region Options

    /*	Every input option is tested and parsed. This'll prevent
        endless validation in internal methods. These tests are
        structured with an item for every option available. An
        option can be marked as required by setting the 'r' flag.
        The testing function is provided with three arguments:
            - The provided value for the option;
            - A reference to the options object;
            - The name for the option;

        The testing function returns false when an error is detected,
        or true when everything is OK. It can also modify the option
        object, to make sure all values can be correctly looped elsewhere. */

    //region Defaults

    var defaultFormatter = {
        to: function(value) {
            return value !== undefined && value.toFixed(2);
        },
        from: Number
    };

    var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
    };

    // Namespaces of internal event listeners
    var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
    };

    //endregion

    function validateFormat(entry) {
        // Any object with a to and from method is supported.
        if (isValidFormatter(entry)) {
            return true;
        }

        throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.");
    }

    function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
        }

        // The step option can still be used to set stepping
        // for linear sliders. Overwritten if set in 'range'.
        parsed.singleStep = entry;
    }

    function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'keyboardPageMultiplier' is not numeric.");
        }

        parsed.keyboardPageMultiplier = entry;
    }

    function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'keyboardDefaultStep' is not numeric.");
        }

        parsed.keyboardDefaultStep = entry;
    }

    function testRange(parsed, entry) {
        // Filter incorrect input.
        if (typeof entry !== "object" || Array.isArray(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
        }

        // Catch missing start or end.
        if (entry.min === undefined || entry.max === undefined) {
            throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
        }

        // Catch equal start or end.
        if (entry.min === entry.max) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
        }

        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
    }

    function testStart(parsed, entry) {
        entry = asArray(entry);

        // Validate input. Values aren't tested, as the public .val method
        // will always provide a valid location.
        if (!Array.isArray(entry) || !entry.length) {
            throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
        }

        // Store the number of handles.
        parsed.handles = entry.length;

        // When the slider is initialized, the .val method will
        // be called with the start options.
        parsed.start = entry;
    }

    function testSnap(parsed, entry) {
        // Enforce 100% stepping within subranges.
        parsed.snap = entry;

        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.");
        }
    }

    function testAnimate(parsed, entry) {
        // Enforce 100% stepping within subranges.
        parsed.animate = entry;

        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.");
        }
    }

    function testAnimationDuration(parsed, entry) {
        parsed.animationDuration = entry;

        if (typeof entry !== "number") {
            throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.");
        }
    }

    function testConnect(parsed, entry) {
        var connect = [false];
        var i;

        // Map legacy options
        if (entry === "lower") {
            entry = [true, false];
        } else if (entry === "upper") {
            entry = [false, true];
        }

        // Handle boolean options
        if (entry === true || entry === false) {
            for (i = 1; i < parsed.handles; i++) {
                connect.push(entry);
            }

            connect.push(false);
        }

        // Reject invalid input
        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
            throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
        } else {
            connect = entry;
        }

        parsed.connect = connect;
    }

    function testOrientation(parsed, entry) {
        // Set orientation to an a numerical value for easy
        // array selection.
        switch (entry) {
            case "horizontal":
                parsed.ort = 0;
                break;
            case "vertical":
                parsed.ort = 1;
                break;
            default:
                throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.");
        }
    }

    function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
        }

        // Issue #582
        if (entry === 0) {
            return;
        }

        parsed.margin = parsed.spectrum.getDistance(entry);
    }

    function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
        }

        parsed.limit = parsed.spectrum.getDistance(entry);

        if (!parsed.limit || parsed.handles < 2) {
            throw new Error(
                "noUiSlider (" +
                    VERSION +
                    "): 'limit' option is only supported on linear sliders with 2 or more handles."
            );
        }
    }

    function testPadding(parsed, entry) {
        var index;

        if (!isNumeric(entry) && !Array.isArray(entry)) {
            throw new Error(
                "noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers."
            );
        }

        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
            throw new Error(
                "noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers."
            );
        }

        if (entry === 0) {
            return;
        }

        if (!Array.isArray(entry)) {
            entry = [entry, entry];
        }

        // 'getDistance' returns false for invalid values.
        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];

        for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {
            // last "range" can't contain step size as it is purely an endpoint.
            if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {
                throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number(s).");
            }
        }

        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];

        if (totalPadding / (lastValue - firstValue) > 1) {
            throw new Error("noUiSlider (" + VERSION + "): 'padding' option must not exceed 100% of the range.");
        }
    }

    function testDirection(parsed, entry) {
        // Set direction as a numerical value for easy parsing.
        // Invert connection for RTL sliders, so that the proper
        // handles get the connect/background classes.
        switch (entry) {
            case "ltr":
                parsed.dir = 0;
                break;
            case "rtl":
                parsed.dir = 1;
                break;
            default:
                throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.");
        }
    }

    function testBehaviour(parsed, entry) {
        // Make sure the input is a string.
        if (typeof entry !== "string") {
            throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
        }

        // Check if the string contains any keywords.
        // None are required.
        var tap = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;

        if (fixed) {
            if (parsed.handles !== 2) {
                throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
            }

            // Use margin to enforce fixed state
            testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }

        if (unconstrained && (parsed.margin || parsed.limit)) {
            throw new Error(
                "noUiSlider (" + VERSION + "): 'unconstrained' behaviour cannot be used with margin or limit"
            );
        }

        parsed.events = {
            tap: tap || snap,
            drag: drag,
            fixed: fixed,
            snap: snap,
            hover: hover,
            unconstrained: unconstrained
        };
    }

    function testTooltips(parsed, entry) {
        if (entry === false) {
            return;
        }

        if (entry === true) {
            parsed.tooltips = [];

            for (var i = 0; i < parsed.handles; i++) {
                parsed.tooltips.push(true);
            }
        } else {
            parsed.tooltips = asArray(entry);

            if (parsed.tooltips.length !== parsed.handles) {
                throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
            }

            parsed.tooltips.forEach(function(formatter) {
                if (
                    typeof formatter !== "boolean" &&
                    (typeof formatter !== "object" || typeof formatter.to !== "function")
                ) {
                    throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.");
                }
            });
        }
    }

    function testAriaFormat(parsed, entry) {
        parsed.ariaFormat = entry;
        validateFormat(entry);
    }

    function testFormat(parsed, entry) {
        parsed.format = entry;
        validateFormat(entry);
    }

    function testKeyboardSupport(parsed, entry) {
        parsed.keyboardSupport = entry;

        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider (" + VERSION + "): 'keyboardSupport' option must be a boolean.");
        }
    }

    function testDocumentElement(parsed, entry) {
        // This is an advanced option. Passed values are used without validation.
        parsed.documentElement = entry;
    }

    function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
            throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
        }

        parsed.cssPrefix = entry;
    }

    function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
            throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
        }

        if (typeof parsed.cssPrefix === "string") {
            parsed.cssClasses = {};

            for (var key in entry) {
                if (!entry.hasOwnProperty(key)) {
                    continue;
                }

                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
            }
        } else {
            parsed.cssClasses = entry;
        }
    }

    // Test all developer settings and parse to assumption-safe values.
    function testOptions(options) {
        // To prove a fix for #537, freeze options here.
        // If the object is modified, an error will be thrown.
        // Object.freeze(options);

        var parsed = {
            margin: 0,
            limit: 0,
            padding: 0,
            animate: true,
            animationDuration: 300,
            ariaFormat: defaultFormatter,
            format: defaultFormatter
        };

        // Tests are executed in the order they are presented here.
        var tests = {
            step: { r: false, t: testStep },
            keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
            keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
            start: { r: true, t: testStart },
            connect: { r: true, t: testConnect },
            direction: { r: true, t: testDirection },
            snap: { r: false, t: testSnap },
            animate: { r: false, t: testAnimate },
            animationDuration: { r: false, t: testAnimationDuration },
            range: { r: true, t: testRange },
            orientation: { r: false, t: testOrientation },
            margin: { r: false, t: testMargin },
            limit: { r: false, t: testLimit },
            padding: { r: false, t: testPadding },
            behaviour: { r: true, t: testBehaviour },
            ariaFormat: { r: false, t: testAriaFormat },
            format: { r: false, t: testFormat },
            tooltips: { r: false, t: testTooltips },
            keyboardSupport: { r: true, t: testKeyboardSupport },
            documentElement: { r: false, t: testDocumentElement },
            cssPrefix: { r: true, t: testCssPrefix },
            cssClasses: { r: true, t: testCssClasses }
        };

        var defaults = {
            connect: false,
            direction: "ltr",
            behaviour: "tap",
            orientation: "horizontal",
            keyboardSupport: true,
            cssPrefix: "noUi-",
            cssClasses: cssClasses,
            keyboardPageMultiplier: 5,
            keyboardDefaultStep: 10
        };

        // AriaFormat defaults to regular format, if any.
        if (options.format && !options.ariaFormat) {
            options.ariaFormat = options.format;
        }

        // Run all options through a testing mechanism to ensure correct
        // input. It should be noted that options might get modified to
        // be handled properly. E.g. wrapping integers in arrays.
        Object.keys(tests).forEach(function(name) {
            // If the option isn't set, but it is required, throw an error.
            if (!isSet(options[name]) && defaults[name] === undefined) {
                if (tests[name].r) {
                    throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
                }

                return true;
            }

            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
        });

        // Forward pips options
        parsed.pips = options.pips;

        // All recent browsers accept unprefixed transform.
        // We need -ms- for IE9 and -webkit- for older Android;
        // Assume use of -webkit- if unprefixed and -ms- are not supported.
        // https://caniuse.com/#feat=transforms2d
        var d = document.createElement("div");
        var msPrefix = d.style.msTransform !== undefined;
        var noPrefix = d.style.transform !== undefined;

        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";

        // Pips don't move, so we can place them using left/top.
        var styles = [["left", "top"], ["right", "bottom"]];

        parsed.style = styles[parsed.dir][parsed.ort];

        return parsed;
    }

    //endregion

    function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();

        // All variables local to 'scope' are prefixed with 'scope_'

        // Slider DOM Nodes
        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips;

        // Slider state values
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {};

        // Exposed API
        var scope_Self;

        // Document Nodes
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body;

        // Pips constants
        var PIPS_NONE = -1;
        var PIPS_NO_VALUE = 0;
        var PIPS_LARGE_VALUE = 1;
        var PIPS_SMALL_VALUE = 2;

        // For horizontal sliders in standard ltr documents,
        // make .noUi-origin overflow to the left so the document doesn't scroll.
        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;

        // Creates a node, adds it to target, returns the new node.
        function addNodeTo(addTarget, className) {
            var div = scope_Document.createElement("div");

            if (className) {
                addClass(div, className);
            }

            addTarget.appendChild(div);

            return div;
        }

        // Append a origin to the base
        function addOrigin(base, handleNumber) {
            var origin = addNodeTo(base, options.cssClasses.origin);
            var handle = addNodeTo(origin, options.cssClasses.handle);

            addNodeTo(handle, options.cssClasses.touchArea);

            handle.setAttribute("data-handle", handleNumber);

            if (options.keyboardSupport) {
                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                // 0 = focusable and reachable
                handle.setAttribute("tabindex", "0");
                handle.addEventListener("keydown", function(event) {
                    return eventKeydown(event, handleNumber);
                });
            }

            handle.setAttribute("role", "slider");
            handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");

            if (handleNumber === 0) {
                addClass(handle, options.cssClasses.handleLower);
            } else if (handleNumber === options.handles - 1) {
                addClass(handle, options.cssClasses.handleUpper);
            }

            return origin;
        }

        // Insert nodes for connect elements
        function addConnect(base, add) {
            if (!add) {
                return false;
            }

            return addNodeTo(base, options.cssClasses.connect);
        }

        // Add handles to the slider base.
        function addElements(connectOptions, base) {
            var connectBase = addNodeTo(base, options.cssClasses.connects);

            scope_Handles = [];
            scope_Connects = [];

            scope_Connects.push(addConnect(connectBase, connectOptions[0]));

            // [::::O====O====O====]
            // connectOptions = [0, 1, 1, 1]

            for (var i = 0; i < options.handles; i++) {
                // Keep a list of all added handles.
                scope_Handles.push(addOrigin(base, i));
                scope_HandleNumbers[i] = i;
                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
            }
        }

        // Initialize a single slider.
        function addSlider(addTarget) {
            // Apply classes and data to the target.
            addClass(addTarget, options.cssClasses.target);

            if (options.dir === 0) {
                addClass(addTarget, options.cssClasses.ltr);
            } else {
                addClass(addTarget, options.cssClasses.rtl);
            }

            if (options.ort === 0) {
                addClass(addTarget, options.cssClasses.horizontal);
            } else {
                addClass(addTarget, options.cssClasses.vertical);
            }

            var textDirection = getComputedStyle(addTarget).direction;

            if (textDirection === "rtl") {
                addClass(addTarget, options.cssClasses.textDirectionRtl);
            } else {
                addClass(addTarget, options.cssClasses.textDirectionLtr);
            }

            return addNodeTo(addTarget, options.cssClasses.base);
        }

        function addTooltip(handle, handleNumber) {
            if (!options.tooltips[handleNumber]) {
                return false;
            }

            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }

        function isSliderDisabled() {
            return scope_Target.hasAttribute("disabled");
        }

        // Disable the slider dragging if any handle is disabled
        function isHandleDisabled(handleNumber) {
            var handleOrigin = scope_Handles[handleNumber];
            return handleOrigin.hasAttribute("disabled");
        }

        function removeTooltips() {
            if (scope_Tooltips) {
                removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
                scope_Tooltips.forEach(function(tooltip) {
                    if (tooltip) {
                        removeElement(tooltip);
                    }
                });
                scope_Tooltips = null;
            }
        }

        // The tooltips option is a shorthand for using the 'update' event.
        function tooltips() {
            removeTooltips();

            // Tooltips are added with options.tooltips in original order.
            scope_Tooltips = scope_Handles.map(addTooltip);

            bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values, handleNumber, unencoded) {
                if (!scope_Tooltips[handleNumber]) {
                    return;
                }

                var formattedValue = values[handleNumber];

                if (options.tooltips[handleNumber] !== true) {
                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
                }

                scope_Tooltips[handleNumber].innerHTML = formattedValue;
            });
        }

        function aria() {
            removeEvent("update" + INTERNAL_EVENT_NS.aria);
            bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values, handleNumber, unencoded, tap, positions) {
                // Update Aria Values for all handles, as a change in one changes min and max values for the next.
                scope_HandleNumbers.forEach(function(index) {
                    var handle = scope_Handles[index];

                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);

                    var now = positions[index];

                    // Formatted value for display
                    var text = options.ariaFormat.to(unencoded[index]);

                    // Map to slider range values
                    min = scope_Spectrum.fromStepping(min).toFixed(1);
                    max = scope_Spectrum.fromStepping(max).toFixed(1);
                    now = scope_Spectrum.fromStepping(now).toFixed(1);

                    handle.children[0].setAttribute("aria-valuemin", min);
                    handle.children[0].setAttribute("aria-valuemax", max);
                    handle.children[0].setAttribute("aria-valuenow", now);
                    handle.children[0].setAttribute("aria-valuetext", text);
                });
            });
        }

        function getGroup(mode, values, stepped) {
            // Use the range.
            if (mode === "range" || mode === "steps") {
                return scope_Spectrum.xVal;
            }

            if (mode === "count") {
                if (values < 2) {
                    throw new Error("noUiSlider (" + VERSION + "): 'values' (>= 2) required for mode 'count'.");
                }

                // Divide 0 - 100 in 'count' parts.
                var interval = values - 1;
                var spread = 100 / interval;

                values = [];

                // List these parts and have them handled as 'positions'.
                while (interval--) {
                    values[interval] = interval * spread;
                }

                values.push(100);

                mode = "positions";
            }

            if (mode === "positions") {
                // Map all percentages to on-range values.
                return values.map(function(value) {
                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
                });
            }

            if (mode === "values") {
                // If the value must be stepped, it needs to be converted to a percentage first.
                if (stepped) {
                    return values.map(function(value) {
                        // Convert to percentage, apply step, return to value.
                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                    });
                }

                // Otherwise, we can simply use the values.
                return values;
            }
        }

        function generateSpread(density, mode, group) {
            function safeIncrement(value, increment) {
                // Avoid floating point variance by dropping the smallest decimal places.
                return (value + increment).toFixed(7) / 1;
            }

            var indexes = {};
            var firstInRange = scope_Spectrum.xVal[0];
            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
            var ignoreFirst = false;
            var ignoreLast = false;
            var prevPct = 0;

            // Create a copy of the group, sort it and filter away all duplicates.
            group = unique(
                group.slice().sort(function(a, b) {
                    return a - b;
                })
            );

            // Make sure the range starts with the first element.
            if (group[0] !== firstInRange) {
                group.unshift(firstInRange);
                ignoreFirst = true;
            }

            // Likewise for the last one.
            if (group[group.length - 1] !== lastInRange) {
                group.push(lastInRange);
                ignoreLast = true;
            }

            group.forEach(function(current, index) {
                // Get the current step and the lower + upper positions.
                var step;
                var i;
                var q;
                var low = current;
                var high = group[index + 1];
                var newPct;
                var pctDifference;
                var pctPos;
                var type;
                var steps;
                var realSteps;
                var stepSize;
                var isSteps = mode === "steps";

                // When using 'steps' mode, use the provided steps.
                // Otherwise, we'll step on to the next subrange.
                if (isSteps) {
                    step = scope_Spectrum.xNumSteps[index];
                }

                // Default to a 'full' step.
                if (!step) {
                    step = high - low;
                }

                // Low can be 0, so test for false. Index 0 is already handled.
                if (low === false) {
                    return;
                }

                // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)
                if (high === undefined) {
                    high = low;
                }

                // Make sure step isn't 0, which would cause an infinite loop (#654)
                step = Math.max(step, 0.0000001);

                // Find all steps in the subrange.
                for (i = low; i <= high; i = safeIncrement(i, step)) {
                    // Get the percentage value for the current step,
                    // calculate the size for the subrange.
                    newPct = scope_Spectrum.toStepping(i);
                    pctDifference = newPct - prevPct;

                    steps = pctDifference / density;
                    realSteps = Math.round(steps);

                    // This ratio represents the amount of percentage-space a point indicates.
                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
                    // Round the percentage offset to an even number, then divide by two
                    // to spread the offset on both sides of the range.
                    stepSize = pctDifference / realSteps;

                    // Divide all points evenly, adding the correct number to this subrange.
                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.
                    for (q = 1; q <= realSteps; q += 1) {
                        // The ratio between the rounded value and the actual size might be ~1% off.
                        // Correct the percentage offset by the number of points
                        // per subrange. density = 1 will result in 100 points on the
                        // full range, 2 for 50, 4 for 25, etc.
                        pctPos = prevPct + q * stepSize;
                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
                    }

                    // Determine the point type.
                    type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE;

                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.
                    if (!index && ignoreFirst && i !== high) {
                        type = 0;
                    }

                    if (!(i === high && ignoreLast)) {
                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
                        indexes[newPct.toFixed(5)] = [i, type];
                    }

                    // Update the percentage count.
                    prevPct = newPct;
                }
            });

            return indexes;
        }

        function addMarking(spread, filterFunc, formatter) {
            var element = scope_Document.createElement("div");

            var valueSizeClasses = [];
            valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;
            valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;
            valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;

            var markerSizeClasses = [];
            markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;
            markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;
            markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;

            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];

            addClass(element, options.cssClasses.pips);
            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);

            function getClasses(type, source) {
                var a = source === options.cssClasses.value;
                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;

                return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
            }

            function addSpread(offset, value, type) {
                // Apply the filter function, if it is set.
                type = filterFunc ? filterFunc(value, type) : type;

                if (type === PIPS_NONE) {
                    return;
                }

                // Add a marker for every point
                var node = addNodeTo(element, false);
                node.className = getClasses(type, options.cssClasses.marker);
                node.style[options.style] = offset + "%";

                // Values are only appended for points marked '1' or '2'.
                if (type > PIPS_NO_VALUE) {
                    node = addNodeTo(element, false);
                    node.className = getClasses(type, options.cssClasses.value);
                    node.setAttribute("data-value", value);
                    node.style[options.style] = offset + "%";
                    node.innerHTML = formatter.to(value);
                }
            }

            // Append all points.
            Object.keys(spread).forEach(function(offset) {
                addSpread(offset, spread[offset][0], spread[offset][1]);
            });

            return element;
        }

        function removePips() {
            if (scope_Pips) {
                removeElement(scope_Pips);
                scope_Pips = null;
            }
        }

        function pips(grid) {
            // Fix #669
            removePips();

            var mode = grid.mode;
            var density = grid.density || 1;
            var filter = grid.filter || false;
            var values = grid.values || false;
            var stepped = grid.stepped || false;
            var group = getGroup(mode, values, stepped);
            var spread = generateSpread(density, mode, group);
            var format = grid.format || {
                to: Math.round
            };

            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));

            return scope_Pips;
        }

        // Shorthand for base dimensions.
        function baseSize() {
            var rect = scope_Base.getBoundingClientRect();
            var alt = "offset" + ["Width", "Height"][options.ort];
            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        }

        // Handler for attaching events trough a proxy.
        function attachEvent(events, element, callback, data) {
            // This function can be used to 'filter' events to the slider.
            // element is a node, not a nodeList

            var method = function(e) {
                e = fixEvent(e, data.pageOffset, data.target || element);

                // fixEvent returns false if this event has a different target
                // when handling (multi-) touch events;
                if (!e) {
                    return false;
                }

                // doNotReject is passed by all end events to make sure released touches
                // are not rejected, leaving the slider "stuck" to the cursor;
                if (isSliderDisabled() && !data.doNotReject) {
                    return false;
                }

                // Stop if an active 'tap' transition is taking place.
                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
                    return false;
                }

                // Ignore right or middle clicks on start #454
                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
                    return false;
                }

                // Ignore right or middle clicks on start #454
                if (data.hover && e.buttons) {
                    return false;
                }

                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
                // touch-action: manipulation, but that allows panning, which breaks
                // sliders after zooming/on non-responsive pages.
                // See: https://bugs.webkit.org/show_bug.cgi?id=133112
                if (!supportsPassive) {
                    e.preventDefault();
                }

                e.calcPoint = e.points[options.ort];

                // Call the event handler with the event [ and additional data ].
                callback(e, data);
            };

            var methods = [];

            // Bind a closure on the target for every event type.
            events.split(" ").forEach(function(eventName) {
                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
                methods.push([eventName, method]);
            });

            return methods;
        }

        // Provide a clean event with standardized offset values.
        function fixEvent(e, pageOffset, eventTarget) {
            // Filter the event to register the type, which can be
            // touch, mouse or pointer. Offset changes need to be
            // made on an event specific basis.
            var touch = e.type.indexOf("touch") === 0;
            var mouse = e.type.indexOf("mouse") === 0;
            var pointer = e.type.indexOf("pointer") === 0;

            var x;
            var y;

            // IE10 implemented pointer events with a prefix;
            if (e.type.indexOf("MSPointer") === 0) {
                pointer = true;
            }

            // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with
            // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore
            // events that have no touches or buttons associated with them. (#1057, #1079, #1095)
            if (e.type === "mousedown" && !e.buttons && !e.touches) {
                return false;
            }

            // The only thing one handle should be concerned about is the touches that originated on top of it.
            if (touch) {
                // Returns true if a touch originated on the target.
                var isTouchOnTarget = function(checkTouch) {
                    return (
                        checkTouch.target === eventTarget ||
                        eventTarget.contains(checkTouch.target) ||
                        (checkTouch.target.shadowRoot && checkTouch.target.shadowRoot.contains(eventTarget))
                    );
                };

                // In the case of touchstart events, we need to make sure there is still no more than one
                // touch on the target so we look amongst all touches.
                if (e.type === "touchstart") {
                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);

                    // Do not support more than one touch per handle.
                    if (targetTouches.length > 1) {
                        return false;
                    }

                    x = targetTouches[0].pageX;
                    y = targetTouches[0].pageY;
                } else {
                    // In the other cases, find on changedTouches is enough.
                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);

                    // Cancel if the target touch has not moved.
                    if (!targetTouch) {
                        return false;
                    }

                    x = targetTouch.pageX;
                    y = targetTouch.pageY;
                }
            }

            pageOffset = pageOffset || getPageOffset(scope_Document);

            if (mouse || pointer) {
                x = e.clientX + pageOffset.x;
                y = e.clientY + pageOffset.y;
            }

            e.pageOffset = pageOffset;
            e.points = [x, y];
            e.cursor = mouse || pointer; // Fix #435

            return e;
        }

        // Translate a coordinate in the document to a percentage on the slider
        function calcPointToPercentage(calcPoint) {
            var location = calcPoint - offset(scope_Base, options.ort);
            var proposal = (location * 100) / baseSize();

            // Clamp proposal between 0% and 100%
            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
            // are used (e.g. contained handles feature)
            proposal = limit(proposal);

            return options.dir ? 100 - proposal : proposal;
        }

        // Find handle closest to a certain percentage on the slider
        function getClosestHandle(clickedPosition) {
            var smallestDifference = 100;
            var handleNumber = false;

            scope_Handles.forEach(function(handle, index) {
                // Disabled handles are ignored
                if (isHandleDisabled(index)) {
                    return;
                }

                var handlePosition = scope_Locations[index];
                var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);

                // Initial state
                var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;

                // Difference with this handle is smaller than the previously checked handle
                var isCloser = differenceWithThisHandle < smallestDifference;
                var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;

                if (isCloser || isCloserAfter || clickAtEdge) {
                    handleNumber = index;
                    smallestDifference = differenceWithThisHandle;
                }
            });

            return handleNumber;
        }

        // Fire 'end' when a mouse or pen leaves the document.
        function documentLeave(event, data) {
            if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
                eventEnd(event, data);
            }
        }

        // Handle movement on document for handle and range drag.
        function eventMove(event, data) {
            // Fix #498
            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
            // IE9 has .buttons and .which zero on mousemove.
            // Firefox breaks the spec MDN defines.
            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
                return eventEnd(event, data);
            }

            // Check if we are moving up or down
            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);

            // Convert the movement into a percentage of the slider width/height
            var proposal = (movement * 100) / data.baseSize;

            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);
        }

        // Unbind move events on document, call callbacks.
        function eventEnd(event, data) {
            // The handle is no longer active, so remove the class.
            if (data.handle) {
                removeClass(data.handle, options.cssClasses.active);
                scope_ActiveHandlesCount -= 1;
            }

            // Unbind the move and end events, which are added on 'start'.
            data.listeners.forEach(function(c) {
                scope_DocumentElement.removeEventListener(c[0], c[1]);
            });

            if (scope_ActiveHandlesCount === 0) {
                // Remove dragging class.
                removeClass(scope_Target, options.cssClasses.drag);
                setZindex();

                // Remove cursor styles and text-selection events bound to the body.
                if (event.cursor) {
                    scope_Body.style.cursor = "";
                    scope_Body.removeEventListener("selectstart", preventDefault);
                }
            }

            data.handleNumbers.forEach(function(handleNumber) {
                fireEvent("change", handleNumber);
                fireEvent("set", handleNumber);
                fireEvent("end", handleNumber);
            });
        }

        // Bind move events on document.
        function eventStart(event, data) {
            // Ignore event if any handle is disabled
            if (data.handleNumbers.some(isHandleDisabled)) {
                return false;
            }

            var handle;

            if (data.handleNumbers.length === 1) {
                var handleOrigin = scope_Handles[data.handleNumbers[0]];

                handle = handleOrigin.children[0];
                scope_ActiveHandlesCount += 1;

                // Mark the handle as 'active' so it can be styled.
                addClass(handle, options.cssClasses.active);
            }

            // A drag should never propagate up to the 'tap' event.
            event.stopPropagation();

            // Record the event listeners.
            var listeners = [];

            // Attach the move and end events.
            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                // The event target has changed so we need to propagate the original one so that we keep
                // relying on it to extract target touches.
                target: event.target,
                handle: handle,
                listeners: listeners,
                startCalcPoint: event.calcPoint,
                baseSize: baseSize(),
                pageOffset: event.pageOffset,
                handleNumbers: data.handleNumbers,
                buttonsProperty: event.buttons,
                locations: scope_Locations.slice()
            });

            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                doNotReject: true,
                handleNumbers: data.handleNumbers
            });

            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                doNotReject: true,
                handleNumbers: data.handleNumbers
            });

            // We want to make sure we pushed the listeners in the listener list rather than creating
            // a new one as it has already been passed to the event handlers.
            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));

            // Text selection isn't an issue on touch devices,
            // so adding cursor styles can be skipped.
            if (event.cursor) {
                // Prevent the 'I' cursor and extend the range-drag cursor.
                scope_Body.style.cursor = getComputedStyle(event.target).cursor;

                // Mark the target with a dragging state.
                if (scope_Handles.length > 1) {
                    addClass(scope_Target, options.cssClasses.drag);
                }

                // Prevent text selection when dragging the handles.
                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
                // The 'cursor' flag is false.
                // See: http://caniuse.com/#search=selectstart
                scope_Body.addEventListener("selectstart", preventDefault, false);
            }

            data.handleNumbers.forEach(function(handleNumber) {
                fireEvent("start", handleNumber);
            });
        }

        // Move closest handle to tapped location.
        function eventTap(event) {
            // The tap event shouldn't propagate up
            event.stopPropagation();

            var proposal = calcPointToPercentage(event.calcPoint);
            var handleNumber = getClosestHandle(proposal);

            // Tackle the case that all handles are 'disabled'.
            if (handleNumber === false) {
                return false;
            }

            // Flag the slider as it is now in a transitional state.
            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.
            if (!options.events.snap) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }

            setHandle(handleNumber, proposal, true, true);

            setZindex();

            fireEvent("slide", handleNumber, true);
            fireEvent("update", handleNumber, true);
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);

            if (options.events.snap) {
                eventStart(event, { handleNumbers: [handleNumber] });
            }
        }

        // Fires a 'hover' event for a hovered mouse/pen position.
        function eventHover(event) {
            var proposal = calcPointToPercentage(event.calcPoint);

            var to = scope_Spectrum.getStep(proposal);
            var value = scope_Spectrum.fromStepping(to);

            Object.keys(scope_Events).forEach(function(targetEvent) {
                if ("hover" === targetEvent.split(".")[0]) {
                    scope_Events[targetEvent].forEach(function(callback) {
                        callback.call(scope_Self, value);
                    });
                }
            });
        }

        // Handles keydown on focused handles
        // Don't move the document when pressing arrow keys on focused handles
        function eventKeydown(event, handleNumber) {
            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
                return false;
            }

            var horizontalKeys = ["Left", "Right"];
            var verticalKeys = ["Down", "Up"];
            var largeStepKeys = ["PageDown", "PageUp"];
            var edgeKeys = ["Home", "End"];

            if (options.dir && !options.ort) {
                // On an right-to-left slider, the left and right keys act inverted
                horizontalKeys.reverse();
            } else if (options.ort && !options.dir) {
                // On a top-to-bottom slider, the up and down keys act inverted
                verticalKeys.reverse();
                largeStepKeys.reverse();
            }

            // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
            var key = event.key.replace("Arrow", "");

            var isLargeDown = key === largeStepKeys[0];
            var isLargeUp = key === largeStepKeys[1];
            var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
            var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
            var isMin = key === edgeKeys[0];
            var isMax = key === edgeKeys[1];

            if (!isDown && !isUp && !isMin && !isMax) {
                return true;
            }

            event.preventDefault();

            var to;

            if (isUp || isDown) {
                var multiplier = options.keyboardPageMultiplier;
                var direction = isDown ? 0 : 1;
                var steps = getNextStepsForHandle(handleNumber);
                var step = steps[direction];

                // At the edge of a slider, do nothing
                if (step === null) {
                    return false;
                }

                // No step set, use the default of 10% of the sub-range
                if (step === false) {
                    step = scope_Spectrum.getDefaultStep(
                        scope_Locations[handleNumber],
                        isDown,
                        options.keyboardDefaultStep
                    );
                }

                if (isLargeUp || isLargeDown) {
                    step *= multiplier;
                }

                // Step over zero-length ranges (#948);
                step = Math.max(step, 0.0000001);

                // Decrement for down steps
                step = (isDown ? -1 : 1) * step;

                to = scope_Values[handleNumber] + step;
            } else if (isMax) {
                // End key
                to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
            } else {
                // Home key
                to = options.spectrum.xVal[0];
            }

            setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);

            fireEvent("slide", handleNumber);
            fireEvent("update", handleNumber);
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);

            return false;
        }

        // Attach events to several slider parts.
        function bindSliderEvents(behaviour) {
            // Attach the standard drag event to the handles.
            if (!behaviour.fixed) {
                scope_Handles.forEach(function(handle, index) {
                    // These events are only bound to the visual handle
                    // element, not the 'real' origin element.
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [index]
                    });
                });
            }

            // Attach the tap event to the slider base.
            if (behaviour.tap) {
                attachEvent(actions.start, scope_Base, eventTap, {});
            }

            // Fire hover events
            if (behaviour.hover) {
                attachEvent(actions.move, scope_Base, eventHover, {
                    hover: true
                });
            }

            // Make the range draggable.
            if (behaviour.drag) {
                scope_Connects.forEach(function(connect, index) {
                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                        return;
                    }

                    var handleBefore = scope_Handles[index - 1];
                    var handleAfter = scope_Handles[index];
                    var eventHolders = [connect];

                    addClass(connect, options.cssClasses.draggable);

                    // When the range is fixed, the entire range can
                    // be dragged by the handles. The handle in the first
                    // origin will propagate the start event upward,
                    // but it needs to be bound manually on the other.
                    if (behaviour.fixed) {
                        eventHolders.push(handleBefore.children[0]);
                        eventHolders.push(handleAfter.children[0]);
                    }

                    eventHolders.forEach(function(eventHolder) {
                        attachEvent(actions.start, eventHolder, eventStart, {
                            handles: [handleBefore, handleAfter],
                            handleNumbers: [index - 1, index]
                        });
                    });
                });
            }
        }

        // Attach an event to this slider, possibly including a namespace
        function bindEvent(namespacedEvent, callback) {
            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
            scope_Events[namespacedEvent].push(callback);

            // If the event bound is 'update,' fire it immediately for all handles.
            if (namespacedEvent.split(".")[0] === "update") {
                scope_Handles.forEach(function(a, index) {
                    fireEvent("update", index);
                });
            }
        }

        function isInternalNamespace(namespace) {
            return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        }

        // Undo attachment of event
        function removeEvent(namespacedEvent) {
            var event = namespacedEvent && namespacedEvent.split(".")[0];
            var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;

            Object.keys(scope_Events).forEach(function(bind) {
                var tEvent = bind.split(".")[0];
                var tNamespace = bind.substring(tEvent.length);
                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
                    // only delete protected internal event if intentional
                    if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                        delete scope_Events[bind];
                    }
                }
            });
        }

        // External event handling
        function fireEvent(eventName, handleNumber, tap) {
            Object.keys(scope_Events).forEach(function(targetEvent) {
                var eventType = targetEvent.split(".")[0];

                if (eventName === eventType) {
                    scope_Events[targetEvent].forEach(function(callback) {
                        callback.call(
                            // Use the slider public API as the scope ('this')
                            scope_Self,
                            // Return values as array, so arg_1[arg_2] is always valid.
                            scope_Values.map(options.format.to),
                            // Handle index, 0 or 1
                            handleNumber,
                            // Un-formatted slider values
                            scope_Values.slice(),
                            // Event is fired by tap, true or false
                            tap || false,
                            // Left offset of the handle, in relation to the slider
                            scope_Locations.slice(),
                            // add the slider public API to an accessible parameter when this is unavailable
                            scope_Self
                        );
                    });
                }
            });
        }

        // Split out the handle positioning logic so the Move event can use it, too
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
            var distance;

            // For sliders with multiple handles, limit movement to the other handle.
            // Apply the margin option by adding it to the handle positions.
            if (scope_Handles.length > 1 && !options.events.unconstrained) {
                if (lookBackward && handleNumber > 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, 0);
                    to = Math.max(to, distance);
                }

                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, 1);
                    to = Math.min(to, distance);
                }
            }

            // The limit option has the opposite effect, limiting handles to a
            // maximum distance from another. Limit must be > 0, as otherwise
            // handles would be unmovable.
            if (scope_Handles.length > 1 && options.limit) {
                if (lookBackward && handleNumber > 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, 0);
                    to = Math.min(to, distance);
                }

                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, 1);
                    to = Math.max(to, distance);
                }
            }

            // The padding option keeps the handles a certain distance from the
            // edges of the slider. Padding must be > 0.
            if (options.padding) {
                if (handleNumber === 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], 0);
                    to = Math.max(to, distance);
                }

                if (handleNumber === scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], 1);
                    to = Math.min(to, distance);
                }
            }

            to = scope_Spectrum.getStep(to);

            // Limit percentage to the 0 - 100 range
            to = limit(to);

            // Return false if handle can't move
            if (to === reference[handleNumber] && !getValue) {
                return false;
            }

            return to;
        }

        // Uses slider orientation to create CSS rules. a = base value;
        function inRuleOrder(v, a) {
            var o = options.ort;
            return (o ? a : v) + ", " + (o ? v : a);
        }

        // Moves handle(s) by a percentage
        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])
        function moveHandles(upward, proposal, locations, handleNumbers) {
            var proposals = locations.slice();

            var b = [!upward, upward];
            var f = [upward, !upward];

            // Copy handleNumbers so we don't change the dataset
            handleNumbers = handleNumbers.slice();

            // Check to see which handle is 'leading'.
            // If that one can't move the second can't either.
            if (upward) {
                handleNumbers.reverse();
            }

            // Step 1: get the maximum percentage that any of the handles can move
            if (handleNumbers.length > 1) {
                handleNumbers.forEach(function(handleNumber, o) {
                    var to = checkHandlePosition(
                        proposals,
                        handleNumber,
                        proposals[handleNumber] + proposal,
                        b[o],
                        f[o],
                        false
                    );

                    // Stop if one of the handles can't move.
                    if (to === false) {
                        proposal = 0;
                    } else {
                        proposal = to - proposals[handleNumber];
                        proposals[handleNumber] = to;
                    }
                });
            }

            // If using one handle, check backward AND forward
            else {
                b = f = [true];
            }

            var state = false;

            // Step 2: Try to set the handles with the found percentage
            handleNumbers.forEach(function(handleNumber, o) {
                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
            });

            // Step 3: If a handle moved, fire events
            if (state) {
                handleNumbers.forEach(function(handleNumber) {
                    fireEvent("update", handleNumber);
                    fireEvent("slide", handleNumber);
                });
            }
        }

        // Takes a base value and an offset. This offset is used for the connect bar size.
        // In the initial design for this feature, the origin element was 1% wide.
        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223
        function transformDirection(a, b) {
            return options.dir ? 100 - a - b : a;
        }

        // Updates scope_Locations and scope_Values, updates visual state
        function updateHandlePosition(handleNumber, to) {
            // Update locations.
            scope_Locations[handleNumber] = to;

            // Convert the value to the slider stepping/range.
            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);

            var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);
            var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";

            scope_Handles[handleNumber].style[options.transformRule] = translateRule;

            updateConnect(handleNumber);
            updateConnect(handleNumber + 1);
        }

        // Handles before the slider middle are stacked later = higher,
        // Handles after the middle later is lower
        // [[7] [8] .......... | .......... [5] [4]
        function setZindex() {
            scope_HandleNumbers.forEach(function(handleNumber) {
                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
                scope_Handles[handleNumber].style.zIndex = zIndex;
            });
        }

        // Test suggested values and apply margin, step.
        // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)
        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
            if (!exactInput) {
                to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
            }

            if (to === false) {
                return false;
            }

            updateHandlePosition(handleNumber, to);

            return true;
        }

        // Updates style attribute for connect nodes
        function updateConnect(index) {
            // Skip connects set to false
            if (!scope_Connects[index]) {
                return;
            }

            var l = 0;
            var h = 100;

            if (index !== 0) {
                l = scope_Locations[index - 1];
            }

            if (index !== scope_Connects.length - 1) {
                h = scope_Locations[index];
            }

            // We use two rules:
            // 'translate' to change the left/top offset;
            // 'scale' to change the width of the element;
            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)
            var connectWidth = h - l;
            var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
            var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";

            scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
        }

        // Parses value passed to .set method. Returns current value if not parse-able.
        function resolveToValue(to, handleNumber) {
            // Setting with null indicates an 'ignore'.
            // Inputting 'false' is invalid.
            if (to === null || to === false || to === undefined) {
                return scope_Locations[handleNumber];
            }

            // If a formatted number was passed, attempt to decode it.
            if (typeof to === "number") {
                to = String(to);
            }

            to = options.format.from(to);
            to = scope_Spectrum.toStepping(to);

            // If parsing the number failed, use the current value.
            if (to === false || isNaN(to)) {
                return scope_Locations[handleNumber];
            }

            return to;
        }

        // Set the slider value.
        function valueSet(input, fireSetEvent, exactInput) {
            var values = asArray(input);
            var isInit = scope_Locations[0] === undefined;

            // Event fires by default
            fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;

            // Animation is optional.
            // Make sure the initial values were set before using animated placement.
            if (options.animate && !isInit) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }

            // First pass, without lookAhead but with lookBackward. Values are set from left to right.
            scope_HandleNumbers.forEach(function(handleNumber) {
                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
            });

            var i = scope_HandleNumbers.length === 1 ? 0 : 1;

            // Secondary passes. Now that all base values are set, apply constraints.
            // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)
            for (; i < scope_HandleNumbers.length; ++i) {
                scope_HandleNumbers.forEach(function(handleNumber) {
                    setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
                });
            }

            setZindex();

            scope_HandleNumbers.forEach(function(handleNumber) {
                fireEvent("update", handleNumber);

                // Fire the event only for handles that received a new value, as per #579
                if (values[handleNumber] !== null && fireSetEvent) {
                    fireEvent("set", handleNumber);
                }
            });
        }

        // Reset slider to initial values
        function valueReset(fireSetEvent) {
            valueSet(options.start, fireSetEvent);
        }

        // Set value for a single handle
        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
            // Ensure numeric input
            handleNumber = Number(handleNumber);

            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
                throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);
            }

            // Look both backward and forward, since we don't want this handle to "push" other handles (#960);
            // The exactInput argument can be used to ignore slider stepping (#436)
            setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);

            fireEvent("update", handleNumber);

            if (fireSetEvent) {
                fireEvent("set", handleNumber);
            }
        }

        // Get the slider value.
        function valueGet() {
            var values = scope_Values.map(options.format.to);

            // If only one handle is used, return a single value.
            if (values.length === 1) {
                return values[0];
            }

            return values;
        }

        // Removes classes from the root and empties it.
        function destroy() {
            // remove protected internal listeners
            removeEvent(INTERNAL_EVENT_NS.aria);
            removeEvent(INTERNAL_EVENT_NS.tooltips);

            for (var key in options.cssClasses) {
                if (!options.cssClasses.hasOwnProperty(key)) {
                    continue;
                }
                removeClass(scope_Target, options.cssClasses[key]);
            }

            while (scope_Target.firstChild) {
                scope_Target.removeChild(scope_Target.firstChild);
            }

            delete scope_Target.noUiSlider;
        }

        function getNextStepsForHandle(handleNumber) {
            var location = scope_Locations[handleNumber];
            var nearbySteps = scope_Spectrum.getNearbySteps(location);
            var value = scope_Values[handleNumber];
            var increment = nearbySteps.thisStep.step;
            var decrement = null;

            // If snapped, directly use defined step value
            if (options.snap) {
                return [
                    value - nearbySteps.stepBefore.startValue || null,
                    nearbySteps.stepAfter.startValue - value || null
                ];
            }

            // If the next value in this step moves into the next step,
            // the increment is the start of the next step - the current value
            if (increment !== false) {
                if (value + increment > nearbySteps.stepAfter.startValue) {
                    increment = nearbySteps.stepAfter.startValue - value;
                }
            }

            // If the value is beyond the starting point
            if (value > nearbySteps.thisStep.startValue) {
                decrement = nearbySteps.thisStep.step;
            } else if (nearbySteps.stepBefore.step === false) {
                decrement = false;
            }

            // If a handle is at the start of a step, it always steps back into the previous step first
            else {
                decrement = value - nearbySteps.stepBefore.highestStep;
            }

            // Now, if at the slider edges, there is no in/decrement
            if (location === 100) {
                increment = null;
            } else if (location === 0) {
                decrement = null;
            }

            // As per #391, the comparison for the decrement step can have some rounding issues.
            var stepDecimals = scope_Spectrum.countStepDecimals();

            // Round per #391
            if (increment !== null && increment !== false) {
                increment = Number(increment.toFixed(stepDecimals));
            }

            if (decrement !== null && decrement !== false) {
                decrement = Number(decrement.toFixed(stepDecimals));
            }

            return [decrement, increment];
        }

        // Get the current step size for the slider.
        function getNextSteps() {
            return scope_HandleNumbers.map(getNextStepsForHandle);
        }

        // Updateable: margin, limit, padding, step, range, animate, snap
        function updateOptions(optionsToUpdate, fireSetEvent) {
            // Spectrum is created using the range, snap, direction and step options.
            // 'snap' and 'step' can be updated.
            // If 'snap' and 'step' are not passed, they should remain unchanged.
            var v = valueGet();

            var updateAble = [
                "margin",
                "limit",
                "padding",
                "range",
                "animate",
                "snap",
                "step",
                "format",
                "pips",
                "tooltips"
            ];

            // Only change options that we're actually passed to update.
            updateAble.forEach(function(name) {
                // Check for undefined. null removes the value.
                if (optionsToUpdate[name] !== undefined) {
                    originalOptions[name] = optionsToUpdate[name];
                }
            });

            var newOptions = testOptions(originalOptions);

            // Load new options into the slider state
            updateAble.forEach(function(name) {
                if (optionsToUpdate[name] !== undefined) {
                    options[name] = newOptions[name];
                }
            });

            scope_Spectrum = newOptions.spectrum;

            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)
            options.margin = newOptions.margin;
            options.limit = newOptions.limit;
            options.padding = newOptions.padding;

            // Update pips, removes existing.
            if (options.pips) {
                pips(options.pips);
            } else {
                removePips();
            }

            // Update tooltips, removes existing.
            if (options.tooltips) {
                tooltips();
            } else {
                removeTooltips();
            }

            // Invalidate the current positioning so valueSet forces an update.
            scope_Locations = [];
            valueSet(optionsToUpdate.start || v, fireSetEvent);
        }

        // Initialization steps
        function setupSlider() {
            // Create the base element, initialize HTML and set classes.
            // Add handles and connect elements.
            scope_Base = addSlider(scope_Target);

            addElements(options.connect, scope_Base);

            // Attach user events.
            bindSliderEvents(options.events);

            // Use the public value method to set the start values.
            valueSet(options.start);

            if (options.pips) {
                pips(options.pips);
            }

            if (options.tooltips) {
                tooltips();
            }

            aria();
        }

        setupSlider();

        // noinspection JSUnusedGlobalSymbols
        scope_Self = {
            destroy: destroy,
            steps: getNextSteps,
            on: bindEvent,
            off: removeEvent,
            get: valueGet,
            set: valueSet,
            setHandle: valueSetHandle,
            reset: valueReset,
            // Exposed for unit testing, don't use this in your application.
            __moveHandles: function(a, b, c) {
                moveHandles(a, b, scope_Locations, c);
            },
            options: originalOptions, // Issue #600, #678
            updateOptions: updateOptions,
            target: scope_Target, // Issue #597
            removePips: removePips,
            removeTooltips: removeTooltips,
            getTooltips: function() {
                return scope_Tooltips;
            },
            getOrigins: function() {
                return scope_Handles;
            },
            pips: pips // Issue #594
        };

        return scope_Self;
    }

    // Run the standard initializer
    function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
            throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
        }

        // Throw an error if the slider was already initialized.
        if (target.noUiSlider) {
            throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
        }

        // Test the options and create the slider environment;
        var options = testOptions(originalOptions, target);
        var api = scope(target, options, originalOptions);

        target.noUiSlider = api;

        return api;
    }

    // Use an object instead of a function for future expandability;
    return {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        version: VERSION,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses: cssClasses,
        create: initialize
    };
});


/***/ }),

/***/ "?3216":
/*!***********************!*\
  !*** jsdom (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?aa72":
/*!********************************************************!*\
  !*** jsdom/lib/jsdom/living/generated/utils (ignored) ***!
  \********************************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c310":
/*!***************************************!*\
  !*** jsdom/lib/jsdom/utils (ignored) ***!
  \***************************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/app/layout.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtLy4vc3JjL2FwcC9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS8uL25vZGVfbW9kdWxlcy9mYWJyaWMvZGlzdC9mYWJyaWMuanMiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS8uL25vZGVfbW9kdWxlcy9ub3Vpc2xpZGVyL2Rpc3RyaWJ1dGUvbm91aXNsaWRlci5jc3MiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS8uL25vZGVfbW9kdWxlcy9ub3Vpc2xpZGVyL2Rpc3RyaWJ1dGUvbm91aXNsaWRlci5qcyIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtL2lnbm9yZWR8anNkb20iLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS9pZ25vcmVkfGpzZG9tL2xpYi9qc2RvbS9saXZpbmcvZ2VuZXJhdGVkL3V0aWxzIiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vaWdub3JlZHxqc2RvbS9saWIvanNkb20vdXRpbHMiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS93ZWJwYWNrL3N0YXJ0dXAiXSwibmFtZXMiOlsiY29uc29sZSIsImxvZyIsImNhbnZhcyIsIm51bWJlciIsImdyaWQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJsaW5lU3Ryb2tlIiwidGFibGVGaWxsIiwidGFibGVTdHJva2UiLCJ0YWJsZVNoYWRvdyIsImNoYWlyRmlsbCIsImNoYWlyU3Ryb2tlIiwiY2hhaXJTaGFkb3ciLCJiYXJGaWxsIiwiYmFyU3Ryb2tlIiwiYmFyU2hhZG93IiwiYmFyVGV4dCIsIndhbGxGaWxsIiwid2FsbFN0cm9rZSIsIndhbGxTaGFkb3ciLCJwaG90b1VybExhbmRzY2FwZSIsInBob3RvVXJsUG9ydHJhaXQiLCJ3aWR0aEVsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImhlaWdodEVsIiwiY2FudmFzRWwiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwidmFsdWUiLCJzZXRJdGVtIiwic2V0QXR0cmlidXRlIiwiaW5pdENhbnZhcyIsImNsZWFyIiwiZGlzcG9zZSIsImZhYnJpYyIsInBhcnNlSW50IiwiaSIsImhlaWdodCIsImxpbmVYIiwic3Ryb2tlIiwic2VsZWN0YWJsZSIsIm5hbWUiLCJsaW5lWSIsInNlbmRMaW5lc1RvQmFjayIsIm9uIiwiZSIsInNuYXBUb0dyaWQiLCJ0YXJnZXQiLCJzY2FsZVgiLCJzY2FsZVkiLCJzdHJva2VXaWR0aFVuc2NhbGVkIiwic3Ryb2tlV2lkdGgiLCJNYXRoIiwicm91bmQiLCJicmluZ1RvRnJvbnQiLCJzZW5kVG9CYWNrIiwiY2hlY2tCb3VkbmluZ0JveCIsInJlc2l6ZUNhbnZhcyIsIndpZHRoIiwiY2FudmFzQ29udGFpbmVyRWwiLCJxdWVyeVNlbGVjdG9yQWxsIiwic3R5bGUiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FudmFzTG9hZGVyIiwiZ2VuZXJhdGVJZCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiYWRkUmVjdCIsImxlZnQiLCJ0b3AiLCJpZCIsIm8iLCJmaWxsIiwic2hhZG93Iiwib3JpZ2luWCIsIm9yaWdpblkiLCJjZW50ZXJlZFJvdGF0aW9uIiwic25hcEFuZ2xlIiwidCIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsInRleHRBbGlnbiIsImciLCJhZGQiLCJhZGRDaXJjbGUiLCJyYWRpdXMiLCJhZGRUcmlhbmdsZSIsImFkZENoYWlyIiwiYWRkQmFyIiwiYWRkV2FsbCIsInNldCIsIm9iaiIsInNldENvb3JkcyIsIm9iakJvdW5kaW5nQm94IiwiZ2V0Qm91bmRpbmdSZWN0IiwiZ2V0T2JqZWN0cyIsIm1hcCIsInNldEFjdGl2ZU9iamVjdCIsImdldEFjdGl2ZU9iamVjdCIsInJlbW92ZSIsImRpc2NhcmRBY3RpdmVPYmplY3QiLCJyZW5kZXJBbGwiLCJoYXNDb250cm9scyIsImxvY2tNb3ZlbWVudFgiLCJsb2NrTW92ZW1lbnRZIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJTY2FsZUZhY3RvciIsInNlbGVjdGlvbiIsImhvdmVyQ3Vyc29yIiwiZGlzcGxheSIsImFkZERlZmF1bHRPYmplY3RzIiwidG90YWxUYWJsZXMiLCJjb250cm9sTnVtYmVyaW5nIiwianNvbl9jYW52YXMiLCJvYmplY3RzIiwibGVuZ3RoIiwidHlwZSIsInRleHQiLCJ0b0pTT04iLCJKU09OIiwic3RyaW5naWZ5IiwianNvbiIsInBhcnNlIiwibG9hZEZyb21KU09OIiwiYmluZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGdCQUFaO0FBRUE7QUFFQTtBQUNBO0FBRUEsSUFBSUMsTUFBSjtBQUNBLElBQUlDLE1BQUo7QUFDQSxJQUFNQyxJQUFJLEdBQUcsRUFBYjtBQUNBLElBQU1DLGVBQWUsR0FBRyxTQUF4QjtBQUNBLElBQU1DLFVBQVUsR0FBRyxTQUFuQjtBQUNBLElBQU1DLFNBQVMsR0FBRywwQkFBbEI7QUFD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RUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEVBQUQsRUFBSyxHQUFMLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVI7QUFDQUEsVUFBUSxDQUFDLEdBQUQs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdELEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDBDQUEwQztBQUMxQyxrREFBa0Q7QUFDbEQsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixRQUFROztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELFNBQVM7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pEO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0Esc0NBQXNDLGNBQWM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtREFBbUQsVUFBVTtBQUM3RDs7QUFFQSwrQ0FBK0MsVUFBVTs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBLHNDQUFzQyxjQUFjOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLEVBQUU7O0FBRXpCLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxrQkFBa0I7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscUJBQXFCLFFBQVE7QUFDNUMsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtB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Z0I7QUFDaEIsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUs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QUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FB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QUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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UUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEOzs7QUFHQTs7QUFFQTs7QUFFQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLEtBQThCLGFBQWEsQ0FBSTs7O0FBR2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUNobTdCRDs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRDtBQUNBLFFBQVEsaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQzNCLEtBQUssTUFBTSxFQU1OO0FBQ0wsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsOENBQThDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLHFDQUFxQywwQ0FBMEM7QUFDL0Usa0NBQWtDLHVDQUF1QztBQUN6RSxvQkFBb0Isd0JBQXdCO0FBQzVDLHNCQUFzQiwwQkFBMEI7QUFDaEQsd0JBQXdCLDRCQUE0QjtBQUNwRCxtQkFBbUIsd0JBQXdCO0FBQzNDLHNCQUFzQiwyQkFBMkI7QUFDakQsZ0NBQWdDLHFDQUFxQztBQUNyRSxvQkFBb0Isd0JBQXdCO0FBQzVDLDBCQUEwQiwrQkFBK0I7QUFDekQscUJBQXFCLDBCQUEwQjtBQUMvQyxvQkFBb0IseUJBQXlCO0FBQzdDLHNCQUFzQiwyQkFBMkI7QUFDakQsd0JBQXdCLDRCQUE0QjtBQUNwRCx5QkFBeUIsOEJBQThCO0FBQ3ZELHFCQUFxQiwwQkFBMEI7QUFDL0MsdUJBQXVCLDRCQUE0QjtBQUNuRCw4QkFBOEIsa0NBQWtDO0FBQ2hFLDhCQUE4QixtQ0FBbUM7QUFDakUsd0JBQXdCLDRCQUE0QjtBQUNwRCx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0VBQStFLGdCQUFnQjtBQUMvRjtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7O0FDcG9GRCxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3JCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQSxzRjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7OztVQ05BO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6ImxheW91dC5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgeyBhdXRoIH0gZnJvbSAnLi9hdXRoLmpzJztcclxuXHJcbmNvbnNvbGUubG9nKCdoZWxsbywgTWFuYWdlcicpO1xyXG5cclxuaW1wb3J0IHsgZmFicmljIH0gZnJvbSAnZmFicmljJztcclxuXHJcbmltcG9ydCBub1VpU2xpZGVyIGZyb20gJ25vdWlzbGlkZXInO1xyXG5pbXBvcnQgJ25vdWlzbGlkZXIvZGlzdHJpYnV0ZS9ub3Vpc2xpZGVyLmNzcyc7XHJcblxyXG5sZXQgY2FudmFzO1xyXG5sZXQgbnVtYmVyO1xyXG5jb25zdCBncmlkID0gMzA7XHJcbmNvbnN0IGJhY2tncm91bmRDb2xvciA9ICcjNjI2MjYyJztcclxuY29uc3QgbGluZVN0cm9rZSA9ICcjZWJlYmViJztcclxuY29uc3QgdGFibGVGaWxsID0gJ3JnYmEoMTg3LCAxODcsIDE4NywgMC43KSc7XHJcbmNvbnN0IHRhYmxlU3Ryb2tlID0gJyM1YzVjNWMnO1xyXG5jb25zdCB0YWJsZVNoYWRvdyA9ICdyZ2JhKDAsIDAsIDAsIDAuNCkgM3B4IDNweCA3cHgnO1xyXG5jb25zdCBjaGFpckZpbGwgPSAncmdiYSg3NSwgNzUsIDc1LCAwLjcpJztcclxuY29uc3QgY2hhaXJTdHJva2UgPSAnIzMyMjMwYic7XHJcbmNvbnN0IGNoYWlyU2hhZG93ID0gJ3JnYmEoMCwgMCwgMCwgMC40KSAzcHggM3B4IDdweCc7XHJcbi8vIGNvbnN0IGJhckZpbGwgPSAncmdiYSgwLCA5MywgMTI3LCAwLjcpJztcclxuY29uc3QgYmFyRmlsbCA9ICdyZ2JhKDAsIDE2MiwgMjU1LCAwLjcpJztcclxuY29uc3QgYmFyU3Ryb2tlID0gJyMwMDNlNTQnO1xyXG5jb25zdCBiYXJTaGFkb3cgPSAncmdiYSgwLCAwLCAwLCAwLjQpIDNweCAzcHggN3B4JztcclxuY29uc3QgYmFyVGV4dCA9ICdCYXInO1xyXG5jb25zdCB3YWxsRmlsbCA9ICdyZ2JhKDEzNiwgMTM2LCAxMzYsIDAuNyknO1xyXG5jb25zdCB3YWxsU3Ryb2tlID0gJyM2ODY4NjgnO1xyXG5jb25zdCB3YWxsU2hhZG93ID0gJ3JnYmEoMCwgMCwgMCwgMC40KSA1cHggNXB4IDIwcHgnO1xyXG5cclxudmFyIHBob3RvVXJsTGFuZHNjYXBlID0gJ2h0dHBzOi8vaW1hZ2VzOC5hbHBoYWNvZGVycy5jb20vMjkyLzI5MjM3OS5qcGcnLFxyXG4gICAgcGhvdG9VcmxQb3J0cmFpdCA9XHJcbiAgICAgICAgJ2h0dHBzOi8vcHJlc3NwYWNrLnJ0ZS5pZS93cC1jb250ZW50L2Jsb2dzLmRpci8yL2ZpbGVzLzIwMTUvMDQvQU1DX1RXRF9NYWdnaWVfUG9ydHJhaXRzXzQ4MTdfVjEuanBnJztcclxuXHJcbnZhciB3aWR0aEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpZHRoJyk7XHJcbnZhciBoZWlnaHRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWlnaHQnKTtcclxudmFyIGNhbnZhc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xyXG5cclxuaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3aWR0aEVsJykgJiYgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2hlaWdodEVsJykpIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aWR0aCcpLnZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dpZHRoRWwnKTtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWlnaHQnKS52YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdoZWlnaHRFbCcpO1xyXG59IGVsc2Uge1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2hlaWdodEVsJywgaGVpZ2h0RWwudmFsdWUpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dpZHRoRWwnLCB3aWR0aEVsLnZhbHVlKTtcclxufVxyXG5cclxuY2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3aWR0aEVsJykpO1xyXG5jYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdoZWlnaHRFbCcpKTtcclxuXHJcbmZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XHJcbiAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgY2FudmFzLmNsZWFyKCk7XHJcbiAgICAgICAgY2FudmFzLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBjYW52YXMgPSBuZXcgZmFicmljLkNhbnZhcygnY2FudmFzJyk7XHJcbiAgICBudW1iZXIgPSBwYXJzZUludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG90YWxUYWJsZXMnKSkgKyAxO1xyXG4gICAgLy8gbnVtYmVyID0gMTtcclxuICAgIGNhbnZhcy5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAvLyBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKFxyXG4gICAgLy8gICAgICdodHRwczovL3ByZXNzcGFjay5ydGUuaWUvd3AtY29udGVudC9ibG9ncy5kaXIvMi9maWxlcy8yMDE1LzA0L0FNQ19UV0RfTWFnZ2llX1BvcnRyYWl0c180ODE3X1YxLmpwZycsXHJcbiAgICAvLyAgICAgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcylcclxuICAgIC8vICk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYW52YXMuaGVpZ2h0IC8gZ3JpZDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluZVggPSBuZXcgZmFicmljLkxpbmUoWzAsIGkgKiBncmlkLCBjYW52YXMuaGVpZ2h0LCBpICogZ3JpZF0sIHtcclxuICAgICAgICAgICAgc3Ryb2tlOiBsaW5lU3Ryb2tlLFxyXG4gICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGxpbmVZID0gbmV3IGZhYnJpYy5MaW5lKFtpICogZ3JpZCwgMCwgaSAqIGdyaWQsIGNhbnZhcy5oZWlnaHRdLCB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogbGluZVN0cm9rZSxcclxuICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjYW52YXMuYWRkKGxpbmVYKTtcclxuICAgICAgICAvLyBjYW52YXMuYWRkKGxpbmVZKTtcclxuICAgICAgICBzZW5kTGluZXNUb0JhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICBjYW52YXMub24oJ29iamVjdDptb3ZpbmcnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHNuYXBUb0dyaWQoZS50YXJnZXQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY2FudmFzLm9uKCdvYmplY3Q6c2NhbGluZycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LnNjYWxlWCA+IDUpIHtcclxuICAgICAgICAgICAgZS50YXJnZXQuc2NhbGVYID0gNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LnNjYWxlWSA+IDUpIHtcclxuICAgICAgICAgICAgZS50YXJnZXQuc2NhbGVZID0gNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlLnRhcmdldC5zdHJva2VXaWR0aFVuc2NhbGVkICYmIGUudGFyZ2V0LnN0cm9rZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGUudGFyZ2V0LnN0cm9rZVdpZHRoVW5zY2FsZWQgPSBlLnRhcmdldC5zdHJva2VXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0LnN0cm9rZVdpZHRoVW5zY2FsZWQpIHtcclxuICAgICAgICAgICAgZS50YXJnZXQuc3Ryb2tlV2lkdGggPVxyXG4gICAgICAgICAgICAgICAgZS50YXJnZXQuc3Ryb2tlV2lkdGhVbnNjYWxlZCAvIGUudGFyZ2V0LnNjYWxlWDtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnN0cm9rZVdpZHRoID09PSBlLnRhcmdldC5zdHJva2VXaWR0aFVuc2NhbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5zdHJva2VXaWR0aCA9XHJcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc3Ryb2tlV2lkdGhVbnNjYWxlZCAvIGUudGFyZ2V0LnNjYWxlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNhbnZhcy5vbignb2JqZWN0Om1vZGlmaWVkJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnRhcmdldC5zY2FsZVggPVxyXG4gICAgICAgICAgICBlLnRhcmdldC5zY2FsZVggPj0gMC4yNSA/IE1hdGgucm91bmQoZS50YXJnZXQuc2NhbGVYICogMikgLyAyIDogMC41O1xyXG4gICAgICAgIGUudGFyZ2V0LnNjYWxlWSA9XHJcbiAgICAgICAgICAgIGUudGFyZ2V0LnNjYWxlWSA+PSAwLjI1ID8gTWF0aC5yb3VuZChlLnRhcmdldC5zY2FsZVkgKiAyKSAvIDIgOiAwLjU7XHJcbiAgICAgICAgc25hcFRvR3JpZChlLnRhcmdldCk7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0Lm5hbWUgPT09ICd0YWJsZScpIHtcclxuICAgICAgICAgICAgY2FudmFzLmJyaW5nVG9Gcm9udChlLnRhcmdldCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FudmFzLnNlbmRUb0JhY2soZS50YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZW5kTGluZXNUb0JhY2soKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNhbnZhcy5vbignb2JqZWN0Om1vdmluZycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgY2hlY2tCb3VkbmluZ0JveChlKTtcclxuICAgIH0pO1xyXG4gICAgY2FudmFzLm9uKCdvYmplY3Q6cm90YXRpbmcnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGNoZWNrQm91ZG5pbmdCb3goZSk7XHJcbiAgICB9KTtcclxuICAgIGNhbnZhcy5vbignb2JqZWN0OnNjYWxpbmcnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGNoZWNrQm91ZG5pbmdCb3goZSk7XHJcbiAgICB9KTtcclxufVxyXG5pbml0Q2FudmFzKCk7XHJcblxyXG5mdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XHJcbiAgICB3aWR0aEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpZHRoJyk7XHJcbiAgICBoZWlnaHRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWlnaHQnKTtcclxuICAgIGNhbnZhc0VsLndpZHRoID0gd2lkdGhFbC52YWx1ZSA/IHdpZHRoRWwudmFsdWUgOiAzMDI7XHJcbiAgICBjYW52YXNFbC5oZWlnaHQgPSBoZWlnaHRFbC52YWx1ZSA/IGhlaWdodEVsLnZhbHVlIDogODEyO1xyXG4gICAgY29uc3QgY2FudmFzQ29udGFpbmVyRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FudmFzLWNvbnRhaW5lcicpWzBdO1xyXG4gICAgY2FudmFzQ29udGFpbmVyRWwuc3R5bGUud2lkdGggPSBjYW52YXNFbC53aWR0aDtcclxuICAgIGNhbnZhc0NvbnRhaW5lckVsLnN0eWxlLmhlaWdodCA9IGNhbnZhc0VsLmhlaWdodDtcclxufVxyXG5yZXNpemVDYW52YXMoKTtcclxuXHJcbndpZHRoRWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgcmVzaXplQ2FudmFzKCk7XHJcbiAgICBpbml0Q2FudmFzKCk7XHJcbiAgICAvLyBhZGREZWZhdWx0T2JqZWN0cygpO1xyXG4gICAgY2FudmFzTG9hZGVyKCk7XHJcbiAgICBzZW5kTGluZXNUb0JhY2soKTtcclxufSk7XHJcbmhlaWdodEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcclxuICAgIHJlc2l6ZUNhbnZhcygpO1xyXG4gICAgaW5pdENhbnZhcygpO1xyXG4gICAgLy8gYWRkRGVmYXVsdE9iamVjdHMoKTtcclxuICAgIGNhbnZhc0xvYWRlcigpO1xyXG4gICAgc2VuZExpbmVzVG9CYWNrKCk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcclxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcclxuICAgIGNvbnN0IG8gPSBuZXcgZmFicmljLlJlY3Qoe1xyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICBmaWxsOiB0YWJsZUZpbGwsXHJcbiAgICAgICAgc3Ryb2tlOiB0YWJsZVN0cm9rZSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzaGFkb3c6IHRhYmxlU2hhZG93LFxyXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxyXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxyXG4gICAgICAgIGNlbnRlcmVkUm90YXRpb246IHRydWUsXHJcbiAgICAgICAgc25hcEFuZ2xlOiA0NSxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB0ID0gbmV3IGZhYnJpYy5JVGV4dChudW1iZXIudG9TdHJpbmcoKSwge1xyXG4gICAgICAgIGZvbnRGYW1pbHk6ICdDYWxpYnJpJyxcclxuICAgICAgICBmb250U2l6ZTogMTQsXHJcbiAgICAgICAgZmlsbDogJyMwMDAnLFxyXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGcgPSBuZXcgZmFicmljLkdyb3VwKFtvLCB0XSwge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgY2VudGVyZWRSb3RhdGlvbjogdHJ1ZSxcclxuICAgICAgICBzbmFwQW5nbGU6IDQ1LFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgbmFtZTogJ3RhYmxlJyxcclxuICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgbnVtYmVyOiBudW1iZXIsXHJcbiAgICB9KTtcclxuICAgIGNhbnZhcy5hZGQoZyk7XHJcbiAgICBudW1iZXIrKztcclxuICAgIHJldHVybiBnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRDaXJjbGUobGVmdCwgdG9wLCByYWRpdXMpIHtcclxuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJZCgpO1xyXG4gICAgY29uc3QgbyA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICBmaWxsOiB0YWJsZUZpbGwsXHJcbiAgICAgICAgc3Ryb2tlOiB0YWJsZVN0cm9rZSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzaGFkb3c6IHRhYmxlU2hhZG93LFxyXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxyXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxyXG4gICAgICAgIGNlbnRlcmVkUm90YXRpb246IHRydWUsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHQgPSBuZXcgZmFicmljLklUZXh0KG51bWJlci50b1N0cmluZygpLCB7XHJcbiAgICAgICAgZm9udEZhbWlseTogJ0NhbGlicmknLFxyXG4gICAgICAgIGZvbnRTaXplOiAxNCxcclxuICAgICAgICBmaWxsOiAnIzAwMCcsXHJcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZyA9IG5ldyBmYWJyaWMuR3JvdXAoW28sIHRdLCB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBjZW50ZXJlZFJvdGF0aW9uOiB0cnVlLFxyXG4gICAgICAgIHNuYXBBbmdsZTogNDUsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBuYW1lOiAndGFibGUnLFxyXG4gICAgICAgIGlkOiBpZCxcclxuICAgICAgICBudW1iZXI6IG51bWJlcixcclxuICAgIH0pO1xyXG4gICAgY2FudmFzLmFkZChnKTtcclxuICAgIG51bWJlcisrO1xyXG4gICAgcmV0dXJuIGc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFRyaWFuZ2xlKGxlZnQsIHRvcCwgcmFkaXVzKSB7XHJcbiAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcclxuICAgIGNvbnN0IG8gPSBuZXcgZmFicmljLlRyaWFuZ2xlKHtcclxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICBmaWxsOiB0YWJsZUZpbGwsXHJcbiAgICAgICAgc3Ryb2tlOiB0YWJsZVN0cm9rZSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzaGFkb3c6IHRhYmxlU2hhZG93LFxyXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxyXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxyXG4gICAgICAgIGNlbnRlcmVkUm90YXRpb246IHRydWUsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHQgPSBuZXcgZmFicmljLklUZXh0KG51bWJlci50b1N0cmluZygpLCB7XHJcbiAgICAgICAgZm9udEZhbWlseTogJ0NhbGlicmknLFxyXG4gICAgICAgIGZvbnRTaXplOiAxNCxcclxuICAgICAgICBmaWxsOiAnIzAwMCcsXHJcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZyA9IG5ldyBmYWJyaWMuR3JvdXAoW28sIHRdLCB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBjZW50ZXJlZFJvdGF0aW9uOiB0cnVlLFxyXG4gICAgICAgIHNuYXBBbmdsZTogNDUsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBuYW1lOiAndGFibGUnLFxyXG4gICAgICAgIGlkOiBpZCxcclxuICAgICAgICBudW1iZXI6IG51bWJlcixcclxuICAgIH0pO1xyXG4gICAgY2FudmFzLmFkZChnKTtcclxuICAgIG51bWJlcisrO1xyXG4gICAgcmV0dXJuIGc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZENoYWlyKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgY29uc3QgbyA9IG5ldyBmYWJyaWMuUmVjdCh7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAzMCxcclxuICAgICAgICBmaWxsOiBjaGFpckZpbGwsXHJcbiAgICAgICAgc3Ryb2tlOiBjaGFpclN0cm9rZSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzaGFkb3c6IGNoYWlyU2hhZG93LFxyXG4gICAgICAgIG9yaWdpblg6ICdsZWZ0JyxcclxuICAgICAgICBvcmlnaW5ZOiAndG9wJyxcclxuICAgICAgICBjZW50ZXJlZFJvdGF0aW9uOiB0cnVlLFxyXG4gICAgICAgIHNuYXBBbmdsZTogNDUsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBuYW1lOiAnY2hhaXInLFxyXG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXHJcbiAgICB9KTtcclxuICAgIGNhbnZhcy5hZGQobyk7XHJcbiAgICByZXR1cm4gbztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQmFyKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgY29uc3QgbyA9IG5ldyBmYWJyaWMuUmVjdCh7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIGZpbGw6IGJhckZpbGwsXHJcbiAgICAgICAgc3Ryb2tlOiBiYXJTdHJva2UsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXHJcbiAgICAgICAgc2hhZG93OiBiYXJTaGFkb3csXHJcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXHJcbiAgICAgICAgbmFtZTogJ2JhcicsXHJcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgdCA9IG5ldyBmYWJyaWMuSVRleHQoYmFyVGV4dCwge1xyXG4gICAgICAgIGZvbnRGYW1pbHk6ICdDYWxpYnJpJyxcclxuICAgICAgICBmb250U2l6ZTogMTQsXHJcbiAgICAgICAgZmlsbDogJyMwMDAnLFxyXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGcgPSBuZXcgZmFicmljLkdyb3VwKFtvLCB0XSwge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgY2VudGVyZWRSb3RhdGlvbjogdHJ1ZSxcclxuICAgICAgICBzbmFwQW5nbGU6IDQ1LFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgbmFtZTogJ2JhcicsXHJcbiAgICB9KTtcclxuICAgIGNhbnZhcy5hZGQoZyk7XHJcbiAgICByZXR1cm4gZztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkV2FsbChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGNvbnN0IG8gPSBuZXcgZmFicmljLlJlY3Qoe1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIGZpbGw6IHdhbGxGaWxsLFxyXG4gICAgICAgIHN0cm9rZTogd2FsbFN0cm9rZSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzaGFkb3c6IHdhbGxTaGFkb3csXHJcbiAgICAgICAgb3JpZ2luWDogJ2xlZnQnLFxyXG4gICAgICAgIG9yaWdpblk6ICd0b3AnLFxyXG4gICAgICAgIGNlbnRlcmVkUm90YXRpb246IHRydWUsXHJcbiAgICAgICAgc25hcEFuZ2xlOiA0NSxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIG5hbWU6ICd3YWxsJyxcclxuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxyXG4gICAgfSk7XHJcbiAgICBjYW52YXMuYWRkKG8pO1xyXG4gICAgcmV0dXJuIG87XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNuYXBUb0dyaWQodGFyZ2V0KSB7XHJcbiAgICB0YXJnZXQuc2V0KHtcclxuICAgICAgICBsZWZ0OiAoTWF0aC5yb3VuZCh0YXJnZXQubGVmdCAvIChncmlkIC8gMikpICogZ3JpZCkgLyAyLFxyXG4gICAgICAgIHRvcDogKE1hdGgucm91bmQodGFyZ2V0LnRvcCAvIChncmlkIC8gMikpICogZ3JpZCkgLyAyLFxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrQm91ZG5pbmdCb3goZSkge1xyXG4gICAgY29uc3Qgb2JqID0gZS50YXJnZXQ7XHJcblxyXG4gICAgaWYgKCFvYmopIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBvYmouc2V0Q29vcmRzKCk7XHJcblxyXG4gICAgY29uc3Qgb2JqQm91bmRpbmdCb3ggPSBvYmouZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICBpZiAob2JqQm91bmRpbmdCb3gudG9wIDwgMCkge1xyXG4gICAgICAgIG9iai5zZXQoJ3RvcCcsIDApO1xyXG4gICAgICAgIG9iai5zZXRDb29yZHMoKTtcclxuICAgIH1cclxuICAgIGlmIChvYmpCb3VuZGluZ0JveC5sZWZ0ID4gY2FudmFzLndpZHRoIC0gb2JqQm91bmRpbmdCb3gud2lkdGgpIHtcclxuICAgICAgICBvYmouc2V0KCdsZWZ0JywgY2FudmFzLndpZHRoIC0gb2JqQm91bmRpbmdCb3gud2lkdGgpO1xyXG4gICAgICAgIG9iai5zZXRDb29yZHMoKTtcclxuICAgIH1cclxuICAgIGlmIChvYmpCb3VuZGluZ0JveC50b3AgPiBjYW52YXMuaGVpZ2h0IC0gb2JqQm91bmRpbmdCb3guaGVpZ2h0KSB7XHJcbiAgICAgICAgb2JqLnNldCgndG9wJywgY2FudmFzLmhlaWdodCAtIG9iakJvdW5kaW5nQm94LmhlaWdodCk7XHJcbiAgICAgICAgb2JqLnNldENvb3JkcygpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iakJvdW5kaW5nQm94LmxlZnQgPCAwKSB7XHJcbiAgICAgICAgb2JqLnNldCgnbGVmdCcsIDApO1xyXG4gICAgICAgIG9iai5zZXRDb29yZHMoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2VuZExpbmVzVG9CYWNrKCkge1xyXG4gICAgY2FudmFzLmdldE9iamVjdHMoKS5tYXAoKG8pID0+IHtcclxuICAgICAgICBpZiAoby5uYW1lID09PSAnbGluZScpIHtcclxuICAgICAgICAgICAgY2FudmFzLnNlbmRUb0JhY2sobyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmRvY3VtZW50XHJcbiAgICAucXVlcnlTZWxlY3RvckFsbCgnLnJlY3RhbmdsZScpWzBdXHJcbiAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgbyA9IGFkZFJlY3QoMCwgMCwgNjAsIDYwKTtcclxuICAgICAgICBjYW52YXMuc2V0QWN0aXZlT2JqZWN0KG8pO1xyXG4gICAgfSk7XHJcblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2lyY2xlJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBvID0gYWRkQ2lyY2xlKDAsIDAsIDMwKTtcclxuICAgIGNhbnZhcy5zZXRBY3RpdmVPYmplY3Qobyk7XHJcbn0pO1xyXG5cclxuZG9jdW1lbnRcclxuICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcudHJpYW5nbGUnKVswXVxyXG4gICAgLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG8gPSBhZGRUcmlhbmdsZSgwLCAwLCAzMCk7XHJcbiAgICAgICAgY2FudmFzLnNldEFjdGl2ZU9iamVjdChvKTtcclxuICAgIH0pO1xyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNoYWlyJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBvID0gYWRkQ2hhaXIoMCwgMCk7XHJcbiAgICBjYW52YXMuc2V0QWN0aXZlT2JqZWN0KG8pO1xyXG59KTtcclxuXHJcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5iYXInKVswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IG8gPSBhZGRCYXIoMCwgMCwgMTgwLCA2MCk7XHJcbiAgICBjYW52YXMuc2V0QWN0aXZlT2JqZWN0KG8pO1xyXG59KTtcclxuXHJcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy53YWxsJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBvID0gYWRkV2FsbCgwLCAwLCA2MCwgMTgwKTtcclxuICAgIGNhbnZhcy5zZXRBY3RpdmVPYmplY3Qobyk7XHJcbn0pO1xyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnJlbW92ZScpWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgbyA9IGNhbnZhcy5nZXRBY3RpdmVPYmplY3QoKTtcclxuICAgIGlmIChvKSB7XHJcbiAgICAgICAgLy8gby5yZW1vdmUoKTtcclxuICAgICAgICBjYW52YXMucmVtb3ZlKG8pO1xyXG4gICAgICAgIGNhbnZhcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XHJcbiAgICAgICAgY2FudmFzLnJlbmRlckFsbCgpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmRvY3VtZW50XHJcbiAgICAucXVlcnlTZWxlY3RvckFsbCgnLmN1c3RvbWVyLW1vZGUnKVswXVxyXG4gICAgLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNhbnZhcy5nZXRPYmplY3RzKCkubWFwKChvKSA9PiB7XHJcbiAgICAgICAgICAgIG8uaGFzQ29udHJvbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgby5sb2NrTW92ZW1lbnRYID0gdHJ1ZTtcclxuICAgICAgICAgICAgby5sb2NrTW92ZW1lbnRZID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKG8ubmFtZSA9PT0gJ2NoYWlyJyB8fCBvLm5hbWUgPT09ICdiYXInIHx8IG8ubmFtZSA9PT0gJ3dhbGwnKSB7XHJcbiAgICAgICAgICAgICAgICBvLnNlbGVjdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvLmJvcmRlckNvbG9yID0gJyMzOEE2MkUnO1xyXG4gICAgICAgICAgICBvLmJvcmRlclNjYWxlRmFjdG9yID0gMi41O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNhbnZhcy5zZWxlY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICBjYW52YXMuaG92ZXJDdXJzb3IgPSAncG9pbnRlcic7XHJcbiAgICAgICAgY2FudmFzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcclxuICAgICAgICBjYW52YXMucmVuZGVyQWxsKCk7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFkbWluLW1lbnUnKVswXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b21lci1tZW51JylbMF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICB9KTtcclxuXHJcbi8vIGRvY3VtZW50XHJcbi8vICAgICAucXVlcnlTZWxlY3RvckFsbCgnLmFkbWluLW1vZGUnKVswXVxyXG4vLyAgICAgLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4vLyAgICAgICAgIGNhbnZhcy5nZXRPYmplY3RzKCkubWFwKChvKSA9PiB7XHJcbi8vICAgICAgICAgICAgIG8uaGFzQ29udHJvbHMgPSB0cnVlO1xyXG4vLyAgICAgICAgICAgICBvLmxvY2tNb3ZlbWVudFggPSBmYWxzZTtcclxuLy8gICAgICAgICAgICAgby5sb2NrTW92ZW1lbnRZID0gZmFsc2U7XHJcbi8vICAgICAgICAgICAgIGlmIChvLm5hbWUgPT09ICdjaGFpcicgfHwgby5uYW1lID09PSAnYmFyJyB8fCBvLm5hbWUgPT09ICd3YWxsJykge1xyXG4vLyAgICAgICAgICAgICAgICAgby5zZWxlY3RhYmxlID0gdHJ1ZTtcclxuLy8gICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICBvLmJvcmRlckNvbG9yID0gJ3JnYmEoMTAyLCAxNTMsIDI1NSwgMC43NSknO1xyXG4vLyAgICAgICAgICAgICBvLmJvcmRlclNjYWxlRmFjdG9yID0gMTtcclxuLy8gICAgICAgICB9KTtcclxuLy8gICAgICAgICBjYW52YXMuc2VsZWN0aW9uID0gdHJ1ZTtcclxuLy8gICAgICAgICBjYW52YXMuaG92ZXJDdXJzb3IgPSAnbW92ZSc7XHJcbi8vICAgICAgICAgY2FudmFzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcclxuLy8gICAgICAgICBjYW52YXMucmVuZGVyQWxsKCk7XHJcbi8vICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFkbWluLW1lbnUnKVswXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuLy8gICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY3VzdG9tZXItbWVudScpWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbi8vICAgICB9KTtcclxuXHJcbmNhbnZhcy5nZXRPYmplY3RzKCkubWFwKChvKSA9PiB7XHJcbiAgICBvLmhhc0NvbnRyb2xzID0gdHJ1ZTtcclxuICAgIG8ubG9ja01vdmVtZW50WCA9IGZhbHNlO1xyXG4gICAgby5sb2NrTW92ZW1lbnRZID0gZmFsc2U7XHJcbiAgICBpZiAoby5uYW1lID09PSAnY2hhaXInIHx8IG8ubmFtZSA9PT0gJ2JhcicgfHwgby5uYW1lID09PSAnd2FsbCcpIHtcclxuICAgICAgICBvLnNlbGVjdGFibGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgby5ib3JkZXJDb2xvciA9ICdyZ2JhKDEwMiwgMTUzLCAyNTUsIDAuNzUpJztcclxuICAgIG8uYm9yZGVyU2NhbGVGYWN0b3IgPSAxO1xyXG59KTtcclxuY2FudmFzLnNlbGVjdGlvbiA9IHRydWU7XHJcbmNhbnZhcy5ob3ZlckN1cnNvciA9ICdtb3ZlJztcclxuY2FudmFzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcclxuY2FudmFzLnJlbmRlckFsbCgpO1xyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWRtaW4tbWVudScpWzBdLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4vLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY3VzdG9tZXItbWVudScpWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4vLyBmdW5jdGlvbiBmb3JtYXRUaW1lKHZhbCkge1xyXG4vLyAgICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHZhbCAvIDYwKTtcclxuLy8gICAgIGNvbnN0IG1pbnV0ZXMgPSB2YWwgJSA2MDtcclxuLy8gICAgIGNvbnN0IGVuZ2xpc2hIb3VycyA9IGhvdXJzID4gMTIgPyBob3VycyAtIDEyIDogaG91cnM7XHJcblxyXG4vLyAgICAgY29uc3Qgbm9ybWFsID0gaG91cnMgKyAnOicgKyBtaW51dGVzICsgKG1pbnV0ZXMgPT09IDAgPyAnMCcgOiAnJyk7XHJcbi8vICAgICBjb25zdCBlbmdsaXNoID1cclxuLy8gICAgICAgICBlbmdsaXNoSG91cnMgK1xyXG4vLyAgICAgICAgICc6JyArXHJcbi8vICAgICAgICAgbWludXRlcyArXHJcbi8vICAgICAgICAgKG1pbnV0ZXMgPT09IDAgPyAnMCcgOiAnJykgK1xyXG4vLyAgICAgICAgICcgJyArXHJcbi8vICAgICAgICAgKGhvdXJzID4gMTIgPyAnUE0nIDogJ0FNJyk7XHJcblxyXG4vLyAgICAgcmV0dXJuIG5vcm1hbCArICcgKCcgKyBlbmdsaXNoICsgJyknO1xyXG4vLyB9XHJcblxyXG4vLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VibWl0JylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbi8vICAgICBjb25zdCBvYmogPSBjYW52YXMuZ2V0QWN0aXZlT2JqZWN0KCk7XHJcbi8vICAgICAkKCcjbW9kYWwnKS5tb2RhbCgnc2hvdycpO1xyXG4vLyAgICAgbGV0IG1vZGFsVGV4dCA9ICdZb3UgaGF2ZSBub3Qgc2VsZWN0ZWQgYW55dGhpbmcnO1xyXG4vLyAgICAgaWYgKG9iaikge1xyXG4vLyAgICAgICAgIG1vZGFsVGV4dCA9XHJcbi8vICAgICAgICAgICAgICdZb3UgaGF2ZSBzZWxlY3RlZCB0YWJsZSAnICtcclxuLy8gICAgICAgICAgICAgb2JqLm51bWJlciArXHJcbi8vICAgICAgICAgICAgICcsIHRpbWU6ICcgK1xyXG4vLyAgICAgICAgICAgICBmb3JtYXRUaW1lKHNsaWRlci5ub1VpU2xpZGVyLmdldCgpKTtcclxuLy8gICAgIH1cclxuLy8gICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNtb2RhbC10YWJsZS1pZCcpWzBdLmlubmVySFRNTCA9IG1vZGFsVGV4dDtcclxuLy8gfSk7XHJcblxyXG4vLyBjb25zdCBzbGlkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2xpZGVyJyk7XHJcbi8vIG5vVWlTbGlkZXIuY3JlYXRlKHNsaWRlciwge1xyXG4vLyAgICAgc3RhcnQ6IDEyMDAsXHJcbi8vICAgICBzdGVwOiAxNSxcclxuLy8gICAgIGNvbm5lY3Q6ICdsb3dlcicsXHJcbi8vICAgICByYW5nZToge1xyXG4vLyAgICAgICAgIG1pbjogMCxcclxuLy8gICAgICAgICBtYXg6IDE0MjUsXHJcbi8vICAgICB9LFxyXG4vLyB9KTtcclxuXHJcbi8vIGNvbnN0IHNsaWRlclZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NsaWRlci12YWx1ZScpO1xyXG4vLyBzbGlkZXIubm9VaVNsaWRlci5vbigndXBkYXRlJywgZnVuY3Rpb24gKHZhbHVlcywgaGFuZGxlKSB7XHJcbi8vICAgICBzbGlkZXJWYWx1ZS5pbm5lckhUTUwgPSBmb3JtYXRUaW1lKHZhbHVlc1toYW5kbGVdKTtcclxuLy8gfSk7XHJcblxyXG5mdW5jdGlvbiBhZGREZWZhdWx0T2JqZWN0cygpIHtcclxuICAgIGFkZENoYWlyKDE1LCAxMDUpO1xyXG4gICAgYWRkQ2hhaXIoMTUsIDEzNSk7XHJcbiAgICBhZGRDaGFpcig3NSwgMTA1KTtcclxuICAgIGFkZENoYWlyKDc1LCAxMzUpO1xyXG4gICAgYWRkQ2hhaXIoMjI1LCA3NSk7XHJcbiAgICBhZGRDaGFpcigyNTUsIDc1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgMTM1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgMTM1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgMTk1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgMTk1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgMjU1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgMjU1KTtcclxuICAgIGFkZENoYWlyKDE1LCAxOTUpO1xyXG4gICAgYWRkQ2hhaXIoNDUsIDE5NSk7XHJcbiAgICBhZGRDaGFpcigxNSwgMjU1KTtcclxuICAgIGFkZENoYWlyKDQ1LCAyNTUpO1xyXG4gICAgYWRkQ2hhaXIoMTUsIDMxNSk7XHJcbiAgICBhZGRDaGFpcig0NSwgMzE1KTtcclxuICAgIGFkZENoYWlyKDE1LCAzNzUpO1xyXG4gICAgYWRkQ2hhaXIoNDUsIDM3NSk7XHJcbiAgICBhZGRDaGFpcigyMjUsIDMxNSk7XHJcbiAgICBhZGRDaGFpcigyNTUsIDMxNSk7XHJcbiAgICBhZGRDaGFpcigyMjUsIDM3NSk7XHJcbiAgICBhZGRDaGFpcigyNTUsIDM3NSk7XHJcbiAgICBhZGRDaGFpcigxNSwgNDM1KTtcclxuICAgIGFkZENoYWlyKDE1LCA0OTUpO1xyXG4gICAgYWRkQ2hhaXIoMTUsIDU1NSk7XHJcbiAgICBhZGRDaGFpcigxNSwgNjE1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgNjE1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNjE1KTtcclxuICAgIGFkZENoYWlyKDE5NSwgNDk1KTtcclxuICAgIGFkZENoYWlyKDE5NSwgNTI1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNDk1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNTI1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgNjc1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNjc1KTtcclxuXHJcbiAgICBhZGRSZWN0KDMwLCA5MCwgNjAsIDkwKTtcclxuICAgIGFkZFJlY3QoMjEwLCA5MCwgOTAsIDYwKTtcclxuICAgIGFkZFJlY3QoMjEwLCAyMTAsIDkwLCA2MCk7XHJcbiAgICBhZGRSZWN0KDAsIDIxMCwgOTAsIDYwKTtcclxuICAgIGFkZFJlY3QoMCwgMzMwLCA5MCwgNjApO1xyXG4gICAgYWRkUmVjdCgyMTAsIDMzMCwgOTAsIDYwKTtcclxuICAgIGFkZFJlY3QoMCwgNDUwLCA2MCwgNjApO1xyXG4gICAgYWRkUmVjdCgwLCA1NzAsIDYwLCA2MCk7XHJcbiAgICBhZGRSZWN0KDIxMCwgNDgwLCA2MCwgOTApO1xyXG4gICAgYWRkUmVjdCgyMTAsIDYzMCwgOTAsIDYwKTtcclxuXHJcbiAgICBhZGRCYXIoMTIwLCAwLCAxODAsIDYwKTtcclxuXHJcbiAgICBhZGRXYWxsKDEyMCwgNTEwLCA2MCwgNjApO1xyXG59XHJcbi8vIGFkZERlZmF1bHRPYmplY3RzKCk7XHJcblxyXG52YXIgdG90YWxUYWJsZXMgPSAwO1xyXG5mdW5jdGlvbiBjb250cm9sTnVtYmVyaW5nKGpzb25fY2FudmFzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb25fY2FudmFzLm9iamVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhqc29uX2NhbnZhcy5vYmplY3RzW2ldKTtcclxuICAgICAgICBpZiAoanNvbl9jYW52YXMub2JqZWN0c1tpXS50eXBlID09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnNlSW50KGpzb25fY2FudmFzLm9iamVjdHNbaV0ub2JqZWN0c1sxXS50ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coanNvbl9jYW52YXMub2JqZWN0c1tpXS5vYmplY3RzWzFdLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgdG90YWxUYWJsZXMrKztcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0b3RhbFRhYmxlcycsIHRvdGFsVGFibGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvdGFsVGFibGVzID0gMDtcclxuXHJcbiAgICByZXR1cm4ganNvbl9jYW52YXM7XHJcbn1cclxuXHJcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYXZlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICBsZXQganNvbl9jYW52YXMgPSBjYW52YXMudG9KU09OKCk7XHJcbiAgICBqc29uX2NhbnZhcyA9IGNvbnRyb2xOdW1iZXJpbmcoanNvbl9jYW52YXMpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2pzb25fY2FudmFzJywgSlNPTi5zdHJpbmdpZnkoanNvbl9jYW52YXMpKTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdoZWlnaHRFbCcsIGhlaWdodEVsLnZhbHVlKTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3aWR0aEVsJywgd2lkdGhFbC52YWx1ZSk7XHJcbn0pO1xyXG5cclxuLy8gY2FudmFzLmNsZWFyKCk7XHJcbmZ1bmN0aW9uIGNhbnZhc0xvYWRlcigpIHtcclxuICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnanNvbl9jYW52YXMnKSk7XHJcbiAgICBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcclxufVxyXG5jYW52YXNMb2FkZXIoKTtcclxuc2VuZExpbmVzVG9CYWNrKCk7XHJcbiIsIi8qIGJ1aWxkOiBgbm9kZSBidWlsZC5qcyBtb2R1bGVzPUFMTCBleGNsdWRlPWdlc3R1cmVzLGFjY2Vzc29ycyByZXF1aXJlanMgbWluaWZpZXI9dWdsaWZ5anNgICovXG4vKiEgRmFicmljLmpzIENvcHlyaWdodCAyMDA4LTIwMTUsIFByaW50aW8gKEp1cml5IFpheXRzZXYsIE1heGltIENoZXJueWFrKSAqL1xuXG52YXIgZmFicmljID0gZmFicmljIHx8IHsgdmVyc2lvbjogJzQuMy4xJyB9O1xuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLmZhYnJpYyA9IGZhYnJpYztcbn1cbi8qIF9BTURfU1RBUlRfICovXG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhYnJpYzsgfSk7XG59XG4vKiBfQU1EX0VORF8gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mICh0eXBlb2YgSFRNTERvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IEhUTUxEb2N1bWVudCA6IERvY3VtZW50KSkge1xuICAgIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICB9XG4gIGVsc2Uge1xuICAgIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7XG4gIH1cbiAgZmFicmljLndpbmRvdyA9IHdpbmRvdztcbn1cbmVsc2Uge1xuICAvLyBhc3N1bWUgd2UncmUgcnVubmluZyB1bmRlciBub2RlLmpzIHdoZW4gZG9jdW1lbnQvd2luZG93IGFyZSBub3QgcHJlc2VudFxuICB2YXIganNkb20gPSByZXF1aXJlKCdqc2RvbScpO1xuICB2YXIgdmlydHVhbFdpbmRvdyA9IG5ldyBqc2RvbS5KU0RPTShcbiAgICBkZWNvZGVVUklDb21wb25lbnQoJyUzQyFET0NUWVBFJTIwaHRtbCUzRSUzQ2h0bWwlM0UlM0NoZWFkJTNFJTNDJTJGaGVhZCUzRSUzQ2JvZHklM0UlM0MlMkZib2R5JTNFJTNDJTJGaHRtbCUzRScpLFxuICAgIHtcbiAgICAgIGZlYXR1cmVzOiB7XG4gICAgICAgIEZldGNoRXh0ZXJuYWxSZXNvdXJjZXM6IFsnaW1nJ11cbiAgICAgIH0sXG4gICAgICByZXNvdXJjZXM6ICd1c2FibGUnXG4gICAgfSkud2luZG93O1xuICBmYWJyaWMuZG9jdW1lbnQgPSB2aXJ0dWFsV2luZG93LmRvY3VtZW50O1xuICBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlciA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS9saXZpbmcvZ2VuZXJhdGVkL3V0aWxzJykuaW1wbEZvcldyYXBwZXI7XG4gIGZhYnJpYy5ub2RlQ2FudmFzID0gcmVxdWlyZSgnanNkb20vbGliL2pzZG9tL3V0aWxzJykuQ2FudmFzO1xuICBmYWJyaWMud2luZG93ID0gdmlydHVhbFdpbmRvdztcbiAgRE9NUGFyc2VyID0gZmFicmljLndpbmRvdy5ET01QYXJzZXI7XG59XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQgc3VwcG9ydHMgdG91Y2ggZXZlbnRzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc1RvdWNoU3VwcG9ydGVkID0gJ29udG91Y2hzdGFydCcgaW4gZmFicmljLndpbmRvdyB8fCAnb250b3VjaHN0YXJ0JyBpbiBmYWJyaWMuZG9jdW1lbnQgfHxcbiAgKGZhYnJpYy53aW5kb3cgJiYgZmFicmljLndpbmRvdy5uYXZpZ2F0b3IgJiYgZmFicmljLndpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKTtcblxuLyoqXG4gKiBUcnVlIHdoZW4gaW4gZW52aXJvbm1lbnQgdGhhdCdzIHByb2JhYmx5IE5vZGUuanNcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuZmFicmljLmlzTGlrZWx5Tm9kZSA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbi8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbi8qKlxuICogQXR0cmlidXRlcyBwYXJzZWQgZnJvbSBhbGwgU1ZHIGVsZW1lbnRzXG4gKiBAdHlwZSBhcnJheVxuICovXG5mYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMgPSBbXG4gICdkaXNwbGF5JyxcbiAgJ3RyYW5zZm9ybScsXG4gICdmaWxsJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLFxuICAnb3BhY2l0eScsXG4gICdzdHJva2UnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJyxcbiAgJ2lkJywgJ3BhaW50LW9yZGVyJywgJ3ZlY3Rvci1lZmZlY3QnLFxuICAnaW5zdGFudGlhdGVkX2J5X3VzZScsICdjbGlwLXBhdGgnLFxuXTtcbi8qIF9GUk9NX1NWR19FTkRfICovXG5cbi8qKlxuICogUGl4ZWwgcGVyIEluY2ggYXMgYSBkZWZhdWx0IHZhbHVlIHNldCB0byA5Ni4gQ2FuIGJlIGNoYW5nZWQgZm9yIG1vcmUgcmVhbGlzdGljIGNvbnZlcnNpb24uXG4gKi9cbmZhYnJpYy5EUEkgPSA5NjtcbmZhYnJpYy5yZU51bSA9ICcoPzpbLStdPyg/OlxcXFxkK3xcXFxcZCpcXFxcLlxcXFxkKykoPzpbZUVdWy0rXT9cXFxcZCspPyknO1xuZmFicmljLmNvbW1hV3NwID0gJyg/OlxcXFxzKyw/XFxcXHMqfCxcXFxccyopJztcbmZhYnJpYy5yZVBhdGhDb21tYW5kID0gLyhbLStdPygoXFxkK1xcLlxcZCspfCgoXFxkKyl8KFxcLlxcZCspKSkoPzpbZUVdWy0rXT9cXGQrKT8pL2lnO1xuZmFicmljLnJlTm9uV29yZCA9IC9bIFxcblxcLiw7IVxcP1xcLV0vO1xuZmFicmljLmZvbnRQYXRocyA9IHsgfTtcbmZhYnJpYy5pTWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuZmFicmljLnN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuLyoqXG4gKiBQaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMuIDFNcHggLCA0TXB4IHNob3VsZCBiZSBmaW5lLlxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsID0gMjA5NzE1MjtcblxuLyoqXG4gKiBQaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMgd2lkdGggb3IgaGVpZ2h0LiBJRSBmaXhlcyB0aGUgbWF4aW11bSBhdCA1MDAwXG4gKiBAc2luY2UgMS43LjE0XG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5tYXhDYWNoZVNpZGVMaW1pdCA9IDQwOTY7XG5cbi8qKlxuICogTG93ZXN0IHBpeGVsIGxpbWl0IGZvciBjYWNoZSBjYW52YXNlcywgc2V0IGF0IDI1NlBYXG4gKiBAc2luY2UgMS43LjE0XG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCA9IDI1NjtcblxuLyoqXG4gKiBDYWNoZSBPYmplY3QgZm9yIHdpZHRocyBvZiBjaGFycyBpbiB0ZXh0IHJlbmRlcmluZy5cbiAqL1xuZmFicmljLmNoYXJXaWR0aHNDYWNoZSA9IHsgfTtcblxuLyoqXG4gKiBpZiB3ZWJnbCBpcyBlbmFibGVkIGFuZCBhdmFpbGFibGUsIHRleHR1cmVTaXplIHdpbGwgZGV0ZXJtaW5lIHRoZSBzaXplXG4gKiBvZiB0aGUgY2FudmFzIGJhY2tlbmRcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMudGV4dHVyZVNpemUgPSAyMDQ4O1xuXG4vKipcbiAqIFdoZW4gJ3RydWUnLCBzdHlsZSBpbmZvcm1hdGlvbiBpcyBub3QgcmV0YWluZWQgd2hlbiBjb3B5L3Bhc3RpbmcgdGV4dCwgbWFraW5nXG4gKiBwYXN0ZWQgdGV4dCB1c2UgZGVzdGluYXRpb24gc3R5bGUuXG4gKiBEZWZhdWx0cyB0byAnZmFsc2UnLlxuICogQHR5cGUgQm9vbGVhblxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEVuYWJsZSB3ZWJnbCBmb3IgZmlsdGVyaW5nIHBpY3R1cmUgaXMgYXZhaWxhYmxlXG4gKiBBIGZpbHRlcmluZyBiYWNrZW5kIHdpbGwgYmUgaW5pdGlhbGl6ZWQsIHRoaXMgd2lsbCBib3RoIHRha2UgbWVtb3J5IGFuZFxuICogdGltZSBzaW5jZSBhIGRlZmF1bHQgMjA0OHgyMDQ4IGNhbnZhcyB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZSBnbCBjb250ZXh0XG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5lbmFibGVHTEZpbHRlcmluZyA9IHRydWU7XG5cbi8qKlxuICogRGV2aWNlIFBpeGVsIFJhdGlvXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9IVE1MLWNhbnZhcy1ndWlkZS9TZXR0aW5nVXB0aGVDYW52YXMvU2V0dGluZ1VwdGhlQ2FudmFzLmh0bWxcbiAqL1xuZmFicmljLmRldmljZVBpeGVsUmF0aW8gPSBmYWJyaWMud2luZG93LmRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXREZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubW96RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAxO1xuLyoqXG4gKiBCcm93c2VyLXNwZWNpZmljIGNvbnN0YW50IHRvIGFkanVzdCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuc2hhZG93Qmx1ciB2YWx1ZSxcbiAqIHdoaWNoIGlzIHVuaXRsZXNzIGFuZCBub3QgcmVuZGVyZWQgZXF1YWxseSBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogVmFsdWVzIHRoYXQgd29yayBxdWl0ZSB3ZWxsIChhcyBvZiBPY3RvYmVyIDIwMTcpIGFyZTpcbiAqIC0gQ2hyb21lOiAxLjVcbiAqIC0gRWRnZTogMS43NVxuICogLSBGaXJlZm94OiAwLjlcbiAqIC0gU2FmYXJpOiAwLjk1XG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0IDFcbiAqL1xuZmFicmljLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgPSAxO1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgYXJjIHRvIGJlemllciBjb252ZXJzaW9uIGZvciBmYXN0ZXIgcmV0cmlldmluZyBpZiB0aGUgc2FtZSBhcmMgbmVlZHMgdG8gYmUgY29udmVydGVkIGFnYWluLlxuICogSXQgd2FzIGFuIGludGVybmFsIHZhcmlhYmxlLCBpcyBhY2Nlc3NpYmxlIHNpbmNlIHZlcnNpb24gMi4zLjRcbiAqL1xuZmFicmljLmFyY1RvU2VnbWVudHNDYWNoZSA9IHsgfTtcblxuLyoqXG4gKiBUaGlzIG9iamVjdCBrZWVwcyB0aGUgcmVzdWx0cyBvZiB0aGUgYm91bmRzT2ZDdXJ2ZSBjYWxjdWxhdGlvbiBtYXBwZWQgYnkgdGhlIGpvaW5lZCBhcmd1bWVudHMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSBpdC5cbiAqIEl0IGRvZXMgc3BlZWQgdXAgY2FsY3VsYXRpb24sIGlmIHlvdSBwYXJzZSBhbmQgYWRkIGFsd2F5cyB0aGUgc2FtZSBwYXRocywgYnV0IGluIGNhc2Ugb2YgaGVhdnkgdXNhZ2Ugb2YgZnJlZWRyYXdpbmdcbiAqIHlvdSBkbyBub3QgZ2V0IGFueSBzcGVlZCBiZW5lZml0IGFuZCB5b3UgZ2V0IGEgYmlnIG9iamVjdCBpbiBtZW1vcnkuXG4gKiBUaGUgb2JqZWN0IHdhcyBhIHByaXZhdGUgdmFyaWFibGUgYmVmb3JlLCB3aGlsZSBub3cgaXMgYXBwZW5kZWQgdG8gdGhlIGxpYiBzbyB0aGF0IHlvdSBoYXZlIGFjY2VzcyB0byBpdCBhbmQgeW91XG4gKiBjYW4gZXZlbnR1YWxseSBjbGVhciBpdC5cbiAqIEl0IHdhcyBhbiBpbnRlcm5hbCB2YXJpYWJsZSwgaXMgYWNjZXNzaWJsZSBzaW5jZSB2ZXJzaW9uIDIuMy40XG4gKi9cbmZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogSWYgZGlzYWJsZWQgYm91bmRzT2ZDdXJ2ZUNhY2hlIGlzIG5vdCB1c2VkLiBGb3IgYXBwcyB0aGF0IG1ha2UgaGVhdnkgdXNhZ2Ugb2YgcGVuY2lsIGRyYXdpbmcgcHJvYmFibHkgZGlzYWJsaW5nIGl0IGlzIGJldHRlclxuICogQGRlZmF1bHQgdHJ1ZVxuICovXG5mYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSA9IHRydWU7XG5cbi8qKlxuICogU2tpcCBwZXJmb3JtYW5jZSB0ZXN0aW5nIG9mIHNldHVwR0xDb250ZXh0IGFuZCBmb3JjZSB0aGUgdXNlIG9mIHB1dEltYWdlRGF0YSB0aGF0IHNlZW1zIHRvIGJlIHRoZSBvbmUgdGhhdCB3b3JrcyBiZXN0IG9uXG4gKiBDaHJvbWUgKyBvbGQgaGFyZHdhcmUuIGlmIHlvdXIgdXNlcnMgYXJlIGV4cGVyaWVuY2luZyBlbXB0eSBpbWFnZXMgYWZ0ZXIgZmlsdGVyaW5nIHlvdSBtYXkgdHJ5IHRvIGZvcmNlIHRoaXMgdG8gdHJ1ZVxuICogdGhpcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBpbnN0YW50aWF0aW5nIHRoZSBmaWx0ZXJpbmcgYmFja2VuZCAoIGJlZm9yZSBmaWx0ZXJpbmcgdGhlIGZpcnN0IGltYWdlIClcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbmZhYnJpYy5mb3JjZUdMUHV0SW1hZ2VEYXRhID0gZmFsc2U7XG5cbmZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoZmFicmljLmVuYWJsZUdMRmlsdGVyaW5nICYmIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkICYmIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkKGZhYnJpYy50ZXh0dXJlU2l6ZSkpIHtcbiAgICBjb25zb2xlLmxvZygnbWF4IHRleHR1cmUgc2l6ZTogJyArIGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSk7XG4gICAgcmV0dXJuIChuZXcgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZCh7IHRpbGVTaXplOiBmYWJyaWMudGV4dHVyZVNpemUgfSkpO1xuICB9XG4gIGVsc2UgaWYgKGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQpIHtcbiAgICByZXR1cm4gKG5ldyBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKCkpO1xuICB9XG59O1xuXG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIGVuc3VyZSBnbG9iYWxpdHkgZXZlbiBpZiBlbnRpcmUgbGlicmFyeSB3ZXJlIGZ1bmN0aW9uIHdyYXBwZWQgKGFzIGluIE1ldGVvci5qcyBwYWNrYWdpbmcgc3lzdGVtKVxuICB3aW5kb3cuZmFicmljID0gZmFicmljO1xufVxuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBldmVudExpc3RlbmVyID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGV2ZW50TGlzdGVuZXJbZXZlbnRMaXN0ZW5lci5pbmRleE9mKGhhbmRsZXIpXSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy51dGlsLmFycmF5LmZpbGwoZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlcyBzcGVjaWZpZWQgZXZlbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvblxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzID0geyB9O1xuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGV2ZW50IG9ic2VydmluZyBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IGhhbmRsZXIuIENhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogd2l0aG91dCBhcmd1bWVudHMgcmVtb3ZlcyBhbGwgaGFuZGxlcnMgZm9yIGFsbCBldmVudHNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvZmZcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRvIGJlIGRlbGV0ZWQgZnJvbSBFdmVudExpc3RlbmVyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBrZXkvdmFsdWUgcGFpcnMgKGV2ZW50IG5hbWUgLT4gZXZlbnQgaGFuZGxlcilcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChldmVudE5hbWUgaW4gdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGZpcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnNGb3JFdmVudCA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmICghbGlzdGVuZXJzRm9yRXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNGb3JFdmVudC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGlzdGVuZXJzRm9yRXZlbnRbaV0gJiYgbGlzdGVuZXJzRm9yRXZlbnRbaV0uY2FsbCh0aGlzLCBvcHRpb25zIHx8IHsgfSk7XG4gICAgfVxuICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gbGlzdGVuZXJzRm9yRXZlbnQuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLk9ic2VydmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjZXZlbnRzfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2V2ZW50c3xFdmVudHMgZGVtb31cbiAgICovXG4gIGZhYnJpYy5PYnNlcnZhYmxlID0ge1xuICAgIGZpcmU6IGZpcmUsXG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkNvbGxlY3Rpb25cbiAqL1xuZmFicmljLkNvbGxlY3Rpb24gPSB7XG5cbiAgX29iamVjdHM6IFtdLFxuXG4gIC8qKlxuICAgKiBBZGRzIG9iamVjdHMgdG8gY29sbGVjdGlvbiwgQ2FudmFzIG9yIEdyb3VwLCB0aGVuIHJlbmRlcnMgY2FudmFzXG4gICAqIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKS5cbiAgICogaW4gY2FzZSBvZiBHcm91cCBubyBjaGFuZ2VzIHRvIGJvdW5kaW5nIGJveCBhcmUgbWFkZS5cbiAgICogT2JqZWN0cyBzaG91bGQgYmUgaW5zdGFuY2VzIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogVXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGZvciBncm91cHMuXG4gICAqIHlvdSBjYW4gYWRkIGEgYnVuY2ggb2Ygb2JqZWN0cyB3aXRoIHRoZSBhZGQgbWV0aG9kIGJ1dCB0aGVuIHlvdSBORUVEXG4gICAqIHRvIHJ1biBhIGFkZFdpdGhVcGRhdGUgY2FsbCBmb3IgdGhlIEdyb3VwIGNsYXNzIG9yIHBvc2l0aW9uL2Jib3ggd2lsbCBiZSB3cm9uZy5cbiAgICogQHBhcmFtIHsuLi5mYWJyaWMuT2JqZWN0fSBvYmplY3QgWmVybyBvciBtb3JlIGZhYnJpYyBpbnN0YW5jZXNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9vYmplY3RzLnB1c2guYXBwbHkodGhpcy5fb2JqZWN0cywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fb25PYmplY3RBZGRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9vbk9iamVjdEFkZGVkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gb2JqZWN0IGludG8gY29sbGVjdGlvbiBhdCBzcGVjaWZpZWQgaW5kZXgsIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEFuIG9iamVjdCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgKG9yIGluaGVyaXQgZnJvbSkgZmFicmljLk9iamVjdFxuICAgKiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyBoaWdobHkgZGlzY291cmFnZWQgZm9yIGdyb3Vwcy5cbiAgICogeW91IGNhbiBhZGQgYSBidW5jaCBvZiBvYmplY3RzIHdpdGggdGhlIGluc2VydEF0IG1ldGhvZCBidXQgdGhlbiB5b3UgTkVFRFxuICAgKiB0byBydW4gYSBhZGRXaXRoVXBkYXRlIGNhbGwgZm9yIHRoZSBHcm91cCBjbGFzcyBvciBwb3NpdGlvbi9iYm94IHdpbGwgYmUgd3JvbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gaW5zZXJ0IG9iamVjdCBhdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vblNwbGljaW5nIFdoZW4gYHRydWVgLCBubyBzcGxpY2luZyAoc2hpZnRpbmcpIG9mIG9iamVjdHMgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgaW5zZXJ0QXQ6IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCBub25TcGxpY2luZykge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICBpZiAobm9uU3BsaWNpbmcpIHtcbiAgICAgIG9iamVjdHNbaW5kZXhdID0gb2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgIH1cbiAgICB0aGlzLl9vbk9iamVjdEFkZGVkICYmIHRoaXMuX29uT2JqZWN0QWRkZWQob2JqZWN0KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG9iamVjdHMgZnJvbSBhIGNvbGxlY3Rpb24sIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgIGluZGV4LCBzb21ldGhpbmdSZW1vdmVkID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihhcmd1bWVudHNbaV0pO1xuXG4gICAgICAvLyBvbmx5IGNhbGwgb25PYmplY3RSZW1vdmVkIGlmIGFuIG9iamVjdCB3YXMgYWN0dWFsbHkgcmVtb3ZlZFxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBzb21ldGhpbmdSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLl9vbk9iamVjdFJlbW92ZWQgJiYgdGhpcy5fb25PYmplY3RSZW1vdmVkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiBzb21ldGhpbmdSZW1vdmVkICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBvYmplY3QgaW4gdGhpcyBncm91cFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpbnZva2VkIHdpdGggY3VycmVudCBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQsXG4gICAqICAgICAgICAgICAgICAgICAgIGluZGV4IC0gYXMgc2Vjb25kIGFuZCBhbiBhcnJheSBvZiBhbGwgb2JqZWN0cyAtIGFzIHRoaXJkLlxuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpcyBpbnZva2VkIGluIGEgY29udGV4dCBvZiBHbG9iYWwgT2JqZWN0IChlLmcuIGB3aW5kb3dgKVxuICAgKiAgICAgICAgICAgICAgICAgICB3aGVuIG5vIGBjb250ZXh0YCBhcmd1bWVudCBpcyBnaXZlblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBDb250ZXh0IChha2EgdGhpc09iamVjdClcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmb3JFYWNoT2JqZWN0OiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0c1tpXSwgaSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgb2YgdGhpcyBpbnN0YW5jZVxuICAgKiBUeXBlIHBhcmFtZXRlciBpbnRyb2R1Y2VkIGluIDEuMy4xMFxuICAgKiBzaW5jZSAyLjMuNSB0aGlzIG1ldGhvZCByZXR1cm4gYWx3YXlzIGEgQ09QWSBvZiB0aGUgYXJyYXk7XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gV2hlbiBzcGVjaWZpZWQsIG9ubHkgb2JqZWN0cyBvZiB0aGlzIHR5cGUgYXJlIHJldHVybmVkXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZ2V0T2JqZWN0czogZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmNvbmNhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIG8udHlwZSA9PT0gdHlwZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgYXQgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqL1xuICBpdGVtOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0c1tpbmRleF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIG9iamVjdHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMubGVuZ3RoID09PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2l6ZSBvZiBhIGNvbGxlY3Rpb24gKGkuZTogbGVuZ3RoIG9mIGFuIGFycmF5IGNvbnRhaW5pbmcgaXRzIG9iamVjdHMpXG4gICAqIEByZXR1cm4ge051bWJlcn0gQ29sbGVjdGlvbiBzaXplXG4gICAqL1xuICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjaGVjayBhZ2FpbnN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIGFuIG9iamVjdFxuICAgKi9cbiAgY29udGFpbnM6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhIGNvbGxlY3Rpb24gY29tcGxleGl0eVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICovXG4gIGNvbXBsZXhpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGN1cnJlbnQpIHtcbiAgICAgIG1lbW8gKz0gY3VycmVudC5jb21wbGV4aXR5ID8gY3VycmVudC5jb21wbGV4aXR5KCkgOiAwO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db21tb25NZXRob2RzXG4gKi9cbmZhYnJpYy5Db21tb25NZXRob2RzID0ge1xuXG4gIC8qKlxuICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIF9zZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldChwcm9wLCBvcHRpb25zW3Byb3BdKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIEdyYWRpZW50IHRvXG4gICAqL1xuICBfaW5pdEdyYWRpZW50OiBmdW5jdGlvbihmaWxsZXIsIHByb3BlcnR5KSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuY29sb3JTdG9wcyAmJiAhKGZpbGxlciBpbnN0YW5jZW9mIGZhYnJpYy5HcmFkaWVudCkpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLkdyYWRpZW50KGZpbGxlcikpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmaWxsZXJdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIHByb3BlcnR5IHRvIHNldCB0aGUgUGF0dGVybiB0b1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciBwYXR0ZXJuIGxvYWRcbiAgICovXG4gIF9pbml0UGF0dGVybjogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZmlsbGVyICYmIGZpbGxlci5zb3VyY2UgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuUGF0dGVybikpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLlBhdHRlcm4oZmlsbGVyLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIHRoaXMuX3NldChwcm9wLCBvYmpbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9zZXRPYmplY3Qoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogVG9nZ2xlcyBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBgdHJ1ZWAgdG8gYGZhbHNlYCBvciBmcm9tIGBmYWxzZWAgdG8gYHRydWVgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byB0b2dnbGVcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICB0b2dnbGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQocHJvcGVydHkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksICF2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCYXNpYyBnZXR0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7Kn0gdmFsdWUgb2YgYSBwcm9wZXJ0eVxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XTtcbiAgfVxufTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICAgIFBpQnkxODAgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgUGlCeTIgPSBNYXRoLlBJIC8gMjtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbFxuICAgKi9cbiAgZmFicmljLnV0aWwgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvcyBvZiBhbiBhbmdsZSwgYXZvaWRpbmcgcmV0dXJuaW5nIGZsb2F0cyBmb3Iga25vd24gcmVzdWx0c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb3IgaW4gZGVncmVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGNvczogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAvLyBjb3MoYSkgPSBjb3MoLWEpXG4gICAgICAgIGFuZ2xlID0gLWFuZ2xlO1xuICAgICAgfVxuICAgICAgdmFyIGFuZ2xlU2xpY2UgPSBhbmdsZSAvIFBpQnkyO1xuICAgICAgc3dpdGNoIChhbmdsZVNsaWNlKSB7XG4gICAgICAgIGNhc2UgMTogY2FzZSAzOiByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5jb3MoYW5nbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNpbiBvZiBhbiBhbmdsZSwgYXZvaWRpbmcgcmV0dXJuaW5nIGZsb2F0cyBmb3Iga25vd24gcmVzdWx0c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb3IgaW4gZGVncmVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHNpbjogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkgeyByZXR1cm4gMDsgfVxuICAgICAgdmFyIGFuZ2xlU2xpY2UgPSBhbmdsZSAvIFBpQnkyLCBzaWduID0gMTtcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gc2luKC1hKSA9IC1zaW4oYSlcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhbmdsZVNsaWNlKSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIHNpZ247XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIC1zaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc2luKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgICAqIFByZXNlbmNlIG9mIHZhbHVlIChhbmQgaXRzIHBvc2l0aW9uIGluIGFuIGFycmF5KSBpcyBkZXRlcm1pbmVkIHZpYSBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvcmlnaW5hbCBhcnJheVxuICAgICAqL1xuICAgIHJlbW92ZUZyb21BcnJheTogZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgaWR4ID0gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBhcnJheS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByYW5kb20gbnVtYmVyIGJldHdlZW4gMiBzcGVjaWZpZWQgb25lcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBsb3dlciBsaW1pdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggdXBwZXIgbGltaXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJhbmRvbSB2YWx1ZSAoYmV0d2VlbiBtaW4gYW5kIG1heClcbiAgICAgKi9cbiAgICBnZXRSYW5kb21JbnQ6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWVzIHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICBkZWdyZWVzVG9SYWRpYW5zOiBmdW5jdGlvbihkZWdyZWVzKSB7XG4gICAgICByZXR1cm4gZGVncmVlcyAqIFBpQnkxODA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgcmFkaWFucyB0byBkZWdyZWVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICovXG4gICAgcmFkaWFuc1RvRGVncmVlczogZnVuY3Rpb24ocmFkaWFucykge1xuICAgICAgcmV0dXJuIHJhZGlhbnMgLyBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGBwb2ludGAgYXJvdW5kIGBvcmlnaW5gIHdpdGggYHJhZGlhbnNgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IG9yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIFRoZSByYWRpYW5zIG9mIHRoZSBhbmdsZSBmb3IgdGhlIHJvdGF0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBUaGUgbmV3IHJvdGF0ZWQgcG9pbnRcbiAgICAgKi9cbiAgICByb3RhdGVQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpbiwgcmFkaWFucykge1xuICAgICAgcG9pbnQuc3VidHJhY3RFcXVhbHMob3JpZ2luKTtcbiAgICAgIHZhciB2ID0gZmFicmljLnV0aWwucm90YXRlVmVjdG9yKHBvaW50LCByYWRpYW5zKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHYueCwgdi55KS5hZGRFcXVhbHMob3JpZ2luKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgdmVjdG9yYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmVjdG9yIFRoZSB2ZWN0b3IgdG8gcm90YXRlICh4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIFRoZSByYWRpYW5zIG9mIHRoZSBhbmdsZSBmb3IgdGhlIHJvdGF0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IHJvdGF0ZWQgcG9pbnRcbiAgICAgKi9cbiAgICByb3RhdGVWZWN0b3I6IGZ1bmN0aW9uKHZlY3RvciwgcmFkaWFucykge1xuICAgICAgdmFyIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWRpYW5zKSxcbiAgICAgICAgICBjb3MgPSBmYWJyaWMudXRpbC5jb3MocmFkaWFucyksXG4gICAgICAgICAgcnggPSB2ZWN0b3IueCAqIGNvcyAtIHZlY3Rvci55ICogc2luLFxuICAgICAgICAgIHJ5ID0gdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJ4LFxuICAgICAgICB5OiByeVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdHJhbnNmb3JtIHQgdG8gcG9pbnQgcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuUG9pbnR9IHAgVGhlIHBvaW50IHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSAge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbaWdub3JlT2Zmc2V0XSBJbmRpY2F0ZXMgdGhhdCB0aGUgb2Zmc2V0IHNob3VsZCBub3QgYmUgYXBwbGllZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIHRyYW5zZm9ybWVkIHBvaW50XG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHAsIHQsIGlnbm9yZU9mZnNldCkge1xuICAgICAgaWYgKGlnbm9yZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSxcbiAgICAgICAgICB0WzFdICogcC54ICsgdFszXSAqIHAueVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIHRbMF0gKiBwLnggKyB0WzJdICogcC55ICsgdFs0XSxcbiAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnkgKyB0WzVdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIHBvaW50cydzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyA0IHBvaW50cyBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2Zvcm1dIGFuIGFycmF5IG9mIDYgbnVtYmVycyByZXByZXNlbnRpbmcgYSAyeDMgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBtYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzOiBmdW5jdGlvbihwb2ludHMsIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBvaW50c1tpXSA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHBvaW50c1tpXSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHhQb2ludHMgPSBbcG9pbnRzWzBdLngsIHBvaW50c1sxXS54LCBwb2ludHNbMl0ueCwgcG9pbnRzWzNdLnhdLFxuICAgICAgICAgIG1pblggPSBmYWJyaWMudXRpbC5hcnJheS5taW4oeFBvaW50cyksXG4gICAgICAgICAgbWF4WCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCh4UG9pbnRzKSxcbiAgICAgICAgICB3aWR0aCA9IG1heFggLSBtaW5YLFxuICAgICAgICAgIHlQb2ludHMgPSBbcG9pbnRzWzBdLnksIHBvaW50c1sxXS55LCBwb2ludHNbMl0ueSwgcG9pbnRzWzNdLnldLFxuICAgICAgICAgIG1pblkgPSBmYWJyaWMudXRpbC5hcnJheS5taW4oeVBvaW50cyksXG4gICAgICAgICAgbWF4WSA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCh5UG9pbnRzKSxcbiAgICAgICAgICBoZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgdHJhbnNmb3JtYXRpb24gdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGludmVydGVkIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGludmVydFRyYW5zZm9ybTogZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGEgPSAxIC8gKHRbMF0gKiB0WzNdIC0gdFsxXSAqIHRbMl0pLFxuICAgICAgICAgIHIgPSBbYSAqIHRbM10sIC1hICogdFsxXSwgLWEgKiB0WzJdLCBhICogdFswXV0sXG4gICAgICAgICAgbyA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHsgeDogdFs0XSwgeTogdFs1XSB9LCByLCB0cnVlKTtcbiAgICAgIHJbNF0gPSAtby54O1xuICAgICAgcls1XSA9IC1vLnk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGFyb3VuZCBOdW1iZXIjdG9GaXhlZCwgd2hpY2ggY29udHJhcnkgdG8gbmF0aXZlIG1ldGhvZCByZXR1cm5zIG51bWJlciwgbm90IHN0cmluZy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBudW1iZXIgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJhY3Rpb25EaWdpdHMgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byBcImxlYXZlXCJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdG9GaXhlZDogZnVuY3Rpb24obnVtYmVyLCBmcmFjdGlvbkRpZ2l0cykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoTnVtYmVyKG51bWJlcikudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBmcm9tIGF0dHJpYnV0ZSB2YWx1ZSB0byBwaXhlbCB2YWx1ZSBpZiBhcHBsaWNhYmxlLlxuICAgICAqIFJldHVybnMgY29udmVydGVkIHBpeGVscyBvciBvcmlnaW5hbCB2YWx1ZSBub3QgY29udmVydGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZm9udFNpemVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVW5pdDogZnVuY3Rpb24odmFsdWUsIGZvbnRTaXplKSB7XG4gICAgICB2YXIgdW5pdCA9IC9cXER7MCwyfSQvLmV4ZWModmFsdWUpLFxuICAgICAgICAgIG51bWJlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKCFmb250U2l6ZSkge1xuICAgICAgICBmb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodW5pdFswXSkge1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyAyNS40O1xuXG4gICAgICAgIGNhc2UgJ2NtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDIuNTQ7XG5cbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJO1xuXG4gICAgICAgIGNhc2UgJ3B0JzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDcyOyAvLyBvciAqIDQgLyAzXG5cbiAgICAgICAgY2FzZSAncGMnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzIgKiAxMjsgLy8gb3IgKiAxNlxuXG4gICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZm9udFNpemU7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZhbHNlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGtsYXNzIFwiQ2xhc3NcIiBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBvYmplY3QgKGVnLiAnY2lyY2xlJylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSB0byBnZXQga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBmcm9tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBrbGFzcyBcIkNsYXNzXCJcbiAgICAgKi9cbiAgICBnZXRLbGFzczogZnVuY3Rpb24odHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAvLyBjYXBpdGFsaXplIGZpcnN0IGxldHRlciBvbmx5XG4gICAgICB0eXBlID0gZmFicmljLnV0aWwuc3RyaW5nLmNhbWVsaXplKHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSlbdHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgYXR0cmlidXRlcyBmb3IgZ2l2ZW4gc3ZnIHRoYXQgZmFicmljIHBhcnNlc1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2Ygc3ZnIGVsZW1lbnQgKGVnLiAnY2lyY2xlJylcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc3RyaW5nIG5hbWVzIG9mIHN1cHBvcnRlZCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0U3ZnQXR0cmlidXRlczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdpbnN0YW50aWF0ZWRfYnlfdXNlJyxcbiAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ2NsYXNzJ1xuICAgICAgXTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdsaW5lYXJHcmFkaWVudCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsneDEnLCAneTEnLCAneDInLCAneTInLCAnZ3JhZGllbnRVbml0cycsICdncmFkaWVudFRyYW5zZm9ybSddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmFkaWFsR3JhZGllbnQnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ2dyYWRpZW50VW5pdHMnLCAnZ3JhZGllbnRUcmFuc2Zvcm0nLCAnY3gnLCAnY3knLCAncicsICdmeCcsICdmeScsICdmciddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RvcCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsnb2Zmc2V0JywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IG9mIGdpdmVuIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHN0cmluZyBlLmcuICdmYWJyaWMuSW1hZ2UuZmlsdGVyJyBvciAnZmFicmljJ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGZvciBnaXZlbiBuYW1lc3BhY2UgKGRlZmF1bHQgZmFicmljKVxuICAgICAqL1xuICAgIHJlc29sdmVOYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRzID0gbmFtZXNwYWNlLnNwbGl0KCcuJyksXG4gICAgICAgICAgbGVuID0gcGFydHMubGVuZ3RoLCBpLFxuICAgICAgICAgIG9iaiA9IGdsb2JhbCB8fCBmYWJyaWMud2luZG93O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgb2JqID0gb2JqW3BhcnRzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgaW1hZ2UgZWxlbWVudCBmcm9tIGdpdmVuIHVybCBhbmQgcGFzc2VzIGl0IHRvIGEgY2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCByZXByZXNlbnRpbmcgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjazsgaW52b2tlZCB3aXRoIGxvYWRlZCBpbWFnZVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIENvbnRleHQgdG8gaW52b2tlIGNhbGxiYWNrIGluXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgdG8gc2V0IGltYWdlIGVsZW1lbnQgdG9cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2U6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGNvbnRleHQsIGNyb3NzT3JpZ2luKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHVybCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZyA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICB2YXIgb25Mb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaW1nLCBmYWxzZSk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBpbWcub25sb2FkID0gb25Mb2FkQ2FsbGJhY2s7XG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmFicmljLmxvZygnRXJyb3IgbG9hZGluZyAnICsgaW1nLnNyYyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvLyBkYXRhLXVybHMgYXBwZWFyIHRvIGJlIGJ1Z2d5IHdpdGggY3Jvc3NPcmlnaW5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL2NvbW1pdC9kMGFiYjkwZjFjZDVjNWVmOWQyYTk0ZDNmYjIxYTIyMzMwZGEzZTBhI2NvbW1pdGNvbW1lbnQtNDUxMzc2N1xuICAgICAgLy8gc2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zMTUxNTJcbiAgICAgIC8vICAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MzUwNjlcbiAgICAgIC8vIGNyb3NzT3JpZ2luIG51bGwgaXMgdGhlIHNhbWUgYXMgbm90IHNldC5cbiAgICAgIGlmICh1cmwuaW5kZXhPZignZGF0YScpICE9PSAwICYmXG4gICAgICAgIGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICB9XG5cbiAgICAgIC8vIElFMTAgLyBJRTExLUZpeDogU1ZHIGNvbnRlbnRzIGZyb20gZGF0YTogVVJJXG4gICAgICAvLyB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBJTUcgaXMgcHJlc2VudFxuICAgICAgLy8gaW4gdGhlIERPTSAoYW5kIHZpc2libGUpXG4gICAgICBpZiAodXJsLnN1YnN0cmluZygwLDE0KSA9PT0gJ2RhdGE6aW1hZ2Uvc3ZnJykge1xuICAgICAgICBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlSW5Eb20oaW1nLCBvbkxvYWRDYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIFNWRyBpbWFnZSB3aXRoIGRhdGE6IFVSTCB0byB0aGUgZG9tXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltZyBJbWFnZSBvYmplY3Qgd2l0aCBkYXRhOmltYWdlL3N2ZyBzcmNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjazsgaW52b2tlZCB3aXRoIGxvYWRlZCBpbWFnZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gRE9NIGVsZW1lbnQgKGRpdiBjb250YWluaW5nIHRoZSBTVkcgaW1hZ2UpXG4gICAgICovXG4gICAgbG9hZEltYWdlSW5Eb206IGZ1bmN0aW9uKGltZywgb25Mb2FkQ2FsbGJhY2spIHtcbiAgICAgIHZhciBkaXYgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG4gICAgICBkaXYuc3R5bGUubGVmdCA9IGRpdi5zdHlsZS50b3AgPSAnLTEwMCUnO1xuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgZmFicmljLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGluIGZ1bmN0aW9uIHRvOlxuICAgICAgICogICAxLiBDYWxsIGV4aXN0aW5nIGNhbGxiYWNrXG4gICAgICAgKiAgIDIuIENsZWFudXAgRE9NXG4gICAgICAgKi9cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uTG9hZENhbGxiYWNrKCk7XG4gICAgICAgIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIGRpdiA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvcnJlc3BvbmRpbmcgZmFicmljIGluc3RhbmNlcyBmcm9tIHRoZWlyIG9iamVjdCByZXByZXNlbnRhdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXZpdmVyIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIG9iamVjdCBlbGVtZW50cyxcbiAgICAgKiBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgZW5saXZlbk9iamVjdHM6IGZ1bmN0aW9uKG9iamVjdHMsIGNhbGxiYWNrLCBuYW1lc3BhY2UsIHJldml2ZXIpIHtcbiAgICAgIG9iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuXG4gICAgICB2YXIgZW5saXZlbmVkT2JqZWN0cyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZE9iamVjdHMgPSAwLFxuICAgICAgICAgIG51bVRvdGFsT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkxvYWRlZCgpIHtcbiAgICAgICAgaWYgKCsrbnVtTG9hZGVkT2JqZWN0cyA9PT0gbnVtVG90YWxPYmplY3RzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHVuZGVmaW5lZCBvYmplY3RzIChvYmplY3RzIHRoYXQgZ2F2ZSBlcnJvcilcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbnVtVG90YWxPYmplY3RzKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAobywgaW5kZXgpIHtcbiAgICAgICAgLy8gaWYgc3BhcnNlIGFycmF5XG4gICAgICAgIGlmICghbyB8fCAhby50eXBlKSB7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtsYXNzID0gZmFicmljLnV0aWwuZ2V0S2xhc3Moby50eXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICBrbGFzcy5mcm9tT2JqZWN0KG8sIGZ1bmN0aW9uIChvYmosIGVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgfHwgKGVubGl2ZW5lZE9iamVjdHNbaW5kZXhdID0gb2JqKTtcbiAgICAgICAgICByZXZpdmVyICYmIHJldml2ZXIobywgb2JqLCBlcnJvcik7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCB3YWl0IGZvciBsb2FkaW5nIG9mIHBhdHRlcm5zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdHRlcm5zIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIGVubGl2ZW5QYXR0ZXJuczogZnVuY3Rpb24ocGF0dGVybnMsIGNhbGxiYWNrKSB7XG4gICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zIHx8IFtdO1xuXG4gICAgICBmdW5jdGlvbiBvbkxvYWRlZCgpIHtcbiAgICAgICAgaWYgKCsrbnVtTG9hZGVkUGF0dGVybnMgPT09IG51bVBhdHRlcm5zKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmxpdmVuZWRQYXR0ZXJucyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZFBhdHRlcm5zID0gMCxcbiAgICAgICAgICBudW1QYXR0ZXJucyA9IHBhdHRlcm5zLmxlbmd0aDtcblxuICAgICAgaWYgKCFudW1QYXR0ZXJucykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRQYXR0ZXJucyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGF0dGVybnMuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHAgJiYgcC5zb3VyY2UpIHtcbiAgICAgICAgICBuZXcgZmFicmljLlBhdHRlcm4ocCwgZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgICAgICAgZW5saXZlbmVkUGF0dGVybnNbaW5kZXhdID0gcGF0dGVybjtcbiAgICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZW5saXZlbmVkUGF0dGVybnNbaW5kZXhdID0gcDtcbiAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIFNWRyBlbGVtZW50cyAodXN1YWxseSB0aG9zZSByZXRyaWV2ZWQgZnJvbSBTVkcgZG9jdW1lbnQpXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIFNWRyBlbGVtZW50cyB0byBncm91cFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBWYWx1ZSB0byBzZXQgc291cmNlUGF0aCB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R8ZmFicmljLkdyb3VwfVxuICAgICAqL1xuICAgIGdyb3VwU1ZHRWxlbWVudHM6IGZ1bmN0aW9uKGVsZW1lbnRzLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICB2YXIgb2JqZWN0O1xuICAgICAgaWYgKGVsZW1lbnRzICYmIGVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudHNbMF07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCkge1xuICAgICAgICAgIG9wdGlvbnMuY2VudGVyUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBvcHRpb25zLndpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IG9wdGlvbnMuaGVpZ2h0IC8gMlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMud2lkdGg7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBuZXcgZmFicmljLkdyb3VwKGVsZW1lbnRzLCBvcHRpb25zKTtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LnNvdXJjZVBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGVzIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBwcm9wZXJ0aWVzIFByb3BlcnRpZXMgbmFtZXMgdG8gaW5jbHVkZVxuICAgICAqL1xuICAgIHBvcHVsYXRlV2l0aFByb3BlcnRpZXM6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24sIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9wZXJ0aWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2ldIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydGllc1tpXV0gPSBzb3VyY2VbcHJvcGVydGllc1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgZGFzaGVkIGxpbmUgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRyYXcgZGFzaGVkIGxpbmUgYXJvdW5kIHNlbGVjdGlvbiBhcmVhLlxuICAgICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NTc2NzI0L2RvdHRlZC1zdHJva2UtaW4tY2FudmFzXCI+ZG90dGVkIHN0cm9rZSBpbiBjYW52YXM8L2E+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAgc3RhcnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgc3RhcnQgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIGVuZCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTIgZW5kIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhIGRhc2ggYXJyYXkgcGF0dGVyblxuICAgICAqL1xuICAgIGRyYXdEYXNoZWRMaW5lOiBmdW5jdGlvbihjdHgsIHgsIHksIHgyLCB5MiwgZGEpIHtcbiAgICAgIHZhciBkeCA9IHgyIC0geCxcbiAgICAgICAgICBkeSA9IHkyIC0geSxcbiAgICAgICAgICBsZW4gPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KSxcbiAgICAgICAgICByb3QgPSBhdGFuMihkeSwgZHgpLFxuICAgICAgICAgIGRjID0gZGEubGVuZ3RoLFxuICAgICAgICAgIGRpID0gMCxcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgY3R4LnJvdGF0ZShyb3QpO1xuXG4gICAgICB4ID0gMDtcbiAgICAgIHdoaWxlIChsZW4gPiB4KSB7XG4gICAgICAgIHggKz0gZGFbZGkrKyAlIGRjXTtcbiAgICAgICAgaWYgKHggPiBsZW4pIHtcbiAgICAgICAgICB4ID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGN0eFtkcmF3ID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10oeCwgMCk7XG4gICAgICAgIGRyYXcgPSAhZHJhdztcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjYW52YXMgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtDYW52YXNFbGVtZW50fSBpbml0aWFsaXplZCBjYW52YXMgZWxlbWVudFxuICAgICAqL1xuICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhcyBlbGVtZW50IHRoYXQgaXMgYSBjb3B5IG9mIGFub3RoZXIgYW5kIGlzIGFsc28gcGFpbnRlZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzRWxlbWVudH0gY2FudmFzIHRvIGNvcHkgc2l6ZSBhbmQgY29udGVudCBvZlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtDYW52YXNFbGVtZW50fSBpbml0aWFsaXplZCBjYW52YXMgZWxlbWVudFxuICAgICAqL1xuICAgIGNvcHlDYW52YXNFbGVtZW50OiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHZhciBuZXdDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBuZXdDYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICBuZXdDYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgIG5ld0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgICAgcmV0dXJuIG5ld0NhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2luY2UgMi42LjAgbW92ZWQgZnJvbSBjYW52YXMgaW5zdGFuY2UgdG8gdXRpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VsZW1lbnR9IGNhbnZhc0VsIHRvIGNvcHkgc2l6ZSBhbmQgY29udGVudCBvZlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgJ2pwZWcnIG9yICdwbmcnLCBpbiBzb21lIGJyb3dzZXJzICd3ZWJwJyBpcyBvayB0b29cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSA8PSAxIGFuZCA+IDBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBkYXRhIHVybFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY2FudmFzRWwsIGZvcm1hdCwgcXVhbGl0eSkge1xuICAgICAgcmV0dXJuIGNhbnZhc0VsLnRvRGF0YVVSTCgnaW1hZ2UvJyArIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW1hZ2UgZWxlbWVudCAod29ya3Mgb24gY2xpZW50IGFuZCBub2RlKVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIGltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSBtYXRyaXggQSBieSBtYXRyaXggQiB0byBuZXN0IHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYSBGaXJzdCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYiBTZWNvbmQgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXMyeDIgZmxhZyB0byBtdWx0aXBseSBtYXRyaWNlcyBhcyAyeDIgbWF0cmljZXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHByb2R1Y3Qgb2YgdGhlIHR3byB0cmFuc2Zvcm0gbWF0cmljZXNcbiAgICAgKi9cbiAgICBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzOiBmdW5jdGlvbihhLCBiLCBpczJ4Mikge1xuICAgICAgLy8gTWF0cml4IG11bHRpcGx5IGEgKiBiXG4gICAgICByZXR1cm4gW1xuICAgICAgICBhWzBdICogYlswXSArIGFbMl0gKiBiWzFdLFxuICAgICAgICBhWzFdICogYlswXSArIGFbM10gKiBiWzFdLFxuICAgICAgICBhWzBdICogYlsyXSArIGFbMl0gKiBiWzNdLFxuICAgICAgICBhWzFdICogYlsyXSArIGFbM10gKiBiWzNdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzBdICogYls0XSArIGFbMl0gKiBiWzVdICsgYVs0XSxcbiAgICAgICAgaXMyeDIgPyAwIDogYVsxXSAqIGJbNF0gKyBhWzNdICogYls1XSArIGFbNV1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgc3RhbmRhcmQgMngzIG1hdHJpeCBpbnRvIHRyYW5zZm9ybSBjb21wb25lbnRzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29tcG9uZW50cyBvZiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBxckRlY29tcG9zZTogZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGFuZ2xlID0gYXRhbjIoYVsxXSwgYVswXSksXG4gICAgICAgICAgZGVub20gPSBwb3coYVswXSwgMikgKyBwb3coYVsxXSwgMiksXG4gICAgICAgICAgc2NhbGVYID0gc3FydChkZW5vbSksXG4gICAgICAgICAgc2NhbGVZID0gKGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV0pIC8gc2NhbGVYLFxuICAgICAgICAgIHNrZXdYID0gYXRhbjIoYVswXSAqIGFbMl0gKyBhWzFdICogYSBbM10sIGRlbm9tKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFuZ2xlOiBhbmdsZSAvIFBpQnkxODAsXG4gICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgc2tld1g6IHNrZXdYIC8gUGlCeTE4MCxcbiAgICAgICAgc2tld1k6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVg6IGFbNF0sXG4gICAgICAgIHRyYW5zbGF0ZVk6IGFbNV1cbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmFuc2Zvcm0gbWF0cml4IHN0YXJ0aW5nIGZyb20gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIGtpbmQgb2ZcbiAgICAgKiB0aGUgb25lIHJldHVybmVkIGZyb20gcXJEZWNvbXBvc2UsIHVzZWZ1bCBhbHNvIGlmIHlvdSB3YW50IHRvIGNhbGN1bGF0ZSBzb21lXG4gICAgICogdHJhbnNmb3JtYXRpb25zIGZyb20gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGVubGl2ZWQgeWV0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIGNhbGNSb3RhdGVNYXRyaXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy5hbmdsZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgICB9XG4gICAgICB2YXIgdGhldGEgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuYW5nbGUpLFxuICAgICAgICAgIGNvcyA9IGZhYnJpYy51dGlsLmNvcyh0aGV0YSksXG4gICAgICAgICAgc2luID0gZmFicmljLnV0aWwuc2luKHRoZXRhKTtcbiAgICAgIHJldHVybiBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmFuc2Zvcm0gbWF0cml4IHN0YXJ0aW5nIGZyb20gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIGtpbmQgb2ZcbiAgICAgKiB0aGUgb25lIHJldHVybmVkIGZyb20gcXJEZWNvbXBvc2UsIHVzZWZ1bCBhbHNvIGlmIHlvdSB3YW50IHRvIGNhbGN1bGF0ZSBzb21lXG4gICAgICogdHJhbnNmb3JtYXRpb25zIGZyb20gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGVubGl2ZWQgeWV0LlxuICAgICAqIGlzIGNhbGxlZCBEaW1lbnNpb25zVHJhbnNmb3JtTWF0cml4IGJlY2F1c2UgdGhvc2UgcHJvcGVydGllcyBhcmUgdGhlIG9uZSB0aGF0IGluZmx1ZW5jZVxuICAgICAqIHRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgYm94IG9mIHRoZSBvYmplY3QuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVZXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBYXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBZXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIGNhbGNEaW1lbnNpb25zTWF0cml4OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc2NhbGVYID0gdHlwZW9mIG9wdGlvbnMuc2NhbGVYID09PSAndW5kZWZpbmVkJyA/IDEgOiBvcHRpb25zLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVkgPSB0eXBlb2Ygb3B0aW9ucy5zY2FsZVkgPT09ICd1bmRlZmluZWQnID8gMSA6IG9wdGlvbnMuc2NhbGVZLFxuICAgICAgICAgIHNjYWxlTWF0cml4ID0gW1xuICAgICAgICAgICAgb3B0aW9ucy5mbGlwWCA/IC1zY2FsZVggOiBzY2FsZVgsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmxpcFkgPyAtc2NhbGVZIDogc2NhbGVZLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBdLFxuICAgICAgICAgIG11bHRpcGx5ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcbiAgICAgICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucztcbiAgICAgIGlmIChvcHRpb25zLnNrZXdYKSB7XG4gICAgICAgIHNjYWxlTWF0cml4ID0gbXVsdGlwbHkoXG4gICAgICAgICAgc2NhbGVNYXRyaXgsXG4gICAgICAgICAgWzEsIDAsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5za2V3WCkpLCAxXSxcbiAgICAgICAgICB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNrZXdZKSB7XG4gICAgICAgIHNjYWxlTWF0cml4ID0gbXVsdGlwbHkoXG4gICAgICAgICAgc2NhbGVNYXRyaXgsXG4gICAgICAgICAgWzEsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5za2V3WSkpLCAwLCAxXSxcbiAgICAgICAgICB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FsZU1hdHJpeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWV1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWF1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWV1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy50cmFuc2xhdGVYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMudHJhbnNsYXRlWV1cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIGNvbXBvc2VNYXRyaXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtYXRyaXggPSBbMSwgMCwgMCwgMSwgb3B0aW9ucy50cmFuc2xhdGVYIHx8IDAsIG9wdGlvbnMudHJhbnNsYXRlWSB8fCAwXSxcbiAgICAgICAgICBtdWx0aXBseSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXM7XG4gICAgICBpZiAob3B0aW9ucy5hbmdsZSkge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseShtYXRyaXgsIGZhYnJpYy51dGlsLmNhbGNSb3RhdGVNYXRyaXgob3B0aW9ucykpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2NhbGVYICE9PSAxIHx8IG9wdGlvbnMuc2NhbGVZICE9PSAxIHx8XG4gICAgICAgICAgb3B0aW9ucy5za2V3WCB8fCBvcHRpb25zLnNrZXdZIHx8IG9wdGlvbnMuZmxpcFggfHwgb3B0aW9ucy5mbGlwWSkge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseShtYXRyaXgsIGZhYnJpYy51dGlsLmNhbGNEaW1lbnNpb25zTWF0cml4KG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0IGFuIG9iamVjdCB0cmFuc2Zvcm0gc3RhdGUgdG8gbmV1dHJhbC4gVG9wIGFuZCBsZWZ0IGFyZSBub3QgYWNjb3VudGVkIGZvclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRvIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHJlc2V0T2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuc2NhbGVYID0gMTtcbiAgICAgIHRhcmdldC5zY2FsZVkgPSAxO1xuICAgICAgdGFyZ2V0LnNrZXdYID0gMDtcbiAgICAgIHRhcmdldC5za2V3WSA9IDA7XG4gICAgICB0YXJnZXQuZmxpcFggPSBmYWxzZTtcbiAgICAgIHRhcmdldC5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LnJvdGF0ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBPYmplY3QgdHJhbnNmb3JtIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRvIHJlYWQgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29tcG9uZW50cyBvZiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBzYXZlT2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGFyZ2V0LnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgYW5nbGU6IHRhcmdldC5hbmdsZSxcbiAgICAgICAgbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgIGZsaXBYOiB0YXJnZXQuZmxpcFgsXG4gICAgICAgIGZsaXBZOiB0YXJnZXQuZmxpcFksXG4gICAgICAgIHRvcDogdGFyZ2V0LnRvcFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGNvbnRleHQgaGFzIHRyYW5zcGFyZW50IHBpeGVsXG4gICAgICogYXQgc3BlY2lmaWVkIGxvY2F0aW9uICh0YWtpbmcgdG9sZXJhbmNlIGludG8gYWNjb3VudClcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZVxuICAgICAqL1xuICAgIGlzVHJhbnNwYXJlbnQ6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgdG9sZXJhbmNlKSB7XG5cbiAgICAgIC8vIElmIHRvbGVyYW5jZSBpcyA+IDAgYWRqdXN0IHN0YXJ0IGNvb3JkcyB0byB0YWtlIGludG8gYWNjb3VudC5cbiAgICAgIC8vIElmIG1vdmVzIG9mZiBDYW52YXMgZml4IHRvIDBcbiAgICAgIGlmICh0b2xlcmFuY2UgPiAwKSB7XG4gICAgICAgIGlmICh4ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgeCAtPSB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICB5IC09IHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX2lzVHJhbnNwYXJlbnQgPSB0cnVlLCBpLCB0ZW1wLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgKHRvbGVyYW5jZSAqIDIpIHx8IDEsICh0b2xlcmFuY2UgKiAyKSB8fCAxKSxcbiAgICAgICAgICBsID0gaW1hZ2VEYXRhLmRhdGEubGVuZ3RoO1xuXG4gICAgICAvLyBTcGxpdCBpbWFnZSBkYXRhIC0gZm9yIHRvbGVyYW5jZSA+IDEsIHBpeGVsRGF0YVNpemUgPSA0O1xuICAgICAgZm9yIChpID0gMzsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICB0ZW1wID0gaW1hZ2VEYXRhLmRhdGFbaV07XG4gICAgICAgIF9pc1RyYW5zcGFyZW50ID0gdGVtcCA8PSAwO1xuICAgICAgICBpZiAoX2lzVHJhbnNwYXJlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7IC8vIFN0b3AgaWYgY29sb3VyIGZvdW5kXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW1hZ2VEYXRhID0gbnVsbDtcblxuICAgICAgcmV0dXJuIF9pc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIGF0dHJpYnV0ZSBmcm9tIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIHRvIGJlIHBhcnNlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxpZ24gYW5kIG1lZXRPclNsaWNlIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZTogZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICB2YXIgbWVldE9yU2xpY2UgPSAnbWVldCcsIGFsaWduWCA9ICdNaWQnLCBhbGlnblkgPSAnTWlkJyxcbiAgICAgICAgICBhc3BlY3RSYXRpb0F0dHJzID0gYXR0cmlidXRlLnNwbGl0KCcgJyksIGFsaWduO1xuXG4gICAgICBpZiAoYXNwZWN0UmF0aW9BdHRycyAmJiBhc3BlY3RSYXRpb0F0dHJzLmxlbmd0aCkge1xuICAgICAgICBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvQXR0cnMucG9wKCk7XG4gICAgICAgIGlmIChtZWV0T3JTbGljZSAhPT0gJ21lZXQnICYmIG1lZXRPclNsaWNlICE9PSAnc2xpY2UnKSB7XG4gICAgICAgICAgYWxpZ24gPSBtZWV0T3JTbGljZTtcbiAgICAgICAgICBtZWV0T3JTbGljZSA9ICdtZWV0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3BlY3RSYXRpb0F0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIGFsaWduID0gYXNwZWN0UmF0aW9BdHRycy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9kaXZpZGUgYWxpZ24gaW4gYWxpZ25YIGFuZCBhbGlnbllcbiAgICAgIGFsaWduWCA9IGFsaWduICE9PSAnbm9uZScgPyBhbGlnbi5zbGljZSgxLCA0KSA6ICdub25lJztcbiAgICAgIGFsaWduWSA9IGFsaWduICE9PSAnbm9uZScgPyBhbGlnbi5zbGljZSg1LCA4KSA6ICdub25lJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZXRPclNsaWNlOiBtZWV0T3JTbGljZSxcbiAgICAgICAgYWxpZ25YOiBhbGlnblgsXG4gICAgICAgIGFsaWduWTogYWxpZ25ZXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBjaGFyIHdpZHRocyBjYWNoZSBmb3IgdGhlIGdpdmVuIGZvbnQgZmFtaWx5IG9yIGFsbCB0aGUgY2FjaGUgaWYgbm9cbiAgICAgKiBmb250RmFtaWx5IGlzIHNwZWNpZmllZC5cbiAgICAgKiBVc2UgaXQgaWYgeW91IGtub3cgeW91IGFyZSBsb2FkaW5nIGZvbnRzIGluIGEgbGF6eSB3YXkgYW5kIHlvdSBhcmUgbm90IHdhaXRpbmdcbiAgICAgKiBmb3IgY3VzdG9tIGZvbnRzIHRvIGxvYWQgcHJvcGVybHkgd2hlbiBhZGRpbmcgdGV4dCBvYmplY3RzIHRvIHRoZSBjYW52YXMuXG4gICAgICogSWYgYSB0ZXh0IG9iamVjdCBpcyBhZGRlZCB3aGVuIGl0cyBvd24gZm9udCBpcyBub3QgbG9hZGVkIHlldCwgeW91IHdpbGwgZ2V0IHdyb25nXG4gICAgICogbWVhc3VyZW1lbnQgYW5kIHNvIHdyb25nIGJvdW5kaW5nIGJveGVzLlxuICAgICAqIEFmdGVyIHRoZSBmb250IGNhY2hlIGlzIGNsZWFyZWQsIGVpdGhlciBjaGFuZ2UgdGhlIHRleHRPYmplY3QgdGV4dCBjb250ZW50IG9yIGNhbGxcbiAgICAgKiBpbml0RGltZW5zaW9ucygpIHRvIHRyaWdnZXIgYSByZWNhbGN1bGF0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtmb250RmFtaWx5XSBmb250IGZhbWlseSB0byBjbGVhclxuICAgICAqL1xuICAgIGNsZWFyRmFicmljRm9udENhY2hlOiBmdW5jdGlvbihmb250RmFtaWx5KSB7XG4gICAgICBmb250RmFtaWx5ID0gKGZvbnRGYW1pbHkgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWZvbnRGYW1pbHkpIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGN1cnJlbnQgYXNwZWN0IHJhdGlvLCBkZXRlcm1pbmVzIHRoZSBtYXggd2lkdGggYW5kIGhlaWdodCB0aGF0IGNhblxuICAgICAqIHJlc3BlY3QgdGhlIHRvdGFsIGFsbG93ZWQgYXJlYSBmb3IgdGhlIGNhY2hlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhciBhc3BlY3QgcmF0aW9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4aW11bUFyZWEgTWF4aW11bSBhcmVhIHlvdSB3YW50IHRvIGFjaGlldmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueH0gTGltaXRlZCBkaW1lbnNpb25zIGJ5IFhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueX0gTGltaXRlZCBkaW1lbnNpb25zIGJ5IFlcbiAgICAgKi9cbiAgICBsaW1pdERpbXNCeUFyZWE6IGZ1bmN0aW9uKGFyLCBtYXhpbXVtQXJlYSkge1xuICAgICAgdmFyIHJvdWdoV2lkdGggPSBNYXRoLnNxcnQobWF4aW11bUFyZWEgKiBhciksXG4gICAgICAgICAgcGVyZkxpbWl0U2l6ZVkgPSBNYXRoLmZsb29yKG1heGltdW1BcmVhIC8gcm91Z2hXaWR0aCk7XG4gICAgICByZXR1cm4geyB4OiBNYXRoLmZsb29yKHJvdWdoV2lkdGgpLCB5OiBwZXJmTGltaXRTaXplWSB9O1xuICAgIH0sXG5cbiAgICBjYXBWYWx1ZTogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzY2FsZSBmb3IgdGhlIG9iamVjdCBzb3VyY2UgdG8gZml0IGluc2lkZSB0aGUgb2JqZWN0IGRlc3RpbmF0aW9uLFxuICAgICAqIGtlZXBpbmcgYXNwZWN0IHJhdGlvIGludGFjdC5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2UuaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24uaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24ud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZSBmYWN0b3IgdG8gYXBwbHkgdG8gc291cmNlIHRvIGZpdCBpbnRvIGRlc3RpbmF0aW9uXG4gICAgICovXG4gICAgZmluZFNjYWxlVG9GaXQ6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihkZXN0aW5hdGlvbi53aWR0aCAvIHNvdXJjZS53aWR0aCwgZGVzdGluYXRpb24uaGVpZ2h0IC8gc291cmNlLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzY2FsZSBmb3IgdGhlIG9iamVjdCBzb3VyY2UgdG8gY292ZXIgZW50aXJlbHkgdGhlIG9iamVjdCBkZXN0aW5hdGlvbixcbiAgICAgKiBrZWVwaW5nIGFzcGVjdCByYXRpbyBpbnRhY3QuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IGRlc3RpbmF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGUgZmFjdG9yIHRvIGFwcGx5IHRvIHNvdXJjZSB0byBjb3ZlciBkZXN0aW5hdGlvblxuICAgICAqL1xuICAgIGZpbmRTY2FsZVRvQ292ZXI6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChkZXN0aW5hdGlvbi53aWR0aCAvIHNvdXJjZS53aWR0aCwgZGVzdGluYXRpb24uaGVpZ2h0IC8gc291cmNlLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGFuIGFycmF5IG9mIDYgbnVtYmVyIHJldHVybnMgc29tZXRoaW5nIGxpa2UgYFwibWF0cml4KC4uLm51bWJlcnMpXCJgXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIGFuIGFycmF5IHdpdGggNiBudW1iZXJzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0cmFuc2Zvcm0gbWF0cml4IGZvciBzdmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueX0gTGltaXRlZCBkaW1lbnNpb25zIGJ5IFlcbiAgICAgKi9cbiAgICBtYXRyaXhUb1NWRzogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gJ21hdHJpeCgnICsgdHJhbnNmb3JtLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLnV0aWwudG9GaXhlZCh2YWx1ZSwgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTKTtcbiAgICAgIH0pLmpvaW4oJyAnKSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYSB3aWR0aCBhbmQgaGVpZ2h0LCByZXR1cm4gdGhlIHNpemUgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgICAqIHRoYXQgY2FuIGNvbnRhaW5zIHRoZSBib3ggd2l0aCB3aWR0aC9oZWlnaHQgd2l0aCBhcHBsaWVkIHRyYW5zZm9ybVxuICAgICAqIGRlc2NyaWJlZCBpbiBvcHRpb25zLlxuICAgICAqIFVzZSB0byBjYWxjdWxhdGUgdGhlIGJveGVzIGFyb3VuZCBvYmplY3RzIGZvciBjb250cm9scy5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zY2FsZVlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5za2V3WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNrZXdZXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnh9IHdpZHRoIG9mIGNvbnRhaW5pbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueX0gaGVpZ2h0IG9mIGNvbnRhaW5pbmdcbiAgICAgKi9cbiAgICBzaXplQWZ0ZXJUcmFuc2Zvcm06IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkaW1YID0gd2lkdGggLyAyLCBkaW1ZID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB0cmFuc2Zvcm1NYXRyaXggPSBmYWJyaWMudXRpbC5jYWxjRGltZW5zaW9uc01hdHJpeChvcHRpb25zKSxcbiAgICAgICAgICBiYm94ID0gZmFicmljLnV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYm94LndpZHRoLFxuICAgICAgICB5OiBiYm94LmhlaWdodCxcbiAgICAgIH07XG4gICAgfVxuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIF9qb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW4sXG4gICAgICBjb21tYW5kTGVuZ3RocyA9IHtcbiAgICAgICAgbTogMixcbiAgICAgICAgbDogMixcbiAgICAgICAgaDogMSxcbiAgICAgICAgdjogMSxcbiAgICAgICAgYzogNixcbiAgICAgICAgczogNCxcbiAgICAgICAgcTogNCxcbiAgICAgICAgdDogMixcbiAgICAgICAgYTogN1xuICAgICAgfSxcbiAgICAgIHJlcGVhdGVkQ29tbWFuZHMgPSB7XG4gICAgICAgIG06ICdsJyxcbiAgICAgICAgTTogJ0wnXG4gICAgICB9O1xuICBmdW5jdGlvbiBzZWdtZW50VG9CZXppZXIodGgyLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSkge1xuICAgIHZhciBjb3N0aDIgPSBmYWJyaWMudXRpbC5jb3ModGgyKSxcbiAgICAgICAgc2ludGgyID0gZmFicmljLnV0aWwuc2luKHRoMiksXG4gICAgICAgIGNvc3RoMyA9IGZhYnJpYy51dGlsLmNvcyh0aDMpLFxuICAgICAgICBzaW50aDMgPSBmYWJyaWMudXRpbC5zaW4odGgzKSxcbiAgICAgICAgdG9YID0gY29zVGggKiByeCAqIGNvc3RoMyAtIHNpblRoICogcnkgKiBzaW50aDMgKyBjeDEsXG4gICAgICAgIHRvWSA9IHNpblRoICogcnggKiBjb3N0aDMgKyBjb3NUaCAqIHJ5ICogc2ludGgzICsgY3kxLFxuICAgICAgICBjcDFYID0gZnJvbVggKyBtVCAqICggLWNvc1RoICogcnggKiBzaW50aDIgLSBzaW5UaCAqIHJ5ICogY29zdGgyKSxcbiAgICAgICAgY3AxWSA9IGZyb21ZICsgbVQgKiAoIC1zaW5UaCAqIHJ4ICogc2ludGgyICsgY29zVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMlggPSB0b1ggKyBtVCAqICggY29zVGggKiByeCAqIHNpbnRoMyArIHNpblRoICogcnkgKiBjb3N0aDMpLFxuICAgICAgICBjcDJZID0gdG9ZICsgbVQgKiAoIHNpblRoICogcnggKiBzaW50aDMgLSBjb3NUaCAqIHJ5ICogY29zdGgzKTtcblxuICAgIHJldHVybiBbJ0MnLFxuICAgICAgY3AxWCwgY3AxWSxcbiAgICAgIGNwMlgsIGNwMlksXG4gICAgICB0b1gsIHRvWVxuICAgIF07XG4gIH1cblxuICAvKiBBZGFwdGVkIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhLWNlbnRyYWwvc291cmNlL2NvbnRlbnQvc3ZnL2NvbnRlbnQvc3JjL25zU1ZHUGF0aERhdGFQYXJzZXIuY3BwXG4gICAqIGJ5IEFuZHJlYSBCb2dhenppIGNvZGUgaXMgdW5kZXIgTVBMLiBpZiB5b3UgZG9uJ3QgaGF2ZSBhIGNvcHkgb2YgdGhlIGxpY2Vuc2UgeW91IGNhbiB0YWtlIGl0IGhlcmVcbiAgICogaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvXG4gICAqL1xuICBmdW5jdGlvbiBhcmNUb1NlZ21lbnRzKHRvWCwgdG9ZLCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCkge1xuICAgIHZhciBQSSA9IE1hdGguUEksIHRoID0gcm90YXRlWCAqIFBJIC8gMTgwLFxuICAgICAgICBzaW5UaCA9IGZhYnJpYy51dGlsLnNpbih0aCksXG4gICAgICAgIGNvc1RoID0gZmFicmljLnV0aWwuY29zKHRoKSxcbiAgICAgICAgZnJvbVggPSAwLCBmcm9tWSA9IDA7XG5cbiAgICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICAgIHZhciBweCA9IC1jb3NUaCAqIHRvWCAqIDAuNSAtIHNpblRoICogdG9ZICogMC41LFxuICAgICAgICBweSA9IC1jb3NUaCAqIHRvWSAqIDAuNSArIHNpblRoICogdG9YICogMC41LFxuICAgICAgICByeDIgPSByeCAqIHJ4LCByeTIgPSByeSAqIHJ5LCBweTIgPSBweSAqIHB5LCBweDIgPSBweCAqIHB4LFxuICAgICAgICBwbCA9IHJ4MiAqIHJ5MiAtIHJ4MiAqIHB5MiAtIHJ5MiAqIHB4MixcbiAgICAgICAgcm9vdCA9IDA7XG5cbiAgICBpZiAocGwgPCAwKSB7XG4gICAgICB2YXIgcyA9IE1hdGguc3FydCgxIC0gcGwgLyAocngyICogcnkyKSk7XG4gICAgICByeCAqPSBzO1xuICAgICAgcnkgKj0gcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByb290ID0gKGxhcmdlID09PSBzd2VlcCA/IC0xLjAgOiAxLjApICpcbiAgICAgICAgICAgICAgTWF0aC5zcXJ0KCBwbCAvIChyeDIgKiBweTIgKyByeTIgKiBweDIpKTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSByb290ICogcnggKiBweSAvIHJ5LFxuICAgICAgICBjeSA9IC1yb290ICogcnkgKiBweCAvIHJ4LFxuICAgICAgICBjeDEgPSBjb3NUaCAqIGN4IC0gc2luVGggKiBjeSArIHRvWCAqIDAuNSxcbiAgICAgICAgY3kxID0gc2luVGggKiBjeCArIGNvc1RoICogY3kgKyB0b1kgKiAwLjUsXG4gICAgICAgIG1UaGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgxLCAwLCAocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnkpLFxuICAgICAgICBkdGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5LCAoLXB4IC0gY3gpIC8gcngsICgtcHkgLSBjeSkgLyByeSk7XG5cbiAgICBpZiAoc3dlZXAgPT09IDAgJiYgZHRoZXRhID4gMCkge1xuICAgICAgZHRoZXRhIC09IDIgKiBQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3dlZXAgPT09IDEgJiYgZHRoZXRhIDwgMCkge1xuICAgICAgZHRoZXRhICs9IDIgKiBQSTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gY3ViaWMgYmV6aWVyIHNlZ21lbnRzIDw9IDkwZGVnXG4gICAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKGR0aGV0YSAvIFBJICogMikpLFxuICAgICAgICByZXN1bHQgPSBbXSwgbURlbHRhID0gZHRoZXRhIC8gc2VnbWVudHMsXG4gICAgICAgIG1UID0gOCAvIDMgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAqIE1hdGguc2luKG1EZWx0YSAvIDQpIC8gTWF0aC5zaW4obURlbHRhIC8gMiksXG4gICAgICAgIHRoMyA9IG1UaGV0YSArIG1EZWx0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gc2VnbWVudFRvQmV6aWVyKG1UaGV0YSwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpO1xuICAgICAgZnJvbVggPSByZXN1bHRbaV1bNV07XG4gICAgICBmcm9tWSA9IHJlc3VsdFtpXVs2XTtcbiAgICAgIG1UaGV0YSA9IHRoMztcbiAgICAgIHRoMyArPSBtRGVsdGE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKlxuICAgKiBQcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjVmVjdG9yQW5nbGUodXgsIHV5LCB2eCwgdnkpIHtcbiAgICB2YXIgdGEgPSBNYXRoLmF0YW4yKHV5LCB1eCksXG4gICAgICAgIHRiID0gTWF0aC5hdGFuMih2eSwgdngpO1xuICAgIGlmICh0YiA+PSB0YSkge1xuICAgICAgcmV0dXJuIHRiIC0gdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIDIgKiBNYXRoLlBJIC0gKHRhIC0gdGIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgYmV6aWVyY3VydmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgwIHN0YXJ0aW5nIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgZmlyc3QgY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIHNlY29uZG8gY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIGVuZCBvZiBiZXppZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gICAqL1xuICAvLyB0YWtlbiBmcm9tIGh0dHA6Ly9qc2Jpbi5jb20vaXZvbWlxLzU2L2VkaXQgIG5vIGNyZWRpdHMgYXZhaWxhYmxlIGZvciB0aGF0LlxuICAvLyBUT0RPOiBjYW4gd2Ugbm9ybWFsaXplIHRoaXMgd2l0aCB0aGUgc3RhcnRpbmcgcG9pbnRzIHNldCBhdCAwIGFuZCB0aGVuIHRyYW5zbGF0ZWQgdGhlIGJib3g/XG4gIGZ1bmN0aW9uIGdldEJvdW5kc09mQ3VydmUoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIGFyZ3NTdHJpbmc7XG4gICAgaWYgKGZhYnJpYy5jYWNoZXNCb3VuZHNPZkN1cnZlKSB7XG4gICAgICBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICAgICAgaWYgKGZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10pIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgIG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIHR2YWx1ZXMgPSBbXSxcbiAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG5cbiAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzcXJ0YjJhYyA9IHNxcnQoYjJhYyk7XG4gICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgfVxuICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLCBqbGVuID0gaiwgbXQ7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgeCA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICAgIGJvdW5kc1swXVtqXSA9IHg7XG5cbiAgICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgICBib3VuZHNbMV1bal0gPSB5O1xuICAgIH1cblxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgIHtcbiAgICAgICAgeDogbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH1cbiAgICBdO1xuICAgIGlmIChmYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSkge1xuICAgICAgZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhcmMgdG8gYSBidW5jaCBvZiBiZXppZXIgY3VydmVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeCBzdGFydGluZyBwb2ludCB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeSBzdGFydGluZyBwb2ludCB5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkcyBBcmMgY29tbWFuZFxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbUFyY1RvQmV6aWVycyhmeCwgZnksIGNvb3Jkcykge1xuICAgIHZhciByeCA9IGNvb3Jkc1sxXSxcbiAgICAgICAgcnkgPSBjb29yZHNbMl0sXG4gICAgICAgIHJvdCA9IGNvb3Jkc1szXSxcbiAgICAgICAgbGFyZ2UgPSBjb29yZHNbNF0sXG4gICAgICAgIHN3ZWVwID0gY29vcmRzWzVdLFxuICAgICAgICB0eCA9IGNvb3Jkc1s2XSxcbiAgICAgICAgdHkgPSBjb29yZHNbN10sXG4gICAgICAgIHNlZ3NOb3JtID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzTm9ybS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2Vnc05vcm1baV1bMV0gKz0gZng7XG4gICAgICBzZWdzTm9ybVtpXVsyXSArPSBmeTtcbiAgICAgIHNlZ3NOb3JtW2ldWzNdICs9IGZ4O1xuICAgICAgc2Vnc05vcm1baV1bNF0gKz0gZnk7XG4gICAgICBzZWdzTm9ybVtpXVs1XSArPSBmeDtcbiAgICAgIHNlZ3NOb3JtW2ldWzZdICs9IGZ5O1xuICAgIH1cbiAgICByZXR1cm4gc2Vnc05vcm07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZSBhIHBhcnNlZCBTVkcgcGF0aCBhbmQgbWFrZSBpdCBzaW1wbGVyIGZvciBmYWJyaWNKUyBsb2dpYy5cbiAgICogc2ltcGxpZmljYXRpb24gY29uc2lzdCBvZjogb25seSBVUFBFUkNBU0UgYWJzb2x1dGUgY29tbWFuZHMgKCByZWxhdGl2ZSBjb252ZXJ0ZWQgdG8gYWJzb2x1dGUgKVxuICAgKiBTIGNvbnZlcnRlZCBpbiBDLCBUIGNvbnZlcnRlZCBpbiBRLCBBIGNvbnZlcnRlZCBpbiBDLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIHRoZSBhcnJheSBvZiBjb21tYW5kcyBvZiBhIHBhcnNlZCBzdmcgcGF0aCBmb3IgZmFicmljLlBhdGhcbiAgICogQHJldHVybiB7QXJyYXl9IHRoZSBzaW1wbGlmaWVkIGFycmF5IG9mIGNvbW1hbmRzIG9mIGEgcGFyc2VkIHN2ZyBwYXRoIGZvciBmYWJyaWMuUGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVBhdGhTaW1wbGVyKHBhdGgpIHtcbiAgICAvLyB4IGFuZCB5IHJlcHJlc2VudCB0aGUgbGFzdCBwb2ludCBvZiB0aGUgcGF0aC4gdGhlIHByZXZpb3VzIGNvbW1hbmQgcG9pbnQuXG4gICAgLy8gd2UgYWRkIHRoZW0gdG8gZWFjaCByZWxhdGl2ZSBjb21tYW5kIHRvIG1ha2UgaXQgYW4gYWJzb2x1dGUgY29tbWVudC5cbiAgICAvLyB3ZSBhbHNvIHN3YXAgdGhlIHYgViBoIEggd2l0aCBMLCBiZWNhdXNlIGFyZSBlYXNpZXIgdG8gdHJhbnNmb3JtLlxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGxlbiA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAvLyB4MSBhbmQgeTEgcmVwcmVzZW50IHRoZSBsYXN0IHBvaW50IG9mIHRoZSBzdWJwYXRoLiB0aGUgc3VicGF0aCBpcyBzdGFydGVkIHdpdGhcbiAgICAgICAgLy8gbSBvciBNIGNvbW1hbmQuIFdoZW4gYSB6IG9yIFogY29tbWFuZCBpcyBkcmF3biwgeCBhbmQgeSBuZWVkIHRvIGJlIHJlc2V0dGVkIHRvXG4gICAgICAgIC8vIHRoZSBsYXN0IHgxIGFuZCB5MS5cbiAgICAgICAgeDEgPSAwLCB5MSA9IDAsIGN1cnJlbnQsIGksIGNvbnZlcnRlZCxcbiAgICAgICAgLy8gcHJldmlvdXMgd2lsbCBob3N0IHRoZSBsZXR0ZXIgb2YgdGhlIHByZXZpb3VzIGNvbW1hbmQsIHRvIGhhbmRsZSBTIGFuZCBULlxuICAgICAgICAvLyBjb250cm9sWCBhbmQgY29udHJvbFkgd2lsbCBob3N0IHRoZSBwcmV2aW91cyByZWZsZWN0ZWQgY29udHJvbCBwb2ludFxuICAgICAgICBkZXN0aW5hdGlvblBhdGggPSBbXSwgcHJldmlvdXMsIGNvbnRyb2xYLCBjb250cm9sWTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgY3VycmVudCA9IHBhdGhbaV0uc2xpY2UoMCk7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG4gICAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdMJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0wnO1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSB5O1xuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTCc7XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgY3VycmVudFsxXSA9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSA9IHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdNJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkxID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdDJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbM10gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzRdICs9IHk7XG4gICAgICAgICAgY3VycmVudFs1XSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1MnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgY3VycmVudFszXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIC8vIHdvdWxkIGJlIHNTY0MgYnV0IHNpbmNlIHdlIGFyZSBzd2FwcGluZyBzU2MgZm9yIEMsIHdlIGNoZWNrIGp1c3QgdGhhdC5cbiAgICAgICAgICBpZiAocHJldmlvdXMgPT09ICdDJykge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBDLCBjLCBTLCBvciBzLFxuICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQyc7XG4gICAgICAgICAgY3VycmVudFs1XSA9IGN1cnJlbnRbM107XG4gICAgICAgICAgY3VycmVudFs2XSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgY3VycmVudFszXSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgY3VycmVudFs0XSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgY3VycmVudFsxXSA9IGNvbnRyb2xYO1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSBjb250cm9sWTtcbiAgICAgICAgICAvLyBjdXJyZW50WzNdIGFuZCBjdXJyZW50WzRdIGFyZSBOT1cgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICAgICAgIC8vIHdlIGtlZXAgaXQgZm9yIHRoZSBuZXh0IHJlZmxlY3Rpb24uXG4gICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdRJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbM10gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzRdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdUJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgaWYgKHByZXZpb3VzID09PSAnUScpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnUSc7XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgY3VycmVudFsxXSA9IGNvbnRyb2xYO1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSBjb250cm9sWTtcbiAgICAgICAgICBjdXJyZW50WzNdID0geDtcbiAgICAgICAgICBjdXJyZW50WzRdID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgY3VycmVudFswXSA9ICdBJztcbiAgICAgICAgICBjdXJyZW50WzZdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs3XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgY29udmVydGVkID0gdHJ1ZTtcbiAgICAgICAgICBkZXN0aW5hdGlvblBhdGggPSBkZXN0aW5hdGlvblBhdGguY29uY2F0KGZyb21BcmNUb0JlemllcnMoeCwgeSwgY3VycmVudCkpO1xuICAgICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgIHkgPSB5MTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICAgIGlmICghY29udmVydGVkKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uUGF0aC5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBjdXJyZW50WzBdO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdGluYXRpb25QYXRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjIGxlbmd0aCBmcm9tIHBvaW50IHgxLHkxIHRvIHgyLHkyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSBzdGFydGluZyBwb2ludCB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MSBzdGFydGluZyBwb2ludCB5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzdGFydGluZyBwb2ludCB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MiBzdGFydGluZyBwb2ludCB5XG4gICAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoIG9mIHNlZ21lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zIGZvciB0aGUgQ3ViaWMgYmVpemVyXG4gIC8vIHRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9rb252YWpzL2tvbnZhL2Jsb2IvNy4wLjUvc3JjL3NoYXBlcy9QYXRoLnRzI0wzNTBcbiAgZnVuY3Rpb24gQ0IxKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIGZ1bmN0aW9uIENCMih0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG4gIH1cbiAgZnVuY3Rpb24gQ0IzKHQpIHtcbiAgICByZXR1cm4gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgfVxuICBmdW5jdGlvbiBDQjQodCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uQ3ViaWNCZXppZXJJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCBwNHgsIHA0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwY3QpIHtcbiAgICAgIHZhciBjMSA9IENCMShwY3QpLCBjMiA9IENCMihwY3QpLCBjMyA9IENCMyhwY3QpLCBjNCA9IENCNChwY3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDR4ICogYzEgKyBwM3ggKiBjMiArIHAyeCAqIGMzICsgcDF4ICogYzQsXG4gICAgICAgIHk6IHA0eSAqIGMxICsgcDN5ICogYzIgKyBwMnkgKiBjMyArIHAxeSAqIGM0XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYW5nZW50Q3ViaWNJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCBwNHgsIHA0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGN0KSB7XG4gICAgICB2YXIgaW52VCA9IDEgLSBwY3QsXG4gICAgICAgICAgdGFuZ2VudFggPSAoMyAqIGludlQgKiBpbnZUICogKHAyeCAtIHAxeCkpICsgKDYgKiBpbnZUICogcGN0ICogKHAzeCAtIHAyeCkpICtcbiAgICAgICAgICAoMyAqIHBjdCAqIHBjdCAqIChwNHggLSBwM3gpKSxcbiAgICAgICAgICB0YW5nZW50WSA9ICgzICogaW52VCAqIGludlQgKiAocDJ5IC0gcDF5KSkgKyAoNiAqIGludlQgKiBwY3QgKiAocDN5IC0gcDJ5KSkgK1xuICAgICAgICAgICgzICogcGN0ICogcGN0ICogKHA0eSAtIHAzeSkpO1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGFuZ2VudFksIHRhbmdlbnRYKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gUUIxKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cblxuICBmdW5jdGlvbiBRQjIodCkge1xuICAgIHJldHVybiAyICogdCAqICgxIC0gdCk7XG4gIH1cblxuICBmdW5jdGlvbiBRQjModCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBvaW50T25RdWFkcmF0aWNCZXppZXJJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBjdCkge1xuICAgICAgdmFyIGMxID0gUUIxKHBjdCksIGMyID0gUUIyKHBjdCksIGMzID0gUUIzKHBjdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwM3ggKiBjMSArIHAyeCAqIGMyICsgcDF4ICogYzMsXG4gICAgICAgIHk6IHAzeSAqIGMxICsgcDJ5ICogYzIgKyBwMXkgKiBjM1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFuZ2VudFF1YWRyYXRpY0l0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBjdCkge1xuICAgICAgdmFyIGludlQgPSAxIC0gcGN0LFxuICAgICAgICAgIHRhbmdlbnRYID0gKDIgKiBpbnZUICogKHAyeCAtIHAxeCkpICsgKDIgKiBwY3QgKiAocDN4IC0gcDJ4KSksXG4gICAgICAgICAgdGFuZ2VudFkgPSAoMiAqIGludlQgKiAocDJ5IC0gcDF5KSkgKyAoMiAqIHBjdCAqIChwM3kgLSBwMnkpKTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRhbmdlbnRZLCB0YW5nZW50WCk7XG4gICAgfTtcbiAgfVxuXG5cbiAgLy8gdGhpcyB3aWxsIHJ1biBvdmVyIGEgcGF0aCBzZWdtZW50ICggYSBjdWJpYyBvciBxdWFkcmF0aWMgc2VnbWVudCkgYW5kIGFwcHJveGltYXRlIGl0XG4gIC8vIHdpdGggMTAwIHNlZ2VtbnRzLiBUaGlzIHdpbGwgZ29vZCBlbm91Z2ggdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIGN1cnZlXG4gIGZ1bmN0aW9uIHBhdGhJdGVyYXRvcihpdGVyYXRvciwgeDEsIHkxKSB7XG4gICAgdmFyIHRlbXBQID0geyB4OiB4MSwgeTogeTEgfSwgcCwgdG1wTGVuID0gMCwgcGVyYztcbiAgICBmb3IgKHBlcmMgPSAwLjAxOyBwZXJjIDw9IDE7IHBlcmMgKz0gMC4wMSkge1xuICAgICAgcCA9IGl0ZXJhdG9yKHBlcmMpO1xuICAgICAgdG1wTGVuICs9IGNhbGNMaW5lTGVuZ3RoKHRlbXBQLngsIHRlbXBQLnksIHAueCwgcC55KTtcbiAgICAgIHRlbXBQID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHRtcExlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHBhdGhJbmZvLCBhbmQgYSBkaXN0YW5jZSBpbiBwaXhlbHMsIGZpbmQgdGhlIHBlcmNlbnRhZ2UgZnJvbSAwIHRvIDFcbiAgICogdGhhdCBjb3JyZXNwb25kIHRvIHRoYXQgcGl4ZWxzIHJ1biBvdmVyIHRoZSBwYXRoLlxuICAgKiBUaGUgcGVyY2VudGFnZSB3aWxsIGJlIHRoZW4gdXNlZCB0byBmaW5kIHRoZSBjb3JyZWN0IHBvaW50IG9uIHRoZSBjYW52YXMgZm9yIHRoZSBwYXRoLlxuICAgKiBAcGFyYW0ge0FycmF5fSBzZWdJbmZvIGZhYnJpY0pTIGNvbGxlY3Rpb24gb2YgaW5mb3JtYXRpb24gb24gYSBwYXJzZWQgcGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgZnJvbSBzdGFydGluZyBwb2ludCwgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluZm8gb2JqZWN0IHdpdGggeCBhbmQgeSAoIHRoZSBwb2ludCBvbiBjYW52YXMgKSBhbmQgYW5nbGUsIHRoZSB0YW5nZW50IG9uIHRoYXQgcG9pbnQ7XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKSB7XG4gICAgdmFyIHBlcmMgPSAwLCB0bXBMZW4gPSAwLCBpdGVyYXRvciA9IHNlZ0luZm8uaXRlcmF0b3IsIHRlbXBQID0geyB4OiBzZWdJbmZvLngsIHk6IHNlZ0luZm8ueSB9LFxuICAgICAgICBwLCBuZXh0TGVuLCBuZXh0U3RlcCA9IDAuMDEsIGFuZ2xlRmluZGVyID0gc2VnSW5mby5hbmdsZUZpbmRlciwgbGFzdFBlcmM7XG4gICAgLy8gbmV4dFN0ZXAgPiAwLjAwMDEgY292ZXJzIDAuMDAwMTU2MjUgdGhhdCAxLzY0dGggb2YgMS8xMDBcbiAgICAvLyB0aGUgcGF0aFxuICAgIHdoaWxlICh0bXBMZW4gPCBkaXN0YW5jZSAmJiBwZXJjIDw9IDEgJiYgbmV4dFN0ZXAgPiAwLjAwMDEpIHtcbiAgICAgIHAgPSBpdGVyYXRvcihwZXJjKTtcbiAgICAgIGxhc3RQZXJjID0gcGVyYztcbiAgICAgIG5leHRMZW4gPSBjYWxjTGluZUxlbmd0aCh0ZW1wUC54LCB0ZW1wUC55LCBwLngsIHAueSk7XG4gICAgICAvLyBjb21wYXJlIHRtcExlbiBlYWNoIGN5Y2xlIHdpdGggZGlzdGFuY2UsIGRlY2lkZSBuZXh0IHBlcmMgdG8gdGVzdC5cbiAgICAgIGlmICgobmV4dExlbiArIHRtcExlbikgPiBkaXN0YW5jZSkge1xuICAgICAgICAvLyB3ZSBkaXNjYXJkIHRoaXMgc3RlcCBhbmQgd2UgbWFrZSBzbWFsbGVyIHN0ZXBzLlxuICAgICAgICBuZXh0U3RlcCAvPSAyO1xuICAgICAgICBwZXJjIC09IG5leHRTdGVwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRlbXBQID0gcDtcbiAgICAgICAgcGVyYyArPSBuZXh0U3RlcDtcbiAgICAgICAgdG1wTGVuICs9IG5leHRMZW47XG4gICAgICB9XG4gICAgfVxuICAgIHAuYW5nbGUgPSBhbmdsZUZpbmRlcihsYXN0UGVyYyk7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG92ZXIgYSBwYXJzZWQgYW5kIHNpbXBsaWZlZCBwYXRoIGFuZCBleHRyYWMgc29tZSBpbmZvcm1hdGlvbnMuXG4gICAqIGluZm9ybWF0aW9ucyBhcmUgbGVuZ3RoIG9mIGVhY2ggY29tbWFuZCBhbmQgc3RhcnRpbmcgcG9pbnRcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBmYWJyaWNKUyBwYXJzZWQgcGF0aCBjb21tYW5kc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gcGF0aCBjb21tYW5kcyBpbmZvcm1hdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFBhdGhTZWdtZW50c0luZm8ocGF0aCkge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IDAsIGxlbiA9IHBhdGgubGVuZ3RoLCBjdXJyZW50LFxuICAgICAgICAvL3gyIGFuZCB5MiBhcmUgdGhlIGNvb3JkcyBvZiBzZWdtZW50IHN0YXJ0XG4gICAgICAgIC8veDEgYW5kIHkxIGFyZSB0aGUgY29vcmRzIG9mIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgIHgxID0gMCwgeTEgPSAwLCB4MiA9IDAsIHkyID0gMCwgaW5mbyA9IFtdLCBpdGVyYXRvciwgdGVtcEluZm8sIGFuZ2xlRmluZGVyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuICAgICAgdGVtcEluZm8gPSB7XG4gICAgICAgIHg6IHgxLFxuICAgICAgICB5OiB5MSxcbiAgICAgICAgY29tbWFuZDogY3VycmVudFswXSxcbiAgICAgIH07XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy9maXJzdCBsZXR0ZXJcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gMDtcbiAgICAgICAgICB4MiA9IHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MiA9IHkxID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gY2FsY0xpbmVMZW5ndGgoeDEsIHkxLCBjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBpdGVyYXRvciA9IGdldFBvaW50T25DdWJpY0Jlemllckl0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICk7XG4gICAgICAgICAgYW5nbGVGaW5kZXIgPSBnZXRUYW5nZW50Q3ViaWNJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRlbXBJbmZvLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgICAgdGVtcEluZm8uYW5nbGVGaW5kZXIgPSBhbmdsZUZpbmRlcjtcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSk7XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzVdO1xuICAgICAgICAgIHkxID0gY3VycmVudFs2XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgaXRlcmF0b3IgPSBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVySXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICk7XG4gICAgICAgICAgYW5nbGVGaW5kZXIgPSBnZXRUYW5nZW50UXVhZHJhdGljSXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGVtcEluZm8uaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgICB0ZW1wSW5mby5hbmdsZUZpbmRlciA9IGFuZ2xlRmluZGVyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IHBhdGhJdGVyYXRvcihpdGVyYXRvciwgeDEsIHkxKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbM107XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgLy8gd2UgYWRkIHRob3NlIGluIG9yZGVyIHRvIGVhc2UgY2FsY3VsYXRpb25zIGxhdGVyXG4gICAgICAgICAgdGVtcEluZm8uZGVzdFggPSB4MjtcbiAgICAgICAgICB0ZW1wSW5mby5kZXN0WSA9IHkyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IGNhbGNMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICB4MSA9IHgyO1xuICAgICAgICAgIHkxID0geTI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0b3RhbExlbmd0aCArPSB0ZW1wSW5mby5sZW5ndGg7XG4gICAgICBpbmZvLnB1c2godGVtcEluZm8pO1xuICAgIH1cbiAgICBpbmZvLnB1c2goeyBsZW5ndGg6IHRvdGFsTGVuZ3RoLCB4OiB4MSwgeTogeTEgfSk7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uUGF0aChwYXRoLCBkaXN0YW5jZSwgaW5mb3MpIHtcbiAgICBpZiAoIWluZm9zKSB7XG4gICAgICBpbmZvcyA9IGdldFBhdGhTZWdtZW50c0luZm8ocGF0aCk7XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKGRpc3RhbmNlIC0gaW5mb3NbaV0ubGVuZ3RoID4gMCkgJiYgaSA8IChpbmZvcy5sZW5ndGggLSAyKSkge1xuICAgICAgZGlzdGFuY2UgLT0gaW5mb3NbaV0ubGVuZ3RoO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICAvLyB2YXIgZGlzdGFuY2UgPSBpbmZvc1tpbmZvcy5sZW5ndGggLSAxXSAqIHBlcmM7XG4gICAgdmFyIHNlZ0luZm8gPSBpbmZvc1tpXSwgc2VnUGVyY2VudCA9IGRpc3RhbmNlIC8gc2VnSW5mby5sZW5ndGgsXG4gICAgICAgIGNvbW1hbmQgPSBzZWdJbmZvLmNvbW1hbmQsIHNlZ21lbnQgPSBwYXRoW2ldLCBpbmZvO1xuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgcmV0dXJuIHsgeDogc2VnSW5mby54LCB5OiBzZWdJbmZvLnksIGFuZ2xlOiAwIH07XG4gICAgICBjYXNlICdaJzpcbiAgICAgIGNhc2UgJ3onOlxuICAgICAgICBpbmZvID0gbmV3IGZhYnJpYy5Qb2ludChzZWdJbmZvLngsIHNlZ0luZm8ueSkubGVycChcbiAgICAgICAgICBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8uZGVzdFgsIHNlZ0luZm8uZGVzdFkpLFxuICAgICAgICAgIHNlZ1BlcmNlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaW5mby5hbmdsZSA9IE1hdGguYXRhbjIoc2VnSW5mby5kZXN0WSAtIHNlZ0luZm8ueSwgc2VnSW5mby5kZXN0WCAtIHNlZ0luZm8ueCk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIGluZm8gPSBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8ueCwgc2VnSW5mby55KS5sZXJwKFxuICAgICAgICAgIG5ldyBmYWJyaWMuUG9pbnQoc2VnbWVudFsxXSwgc2VnbWVudFsyXSksXG4gICAgICAgICAgc2VnUGVyY2VudFxuICAgICAgICApO1xuICAgICAgICBpbmZvLmFuZ2xlID0gTWF0aC5hdGFuMihzZWdtZW50WzJdIC0gc2VnSW5mby55LCBzZWdtZW50WzFdIC0gc2VnSW5mby54KTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgcmV0dXJuIGZpbmRQZXJjZW50YWdlRm9yRGlzdGFuY2Uoc2VnSW5mbywgZGlzdGFuY2UpO1xuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHJldHVybiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aFN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgY29vcmRzID0gW10sXG4gICAgICAgIGN1cnJlbnRQYXRoLFxuICAgICAgICBwYXJzZWQsXG4gICAgICAgIHJlID0gZmFicmljLnJlUGF0aENvbW1hbmQsXG4gICAgICAgIHJOdW1iZXIgPSAnWy0rXT8oPzpcXFxcZCpcXFxcLlxcXFxkK3xcXFxcZCtcXFxcLj8pKD86W2VFXVstK10/XFxcXGQrKT9cXFxccyonLFxuICAgICAgICByTnVtYmVyQ29tbWFXc3AgPSAnKCcgKyByTnVtYmVyICsgJyknICsgZmFicmljLmNvbW1hV3NwLFxuICAgICAgICByRmxhZ0NvbW1hV3NwID0gJyhbMDFdKScgKyBmYWJyaWMuY29tbWFXc3AgKyAnPycsXG4gICAgICAgIHJBcmNTZXEgPSByTnVtYmVyQ29tbWFXc3AgKyAnPycgKyByTnVtYmVyQ29tbWFXc3AgKyAnPycgKyByTnVtYmVyQ29tbWFXc3AgKyByRmxhZ0NvbW1hV3NwICsgckZsYWdDb21tYVdzcCArXG4gICAgICAgICAgck51bWJlckNvbW1hV3NwICsgJz8oJyArIHJOdW1iZXIgKyAnKScsXG4gICAgICAgIHJlZ0FyY0FyZ3VtZW50U2VxdWVuY2UgPSBuZXcgUmVnRXhwKHJBcmNTZXEsICdnJyksXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb29yZHNTdHIsXG4gICAgICAgIC8vIG9uZSBvZiBjb21tYW5kcyAobSxNLGwsTCxxLFEsYyxDLGV0Yy4pIGZvbGxvd2VkIGJ5IG5vbi1jb21tYW5kIGNoYXJhY3RlcnMgKGkuZS4gY29tbWFuZCB2YWx1ZXMpXG4gICAgICAgIHBhdGg7XG4gICAgaWYgKCFwYXRoU3RyaW5nIHx8ICFwYXRoU3RyaW5nLm1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXRoID0gcGF0aFN0cmluZy5tYXRjaCgvW216bGh2Y3NxdGFdW15temxodmNzcXRhXSovZ2kpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGNvb3Jkc1BhcnNlZCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudFBhdGggPSBwYXRoW2ldO1xuXG4gICAgICBjb29yZHNTdHIgPSBjdXJyZW50UGF0aC5zbGljZSgxKS50cmltKCk7XG4gICAgICBjb29yZHMubGVuZ3RoID0gMDtcblxuICAgICAgdmFyIGNvbW1hbmQgPSBjdXJyZW50UGF0aC5jaGFyQXQoMCk7XG4gICAgICBjb29yZHNQYXJzZWQgPSBbY29tbWFuZF07XG5cbiAgICAgIGlmIChjb21tYW5kLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICAvLyBhcmNzIGhhdmUgc3BlY2lhbCBmbGFncyB0aGF0IGFwcGFyZW50bHkgZG9uJ3QgcmVxdWlyZSBzcGFjZXMgc28gaGFuZGxlIHNwZWNpYWxcbiAgICAgICAgZm9yICh2YXIgYXJnczsgKGFyZ3MgPSByZWdBcmNBcmd1bWVudFNlcXVlbmNlLmV4ZWMoY29vcmRzU3RyKSk7KSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb29yZHMucHVzaChhcmdzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhjb29yZHNTdHIpKSkge1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VGbG9hdChjb29yZHNbal0pO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICBjb29yZHNQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21tYW5kTGVuZ3RoID0gY29tbWFuZExlbmd0aHNbY29tbWFuZC50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICByZXBlYXRlZENvbW1hbmQgPSByZXBlYXRlZENvbW1hbmRzW2NvbW1hbmRdIHx8IGNvbW1hbmQ7XG5cbiAgICAgIGlmIChjb29yZHNQYXJzZWQubGVuZ3RoIC0gMSA+IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDEsIGtsZW4gPSBjb29yZHNQYXJzZWQubGVuZ3RoOyBrIDwga2xlbjsgayArPSBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW2NvbW1hbmRdLmNvbmNhdChjb29yZHNQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICAgICAgY29tbWFuZCA9IHJlcGVhdGVkQ29tbWFuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvb3Jkc1BhcnNlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhIGVsbGlwdGljLWFyY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZnggc3RhcnQgcG9pbnQgb2YgYXJjXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeVxuICAgKiBAcGFyYW0ge051bWJlcn0gcnggaG9yaXpvbnRhbCByYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJ5IHZlcnRpY2FsIHJhZGl1c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcm90IGFuZ2xlIG9mIGhvcml6b250YWwgYXhpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gbGFyZ2UgMSBvciAwLCB3aGF0ZXZlciB0aGUgYXJjIGlzIHRoZSBiaWcgb3IgdGhlIHNtYWxsIG9uIHRoZSAyIHBvaW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3dlZXAgMSBvciAwLCAxIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gdHggZW5kIHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gdHlcbiAgICovXG4gIGZ1bmN0aW9uIGdldEJvdW5kc09mQXJjKGZ4LCBmeSwgcngsIHJ5LCByb3QsIGxhcmdlLCBzd2VlcCwgdHgsIHR5KSB7XG5cbiAgICB2YXIgZnJvbVggPSAwLCBmcm9tWSA9IDAsIGJvdW5kLCBib3VuZHMgPSBbXSxcbiAgICAgICAgc2VncyA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYm91bmQgPSBnZXRCb3VuZHNPZkN1cnZlKGZyb21YLCBmcm9tWSwgc2Vnc1tpXVsxXSwgc2Vnc1tpXVsyXSwgc2Vnc1tpXVszXSwgc2Vnc1tpXVs0XSwgc2Vnc1tpXVs1XSwgc2Vnc1tpXVs2XSk7XG4gICAgICBib3VuZHMucHVzaCh7IHg6IGJvdW5kWzBdLnggKyBmeCwgeTogYm91bmRbMF0ueSArIGZ5IH0pO1xuICAgICAgYm91bmRzLnB1c2goeyB4OiBib3VuZFsxXS54ICsgZngsIHk6IGJvdW5kWzFdLnkgKyBmeSB9KTtcbiAgICAgIGZyb21YID0gc2Vnc1tpXVs1XTtcbiAgICAgIGZyb21ZID0gc2Vnc1tpXVs2XTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcblxuICAvKipcbiAgICogRHJhd3MgYXJjXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgY29vcmRzIG9mIHRoZSBhcmMsIHdpdGhvdXQgdGhlIGZyb250ICdBL2EnXG4gICAqL1xuICBmdW5jdGlvbiBkcmF3QXJjKGN0eCwgZngsIGZ5LCBjb29yZHMpIHtcbiAgICBjb29yZHMgPSBjb29yZHMuc2xpY2UoMCkudW5zaGlmdCgnWCcpOyAvLyBjb21tYW5kIEEgb3IgYSBkb2VzIG5vdCBtYXR0ZXJcbiAgICB2YXIgYmV6aWVycyA9IGZyb21BcmNUb0JlemllcnMoZngsIGZ5LCBjb29yZHMpO1xuICAgIGJlemllcnMuZm9yRWFjaChmdW5jdGlvbihiZXppZXIpIHtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgYmV6aWVyLnNsaWNlKDEpKTtcbiAgICB9KTtcbiAgfTtcblxuICBmYWJyaWMudXRpbC5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG4gIGZhYnJpYy51dGlsLm1ha2VQYXRoU2ltcGxlciA9IG1ha2VQYXRoU2ltcGxlcjtcbiAgZmFicmljLnV0aWwuZ2V0UGF0aFNlZ21lbnRzSW5mbyA9IGdldFBhdGhTZWdtZW50c0luZm87XG4gIGZhYnJpYy51dGlsLmZyb21BcmNUb0JlemllcnMgPSBmcm9tQXJjVG9CZXppZXJzO1xuICAvKipcbiAgICogVHlwbyBvZiBgZnJvbUFyY1RvQmV6aWVyc2Aga2VwdCBmb3Igbm90IGJyZWFraW5nIHRoZSBhcGkgb25jZSBjb3JyZWN0ZWQuXG4gICAqIFdpbGwgYmUgcmVtb3ZlZCBpbiBmYWJyaWMgNS4wXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBmYWJyaWMudXRpbC5mcm9tQXJjVG9CZWl6ZXJzID0gZnJvbUFyY1RvQmV6aWVycztcbiAgZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGdldEJvdW5kc09mQ3VydmU7XG4gIGZhYnJpYy51dGlsLmdldFBvaW50T25QYXRoID0gZ2V0UG9pbnRPblBhdGg7XG4gIC8vIGtlcHQgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0byBtYWtlIGJyZWFraW5nIGNoYW5nZXMuXG4gIC8vIGJ1dCB1c2VsZXNzIGFuZCBkZXByZWNhdGVkLlxuICBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkFyYyA9IGdldEJvdW5kc09mQXJjO1xuICBmYWJyaWMudXRpbC5kcmF3QXJjID0gZHJhd0FyYztcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2Qgb24gYWxsIGl0ZW1zIGluIGEgZ2l2ZW4gYXJyYXlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYSBtZXRob2QgdG8gaW52b2tlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGFycmF5LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhcmdzLmxlbmd0aCA/IGFycmF5W2ldW21ldGhvZF0uYXBwbHkoYXJyYXlbaV0sIGFyZ3MpIDogYXJyYXlbaV1bbWV0aG9kXS5jYWxsKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtYXhpbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID49IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtaW5pbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxIDwgdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBrID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChrLS0pIHtcbiAgICAgIGFycmF5W2tdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDEsXG4gICAgICAgIHJlc3VsdCA9IGJ5UHJvcGVydHkgPyBhcnJheVtpXVtieVByb3BlcnR5XSA6IGFycmF5W2ldO1xuICAgIGlmIChieVByb3BlcnR5KSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV1bYnlQcm9wZXJ0eV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXVtieVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5hcnJheVxuICAgKi9cbiAgZmFicmljLnV0aWwuYXJyYXkgPSB7XG4gICAgZmlsbDogZmlsbCxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIENvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIG9uZSBqcyBvYmplY3QgdG8gYW5vdGhlclxuICAgKiB0aGlzIGRvZXMgbm90IGFuZCBjYW5ub3QgY29tcGV0ZSB3aXRoIGdlbmVyaWMgdXRpbHMuXG4gICAqIERvZXMgbm90IGNsb25lIG9yIGV4dGVuZCBmYWJyaWMuT2JqZWN0IHN1YmNsYXNzZXMuXG4gICAqIFRoaXMgaXMgbW9zdGx5IGZvciBpbnRlcm5hbCB1c2UgYW5kIGhhcyBleHRyYSBoYW5kbGluZyBmb3IgZmFicmljSlMgb2JqZWN0c1xuICAgKiBpdCBza2lwcyB0aGUgY2FudmFzIGFuZCBncm91cCBwcm9wZXJ0aWVzIGluIGRlZXAgY2xvbmluZy5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLm9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gV2hlcmUgdG8gY29weSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFdoZXJlIHRvIGNvcHkgZnJvbVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlLCBkZWVwKSB7XG4gICAgLy8gSlNjcmlwdCBEb250RW51bSBidWcgaXMgbm90IHRha2VuIGNhcmUgb2ZcbiAgICAvLyB0aGUgZGVlcCBjbG9uZSBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBub3QgbWVhbnQgdG8gYXZvaWRcbiAgICAvLyBqYXZhc2NyaXB0IHRyYXBzIG9yIGNsb25pbmcgaHRtbCBlbGVtZW50IG9yIHNlbGYgcmVmZXJlbmNlZCBvYmplY3RzLlxuICAgIGlmIChkZWVwKSB7XG4gICAgICBpZiAoIWZhYnJpYy5pc0xpa2VseU5vZGUgJiYgc291cmNlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAvLyBhdm9pZCBjbG9uaW5nIGRlZXAgaW1hZ2VzLCBjYW52YXNlcyxcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25baV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbaV0sIGRlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnY2FudmFzJyB8fCBwcm9wZXJ0eSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gY2xvbmUgdGhpcyBwcm9wcyBhdCBhbGwuXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGtlZXAgdGhlIGtleXMgaW4gdGhlIGNvcHlcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IGV4dGVuZCh7IH0sIHNvdXJjZVtwcm9wZXJ0eV0sIGRlZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgc291bmRzIG9kZCBmb3IgYW4gZXh0ZW5kIGJ1dCBpcyBvayBmb3IgcmVjdXJzaXZlIHVzZVxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1wdHkgb2JqZWN0IGFuZCBjb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdCB0byBpdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIFRPRE86IHRoaXMgZnVuY3Rpb24gcmV0dXJuIGFuIGVtcHR5IG9iamVjdCBpZiB5b3UgdHJ5IHRvIGNsb25lIG51bGxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2xvbmVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gY2xvbmUob2JqZWN0LCBkZWVwKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7IH0sIG9iamVjdCwgZGVlcCk7XG4gIH1cblxuICAvKiogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5vYmplY3QgKi9cbiAgZmFicmljLnV0aWwub2JqZWN0ID0ge1xuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGNsb25lOiBjbG9uZVxuICB9O1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy51dGlsLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQ2FtZWxpemVzIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gY2FtZWxpemVcbiAgICogQHJldHVybiB7U3RyaW5nfSBDYW1lbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24obWF0Y2gsIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3RlciA/IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYXBpdGFsaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpcnN0TGV0dGVyT25seV0gSWYgdHJ1ZSBvbmx5IGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgKiBhbmQgb3RoZXIgbGV0dGVycyBzdGF5IHVudG91Y2hlZCwgaWYgZmFsc2UgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhcGl0YWxpemVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nLCBmaXJzdExldHRlck9ubHkpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgIChmaXJzdExldHRlck9ubHkgPyBzdHJpbmcuc2xpY2UoMSkgOiBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyBYTUwgaW4gYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVhtbChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKVxuICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGUgYSBzdHJpbmcgaW4gdGhlIHVzZXIgcGVyY2VpdmVkIHNpbmdsZSB1bml0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0c3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IGNvbnRhaW5pbmcgdGhlIGdyYXBoZW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gZ3JhcGhlbWVTcGxpdCh0ZXh0c3RyaW5nKSB7XG4gICAgdmFyIGkgPSAwLCBjaHIsIGdyYXBoZW1lcyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGNocjsgaSA8IHRleHRzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgoY2hyID0gZ2V0V2hvbGVDaGFyKHRleHRzdHJpbmcsIGkpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBncmFwaGVtZXMucHVzaChjaHIpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGhlbWVzO1xuICB9XG5cbiAgLy8gdGFrZW4gZnJvbSBtZG4gaW4gdGhlIGNoYXJBdCBkb2MgcGFnZS5cbiAgZnVuY3Rpb24gZ2V0V2hvbGVDaGFyKHN0ciwgaSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgIHJldHVybiAnJzsgLy8gUG9zaXRpb24gbm90IGZvdW5kXG4gICAgfVxuICAgIGlmIChjb2RlIDwgMHhEODAwIHx8IGNvZGUgPiAweERGRkYpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIC8vIEhpZ2ggc3Vycm9nYXRlIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA8PSAoaSArIDEpKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gc3RyLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKDB4REMwMCA+IG5leHQgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgICB0aHJvdyAnSGlnaCBzdXJyb2dhdGUgd2l0aG91dCBmb2xsb3dpbmcgbG93IHN1cnJvZ2F0ZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdChpKSArIHN0ci5jaGFyQXQoaSArIDEpO1xuICAgIH1cbiAgICAvLyBMb3cgc3Vycm9nYXRlICgweERDMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REZGRilcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICB2YXIgcHJldiA9IHN0ci5jaGFyQ29kZUF0KGkgLSAxKTtcblxuICAgIC8vIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA+IHByZXYgfHwgcHJldiA+IDB4REJGRikge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gcGFzcyBvdmVyIGxvdyBzdXJyb2dhdGVzIG5vdyBhcyB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICAgIC8vIGluIGEgcGFpciB3aGljaCB3ZSBoYXZlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuICAvKipcbiAgICogU3RyaW5nIHV0aWxpdGllc1xuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKi9cbiAgZmFicmljLnV0aWwuc3RyaW5nID0ge1xuICAgIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgICBjYXBpdGFsaXplOiBjYXBpdGFsaXplLFxuICAgIGVzY2FwZVhtbDogZXNjYXBlWG1sLFxuICAgIGdyYXBoZW1lU3BsaXQ6IGdyYXBoZW1lU3BsaXRcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgICBJU19ET05URU5VTV9CVUdHWSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB7IHRvU3RyaW5nOiAxIH0pIHtcbiAgICAgICAgICBpZiAocCA9PT0gJ3RvU3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pKCksXG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBhZGRNZXRob2RzID0gZnVuY3Rpb24oa2xhc3MsIHNvdXJjZSwgcGFyZW50KSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuXG4gICAgICAgICAgaWYgKHByb3BlcnR5IGluIGtsYXNzLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICB0eXBlb2Yga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAoc291cmNlW3Byb3BlcnR5XSArICcnKS5pbmRleE9mKCdjYWxsU3VwZXInKSA+IC0xKSB7XG5cbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSAoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnaW5pdGlhbGl6ZScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKElTX0RPTlRFTlVNX0JVR0dZKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS50b1N0cmluZyA9IHNvdXJjZS50b1N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS52YWx1ZU9mID0gc291cmNlLnZhbHVlT2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gIGZ1bmN0aW9uIFN1YmNsYXNzKCkgeyB9XG5cbiAgZnVuY3Rpb24gY2FsbFN1cGVyKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgcGFyZW50TWV0aG9kID0gbnVsbCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gY2xpbWIgcHJvdG90eXBlIGNoYWluIHRvIGZpbmQgbWV0aG9kIG5vdCBlcXVhbCB0byBjYWxsZWUncyBtZXRob2RcbiAgICB3aGlsZSAoX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcykge1xuICAgICAgdmFyIHN1cGVyQ2xhc3NNZXRob2QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgIGlmIChfdGhpc1ttZXRob2ROYW1lXSAhPT0gc3VwZXJDbGFzc01ldGhvZCkge1xuICAgICAgICBwYXJlbnRNZXRob2QgPSBzdXBlckNsYXNzTWV0aG9kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgX3RoaXMgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmVudE1ldGhvZCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCd0cmllZCB0byBjYWxsU3VwZXIgJyArIG1ldGhvZE5hbWUgKyAnLCBtZXRob2Qgbm90IGZvdW5kIGluIHByb3RvdHlwZSBjaGFpbicsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICA/IHBhcmVudE1ldGhvZC5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gICAgICA6IHBhcmVudE1ldGhvZC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY3JlYXRpb24gb2YgXCJjbGFzc2VzXCIuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyZW50XSBvcHRpb25hbCBcIkNsYXNzXCIgdG8gaW5oZXJpdCBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgKGJlIGNhcmVmdWwgbW9kaWZ5aW5nIG9iamVjdHMgZGVmaW5lZCBoZXJlIGFzIHRoaXMgd291bGQgYWZmZWN0IGFsbCBpbnN0YW5jZXMpXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDbGFzcygpIHtcbiAgICB2YXIgcGFyZW50ID0gbnVsbCxcbiAgICAgICAgcHJvcGVydGllcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyZW50ID0gcHJvcGVydGllcy5zaGlmdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrbGFzcygpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGtsYXNzLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAga2xhc3Muc3ViY2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgU3ViY2xhc3MucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgIGtsYXNzLnByb3RvdHlwZSA9IG5ldyBTdWJjbGFzcygpO1xuICAgICAgcGFyZW50LnN1YmNsYXNzZXMucHVzaChrbGFzcyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGRNZXRob2RzKGtsYXNzLCBwcm9wZXJ0aWVzW2ldLCBwYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoIWtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGVtcHR5RnVuY3Rpb247XG4gICAgfVxuICAgIGtsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGtsYXNzO1xuICAgIGtsYXNzLnByb3RvdHlwZS5jYWxsU3VwZXIgPSBjYWxsU3VwZXI7XG4gICAgcmV0dXJuIGtsYXNzO1xuICB9XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MgPSBjcmVhdGVDbGFzcztcbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2luY2UgaWUxMSBjYW4gdXNlIGFkZEV2ZW50TGlzdGVuZXIgYnV0IHRoZXkgZG8gbm90IHN1cHBvcnQgb3B0aW9ucywgaSBuZWVkIHRvIGNoZWNrXG4gIHZhciBjb3VsZFVzZUF0dGFjaEV2ZW50ID0gISFmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYXR0YWNoRXZlbnQsXG4gICAgICB0b3VjaEV2ZW50cyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXTtcbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgY291bGRVc2VBdHRhY2hFdmVudCA/IGZhbHNlIDogb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBjb3VsZFVzZUF0dGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUb3VjaEluZm8oZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hQcm9wID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKHRvdWNoUHJvcCAmJiB0b3VjaFByb3BbMF0pIHtcbiAgICAgIHJldHVybiB0b3VjaFByb3BbMF07XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmdldFBvaW50ZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICBzY3JvbGwgPSBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpLFxuICAgICAgICBfZXZ0ID0gZ2V0VG91Y2hJbmZvKGV2ZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogX2V2dC5jbGllbnRYICsgc2Nyb2xsLmxlZnQsXG4gICAgICB5OiBfZXZ0LmNsaWVudFkgKyBzY3JvbGwudG9wXG4gICAgfTtcbiAgfTtcblxuICBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiB0b3VjaEV2ZW50cy5pbmRleE9mKGV2ZW50LnR5cGUpID4gLTEgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3Igc2V0dGluZyBlbGVtZW50J3Mgc3R5bGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKCFlbGVtZW50U3R5bGUpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBzdHlsZXM7XG4gICAgICByZXR1cm4gc3R5bGVzLmluZGV4T2YoJ29wYWNpdHknKSA+IC0xXG4gICAgICAgID8gc2V0T3BhY2l0eShlbGVtZW50LCBzdHlsZXMubWF0Y2goL29wYWNpdHk6XFxzKihcXGQ/XFwuP1xcZCopLylbMV0pXG4gICAgICAgIDogZWxlbWVudDtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUHJvcGVydHkgPSAocHJvcGVydHkgPT09ICdmbG9hdCcgfHwgcHJvcGVydHkgPT09ICdjc3NGbG9hdCcpXG4gICAgICAgICAgPyAodHlwZW9mIGVsZW1lbnRTdHlsZS5zdHlsZUZsb2F0ID09PSAndW5kZWZpbmVkJyA/ICdjc3NGbG9hdCcgOiAnc3R5bGVGbG9hdCcpXG4gICAgICAgICAgOiBwcm9wZXJ0eTtcbiAgICAgICAgZWxlbWVudFN0eWxlW25vcm1hbGl6ZWRQcm9wZXJ0eV0gPSBzdHlsZXNbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHZhciBwYXJzZUVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgc3VwcG9ydHNPcGFjaXR5ID0gdHlwZW9mIHBhcnNlRWwuc3R5bGUub3BhY2l0eSA9PT0gJ3N0cmluZycsXG4gICAgICBzdXBwb3J0c0ZpbHRlcnMgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5maWx0ZXIgPT09ICdzdHJpbmcnLFxuICAgICAgcmVPcGFjaXR5ID0gL2FscGhhXFxzKlxcKFxccypvcGFjaXR5XFxzKj1cXHMqKFteXFwpXSspXFwpLyxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudDsgfTtcblxuICBpZiAoc3VwcG9ydHNPcGFjaXR5KSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIGlmIChzdXBwb3J0c0ZpbHRlcnMpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgdmFyIGVzID0gZWxlbWVudC5zdHlsZTtcbiAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSAmJiAhZWxlbWVudC5jdXJyZW50U3R5bGUuaGFzTGF5b3V0KSB7XG4gICAgICAgIGVzLnpvb20gPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHJlT3BhY2l0eS50ZXN0KGVzLmZpbHRlcikpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PSAwLjk5OTkgPyAnJyA6ICgnYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJyk7XG4gICAgICAgIGVzLmZpbHRlciA9IGVzLmZpbHRlci5yZXBsYWNlKHJlT3BhY2l0eSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVzLmZpbHRlciArPSAnIGFscGhhKG9wYWNpdHk9JyArICh2YWx1ZSAqIDEwMCkgKyAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG5cbiAgZmFicmljLnV0aWwuc2V0U3R5bGUgPSBzZXRTdHlsZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogVGFrZXMgaWQgYW5kIHJldHVybnMgYW4gZWxlbWVudCB3aXRoIHRoYXQgaWQgKGlmIG9uZSBleGlzdHMgaW4gYSBkb2N1bWVudClcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSBpZFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZmFicmljLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xuICB9XG5cbiAgdmFyIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyxcbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYW4gYXJyYXktbGlrZSBvYmplY3QgKGUuZy4gYXJndW1lbnRzIG9yIE5vZGVMaXN0KSB0byBhbiBhcnJheVxuICAgICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJyYXlMaWtlLCAwKTtcbiAgICAgIH07XG5cbiAgdHJ5IHtcbiAgICBzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMgPSB0b0FycmF5KGZhYnJpYy5kb2N1bWVudC5jaGlsZE5vZGVzKSBpbnN0YW5jZW9mIEFycmF5O1xuICB9XG4gIGNhdGNoIChlcnIpIHsgfVxuXG4gIGlmICghc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzKSB7XG4gICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShhcnJheUxpa2UubGVuZ3RoKSwgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHNwZWNpZmllZCBlbGVtZW50IHdpdGggc3BlY2lmaWVkIGF0dHJpYnV0ZXNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFR5cGUgb2YgYW4gZWxlbWVudCB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhbiBlbGVtZW50XG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBOZXdseSBjcmVhdGVkIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFbGVtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBmb3IgKHZhciBwcm9wIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChwcm9wID09PSAnY2xhc3MnKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wID09PSAnZm9yJykge1xuICAgICAgICBlbC5odG1sRm9yID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNsYXNzIHRvIGFuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBhZGQgY2xhc3MgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyB0byBhZGQgdG8gYW4gZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPT09IC0xKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAoZWxlbWVudC5jbGFzc05hbWUgPyAnICcgOiAnJykgKyBjbGFzc05hbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGVsZW1lbnQgd2l0aCBhbm90aGVyIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB3cmFwXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSB3cmFwcGVyIEVsZW1lbnQgdG8gd3JhcCB3aXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gQXR0cmlidXRlcyB0byBzZXQgb24gYSB3cmFwcGVyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB3cmFwcGVyXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwRWxlbWVudChlbGVtZW50LCB3cmFwcGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHR5cGVvZiB3cmFwcGVyID09PSAnc3RyaW5nJykge1xuICAgICAgd3JhcHBlciA9IG1ha2VFbGVtZW50KHdyYXBwZXIsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXIsIGVsZW1lbnQpO1xuICAgIH1cbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZWxlbWVudCBzY3JvbGwgb2Zmc2V0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG9wZXJhdGUgb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0L3RvcCB2YWx1ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCkge1xuXG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwLFxuICAgICAgICBkb2NFbGVtZW50ID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgYm9keSA9IGZhYnJpYy5kb2N1bWVudC5ib2R5IHx8IHtcbiAgICAgICAgICBzY3JvbGxMZWZ0OiAwLCBzY3JvbGxUb3A6IDBcbiAgICAgICAgfTtcblxuICAgIC8vIFdoaWxlIGxvb3AgY2hlY2tzIChhbmQgdGhlbiBzZXRzIGVsZW1lbnQgdG8pIC5wYXJlbnROb2RlIE9SIC5ob3N0XG4gICAgLy8gIHRvIGFjY291bnQgZm9yIFNoYWRvd0RPTS4gV2Ugc3RpbGwgd2FudCB0byB0cmF2ZXJzZSB1cCBvdXQgb2YgU2hhZG93RE9NLFxuICAgIC8vICBidXQgdGhlIC5wYXJlbnROb2RlIG9mIGEgcm9vdCBTaGFkb3dET00gbm9kZSB3aWxsIGFsd2F5cyBiZSBudWxsLCBpbnN0ZWFkXG4gICAgLy8gIGl0IHNob3VsZCBiZSBhY2Nlc3NlZCB0aHJvdWdoIC5ob3N0LiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQ3NjU1MjgvNDM4MzkzOFxuICAgIHdoaWxlIChlbGVtZW50ICYmIChlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0KSkge1xuXG4gICAgICAvLyBTZXQgZWxlbWVudCB0byBlbGVtZW50IHBhcmVudCwgb3IgJ2hvc3QnIGluIGNhc2Ugb2YgU2hhZG93RE9NXG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcblxuICAgICAgaWYgKGVsZW1lbnQgPT09IGZhYnJpYy5kb2N1bWVudCkge1xuICAgICAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCAgZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZWZ0ICs9IGVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEgJiYgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2Zmc2V0IGZvciBhIGdpdmVuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IG9mZnNldCBmb3JcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcImxlZnRcIiBhbmQgXCJ0b3BcIiBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jRWxlbSxcbiAgICAgICAgZG9jID0gZWxlbWVudCAmJiBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGJveCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIHNjcm9sbExlZnRUb3AsXG4gICAgICAgIG9mZnNldEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiAnbGVmdCcsXG4gICAgICAgICAgYm9yZGVyVG9wV2lkdGg6ICAndG9wJyxcbiAgICAgICAgICBwYWRkaW5nTGVmdDogICAgICdsZWZ0JyxcbiAgICAgICAgICBwYWRkaW5nVG9wOiAgICAgICd0b3AnXG4gICAgICAgIH07XG5cbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIG9mZnNldEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9mZnNldFtvZmZzZXRBdHRyaWJ1dGVzW2F0dHJdXSArPSBwYXJzZUludChnZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgYXR0ciksIDEwKSB8fCAwO1xuICAgIH1cblxuICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIGlmICggdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIGJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsTGVmdFRvcCA9IGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0VG9wLmxlZnQgLSAoZG9jRWxlbS5jbGllbnRMZWZ0IHx8IDApICsgb2Zmc2V0LmxlZnQsXG4gICAgICB0b3A6IGJveC50b3AgKyBzY3JvbGxMZWZ0VG9wLnRvcCAtIChkb2NFbGVtLmNsaWVudFRvcCB8fCAwKSAgKyBvZmZzZXQudG9wXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0eWxlIGF0dHJpYnV0ZSB2YWx1ZSBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgc3R5bGUgYXR0cmlidXRlIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBTdHlsZSBhdHRyaWJ1dGUgdG8gZ2V0IGZvciBlbGVtZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gU3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIGdldEVsZW1lbnRTdHlsZTtcbiAgaWYgKGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0VmlldyAmJiBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgcmV0dXJuIHN0eWxlID8gc3R5bGVbYXR0cl0gOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBnZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LnN0eWxlW2F0dHJdO1xuICAgICAgaWYgKCF2YWx1ZSAmJiBlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuY3VycmVudFN0eWxlW2F0dHJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHNlbGVjdFByb3AgPSAndXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICA/ICd1c2VyU2VsZWN0J1xuICAgICAgICAgIDogJ01velVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICA/ICdNb3pVc2VyU2VsZWN0J1xuICAgICAgICAgICAgOiAnV2Via2l0VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgICAgPyAnV2Via2l0VXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgOiAnS2h0bWxVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICAgID8gJ0todG1sVXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgICA6ICcnO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCB1bnNlbGVjdGFibGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbWFrZSB1bnNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFicmljLnV0aWwuZmFsc2VGdW5jdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJ29uJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFNlbGVjdGFibGUoZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3NlbGVjdFByb3BdID0gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlO1xuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50U2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50U2VsZWN0YWJsZTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBnZXROb2RlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICB2YXIgaW1wbCA9IGZhYnJpYy5qc2RvbUltcGxGb3JXcmFwcGVyKGVsZW1lbnQpO1xuICAgIHJldHVybiBpbXBsLl9jYW52YXMgfHwgaW1wbC5faW1hZ2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xlYW5VcEpzZG9tTm9kZShlbGVtZW50KSB7XG4gICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgaWYgKGltcGwpIHtcbiAgICAgIGltcGwuX2ltYWdlID0gbnVsbDtcbiAgICAgIGltcGwuX2NhbnZhcyA9IG51bGw7XG4gICAgICAvLyB1bnN1cmUgaWYgbmVjZXNzYXJ5XG4gICAgICBpbXBsLl9jdXJyZW50U3JjID0gbnVsbDtcbiAgICAgIGltcGwuX2F0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgaW1wbC5fY2xhc3NMaXN0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbWFnZVNtb290aGluZyhjdHgsIHZhbHVlKSB7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZFxuICAgICAgfHwgY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldEltYWdlU21vb3RoaW5nIHNldHMgdGhlIGNvbnRleHQgaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHByb3BlcnR5LlxuICAgKiBVc2VkIGJ5IGNhbnZhcyBhbmQgYnkgSW1hZ2VPYmplY3QuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQHBhcmFtIHtIVE1MUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdG8gc2V0IG9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgdHJ1ZSBvciBmYWxzZVxuICAgKi9cbiAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcgPSBzZXRJbWFnZVNtb290aGluZztcbiAgZmFicmljLnV0aWwuZ2V0QnlJZCA9IGdldEJ5SWQ7XG4gIGZhYnJpYy51dGlsLnRvQXJyYXkgPSB0b0FycmF5O1xuICBmYWJyaWMudXRpbC5hZGRDbGFzcyA9IGFkZENsYXNzO1xuICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudCA9IG1ha2VFbGVtZW50O1xuICBmYWJyaWMudXRpbC53cmFwRWxlbWVudCA9IHdyYXBFbGVtZW50O1xuICBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcDtcbiAgZmFicmljLnV0aWwuZ2V0RWxlbWVudE9mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQ7XG4gIGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXMgPSBnZXROb2RlQ2FudmFzO1xuICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlID0gY2xlYW5VcEpzZG9tTm9kZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gYWRkUGFyYW1Ub1VybCh1cmwsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcGFyYW07XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eUZuKCkgeyB9XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgYWJzdHJhY3Rpb24gZm9yIHNlbmRpbmcgWE1MSHR0cFJlcXVlc3RcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIHNlbmQgWE1MSHR0cFJlcXVlc3QgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kPVwiR0VUXCJdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbWV0ZXJzXSBwYXJhbWV0ZXJzIHRvIGFwcGVuZCB0byB1cmwgaW4gR0VUIG9yIGluIGJvZHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJvZHldIGJvZHkgdG8gc2VuZCB3aXRoIFBPU1Qgb3IgUFVUIHJlcXVlc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbkNvbXBsZXRlIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIHJlcXVlc3QgaXMgY29tcGxldGVkXG4gICAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fSByZXF1ZXN0XG4gICAqL1xuICBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kID8gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSA6ICdHRVQnLFxuICAgICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlIHx8IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICB4aHIgPSBuZXcgZmFicmljLndpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMucGFyYW1ldGVycztcblxuICAgIC8qKiBAaWdub3JlICovXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIG9uQ29tcGxldGUoeGhyKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5Rm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICBib2R5ID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICB1cmwgPSBhZGRQYXJhbVRvVXJsKHVybCwgb3B0aW9ucy5wYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnUE9TVCcgfHwgbWV0aG9kID09PSAnUFVUJykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KTtcbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgZmFicmljLnV0aWwucmVxdWVzdCA9IHJlcXVlc3Q7XG59KSgpO1xuXG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUubG9nYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2dcbiAqL1xuZmFicmljLmxvZyA9IGNvbnNvbGUubG9nO1xuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLndhcm5gICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZyBhcyBhIHdhcm5pbmdcbiAqL1xuZmFicmljLndhcm4gPSBjb25zb2xlLndhcm47XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEVhc2luZyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogTWF0aC5jb3ModCAvIGQgKiAoTWF0aC5QSSAvIDIpKSArIGMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdmFsdWUgZnJvbSBvbmUgdG8gYW5vdGhlciB3aXRoaW4gY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgaW52b2tpbmcgY2FsbGJhY2tzIGFzIHZhbHVlIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ2hhbmdlXSBDYWxsYmFjazsgaW52b2tlZCBvbiBldmVyeSB2YWx1ZSBjaGFuZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25Db21wbGV0ZV0gQ2FsbGJhY2s7IGludm9rZWQgd2hlbiB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdGFydFZhbHVlPTBdIFN0YXJ0aW5nIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbmRWYWx1ZT0xMDBdIEVuZGluZyB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnlWYWx1ZT0xMDBdIFZhbHVlIHRvIG1vZGlmeSB0aGUgcHJvcGVydHkgYnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZWFzaW5nXSBFYXNpbmcgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uPTUwMF0gRHVyYXRpb24gb2YgY2hhbmdlIChpbiBtcylcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBvbkNvbXBsZXRlIGlzIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFuaW1hdGUob3B0aW9ucykge1xuXG4gICAgcmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aW1lc3RhbXAgfHwgK25ldyBEYXRlKCksXG4gICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDUwMCxcbiAgICAgICAgICBmaW5pc2ggPSBzdGFydCArIGR1cmF0aW9uLCB0aW1lLFxuICAgICAgICAgIG9uQ2hhbmdlID0gb3B0aW9ucy5vbkNoYW5nZSB8fCBub29wLFxuICAgICAgICAgIGFib3J0ID0gb3B0aW9ucy5hYm9ydCB8fCBub29wLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUgfHwgbm9vcCxcbiAgICAgICAgICBlYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCBkZWZhdWx0RWFzaW5nLFxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICAgICAgZW5kVmFsdWUgPSAnZW5kVmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuZFZhbHVlIDogMTAwLFxuICAgICAgICAgIGJ5VmFsdWUgPSBvcHRpb25zLmJ5VmFsdWUgfHwgZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xuXG4gICAgICBvcHRpb25zLm9uU3RhcnQgJiYgb3B0aW9ucy5vblN0YXJ0KCk7XG5cbiAgICAgIChmdW5jdGlvbiB0aWNrKHRpY2t0aW1lKSB7XG4gICAgICAgIC8vIFRPRE86IG1vdmUgYWJvcnQgY2FsbCBhZnRlciBjYWxjdWxhdGlvblxuICAgICAgICAvLyBhbmQgcGFzcyAoY3VycmVudCx2YWx1ZVBlcmMsIHRpbWVQZXJjKSBhcyBhcmd1bWVudHNcbiAgICAgICAgdGltZSA9IHRpY2t0aW1lIHx8ICtuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aW1lID4gZmluaXNoID8gZHVyYXRpb24gOiAodGltZSAtIHN0YXJ0KSxcbiAgICAgICAgICAgIHRpbWVQZXJjID0gY3VycmVudFRpbWUgLyBkdXJhdGlvbixcbiAgICAgICAgICAgIGN1cnJlbnQgPSBlYXNpbmcoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHZhbHVlUGVyYyA9IE1hdGguYWJzKChjdXJyZW50IC0gc3RhcnRWYWx1ZSkgLyBieVZhbHVlKTtcbiAgICAgICAgaWYgKGFib3J0KCkpIHtcbiAgICAgICAgICBvbkNvbXBsZXRlKGVuZFZhbHVlLCAxLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWUgPiBmaW5pc2gpIHtcbiAgICAgICAgICBvbkNoYW5nZShlbmRWYWx1ZSwgMSwgMSk7XG4gICAgICAgICAgb25Db21wbGV0ZShlbmRWYWx1ZSwgMSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9uQ2hhbmdlKGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpO1xuICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUodGljayk7XG4gICAgICAgIH1cbiAgICAgIH0pKHN0YXJ0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBfcmVxdWVzdEFuaW1GcmFtZSA9IGZhYnJpYy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhYnJpYy53aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICB2YXIgX2NhbmNlbEFuaW1GcmFtZSA9IGZhYnJpYy53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZmFicmljLndpbmRvdy5jbGVhclRpbWVvdXQ7XG5cbiAgLyoqXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBiYXNlZCBvbiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBJbiBvcmRlciB0byBnZXQgYSBwcmVjaXNlIHN0YXJ0IHRpbWUsIGByZXF1ZXN0QW5pbUZyYW1lYCBzaG91bGQgYmUgY2FsbGVkIGFzIGFuIGVudHJ5IGludG8gdGhlIG1ldGhvZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBvcHRpb25hbCBFbGVtZW50IHRvIGFzc29jaWF0ZSB3aXRoIGFuaW1hdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3RBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gX2NhbmNlbEFuaW1GcmFtZS5hcHBseShmYWJyaWMud2luZG93LCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZmFicmljLnV0aWwuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gIGZhYnJpYy51dGlsLnJlcXVlc3RBbmltRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lO1xuICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUgPSBjYW5jZWxBbmltRnJhbWU7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLy8gQ2FsY3VsYXRlIGFuIGluLWJldHdlZW4gY29sb3IuIFJldHVybnMgYSBcInJnYmEoKVwiIHN0cmluZy5cbiAgLy8gQ3JlZGl0OiBFZHdpbiBNYXJ0aW4gPGVkd2luQGJpdHN0b3JtLm9yZz5cbiAgLy8gICAgICAgICBodHRwOi8vd3d3LmJpdHN0b3JtLm9yZy9qcXVlcnkvY29sb3ItYW5pbWF0aW9uL2pxdWVyeS5hbmltYXRlLWNvbG9ycy5qc1xuICBmdW5jdGlvbiBjYWxjdWxhdGVDb2xvcihiZWdpbiwgZW5kLCBwb3MpIHtcbiAgICB2YXIgY29sb3IgPSAncmdiYSgnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzBdICsgcG9zICogKGVuZFswXSAtIGJlZ2luWzBdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsxXSArIHBvcyAqIChlbmRbMV0gLSBiZWdpblsxXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMl0gKyBwb3MgKiAoZW5kWzJdIC0gYmVnaW5bMl0pKSwgMTApO1xuXG4gICAgY29sb3IgKz0gJywnICsgKGJlZ2luICYmIGVuZCA/IHBhcnNlRmxvYXQoYmVnaW5bM10gKyBwb3MgKiAoZW5kWzNdIC0gYmVnaW5bM10pKSA6IDEpO1xuICAgIGNvbG9yICs9ICcpJztcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgY29sb3IgZnJvbSBvbmUgdG8gYW5vdGhlciB3aXRoaW4gY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgaW52b2tpbmcgY2FsbGJhY2tzIGFzIHZhbHVlIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbUNvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jb2xvckVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHRha2UgdHdvIGFyZ3VtZW50cyAoY3VycmVudFRpbWUsIGR1cmF0aW9uKS4gVGh1cyB0aGUgcmVndWxhciBhbmltYXRpb24gZWFzaW5nIGZ1bmN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBvbkNvbXBsZXRlIGlzIGNhbGxlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFuaW1hdGVDb2xvcihmcm9tQ29sb3IsIHRvQ29sb3IsIGR1cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHN0YXJ0Q29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGZyb21Db2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgIGVuZENvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0b0NvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgb3JpZ2luYWxPbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlLFxuICAgICAgICBvcmlnaW5hbE9uQ2hhbmdlID0gb3B0aW9ucy5vbkNoYW5nZTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChvcHRpb25zLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gfHwgNTAwLFxuICAgICAgc3RhcnRWYWx1ZTogc3RhcnRDb2xvcixcbiAgICAgIGVuZFZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGJ5VmFsdWU6IGVuZENvbG9yLFxuICAgICAgZWFzaW5nOiBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBwb3NWYWx1ZSA9IG9wdGlvbnMuY29sb3JFYXNpbmdcbiAgICAgICAgICA/IG9wdGlvbnMuY29sb3JFYXNpbmcoY3VycmVudFRpbWUsIGR1cmF0aW9uKVxuICAgICAgICAgIDogMSAtIE1hdGguY29zKGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKiAoTWF0aC5QSSAvIDIpKTtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9yKHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIHBvc1ZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAvLyBoYXMgdG8gdGFrZSBpbiBhY2NvdW50IGZvciBjb2xvciByZXN0b3Jpbmc7XG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkNvbXBsZXRlKFxuICAgICAgICAgICAgY2FsY3VsYXRlQ29sb3IoZW5kQ29sb3IsIGVuZENvbG9yLCAwKSxcbiAgICAgICAgICAgIHZhbHVlUGVyYyxcbiAgICAgICAgICAgIHRpbWVQZXJjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ2hhbmdlKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9uQ2hhbmdlKFxuICAgICAgICAgICAgICBjYWxjdWxhdGVDb2xvcihjdXJyZW50LCBjdXJyZW50LCAwKSxcbiAgICAgICAgICAgICAgdmFsdWVQZXJjLFxuICAgICAgICAgICAgICB0aW1lUGVyY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxPbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvciA9IGFuaW1hdGVDb2xvcjtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGEsIGMsIHAsIHMpIHtcbiAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICBhID0gYztcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2hhbmRsZSB0aGUgMC8wIGNhc2U6XG4gICAgICBpZiAoYyA9PT0gMCAmJiBhID09PSAwKSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhOiBhLCBjOiBjLCBwOiBwLCBzOiBzIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbGFzdGljKG9wdHMsIHQsIGQpIHtcbiAgICByZXR1cm4gb3B0cy5hICpcbiAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCAodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5TaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNpbih0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IDApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0IC8gZCAtIDEpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gZCkgPyBiICsgYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQgLyBkKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAodCA9PT0gZCkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkNpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dENpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zcXJ0KDEgLSAodCA9IHQgLyBkIC0gMSkgKiB0KSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dENpcmModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gLWVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA9PT0gMikge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiBlbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICogMC41ICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5CYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgLSBlYXNlT3V0Qm91bmNlIChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgIHJldHVybiBlYXNlSW5Cb3VuY2UgKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgfVxuICAgIHJldHVybiBlYXNlT3V0Qm91bmNlKHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb25zXG4gICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXCI+RWFzaW5nIEVxdWF0aW9ucyBieSBSb2JlcnQgUGVubmVyPC9hPlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLmVhc2UgPSB7XG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB0IC89IChkIC8gMik7XG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEN1YmljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XG4gICAgfSxcblxuICAgIGVhc2VPdXRDdWJpYzogZWFzZU91dEN1YmljLFxuICAgIGVhc2VJbk91dEN1YmljOiBlYXNlSW5PdXRDdWJpYyxcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXG4gICAgZWFzZU91dFF1YXJ0OiBlYXNlT3V0UXVhcnQsXG4gICAgZWFzZUluT3V0UXVhcnQ6IGVhc2VJbk91dFF1YXJ0LFxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcbiAgICBlYXNlT3V0UXVpbnQ6IGVhc2VPdXRRdWludCxcbiAgICBlYXNlSW5PdXRRdWludDogZWFzZUluT3V0UXVpbnQsXG4gICAgZWFzZUluU2luZTogZWFzZUluU2luZSxcbiAgICBlYXNlT3V0U2luZTogZWFzZU91dFNpbmUsXG4gICAgZWFzZUluT3V0U2luZTogZWFzZUluT3V0U2luZSxcbiAgICBlYXNlSW5FeHBvOiBlYXNlSW5FeHBvLFxuICAgIGVhc2VPdXRFeHBvOiBlYXNlT3V0RXhwbyxcbiAgICBlYXNlSW5PdXRFeHBvOiBlYXNlSW5PdXRFeHBvLFxuICAgIGVhc2VJbkNpcmM6IGVhc2VJbkNpcmMsXG4gICAgZWFzZU91dENpcmM6IGVhc2VPdXRDaXJjLFxuICAgIGVhc2VJbk91dENpcmM6IGVhc2VJbk91dENpcmMsXG4gICAgZWFzZUluRWxhc3RpYzogZWFzZUluRWxhc3RpYyxcbiAgICBlYXNlT3V0RWxhc3RpYzogZWFzZU91dEVsYXN0aWMsXG4gICAgZWFzZUluT3V0RWxhc3RpYzogZWFzZUluT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5CYWNrOiBlYXNlSW5CYWNrLFxuICAgIGVhc2VPdXRCYWNrOiBlYXNlT3V0QmFjayxcbiAgICBlYXNlSW5PdXRCYWNrOiBlYXNlSW5PdXRCYWNrLFxuICAgIGVhc2VJbkJvdW5jZTogZWFzZUluQm91bmNlLFxuICAgIGVhc2VPdXRCb3VuY2U6IGVhc2VPdXRCb3VuY2UsXG4gICAgZWFzZUluT3V0Qm91bmNlOiBlYXNlSW5PdXRCb3VuY2VcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmYWJyaWNcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHBhcnNlVW5pdCA9IGZhYnJpYy51dGlsLnBhcnNlVW5pdCxcbiAgICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuXG4gICAgICBzdmdWYWxpZFRhZ05hbWVzID0gWydwYXRoJywgJ2NpcmNsZScsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ2VsbGlwc2UnLCAncmVjdCcsICdsaW5lJyxcbiAgICAgICAgJ2ltYWdlJywgJ3RleHQnXSxcbiAgICAgIHN2Z1ZpZXdCb3hFbGVtZW50cyA9IFsnc3ltYm9sJywgJ2ltYWdlJywgJ21hcmtlcicsICdwYXR0ZXJuJywgJ3ZpZXcnLCAnc3ZnJ10sXG4gICAgICBzdmdJbnZhbGlkQW5jZXN0b3JzID0gWydwYXR0ZXJuJywgJ2RlZnMnLCAnc3ltYm9sJywgJ21ldGFkYXRhJywgJ2NsaXBQYXRoJywgJ21hc2snLCAnZGVzYyddLFxuICAgICAgc3ZnVmFsaWRQYXJlbnRzID0gWydzeW1ib2wnLCAnZycsICdhJywgJ3N2ZycsICdjbGlwUGF0aCcsICdkZWZzJ10sXG5cbiAgICAgIGF0dHJpYnV0ZXNNYXAgPSB7XG4gICAgICAgIGN4OiAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHg6ICAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHI6ICAgICAgICAgICAgICAgICAgICAncmFkaXVzJyxcbiAgICAgICAgY3k6ICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICB5OiAgICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGRpc3BsYXk6ICAgICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHZpc2liaWxpdHk6ICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHRyYW5zZm9ybTogICAgICAgICAgICAndHJhbnNmb3JtTWF0cml4JyxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAgICdmaWxsT3BhY2l0eScsXG4gICAgICAgICdmaWxsLXJ1bGUnOiAgICAgICAgICAnZmlsbFJ1bGUnLFxuICAgICAgICAnZm9udC1mYW1pbHknOiAgICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgICAnZm9udC1zaXplJzogICAgICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICAgJ2ZvbnQtc3R5bGUnOiAgICAgICAgICdmb250U3R5bGUnLFxuICAgICAgICAnZm9udC13ZWlnaHQnOiAgICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgICAnbGV0dGVyLXNwYWNpbmcnOiAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICAgJ3BhaW50LW9yZGVyJzogICAgICAgICdwYWludEZpcnN0JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgICdzdHJva2VEYXNoQXJyYXknLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAgJ3N0cm9rZURhc2hPZmZzZXQnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAgJ3N0cm9rZUxpbmVDYXAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogICAgJ3N0cm9rZUxpbmVKb2luJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogICdzdHJva2VNaXRlckxpbWl0JyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICAgICAndGV4dC1hbmNob3InOiAgICAgICAgJ3RleHRBbmNob3InLFxuICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnY2xpcC1wYXRoJzogICAgICAgICAgJ2NsaXBQYXRoJyxcbiAgICAgICAgJ2NsaXAtcnVsZSc6ICAgICAgICAgICdjbGlwUnVsZScsXG4gICAgICAgICd2ZWN0b3ItZWZmZWN0JzogICAgICAnc3Ryb2tlVW5pZm9ybScsXG4gICAgICAgICdpbWFnZS1yZW5kZXJpbmcnOiAgICAnaW1hZ2VTbW9vdGhpbmcnLFxuICAgICAgfSxcblxuICAgICAgY29sb3JBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzdHJva2U6ICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgZmlsbDogICAnZmlsbE9wYWNpdHknXG4gICAgICB9LFxuXG4gICAgICBmU2l6ZSA9ICdmb250LXNpemUnLCBjUGF0aCA9ICdjbGlwLXBhdGgnO1xuXG4gIGZhYnJpYy5zdmdWYWxpZFRhZ05hbWVzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFRhZ05hbWVzKTtcbiAgZmFicmljLnN2Z1ZpZXdCb3hFbGVtZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmlld0JveEVsZW1lbnRzKTtcbiAgZmFicmljLnN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z0ludmFsaWRBbmNlc3RvcnMpO1xuICBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFBhcmVudHMpO1xuXG4gIGZhYnJpYy5jc3NSdWxlcyA9IHsgfTtcbiAgZmFicmljLmdyYWRpZW50RGVmcyA9IHsgfTtcbiAgZmFicmljLmNsaXBQYXRocyA9IHsgfTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVBdHRyKGF0dHIpIHtcbiAgICAvLyB0cmFuc2Zvcm0gYXR0cmlidXRlIG5hbWVzXG4gICAgaWYgKGF0dHIgaW4gYXR0cmlidXRlc01hcCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNNYXBbYXR0cl07XG4gICAgfVxuICAgIHJldHVybiBhdHRyO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUoYXR0ciwgdmFsdWUsIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKSB7XG4gICAgdmFyIGlzQXJyYXkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgICBwYXJzZWQ7XG5cbiAgICBpZiAoKGF0dHIgPT09ICdmaWxsJyB8fCBhdHRyID09PSAnc3Ryb2tlJykgJiYgdmFsdWUgPT09ICdub25lJykge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3N0cm9rZVVuaWZvcm0nKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VEYXNoQXJyYXknKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICdub25lJykge1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8sL2csICcgJykuc3BsaXQoL1xccysvKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd0cmFuc2Zvcm1NYXRyaXgnKSB7XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB2YWx1ZSA9IG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgsIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSAnbm9uZScgJiYgdmFsdWUgIT09ICdoaWRkZW4nO1xuICAgICAgLy8gZGlzcGxheT1ub25lIG9uIHBhcmVudCBlbGVtZW50IGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY2hpbGQgZWxlbWVudFxuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnb3BhY2l0eScpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiB0eXBlb2YgcGFyZW50QXR0cmlidXRlcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSAqPSBwYXJlbnRBdHRyaWJ1dGVzLm9wYWNpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd0ZXh0QW5jaG9yJyAvKiB0ZXh0LWFuY2hvciAqLykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IHZhbHVlID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2NoYXJTcGFjaW5nJykge1xuICAgICAgLy8gcGFyc2VVbml0IHJldHVybnMgcHggYW5kIHdlIGNvbnZlcnQgaXQgdG8gZW1cbiAgICAgIHBhcnNlZCA9IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpIC8gZm9udFNpemUgKiAxMDAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAncGFpbnRGaXJzdCcpIHtcbiAgICAgIHZhciBmaWxsSW5kZXggPSB2YWx1ZS5pbmRleE9mKCdmaWxsJyk7XG4gICAgICB2YXIgc3Ryb2tlSW5kZXggPSB2YWx1ZS5pbmRleE9mKCdzdHJva2UnKTtcbiAgICAgIHZhciB2YWx1ZSA9ICdmaWxsJztcbiAgICAgIGlmIChmaWxsSW5kZXggPiAtMSAmJiBzdHJva2VJbmRleCA+IC0xICYmIHN0cm9rZUluZGV4IDwgZmlsbEluZGV4KSB7XG4gICAgICAgIHZhbHVlID0gJ3N0cm9rZSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmaWxsSW5kZXggPT09IC0xICYmIHN0cm9rZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFsdWUgPSAnc3Ryb2tlJztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2hyZWYnIHx8IGF0dHIgPT09ICd4bGluazpocmVmJyB8fCBhdHRyID09PSAnZm9udCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2ltYWdlU21vb3RoaW5nJykge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gJ29wdGltaXplUXVhbGl0eScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZCA9IGlzQXJyYXkgPyB2YWx1ZS5tYXAocGFyc2VVbml0KSA6IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiAoIWlzQXJyYXkgJiYgaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBmdW5jdGlvbiBnZXRTdmdSZWdleChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgYXJyLmpvaW4oJ3wnKSArICcpXFxcXGInLCAnaScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICovXG4gIGZ1bmN0aW9uIF9zZXRTdHJva2VGaWxsT3BhY2l0eShhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBjb2xvckF0dHJpYnV0ZXMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0gPT09ICd1bmRlZmluZWQnIHx8IGF0dHJpYnV0ZXNbYXR0cl0gPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbYXR0cl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBjb2xvci5zZXRBbHBoYSh0b0ZpeGVkKGNvbG9yLmdldEFscGhhKCkgKiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0sIDIpKS50b1JnYmEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgbm9kZU5hbWVzKSB7XG4gICAgdmFyIG5vZGVOYW1lLCBub2RlQXJyYXkgPSBbXSwgbm9kZUxpc3QsIGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVOYW1lID0gbm9kZU5hbWVzW2ldO1xuICAgICAgbm9kZUxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUobm9kZU5hbWUpO1xuICAgICAgbm9kZUFycmF5ID0gbm9kZUFycmF5LmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVWYWx1ZSBTdHJpbmcgY29udGFpbmluZyBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIDYgZWxlbWVudHMgcmVwcmVzZW50aW5nIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKi9cbiAgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBjb3MgPSBmYWJyaWMudXRpbC5jb3MoYXJnc1swXSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihhcmdzWzBdKSxcbiAgICAgICAgICB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgeCA9IGFyZ3NbMV07XG4gICAgICAgIHkgPSBhcmdzWzJdO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXhbMF0gPSBjb3M7XG4gICAgICBtYXRyaXhbMV0gPSBzaW47XG4gICAgICBtYXRyaXhbMl0gPSAtc2luO1xuICAgICAgbWF0cml4WzNdID0gY29zO1xuICAgICAgbWF0cml4WzRdID0geCAtIChjb3MgKiB4IC0gc2luICogeSk7XG4gICAgICBtYXRyaXhbNV0gPSB5IC0gKHNpbiAqIHggKyBjb3MgKiB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyWCA9IGFyZ3NbMF0sXG4gICAgICAgICAgbXVsdGlwbGllclkgPSAoYXJncy5sZW5ndGggPT09IDIpID8gYXJnc1sxXSA6IGFyZ3NbMF07XG5cbiAgICAgIG1hdHJpeFswXSA9IG11bHRpcGxpZXJYO1xuICAgICAgbWF0cml4WzNdID0gbXVsdGlwbGllclk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIHBvcykge1xuICAgICAgbWF0cml4W3Bvc10gPSBNYXRoLnRhbihmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICBtYXRyaXhbNF0gPSBhcmdzWzBdO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1hdHJpeFs1XSA9IGFyZ3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpdHkgbWF0cml4XG4gICAgdmFyIGlNYXRyaXggPSBmYWJyaWMuaU1hdHJpeCxcblxuICAgICAgICAvLyA9PSBiZWdpbiB0cmFuc2Zvcm0gcmVnZXhwXG4gICAgICAgIG51bWJlciA9IGZhYnJpYy5yZU51bSxcblxuICAgICAgICBjb21tYVdzcCA9IGZhYnJpYy5jb21tYVdzcCxcblxuICAgICAgICBza2V3WCA9ICcoPzooc2tld1gpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBza2V3WSA9ICcoPzooc2tld1kpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICByb3RhdGUgPSAnKD86KHJvdGF0ZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNjYWxlID0gJyg/OihzY2FsZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICB0cmFuc2xhdGUgPSAnKD86KHRyYW5zbGF0ZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBtYXRyaXggPSAnKD86KG1hdHJpeClcXFxccypcXFxcKFxcXFxzKicgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICtcbiAgICAgICAgICAgICAgICAgICdcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zZm9ybSA9ICcoPzonICtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICByb3RhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBza2V3WCArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdZICtcbiAgICAgICAgICAgICAgICAgICAgJyknLFxuXG4gICAgICAgIHRyYW5zZm9ybXMgPSAnKD86JyArIHRyYW5zZm9ybSArICcoPzonICsgY29tbWFXc3AgKyAnKicgKyB0cmFuc2Zvcm0gKyAnKSonICsgJyknLFxuXG4gICAgICAgIHRyYW5zZm9ybUxpc3QgPSAnXlxcXFxzKig/OicgKyB0cmFuc2Zvcm1zICsgJz8pXFxcXHMqJCcsXG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1RyYW5zZm9ybUF0dHJpYnV0ZVxuICAgICAgICByZVRyYW5zZm9ybUxpc3QgPSBuZXcgUmVnRXhwKHRyYW5zZm9ybUxpc3QpLFxuICAgICAgICAvLyA9PSBlbmQgdHJhbnNmb3JtIHJlZ2V4cFxuXG4gICAgICAgIHJlVHJhbnNmb3JtID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm0sICdnJyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcblxuICAgICAgLy8gc3RhcnQgd2l0aCBpZGVudGl0eSBtYXRyaXhcbiAgICAgIHZhciBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpLFxuICAgICAgICAgIG1hdHJpY2VzID0gW107XG5cbiAgICAgIC8vIHJldHVybiBpZiBubyBhcmd1bWVudCB3YXMgZ2l2ZW4gb3JcbiAgICAgIC8vIGFuIGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIHRyYW5zZm9ybSBhdHRyaWJ1dGUgcmVnZXhwXG4gICAgICBpZiAoIWF0dHJpYnV0ZVZhbHVlIHx8IChhdHRyaWJ1dGVWYWx1ZSAmJiAhcmVUcmFuc2Zvcm1MaXN0LnRlc3QoYXR0cmlidXRlVmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfVxuXG4gICAgICBhdHRyaWJ1dGVWYWx1ZS5yZXBsYWNlKHJlVHJhbnNmb3JtLCBmdW5jdGlvbihtYXRjaCkge1xuXG4gICAgICAgIHZhciBtID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm0pLmV4ZWMobWF0Y2gpLmZpbHRlcihmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gbWF0Y2ggIT09ICcnICYmIG1hdGNoICE9IG51bGxcbiAgICAgICAgICAgICAgcmV0dXJuICghIW1hdGNoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3BlcmF0aW9uID0gbVsxXSxcbiAgICAgICAgICAgIGFyZ3MgPSBtLnNsaWNlKDIpLm1hcChwYXJzZUZsb2F0KTtcblxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICBhcmdzWzBdID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhhcmdzWzBdKTtcbiAgICAgICAgICAgIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgc2NhbGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgICAgIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICAgIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICBtYXRyaXggPSBhcmdzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzbmFwc2hvdCBjdXJyZW50IG1hdHJpeCBpbnRvIG1hdHJpY2VzIGFycmF5XG4gICAgICAgIG1hdHJpY2VzLnB1c2gobWF0cml4LmNvbmNhdCgpKTtcbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY29tYmluZWRNYXRyaXggPSBtYXRyaWNlc1swXTtcbiAgICAgIHdoaWxlIChtYXRyaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1hdHJpY2VzLnNoaWZ0KCk7XG4gICAgICAgIGNvbWJpbmVkTWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhjb21iaW5lZE1hdHJpeCwgbWF0cmljZXNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0cml4O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpIHtcbiAgICB2YXIgYXR0ciwgdmFsdWU7XG4gICAgc3R5bGUucmVwbGFjZSgvO1xccyokLywgJycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHZhciBwYWlyID0gY2h1bmsuc3BsaXQoJzonKTtcblxuICAgICAgYXR0ciA9IHBhaXJbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9ICBwYWlyWzFdLnRyaW0oKTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYXR0ciA9IHByb3AudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIG9TdHlsZVthdHRyXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpIHtcbiAgICB2YXIgc3R5bGVzID0geyB9O1xuICAgIGZvciAodmFyIHJ1bGUgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF0pIHtcbiAgICAgIGlmIChlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgcnVsZS5zcGxpdCgnICcpKSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXSkge1xuICAgICAgICAgIHN0eWxlc1twcm9wZXJ0eV0gPSBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBmaXJzdE1hdGNoaW5nLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgLy9zdGFydCBmcm9tIHJpZ2h0bW9zdCBzZWxlY3Rvci5cbiAgICBmaXJzdE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9ycy5wb3AoKSk7XG4gICAgaWYgKGZpcnN0TWF0Y2hpbmcgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdE1hdGNoaW5nICYmIHBhcmVudE1hdGNoaW5nICYmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIHNlbGVjdG9yLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgaWYgKHBhcmVudE1hdGNoaW5nKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzLnBvcCgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUsXG4gICAgICAgIGNsYXNzTmFtZXMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSxcbiAgICAgICAgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSwgbWF0Y2hlciwgaTtcbiAgICAvLyBpIGNoZWNrIGlmIGEgc2VsZWN0b3IgbWF0Y2hlcyBzbGljaW5nIGF3YXkgcGFydCBmcm9tIGl0LlxuICAgIC8vIGlmIGkgZ2V0IGVtcHR5IHN0cmluZyBpIHNob3VsZCBtYXRjaFxuICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCdeJyArIG5vZGVOYW1lLCAnaScpO1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgaWYgKGlkICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJyMnICsgaWQgKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWVzICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgIGZvciAoaSA9IGNsYXNzTmFtZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCdcXFxcLicgKyBjbGFzc05hbWVzW2ldICsgJyg/IVthLXpBLVpcXFxcLV0rKScsICdpJyk7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rvci5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdG8gc3VwcG9ydCBJRTggbWlzc2luZyBnZXRFbGVtZW50QnlJZCBvbiBTVkdkb2N1bWVudCBhbmQgb24gbm9kZSB4bWxET01cbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRCeUlkKGRvYywgaWQpIHtcbiAgICB2YXIgZWw7XG4gICAgZG9jLmdldEVsZW1lbnRCeUlkICYmIChlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChpZCkpO1xuICAgIGlmIChlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICB2YXIgbm9kZSwgaSwgbGVuLCBub2RlbGlzdCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGVsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZWxpc3RbaV07XG4gICAgICBpZiAoaWQgPT09IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VVc2VEaXJlY3RpdmVzKGRvYykge1xuICAgIHZhciBub2RlbGlzdCA9IF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgWyd1c2UnLCAnc3ZnOnVzZSddKSwgaSA9IDA7XG4gICAgd2hpbGUgKG5vZGVsaXN0Lmxlbmd0aCAmJiBpIDwgbm9kZWxpc3QubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwgPSBub2RlbGlzdFtpXSxcbiAgICAgICAgICB4bGluayA9IChlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkuc3Vic3RyKDEpLFxuICAgICAgICAgIHggPSBlbC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwLFxuICAgICAgICAgIHkgPSBlbC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLFxuICAgICAgICAgIGVsMiA9IGVsZW1lbnRCeUlkKGRvYywgeGxpbmspLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICBjdXJyZW50VHJhbnMgPSAoZWwyLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJycpICsgJyB0cmFuc2xhdGUoJyArIHggKyAnLCAnICsgeSArICcpJyxcbiAgICAgICAgICBwYXJlbnROb2RlLCBvbGRMZW5ndGggPSBub2RlbGlzdC5sZW5ndGgsIGF0dHIsIGosIGF0dHJzLCBsZW4sIG5hbWVzcGFjZSA9IGZhYnJpYy5zdmdOUztcblxuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsMik7XG4gICAgICBpZiAoL15zdmckL2kudGVzdChlbDIubm9kZU5hbWUpKSB7XG4gICAgICAgIHZhciBlbDMgPSBlbDIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAnZycpO1xuICAgICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsMi5hdHRyaWJ1dGVzLCBsZW4gPSBhdHRycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICAgIGVsMy5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbDIuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsMy5hcHBlbmRDaGlsZChlbDIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwyID0gZWwzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3gnIHx8IGF0dHIubm9kZU5hbWUgPT09ICd5JyB8fFxuICAgICAgICAgIGF0dHIubm9kZU5hbWUgPT09ICd4bGluazpocmVmJyB8fCBhdHRyLm5vZGVOYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IGF0dHIubm9kZVZhbHVlICsgJyAnICsgY3VycmVudFRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN1cnJlbnRUcmFucyk7XG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJzEnKTtcbiAgICAgIGVsMi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsMiwgZWwpO1xuICAgICAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc2hvcnRlbiBub2RlbGlzdCBhZnRlciByZXBsYWNlQ2hpbGQgKElFOClcbiAgICAgIGlmIChub2RlbGlzdC5sZW5ndGggPT09IG9sZExlbmd0aCkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAgLy8gbWF0Y2hlcywgZS5nLjogKzE0LjU2ZS0xMiwgZXRjLlxuICB2YXIgcmVWaWV3Qm94QXR0clZhbHVlID0gbmV3IFJlZ0V4cChcbiAgICAnXicgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKicgK1xuICAgICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Zz4gZWxlbWVudCB0aGF0IGVudmVsb3AgYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGUgdmlld2JveCB0cmFuc2Zvcm1NYXRyaXggZGVzY2VuZCBvbiBhbGwgZWxlbWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbGVtZW50KSB7XG4gICAgaWYgKCFmYWJyaWMuc3ZnVmlld0JveEVsZW1lbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmlld0JveEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLFxuICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICBzY2FsZVkgPSAxLFxuICAgICAgICBtaW5YID0gMCxcbiAgICAgICAgbWluWSA9IDAsXG4gICAgICAgIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCwgbWF0cml4LCBlbCxcbiAgICAgICAgd2lkdGhBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgIGhlaWdodEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgIHggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgIHkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnLFxuICAgICAgICBtaXNzaW5nVmlld0JveCA9ICghdmlld0JveEF0dHIgfHwgISh2aWV3Qm94QXR0ciA9IHZpZXdCb3hBdHRyLm1hdGNoKHJlVmlld0JveEF0dHJWYWx1ZSkpKSxcbiAgICAgICAgbWlzc2luZ0RpbUF0dHIgPSAoIXdpZHRoQXR0ciB8fCAhaGVpZ2h0QXR0ciB8fCB3aWR0aEF0dHIgPT09ICcxMDAlJyB8fCBoZWlnaHRBdHRyID09PSAnMTAwJScpLFxuICAgICAgICB0b0JlUGFyc2VkID0gbWlzc2luZ1ZpZXdCb3ggJiYgbWlzc2luZ0RpbUF0dHIsXG4gICAgICAgIHBhcnNlZERpbSA9IHsgfSwgdHJhbnNsYXRlTWF0cml4ID0gJycsIHdpZHRoRGlmZiA9IDAsIGhlaWdodERpZmYgPSAwO1xuXG4gICAgcGFyc2VkRGltLndpZHRoID0gMDtcbiAgICBwYXJzZWREaW0uaGVpZ2h0ID0gMDtcbiAgICBwYXJzZWREaW0udG9CZVBhcnNlZCA9IHRvQmVQYXJzZWQ7XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIGlmICgoKHggfHwgeSkgJiYgZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lICE9PSAnI2RvY3VtZW50JykpIHtcbiAgICAgICAgdHJhbnNsYXRlTWF0cml4ID0gJyB0cmFuc2xhdGUoJyArIHBhcnNlVW5pdCh4KSArICcgJyArIHBhcnNlVW5pdCh5KSArICcpICc7XG4gICAgICAgIG1hdHJpeCA9IChlbGVtZW50LmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJycpICsgdHJhbnNsYXRlTWF0cml4O1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3knKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9CZVBhcnNlZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHBhcnNlVW5pdCh3aWR0aEF0dHIpO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHBhcnNlVW5pdChoZWlnaHRBdHRyKTtcbiAgICAgIC8vIHNldCBhIHRyYW5zZm9ybSBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHggeSBhbmQgYXJlIGlubmVyKG9ubHkpIFNWR3NcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuICAgIG1pblggPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsxXSk7XG4gICAgbWluWSA9IC1wYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzJdKTtcbiAgICB2aWV3Qm94V2lkdGggPSBwYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzNdKTtcbiAgICB2aWV3Qm94SGVpZ2h0ID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0cls0XSk7XG4gICAgcGFyc2VkRGltLm1pblggPSBtaW5YO1xuICAgIHBhcnNlZERpbS5taW5ZID0gbWluWTtcbiAgICBwYXJzZWREaW0udmlld0JveFdpZHRoID0gdmlld0JveFdpZHRoO1xuICAgIHBhcnNlZERpbS52aWV3Qm94SGVpZ2h0ID0gdmlld0JveEhlaWdodDtcbiAgICBpZiAoIW1pc3NpbmdEaW1BdHRyKSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICBzY2FsZVggPSBwYXJzZWREaW0ud2lkdGggLyB2aWV3Qm94V2lkdGg7XG4gICAgICBzY2FsZVkgPSBwYXJzZWREaW0uaGVpZ2h0IC8gdmlld0JveEhlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSB2aWV3Qm94V2lkdGg7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gdmlld0JveEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IGlzIHRvIHByZXNlcnZlIGFzcGVjdCByYXRpb1xuICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBmYWJyaWMudXRpbC5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUocHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25YICE9PSAnbm9uZScpIHtcbiAgICAgIC8vdHJhbnNsYXRlIGFsbCBjb250YWluZXIgZm9yIHRoZSBlZmZlY3Qgb2YgTWlkLCBNaW4sIE1heFxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8ubWVldE9yU2xpY2UgPT09ICdtZWV0Jykge1xuICAgICAgICBzY2FsZVkgPSBzY2FsZVggPSAoc2NhbGVYID4gc2NhbGVZID8gc2NhbGVZIDogc2NhbGVYKTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGFkZGl0aW9uYWwgdHJhbnNsYXRpb24gdG8gbW92ZSB0aGUgdmlld2JveFxuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8ubWVldE9yU2xpY2UgPT09ICdzbGljZScpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWCA6IHNjYWxlWSk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIHdpZHRoRGlmZiA9IHBhcnNlZERpbS53aWR0aCAtIHZpZXdCb3hXaWR0aCAqIHNjYWxlWDtcbiAgICAgIGhlaWdodERpZmYgPSBwYXJzZWREaW0uaGVpZ2h0IC0gdmlld0JveEhlaWdodCAqIHNjYWxlWDtcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCA9PT0gJ01pZCcpIHtcbiAgICAgICAgd2lkdGhEaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaWQnKSB7XG4gICAgICAgIGhlaWdodERpZmYgLz0gMjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCA9PT0gJ01pbicpIHtcbiAgICAgICAgd2lkdGhEaWZmID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWSA9PT0gJ01pbicpIHtcbiAgICAgICAgaGVpZ2h0RGlmZiA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEgJiYgbWluWCA9PT0gMCAmJiBtaW5ZID09PSAwICYmIHggPT09IDAgJiYgeSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG4gICAgaWYgKCh4IHx8IHkpICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudCcpIHtcbiAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgIH1cblxuICAgIG1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeCArICcgbWF0cml4KCcgKyBzY2FsZVggK1xuICAgICAgICAgICAgICAgICAgJyAwJyArXG4gICAgICAgICAgICAgICAgICAnIDAgJyArXG4gICAgICAgICAgICAgICAgICBzY2FsZVkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgKG1pblggKiBzY2FsZVggKyB3aWR0aERpZmYpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5ZICogc2NhbGVZICsgaGVpZ2h0RGlmZikgKyAnKSAnO1xuICAgIC8vIHNlZW1zIHVudXNlZC5cbiAgICAvLyBwYXJzZWREaW0udmlld2JveFRyYW5zZm9ybSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZShtYXRyaXgpO1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnc3ZnJykge1xuICAgICAgZWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZhYnJpYy5zdmdOUywgJ2cnKTtcbiAgICAgIC8vIGVsZW1lbnQuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbCA9IGVsZW1lbnQ7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgneScpO1xuICAgICAgbWF0cml4ID0gZWwuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSArIG1hdHJpeDtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBtYXRyaXgpO1xuICAgIHJldHVybiBwYXJzZWREaW07XG4gIH1cblxuICBmdW5jdGlvbiBoYXNBbmNlc3RvcldpdGhOb2RlTmFtZShlbGVtZW50LCBub2RlTmFtZSkge1xuICAgIHdoaWxlIChlbGVtZW50ICYmIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlKSkge1xuICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgJiYgbm9kZU5hbWUudGVzdChlbGVtZW50Lm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXG4gICAgICAgICYmICFlbGVtZW50LmdldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIFNWRyBkb2N1bWVudCwgY29udmVydHMgaXQgdG8gYW4gYXJyYXkgb2YgY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXMgYW5kIHBhc3NlcyB0aGVtIHRvIGEgY2FsbGJhY2tcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGNhbGwgd2hlbiBwYXJzaW5nIGlzIGZpbmlzaGVkO1xuICAgKiBJdCdzIGJlaW5nIHBhc3NlZCBhbiBhcnJheSBvZiBlbGVtZW50cyAocGFyc2VkIGZyb20gYSBkb2N1bWVudCkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJzaW5nT3B0aW9uc10gb3B0aW9ucyBmb3IgcGFyc2luZyBkb2N1bWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcnNpbmdPcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBzZXR0aW5nc1xuICAgKi9cbiAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQgPSBmdW5jdGlvbihkb2MsIGNhbGxiYWNrLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFyc2VVc2VEaXJlY3RpdmVzKGRvYyk7XG5cbiAgICB2YXIgc3ZnVWlkID0gIGZhYnJpYy5PYmplY3QuX191aWQrKywgaSwgbGVuLFxuICAgICAgICBvcHRpb25zID0gYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGRvYyksXG4gICAgICAgIGRlc2NlbmRhbnRzID0gZmFicmljLnV0aWwudG9BcnJheShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSk7XG4gICAgb3B0aW9ucy5jcm9zc09yaWdpbiA9IHBhcnNpbmdPcHRpb25zICYmIHBhcnNpbmdPcHRpb25zLmNyb3NzT3JpZ2luO1xuICAgIG9wdGlvbnMuc3ZnVWlkID0gc3ZnVWlkO1xuXG4gICAgaWYgKGRlc2NlbmRhbnRzLmxlbmd0aCA9PT0gMCAmJiBmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICAvLyB3ZSdyZSBsaWtlbHkgaW4gbm9kZSwgd2hlcmUgXCJvMy14bWxcIiBsaWJyYXJ5IGZhaWxzIHRvIGdFQlROKFwiKlwiKVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FqYXhvcmcvbm9kZS1vMy14bWwvaXNzdWVzLzIxXG4gICAgICBkZXNjZW5kYW50cyA9IGRvYy5zZWxlY3ROb2RlcygnLy8qW25hbWUoLikhPVwic3ZnXCJdJyk7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkZXNjZW5kYW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBkZXNjZW5kYW50c1tpXTtcbiAgICAgIH1cbiAgICAgIGRlc2NlbmRhbnRzID0gYXJyO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IGRlc2NlbmRhbnRzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4LnRlc3QoZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSkgJiZcbiAgICAgICAgICAgICFoYXNBbmNlc3RvcldpdGhOb2RlTmFtZShlbCwgZmFicmljLnN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCk7IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNEZWZzRWxlbWVudFxuICAgIH0pO1xuICAgIGlmICghZWxlbWVudHMgfHwgKGVsZW1lbnRzICYmICFlbGVtZW50cy5sZW5ndGgpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSwge30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2xpcFBhdGhzID0geyB9O1xuICAgIGRlc2NlbmRhbnRzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykgPT09ICdjbGlwUGF0aCc7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGlkID0gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgY2xpcFBhdGhzW2lkXSA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4LnRlc3QoZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmYWJyaWMuZ3JhZGllbnREZWZzW3N2Z1VpZF0gPSBmYWJyaWMuZ2V0R3JhZGllbnREZWZzKGRvYyk7XG4gICAgZmFicmljLmNzc1J1bGVzW3N2Z1VpZF0gPSBmYWJyaWMuZ2V0Q1NTUnVsZXMoZG9jKTtcbiAgICBmYWJyaWMuY2xpcFBhdGhzW3N2Z1VpZF0gPSBjbGlwUGF0aHM7XG4gICAgLy8gUHJlY2VkZW5jZSBvZiBydWxlczogICBzdHlsZSA+IGNsYXNzID4gYXR0cmlidXRlXG4gICAgZmFicmljLnBhcnNlRWxlbWVudHMoZWxlbWVudHMsIGZ1bmN0aW9uKGluc3RhbmNlcywgZWxlbWVudHMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpbnN0YW5jZXMsIG9wdGlvbnMsIGVsZW1lbnRzLCBkZXNjZW5kYW50cyk7XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuZ3JhZGllbnREZWZzW3N2Z1VpZF07XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXTtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5jbGlwUGF0aHNbc3ZnVWlkXTtcbiAgICAgIH1cbiAgICB9LCBjbG9uZShvcHRpb25zKSwgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIGdyYWRpZW50KSB7XG4gICAgdmFyIGdyYWRpZW50c0F0dHJzID0gWydncmFkaWVudFRyYW5zZm9ybScsICd4MScsICd4MicsICd5MScsICd5MicsICdncmFkaWVudFVuaXRzJywgJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknXSxcbiAgICAgICAgeGxpbmtBdHRyID0gJ3hsaW5rOmhyZWYnLFxuICAgICAgICB4TGluayA9IGdyYWRpZW50LmdldEF0dHJpYnV0ZSh4bGlua0F0dHIpLnN1YnN0cigxKSxcbiAgICAgICAgcmVmZXJlbmNlZEdyYWRpZW50ID0gZWxlbWVudEJ5SWQoZG9jLCB4TGluayk7XG4gICAgaWYgKHJlZmVyZW5jZWRHcmFkaWVudCAmJiByZWZlcmVuY2VkR3JhZGllbnQuZ2V0QXR0cmlidXRlKHhsaW5rQXR0cikpIHtcbiAgICAgIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIHJlZmVyZW5jZWRHcmFkaWVudCk7XG4gICAgfVxuICAgIGdyYWRpZW50c0F0dHJzLmZvckVhY2goZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKHJlZmVyZW5jZWRHcmFkaWVudCAmJiAhZ3JhZGllbnQuaGFzQXR0cmlidXRlKGF0dHIpICYmIHJlZmVyZW5jZWRHcmFkaWVudC5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlKGF0dHIsIHJlZmVyZW5jZWRHcmFkaWVudC5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZ3JhZGllbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlQ2xvbmUgPSByZWZlcmVuY2VkR3JhZGllbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgd2hpbGUgKHJlZmVyZW5jZUNsb25lLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZ3JhZGllbnQuYXBwZW5kQ2hpbGQocmVmZXJlbmNlQ2xvbmUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdyYWRpZW50LnJlbW92ZUF0dHJpYnV0ZSh4bGlua0F0dHIpO1xuICB9XG5cbiAgdmFyIHJlRm9udERlY2xhcmF0aW9uID0gbmV3IFJlZ0V4cChcbiAgICAnKG5vcm1hbHxpdGFsaWMpP1xcXFxzKihub3JtYWx8c21hbGwtY2Fwcyk/XFxcXHMqJyArXG4gICAgJyhub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMCk/XFxcXHMqKCcgK1xuICAgICAgZmFicmljLnJlTnVtICtcbiAgICAnKD86cHh8Y218bW18ZW18cHR8cGN8aW4pKikoPzpcXFxcLyhub3JtYWx8JyArIGZhYnJpYy5yZU51bSArICcpKT9cXFxccysoLiopJyk7XG5cbiAgZXh0ZW5kKGZhYnJpYywge1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNob3J0IGZvbnQgZGVjbGFyYXRpb24sIGJ1aWxkaW5nIGFkZGluZyBpdHMgcHJvcGVydGllcyB0byBhIHN0eWxlIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGZvbnQgZGVjbGFyYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb1N0eWxlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBwYXJzZUZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24odmFsdWUsIG9TdHlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVGb250RGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmb250U3R5bGUgPSBtYXRjaFsxXSxcbiAgICAgICAgICAvLyBmb250IHZhcmlhbnQgaXMgbm90IHVzZWRcbiAgICAgICAgICAvLyBmb250VmFyaWFudCA9IG1hdGNoWzJdLFxuICAgICAgICAgIGZvbnRXZWlnaHQgPSBtYXRjaFszXSxcbiAgICAgICAgICBmb250U2l6ZSA9IG1hdGNoWzRdLFxuICAgICAgICAgIGxpbmVIZWlnaHQgPSBtYXRjaFs1XSxcbiAgICAgICAgICBmb250RmFtaWx5ID0gbWF0Y2hbNl07XG5cbiAgICAgIGlmIChmb250U3R5bGUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250V2VpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5mb250V2VpZ2h0ID0gaXNOYU4ocGFyc2VGbG9hdChmb250V2VpZ2h0KSkgPyBmb250V2VpZ2h0IDogcGFyc2VGbG9hdChmb250V2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250U2l6ZSkge1xuICAgICAgICBvU3R5bGUuZm9udFNpemUgPSBwYXJzZVVuaXQoZm9udFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRGYW1pbHkpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJyA/IDEgOiBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gU1ZHIGRvY3VtZW50LCByZXR1cm5pbmcgYWxsIG9mIHRoZSBncmFkaWVudCBkZWNsYXJhdGlvbnMgZm91bmQgaW4gaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEdyYWRpZW50IGRlZmluaXRpb25zOyBrZXkgY29ycmVzcG9uZHMgdG8gZWxlbWVudCBpZCwgdmFsdWUgLS0gdG8gZ3JhZGllbnQgZGVmaW5pdGlvbiBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0R3JhZGllbnREZWZzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciB0YWdBcnJheSA9IFtcbiAgICAgICAgICAgICdsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOnJhZGlhbEdyYWRpZW50J10sXG4gICAgICAgICAgZWxMaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCB0YWdBcnJheSksXG4gICAgICAgICAgZWwsIGogPSAwLCBncmFkaWVudERlZnMgPSB7IH07XG4gICAgICBqID0gZWxMaXN0Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgZWwgPSBlbExpc3Rbal07XG4gICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSkge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudERlZnNbZWwuZ2V0QXR0cmlidXRlKCdpZCcpXSA9IGVsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50RGVmcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcycgbmFtZS92YWx1ZSwgZ2l2ZW4gZWxlbWVudCBhbmQgYW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzO1xuICAgICAqIFBhcnNlcyBwYXJlbnQgXCJnXCIgbm9kZXMgcmVjdXJzaXZlbHkgdXB3YXJkcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJzZWQgYXR0cmlidXRlcycgbmFtZXMvdmFsdWVzXG4gICAgICovXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzLCBzdmdVaWQpIHtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSB7IH0sXG4gICAgICAgICAgZm9udFNpemUsIHBhcmVudEZvbnRTaXplO1xuXG4gICAgICBpZiAodHlwZW9mIHN2Z1VpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3ZnVWlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N2Z1VpZCcpO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUncyBhIHBhcmVudCBjb250YWluZXIgKGBnYCBvciBgYWAgb3IgYHN5bWJvbGAgbm9kZSksIHBhcnNlIGl0cyBhdHRyaWJ1dGVzIHJlY3Vyc2l2ZWx5IHVwd2FyZHNcbiAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LnBhcmVudE5vZGUsIGF0dHJpYnV0ZXMsIHN2Z1VpZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvd25BdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgYXR0cikge1xuICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICBpZiAodmFsdWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIG1lbW9bYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHsgfSk7XG4gICAgICAvLyBhZGQgdmFsdWVzIHBhcnNlZCBmcm9tIHN0eWxlLCB3aGljaCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhdHRyaWJ1dGVzXG4gICAgICAvLyAoc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3R5bGluZy5odG1sI1VzaW5nUHJlc2VudGF0aW9uQXR0cmlidXRlcylcbiAgICAgIHZhciBjc3NBdHRycyA9IGV4dGVuZChcbiAgICAgICAgZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpLFxuICAgICAgICBmYWJyaWMucGFyc2VTdHlsZUF0dHJpYnV0ZShlbGVtZW50KVxuICAgICAgKTtcbiAgICAgIG93bkF0dHJpYnV0ZXMgPSBleHRlbmQoXG4gICAgICAgIG93bkF0dHJpYnV0ZXMsXG4gICAgICAgIGNzc0F0dHJzXG4gICAgICApO1xuICAgICAgaWYgKGNzc0F0dHJzW2NQYXRoXSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShjUGF0aCwgY3NzQXR0cnNbY1BhdGhdKTtcbiAgICAgIH1cbiAgICAgIGZvbnRTaXplID0gcGFyZW50Rm9udFNpemUgPSBwYXJlbnRBdHRyaWJ1dGVzLmZvbnRTaXplIHx8IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICAgIGlmIChvd25BdHRyaWJ1dGVzW2ZTaXplXSkge1xuICAgICAgICAvLyBsb29rcyBsaWtlIHRoZSBtaW5pbXVtIHNob3VsZCBiZSA5cHggd2hlbiBkZWFsaW5nIHdpdGggZW1zLiB0aGlzIGlzIHdoYXQgbG9va3MgbGlrZSBpbiBicm93c2Vycy5cbiAgICAgICAgb3duQXR0cmlidXRlc1tmU2l6ZV0gPSBmb250U2l6ZSA9IHBhcnNlVW5pdChvd25BdHRyaWJ1dGVzW2ZTaXplXSwgcGFyZW50Rm9udFNpemUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplZEF0dHIsIG5vcm1hbGl6ZWRWYWx1ZSwgbm9ybWFsaXplZFN0eWxlID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG93bkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbm9ybWFsaXplZEF0dHIgPSBub3JtYWxpemVBdHRyKGF0dHIpO1xuICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVWYWx1ZShub3JtYWxpemVkQXR0ciwgb3duQXR0cmlidXRlc1thdHRyXSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpO1xuICAgICAgICBub3JtYWxpemVkU3R5bGVbbm9ybWFsaXplZEF0dHJdID0gbm9ybWFsaXplZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vcm1hbGl6ZWRTdHlsZSAmJiBub3JtYWxpemVkU3R5bGUuZm9udCkge1xuICAgICAgICBmYWJyaWMucGFyc2VGb250RGVjbGFyYXRpb24obm9ybWFsaXplZFN0eWxlLmZvbnQsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWVyZ2VkQXR0cnMgPSBleHRlbmQocGFyZW50QXR0cmlidXRlcywgbm9ybWFsaXplZFN0eWxlKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSA/IG1lcmdlZEF0dHJzIDogX3NldFN0cm9rZUZpbGxPcGFjaXR5KG1lcmdlZEF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBzdmcgZWxlbWVudHMgdG8gY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIEFycmF5IG9mIGVsZW1lbnRzIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQmVpbmcgcGFzc2VkIGFuIGFycmF5IG9mIGZhYnJpYyBpbnN0YW5jZXMgKHRyYW5zZm9ybWVkIGZyb20gU1ZHIGVsZW1lbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcGFyc2VFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgICAgbmV3IGZhYnJpYy5FbGVtZW50c1BhcnNlcihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKS5wYXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJzdHlsZVwiIGF0dHJpYnV0ZSwgcmV0dW5pbmcgYW4gb2JqZWN0IHdpdGggdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0cyB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSBhdHRyaWJ1dGUgb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHBhcnNlU3R5bGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvU3R5bGUgPSB7IH0sXG4gICAgICAgICAgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gb1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInBvaW50c1wiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50cyBwb2ludHMgYXR0cmlidXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBwYXJzZVBvaW50c0F0dHJpYnV0ZTogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgIC8vIHBvaW50cyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjb21tYXMgd2l0aCB3aGl0ZXNwYWNlIGFuZCByZW1vdmUgYm9va2VuZGluZyB3aGl0ZXNwYWNlXG4gICAgICBwb2ludHMgPSBwb2ludHMucmVwbGFjZSgvLC9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgcGFyc2VkUG9pbnRzID0gW10sIGksIGxlbjtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHBhcnNlZFBvaW50cy5wdXNoKHtcbiAgICAgICAgICB4OiBwYXJzZUZsb2F0KHBvaW50c1tpXSksXG4gICAgICAgICAgeTogcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gb2RkIG51bWJlciBvZiBwb2ludHMgaXMgYW4gZXJyb3JcbiAgICAgIC8vIGlmIChwYXJzZWRQb2ludHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZFBvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgcnVsZXMgZm9yIGEgZ2l2ZW4gU1ZHIGRvY3VtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDU1MgcnVsZXMgb2YgdGhpcyBkb2N1bWVudFxuICAgICAqL1xuICAgIGdldENTU1J1bGVzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJyksIGksIGxlbixcbiAgICAgICAgICBhbGxSdWxlcyA9IHsgfSwgcnVsZXM7XG5cbiAgICAgIC8vIHZlcnkgY3J1ZGUgcGFyc2luZyBvZiBzdHlsZSBjb250ZW50c1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3R5bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbnRlbnRzID0gc3R5bGVzW2ldLnRleHRDb250ZW50O1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICBzdHlsZUNvbnRlbnRzID0gc3R5bGVDb250ZW50cy5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgaWYgKHN0eWxlQ29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGVzID0gc3R5bGVDb250ZW50cy5tYXRjaCgvW157XSpcXHtbXFxzXFxTXSo/XFx9L2cpO1xuICAgICAgICBydWxlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbihydWxlKSB7IHJldHVybiBydWxlLnRyaW0oKTsgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKC8oW1xcc1xcU10qPylcXHMqXFx7KFtefV0qKVxcfS8pLFxuICAgICAgICAgICAgICBydWxlT2JqID0geyB9LCBkZWNsYXJhdGlvbiA9IG1hdGNoWzJdLnRyaW0oKSxcbiAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZVBhaXJzID0gZGVjbGFyYXRpb24ucmVwbGFjZSgvOyQvLCAnJykuc3BsaXQoL1xccyo7XFxzKi8pO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvcGVydHlWYWx1ZVBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHByb3BlcnR5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYWlyWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFpclsxXTtcbiAgICAgICAgICAgIHJ1bGVPYmpbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJ1bGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICBydWxlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbihfcnVsZSkge1xuICAgICAgICAgICAgX3J1bGUgPSBfcnVsZS5yZXBsYWNlKC9ec3ZnL2ksICcnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoX3J1bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxSdWxlc1tfcnVsZV0pIHtcbiAgICAgICAgICAgICAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChhbGxSdWxlc1tfcnVsZV0sIHJ1bGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFsbFJ1bGVzW19ydWxlXSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsUnVsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHVybCBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzLlxuICAgICAqIE5vdGUgdGhhdCBTVkcgaXMgZmV0Y2hlZCB2aWEgWE1MSHR0cFJlcXVlc3QsIHNvIGl0IG5lZWRzIHRvIGNvbmZvcm0gdG8gU09QIChTYW1lIE9yaWdpbiBQb2xpY3kpXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIGNyb3NzT3JpZ2luIHNldHRpbmcgdG8gdXNlIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVVSTDogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgcmV2aXZlciwgb3B0aW9ucykge1xuXG4gICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXlxcblxccyovLCAnJykudHJpbSgpO1xuICAgICAgbmV3IGZhYnJpYy51dGlsLnJlcXVlc3QodXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlKHIpIHtcblxuICAgICAgICB2YXIgeG1sID0gci5yZXNwb25zZVhNTDtcbiAgICAgICAgaWYgKCF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudCh4bWwuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gYW4gU1ZHIGRvY3VtZW50LCBhbmQgcGFyc2VzIGl0IGludG8gYSBzZXQgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gY3Jvc3NPcmlnaW4gc2V0dGluZyB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGxvYWRTVkdGcm9tU3RyaW5nOiBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IGZhYnJpYy53aW5kb3cuRE9NUGFyc2VyKCksXG4gICAgICAgICAgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdHJpbmcudHJpbSgpLCAndGV4dC94bWwnKTtcbiAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KGRvYy5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgfSwgcmV2aXZlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMsIGRvYykge1xuICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgdGhpcy5zdmdVaWQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnN2Z1VpZCkgfHwgMDtcbiAgdGhpcy5wYXJzaW5nT3B0aW9ucyA9IHBhcnNpbmdPcHRpb25zO1xuICB0aGlzLnJlZ2V4VXJsID0gL151cmxcXChbJ1wiXT8jKFteJ1wiXSspWydcIl0/XFwpL2c7XG4gIHRoaXMuZG9jID0gZG9jO1xufTtcblxuKGZ1bmN0aW9uKHByb3RvKSB7XG4gIHByb3RvLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgQXJyYXkodGhpcy5lbGVtZW50cy5sZW5ndGgpO1xuICAgIHRoaXMubnVtRWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLmNyZWF0ZU9iamVjdHMoKTtcbiAgfTtcblxuICBwcm90by5jcmVhdGVPYmplY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N2Z1VpZCcsIF90aGlzLnN2Z1VpZCk7XG4gICAgICBfdGhpcy5jcmVhdGVPYmplY3QoZWxlbWVudCwgaSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdG8uZmluZFRhZyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGZhYnJpY1tmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShlbC50YWdOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXTtcbiAgfTtcblxuICBwcm90by5jcmVhdGVPYmplY3QgPSBmdW5jdGlvbihlbCwgaW5kZXgpIHtcbiAgICB2YXIga2xhc3MgPSB0aGlzLmZpbmRUYWcoZWwpO1xuICAgIGlmIChrbGFzcyAmJiBrbGFzcy5mcm9tRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAga2xhc3MuZnJvbUVsZW1lbnQoZWwsIHRoaXMuY3JlYXRlQ2FsbGJhY2soaW5kZXgsIGVsKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZmFicmljLmxvZyhlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tJZkRvbmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihpbmRleCwgZWwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBfb3B0aW9ucztcbiAgICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosIGVsLCAnZmlsbCcpO1xuICAgICAgX3RoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgZWwsICdzdHJva2UnKTtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBmYWJyaWMuSW1hZ2UgJiYgb2JqLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgX29wdGlvbnMgPSBvYmoucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKGVsKTtcbiAgICAgIH1cbiAgICAgIG9iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KF9vcHRpb25zKTtcbiAgICAgIF90aGlzLnJlc29sdmVDbGlwUGF0aChvYmosIGVsKTtcbiAgICAgIF90aGlzLnJldml2ZXIgJiYgX3RoaXMucmV2aXZlcihlbCwgb2JqKTtcbiAgICAgIF90aGlzLmluc3RhbmNlc1tpbmRleF0gPSBvYmo7XG4gICAgICBfdGhpcy5jaGVja0lmRG9uZSgpO1xuICAgIH07XG4gIH07XG5cbiAgcHJvdG8uZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJvcGVydHksIHN0b3JhZ2UpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcGVydHldLCByZWdleCA9IHRoaXMucmVnZXhVcmw7XG4gICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdleC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBpZCA9IHJlZ2V4LmV4ZWModmFsdWUpWzFdO1xuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGZhYnJpY1tzdG9yYWdlXVt0aGlzLnN2Z1VpZF1baWRdO1xuICB9O1xuXG4gIHByb3RvLnJlc29sdmVHcmFkaWVudCA9IGZ1bmN0aW9uKG9iaiwgZWwsIHByb3BlcnR5KSB7XG4gICAgdmFyIGdyYWRpZW50RGVmID0gdGhpcy5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uKG9iaiwgcHJvcGVydHksICdncmFkaWVudERlZnMnKTtcbiAgICBpZiAoZ3JhZGllbnREZWYpIHtcbiAgICAgIHZhciBvcGFjaXR5QXR0ciA9IGVsLmdldEF0dHJpYnV0ZShwcm9wZXJ0eSArICctb3BhY2l0eScpO1xuICAgICAgdmFyIGdyYWRpZW50ID0gZmFicmljLkdyYWRpZW50LmZyb21FbGVtZW50KGdyYWRpZW50RGVmLCBvYmosIG9wYWNpdHlBdHRyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgb2JqLnNldChwcm9wZXJ0eSwgZ3JhZGllbnQpO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jcmVhdGVDbGlwUGF0aENhbGxiYWNrID0gZnVuY3Rpb24ob2JqLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oX25ld09iaikge1xuICAgICAgX25ld09iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBfbmV3T2JqLmZpbGxSdWxlID0gX25ld09iai5jbGlwUnVsZTtcbiAgICAgIGNvbnRhaW5lci5wdXNoKF9uZXdPYmopO1xuICAgIH07XG4gIH07XG5cbiAgcHJvdG8ucmVzb2x2ZUNsaXBQYXRoID0gZnVuY3Rpb24ob2JqLCB1c2luZ0VsZW1lbnQpIHtcbiAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24ob2JqLCAnY2xpcFBhdGgnLCAnY2xpcFBhdGhzJyksXG4gICAgICAgIGVsZW1lbnQsIGtsYXNzLCBvYmpUcmFuc2Zvcm1JbnYsIGNvbnRhaW5lciwgZ1RyYW5zZm9ybSwgb3B0aW9ucztcbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGNvbnRhaW5lciA9IFtdO1xuICAgICAgb2JqVHJhbnNmb3JtSW52ID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG9iai5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgLy8gbW92ZSB0aGUgY2xpcFBhdGggdGFnIGFzIHNpYmxpbmcgdG8gdGhlIHJlYWwgZWxlbWVudCB0aGF0IGlzIHVzaW5nIGl0XG4gICAgICB2YXIgY2xpcFBhdGhUYWcgPSBjbGlwUGF0aFswXS5wYXJlbnROb2RlO1xuICAgICAgdmFyIGNsaXBQYXRoT3duZXIgPSB1c2luZ0VsZW1lbnQ7XG4gICAgICB3aGlsZSAoY2xpcFBhdGhPd25lci5wYXJlbnROb2RlICYmIGNsaXBQYXRoT3duZXIuZ2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnKSAhPT0gb2JqLmNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoT3duZXIgPSBjbGlwUGF0aE93bmVyLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aE93bmVyLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2xpcFBhdGhUYWcpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gY2xpcFBhdGhbaV07XG4gICAgICAgIGtsYXNzID0gdGhpcy5maW5kVGFnKGVsZW1lbnQpO1xuICAgICAgICBrbGFzcy5mcm9tRWxlbWVudChcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHRoaXMuY3JlYXRlQ2xpcFBhdGhDYWxsYmFjayhvYmosIGNvbnRhaW5lciksXG4gICAgICAgICAgdGhpcy5vcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjbGlwUGF0aCA9IGNvbnRhaW5lclswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjbGlwUGF0aCA9IG5ldyBmYWJyaWMuR3JvdXAoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIGdUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICBvYmpUcmFuc2Zvcm1JbnYsXG4gICAgICAgIGNsaXBQYXRoLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKVxuICAgICAgKTtcbiAgICAgIGlmIChjbGlwUGF0aC5jbGlwUGF0aCkge1xuICAgICAgICB0aGlzLnJlc29sdmVDbGlwUGF0aChjbGlwUGF0aCwgY2xpcFBhdGhPd25lcik7XG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKGdUcmFuc2Zvcm0pO1xuICAgICAgY2xpcFBhdGguZmxpcFggPSBmYWxzZTtcbiAgICAgIGNsaXBQYXRoLmZsaXBZID0gZmFsc2U7XG4gICAgICBjbGlwUGF0aC5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgIGNsaXBQYXRoLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgY2xpcFBhdGguYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgY2xpcFBhdGguc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgY2xpcFBhdGguc2tld1kgPSAwO1xuICAgICAgY2xpcFBhdGguc2V0UG9zaXRpb25CeU9yaWdpbih7IHg6IG9wdGlvbnMudHJhbnNsYXRlWCwgeTogb3B0aW9ucy50cmFuc2xhdGVZIH0sICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmouY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBpZiBjbGlwLXBhdGggZG9lcyBub3QgcmVzb2x2ZSB0byBhbnkgZWxlbWVudCwgZGVsZXRlIHRoZSBwcm9wZXJ0eS5cbiAgICAgIGRlbGV0ZSBvYmouY2xpcFBhdGg7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmNoZWNrSWZEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tdGhpcy5udW1FbGVtZW50cyA9PT0gMCkge1xuICAgICAgdGhpcy5pbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuICAgICAgICByZXR1cm4gZWwgIT0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLmluc3RhbmNlcywgdGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICB9O1xufSkoZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Qb2ludCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9pbnQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZmFicmljLlBvaW50ID0gUG9pbnQ7XG5cbiAgLyoqXG4gICAqIFBvaW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9pbnRcbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgUG9pbnQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuUG9pbnQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdwb2ludCcsXG5cbiAgICBjb25zdHJ1Y3RvcjogUG9pbnQsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmUgYW5kIHJldHVybnMgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IGluc3RhbmNlIHdpdGggYWRkZWQgdmFsdWVzXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGF0LngsIHRoaXMueSArIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCArPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgKz0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgd2l0aCBhZGRlZCB2YWx1ZVxuICAgICAqL1xuICAgIHNjYWxhckFkZDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBzY2FsYXIsIHRoaXMueSArIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyQWRkRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKz0gc2NhbGFyO1xuICAgICAgdGhpcy55ICs9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBvYmplY3Qgd2l0aCBzdWJ0cmFjdGVkIHZhbHVlc1xuICAgICAqL1xuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSB0aGF0LngsIHRoaXMueSAtIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54IC09IHRoYXQueDtcbiAgICAgIHRoaXMueSAtPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHNjYWxhciwgdGhpcy55IC0gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAtPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLT0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHlFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtdWx0aXBseUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGRpdmlkZTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBzY2FsYXIsIHRoaXMueSAvIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpdmlkZUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC89IHNjYWxhcjtcbiAgICAgIHRoaXMueSAvPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZXE6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA9PT0gdGhhdC54ICYmIHRoaXMueSA9PT0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPCB0aGF0LnggJiYgdGhpcy55IDwgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDw9IHRoYXQueCAmJiB0aGlzLnkgPD0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG5cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPiB0aGF0LnggJiYgdGhpcy55ID4gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID49IHRoYXQueCAmJiB0aGlzLnkgPj0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHRoaXMgb25lIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLCBwb3NpdGlvbiBvZiBpbnRlcnBvbGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDEgZGVmYXVsdCAwLjVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbGVycDogZnVuY3Rpb24gKHRoYXQsIHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdCA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHQgPSBNYXRoLm1heChNYXRoLm1pbigxLCB0KSwgMCk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArICh0aGF0LnggLSB0aGlzLngpICogdCwgdGhpcy55ICsgKHRoYXQueSAtIHRoaXMueSkgKiB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZGlzdGFuY2VGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdGhhdC54LFxuICAgICAgICAgIGR5ID0gdGhpcy55IC0gdGhhdC55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaWRQb2ludEZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoYXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtaW4gb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWluKHRoaXMueCwgdGhhdC54KSwgTWF0aC5taW4odGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWF4IG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1heCh0aGlzLngsIHRoYXQueCksIE1hdGgubWF4KHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyAnLCcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFhZOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHkgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnQgZnJvbSBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RnJvbVBvaW50OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3YXBzIHgveSBvZiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKi9cbiAgICBzd2FwOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueTtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHRoYXQueCA9IHg7XG4gICAgICB0aGF0LnkgPSB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhlIHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5JbnRlcnNlY3Rpb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkludGVyc2VjdGlvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJzZWN0aW9uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW50ZXJzZWN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnNlY3Rpb24oc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfVxuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24gPSBJbnRlcnNlY3Rpb247XG5cbiAgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIGNvbnN0cnVjdG9yOiBJbnRlcnNlY3Rpb24sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcG9pbnQgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHBvaW50cyB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgdGhpcy5wb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQocG9pbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9uZSBsaW5lIGludGVyc2VjdHMgYW5vdGhlclxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFNlZ21lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZUxpbmUgPSBmdW5jdGlvbiAoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICB1YVQgPSAoYjIueCAtIGIxLngpICogKGExLnkgLSBiMS55KSAtIChiMi55IC0gYjEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1YlQgPSAoYTIueCAtIGExLngpICogKGExLnkgLSBiMS55KSAtIChhMi55IC0gYTEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1QiA9IChiMi55IC0gYjEueSkgKiAoYTIueCAtIGExLngpIC0gKGIyLnggLSBiMS54KSAqIChhMi55IC0gYTEueSk7XG4gICAgaWYgKHVCICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YVQgLyB1QixcbiAgICAgICAgICB1YiA9IHViVCAvIHVCO1xuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignSW50ZXJzZWN0aW9uJyk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRQb2ludChuZXcgZmFicmljLlBvaW50KGExLnggKyB1YSAqIChhMi54IC0gYTEueCksIGExLnkgKyB1YSAqIChhMi55IC0gYTEueSkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHVhVCA9PT0gMCB8fCB1YlQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignQ29pbmNpZGVudCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ1BhcmFsbGVsJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBsaW5lIGludGVyc2VjdHMgcG9seWdvblxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFBvbHlnb25cbiAgICogZml4IGRldGVjdGlvbiBvZiBjb2luY2lkZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24gPSBmdW5jdGlvbihhMSwgYTIsIHBvaW50cykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCksXG4gICAgICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGIxLCBiMiwgaW50ZXIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGIxID0gcG9pbnRzW2ldO1xuICAgICAgYjIgPSBwb2ludHNbKGkgKyAxKSAlIGxlbmd0aF07XG4gICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZShhMSwgYTIsIGIxLCBiMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIGFub3RoZXIgcG9seWdvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czFcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzMS5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhMSA9IHBvaW50czFbaV0sXG4gICAgICAgICAgYTIgPSBwb2ludHMxWyhpICsgMSkgJSBsZW5ndGhdLFxuICAgICAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGExLCBhMiwgcG9pbnRzMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIHJlY3RhbmdsZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUgPSBmdW5jdGlvbiAocG9pbnRzLCByMSwgcjIpIHtcbiAgICB2YXIgbWluID0gcjEubWluKHIyKSxcbiAgICAgICAgbWF4ID0gcjEubWF4KHIyKSxcbiAgICAgICAgdG9wUmlnaHQgPSBuZXcgZmFicmljLlBvaW50KG1heC54LCBtaW4ueSksXG4gICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgZmFicmljLlBvaW50KG1pbi54LCBtYXgueSksXG4gICAgICAgIGludGVyMSA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtaW4sIHRvcFJpZ2h0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24odG9wUmlnaHQsIG1heCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIzID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1heCwgYm90dG9tTGVmdCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXI0ID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGJvdHRvbUxlZnQsIG1pbiwgcG9pbnRzKSxcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuXG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjEucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMi5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIzLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjQucG9pbnRzKTtcblxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQ29sb3IpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNvbG9yIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ29sb3IgY2xhc3NcbiAgICogVGhlIHB1cnBvc2Ugb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgdG8gYWJzdHJhY3QgYW5kIGVuY2Fwc3VsYXRlIGNvbW1vbiBjb2xvciBvcGVyYXRpb25zO1xuICAgKiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBjcmVhdGVzIGluc3RhbmNlcyBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBvYmplY3RzLlxuICAgKlxuICAgKiBAY2xhc3MgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBvcHRpb25hbCBpbiBoZXggb3IgcmdiKGEpIG9yIGhzbCBmb3JtYXQgb3IgZnJvbSBrbm93biBjb2xvciBsaXN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMi8jY29sb3JzfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICB0aGlzLnNldFNvdXJjZShbMCwgMCwgMCwgMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RyeVBhcnNpbmdDb2xvcihjb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbG9yID0gQ29sb3I7XG5cbiAgZmFicmljLkNvbG9yLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBjb2xvciBDb2xvciB2YWx1ZSB0byBwYXJzZVxuICAgICAqL1xuICAgIF90cnlQYXJzaW5nQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICB2YXIgc291cmNlO1xuXG4gICAgICBpZiAoY29sb3IgaW4gQ29sb3IuY29sb3JOYW1lTWFwKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3IuY29sb3JOYW1lTWFwW2NvbG9yXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHNvdXJjZSA9IFsyNTUsIDI1NSwgMjU1LCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgLy9pZiBjb2xvciBpcyBub3QgcmVjb2duaXplIGxldCdzIG1ha2UgYmxhY2sgYXMgY2FudmFzIGRvZXNcbiAgICAgICAgc291cmNlID0gWzAsIDAsIDAsIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFJlZCBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIEdyZWVuIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgQmx1ZSBjb2xvciB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBIc2wgY29sb3JcbiAgICAgKi9cbiAgICBfcmdiVG9Ic2w6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHIgLz0gMjU1OyBnIC89IDI1NTsgYiAvPSAyNTU7XG5cbiAgICAgIHZhciBoLCBzLCBsLFxuICAgICAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heChbciwgZywgYl0pLFxuICAgICAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbihbciwgZywgYl0pO1xuXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5yb3VuZChoICogMzYwKSxcbiAgICAgICAgTWF0aC5yb3VuZChzICogMTAwKSxcbiAgICAgICAgTWF0aC5yb3VuZChsICogMTAwKVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAgICovXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0IgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgICAqL1xuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0JBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IHJnYmEoMC0yNTUsMC0yNTUsMC0yNTUsMC0xKVxuICAgICAqL1xuICAgIHRvUmdiYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHJldHVybiAncmdiYSgnICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJywnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhTTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgICAqL1xuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbCgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwwLTEpXG4gICAgICovXG4gICAgdG9Ic2xhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbGEoJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSwnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBGRjU1NTVcbiAgICAgKi9cbiAgICB0b0hleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSwgciwgZywgYjtcblxuICAgICAgciA9IHNvdXJjZVswXS50b1N0cmluZygxNik7XG4gICAgICByID0gKHIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyByKSA6IHI7XG5cbiAgICAgIGcgPSBzb3VyY2VbMV0udG9TdHJpbmcoMTYpO1xuICAgICAgZyA9IChnLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgZykgOiBnO1xuXG4gICAgICBiID0gc291cmNlWzJdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGIgPSAoYi5sZW5ndGggPT09IDEpID8gKCcwJyArIGIpIDogYjtcblxuICAgICAgcmV0dXJuIHIudG9VcHBlckNhc2UoKSArIGcudG9VcHBlckNhc2UoKSArIGIudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIRVhBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NUNDXG4gICAgICovXG4gICAgdG9IZXhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCBhO1xuXG4gICAgICBhID0gTWF0aC5yb3VuZChzb3VyY2VbM10gKiAyNTUpO1xuICAgICAgYSA9IGEudG9TdHJpbmcoMTYpO1xuICAgICAgYSA9IChhLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYSkgOiBhO1xuXG4gICAgICByZXR1cm4gdGhpcy50b0hleCgpICsgYS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAtMVxuICAgICAqL1xuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpWzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgQWxwaGEgdmFsdWUgMC0xXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBncmF5c2NhbGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0dyYXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gcGFyc2VJbnQoKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLCAxMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGJsYWNrIGFuZCB3aGl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0JsYWNrV2hpdGU6IGZ1bmN0aW9uKHRocmVzaG9sZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG5cbiAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxMjc7XG5cbiAgICAgIGF2ZXJhZ2UgPSAoTnVtYmVyKGF2ZXJhZ2UpIDwgTnVtYmVyKHRocmVzaG9sZCkpID8gMCA6IDI1NTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5cyBjb2xvciB3aXRoIGFub3RoZXIgY29sb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xmYWJyaWMuQ29sb3J9IG90aGVyQ29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBvdmVybGF5V2l0aDogZnVuY3Rpb24ob3RoZXJDb2xvcikge1xuICAgICAgaWYgKCEob3RoZXJDb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICBvdGhlckNvbG9yID0gbmV3IENvbG9yKG90aGVyQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgYWxwaGEgPSB0aGlzLmdldEFscGhhKCksXG4gICAgICAgICAgb3RoZXJBbHBoYSA9IDAuNSxcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIG90aGVyU291cmNlID0gb3RoZXJDb2xvci5nZXRTb3VyY2UoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChNYXRoLnJvdW5kKChzb3VyY2VbaV0gKiAoMSAtIG90aGVyQWxwaGEpKSArIChvdGhlclNvdXJjZVtpXSAqIG90aGVyQWxwaGEpKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2UocmVzdWx0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gUkdCIG9yIFJHQkEgZm9ybWF0cyAoZXg6IHJnYigwLCAwLCAwKSwgcmdiYSgyNTUsIDEwMCwgMTAsIDAuNSksIHJnYmEoIDI1NSAsIDEwMCAsIDEwICwgMC41ICksIHJnYigxLDEsMSksIHJnYmEoMTAwJSwgNjAlLCAxMCUsIDAuNSkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGZhYnJpYy5Db2xvci5yZVJHQmEgPSAvXnJnYmE/XFwoXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyooPzpcXHMqLFxccyooKD86XFxkKlxcLj9cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIU0wgb3IgSFNMQSBmb3JtYXRzIChleDogaHNsKDIwMCwgODAlLCAxMCUpLCBoc2xhKDMwMCwgNTAlLCA4MCUsIDAuNSksIGhzbGEoIDMwMCAsIDUwJSAsIDgwJSAsIDAuNSApKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIU0xhID0gL15oc2xhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqKD86XFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIRVggZm9ybWF0IChleDogI0ZGNTU0NENDLCAjRkY1NTU1LCAwMTAxNTUsIGFmZilcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnJlSGV4ID0gL14jPyhbMC05YS1mXXs4fXxbMC05YS1mXXs2fXxbMC05YS1mXXs0fXxbMC05YS1mXXszfSkkL2k7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiB0aGUgMTQ4IGNvbG9yIG5hbWVzIHdpdGggSEVYIGNvZGVcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IuY29sb3JOYW1lTWFwID0ge1xuICAgIGFsaWNlYmx1ZTogICAgICAgICAgICAnI0YwRjhGRicsXG4gICAgYW50aXF1ZXdoaXRlOiAgICAgICAgICcjRkFFQkQ3JyxcbiAgICBhcXVhOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGFxdWFtYXJpbmU6ICAgICAgICAgICAnIzdGRkZENCcsXG4gICAgYXp1cmU6ICAgICAgICAgICAgICAgICcjRjBGRkZGJyxcbiAgICBiZWlnZTogICAgICAgICAgICAgICAgJyNGNUY1REMnLFxuICAgIGJpc3F1ZTogICAgICAgICAgICAgICAnI0ZGRTRDNCcsXG4gICAgYmxhY2s6ICAgICAgICAgICAgICAgICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogICAgICAgJyNGRkVCQ0QnLFxuICAgIGJsdWU6ICAgICAgICAgICAgICAgICAnIzAwMDBGRicsXG4gICAgYmx1ZXZpb2xldDogICAgICAgICAgICcjOEEyQkUyJyxcbiAgICBicm93bjogICAgICAgICAgICAgICAgJyNBNTJBMkEnLFxuICAgIGJ1cmx5d29vZDogICAgICAgICAgICAnI0RFQjg4NycsXG4gICAgY2FkZXRibHVlOiAgICAgICAgICAgICcjNUY5RUEwJyxcbiAgICBjaGFydHJldXNlOiAgICAgICAgICAgJyM3RkZGMDAnLFxuICAgIGNob2NvbGF0ZTogICAgICAgICAgICAnI0QyNjkxRScsXG4gICAgY29yYWw6ICAgICAgICAgICAgICAgICcjRkY3RjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogICAgICAgJyM2NDk1RUQnLFxuICAgIGNvcm5zaWxrOiAgICAgICAgICAgICAnI0ZGRjhEQycsXG4gICAgY3JpbXNvbjogICAgICAgICAgICAgICcjREMxNDNDJyxcbiAgICBjeWFuOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGRhcmtibHVlOiAgICAgICAgICAgICAnIzAwMDA4QicsXG4gICAgZGFya2N5YW46ICAgICAgICAgICAgICcjMDA4QjhCJyxcbiAgICBkYXJrZ29sZGVucm9kOiAgICAgICAgJyNCODg2MEInLFxuICAgIGRhcmtncmF5OiAgICAgICAgICAgICAnI0E5QTlBOScsXG4gICAgZGFya2dyZXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JlZW46ICAgICAgICAgICAgJyMwMDY0MDAnLFxuICAgIGRhcmtraGFraTogICAgICAgICAgICAnI0JEQjc2QicsXG4gICAgZGFya21hZ2VudGE6ICAgICAgICAgICcjOEIwMDhCJyxcbiAgICBkYXJrb2xpdmVncmVlbjogICAgICAgJyM1NTZCMkYnLFxuICAgIGRhcmtvcmFuZ2U6ICAgICAgICAgICAnI0ZGOEMwMCcsXG4gICAgZGFya29yY2hpZDogICAgICAgICAgICcjOTkzMkNDJyxcbiAgICBkYXJrcmVkOiAgICAgICAgICAgICAgJyM4QjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICAgICAgICAgICAnI0U5OTY3QScsXG4gICAgZGFya3NlYWdyZWVuOiAgICAgICAgICcjOEZCQzhGJyxcbiAgICBkYXJrc2xhdGVibHVlOiAgICAgICAgJyM0ODNEOEInLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgICAnIzJGNEY0RicsXG4gICAgZGFya3NsYXRlZ3JleTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrdHVycXVvaXNlOiAgICAgICAgJyMwMENFRDEnLFxuICAgIGRhcmt2aW9sZXQ6ICAgICAgICAgICAnIzk0MDBEMycsXG4gICAgZGVlcHBpbms6ICAgICAgICAgICAgICcjRkYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogICAgICAgICAgJyMwMEJGRkYnLFxuICAgIGRpbWdyYXk6ICAgICAgICAgICAgICAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAgICAgICAgICAgJyMxRTkwRkYnLFxuICAgIGZpcmVicmljazogICAgICAgICAgICAnI0IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICAgICAgICAgICcjRkZGQUYwJyxcbiAgICBmb3Jlc3RncmVlbjogICAgICAgICAgJyMyMjhCMjInLFxuICAgIGZ1Y2hzaWE6ICAgICAgICAgICAgICAnI0ZGMDBGRicsXG4gICAgZ2FpbnNib3JvOiAgICAgICAgICAgICcjRENEQ0RDJyxcbiAgICBnaG9zdHdoaXRlOiAgICAgICAgICAgJyNGOEY4RkYnLFxuICAgIGdvbGQ6ICAgICAgICAgICAgICAgICAnI0ZGRDcwMCcsXG4gICAgZ29sZGVucm9kOiAgICAgICAgICAgICcjREFBNTIwJyxcbiAgICBncmF5OiAgICAgICAgICAgICAgICAgJyM4MDgwODAnLFxuICAgIGdyZXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICAgICAgICAgICAgICAgICcjMDA4MDAwJyxcbiAgICBncmVlbnllbGxvdzogICAgICAgICAgJyNBREZGMkYnLFxuICAgIGhvbmV5ZGV3OiAgICAgICAgICAgICAnI0YwRkZGMCcsXG4gICAgaG90cGluazogICAgICAgICAgICAgICcjRkY2OUI0JyxcbiAgICBpbmRpYW5yZWQ6ICAgICAgICAgICAgJyNDRDVDNUMnLFxuICAgIGluZGlnbzogICAgICAgICAgICAgICAnIzRCMDA4MicsXG4gICAgaXZvcnk6ICAgICAgICAgICAgICAgICcjRkZGRkYwJyxcbiAgICBraGFraTogICAgICAgICAgICAgICAgJyNGMEU2OEMnLFxuICAgIGxhdmVuZGVyOiAgICAgICAgICAgICAnI0U2RTZGQScsXG4gICAgbGF2ZW5kZXJibHVzaDogICAgICAgICcjRkZGMEY1JyxcbiAgICBsYXduZ3JlZW46ICAgICAgICAgICAgJyM3Q0ZDMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogICAgICAgICAnI0ZGRkFDRCcsXG4gICAgbGlnaHRibHVlOiAgICAgICAgICAgICcjQUREOEU2JyxcbiAgICBsaWdodGNvcmFsOiAgICAgICAgICAgJyNGMDgwODAnLFxuICAgIGxpZ2h0Y3lhbjogICAgICAgICAgICAnI0UwRkZGRicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxcbiAgICBsaWdodGdyYXk6ICAgICAgICAgICAgJyNEM0QzRDMnLFxuICAgIGxpZ2h0Z3JleTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmVlbjogICAgICAgICAgICcjOTBFRTkwJyxcbiAgICBsaWdodHBpbms6ICAgICAgICAgICAgJyNGRkI2QzEnLFxuICAgIGxpZ2h0c2FsbW9uOiAgICAgICAgICAnI0ZGQTA3QScsXG4gICAgbGlnaHRzZWFncmVlbjogICAgICAgICcjMjBCMkFBJyxcbiAgICBsaWdodHNreWJsdWU6ICAgICAgICAgJyM4N0NFRkEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAgICAgICAnIzc3ODg5OScsXG4gICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogICAgICAgJyNCMEM0REUnLFxuICAgIGxpZ2h0eWVsbG93OiAgICAgICAgICAnI0ZGRkZFMCcsXG4gICAgbGltZTogICAgICAgICAgICAgICAgICcjMDBGRjAwJyxcbiAgICBsaW1lZ3JlZW46ICAgICAgICAgICAgJyMzMkNEMzInLFxuICAgIGxpbmVuOiAgICAgICAgICAgICAgICAnI0ZBRjBFNicsXG4gICAgbWFnZW50YTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBtYXJvb246ICAgICAgICAgICAgICAgJyM4MDAwMDAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgICAnIzY2Q0RBQScsXG4gICAgbWVkaXVtYmx1ZTogICAgICAgICAgICcjMDAwMENEJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICAgICAgICAgJyNCQTU1RDMnLFxuICAgIG1lZGl1bXB1cnBsZTogICAgICAgICAnIzkzNzBEQicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgICcjM0NCMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgICAgJyM3QjY4RUUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAgICAnIzAwRkE5QScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAgICAgICcjNDhEMUNDJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICAgICAgJyNDNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogICAgICAgICAnIzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAgICAgICAgICAgICcjRjVGRkZBJyxcbiAgICBtaXN0eXJvc2U6ICAgICAgICAgICAgJyNGRkU0RTEnLFxuICAgIG1vY2Nhc2luOiAgICAgICAgICAgICAnI0ZGRTRCNScsXG4gICAgbmF2YWpvd2hpdGU6ICAgICAgICAgICcjRkZERUFEJyxcbiAgICBuYXZ5OiAgICAgICAgICAgICAgICAgJyMwMDAwODAnLFxuICAgIG9sZGxhY2U6ICAgICAgICAgICAgICAnI0ZERjVFNicsXG4gICAgb2xpdmU6ICAgICAgICAgICAgICAgICcjODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICAgICAgICAgICAgJyM2QjhFMjMnLFxuICAgIG9yYW5nZTogICAgICAgICAgICAgICAnI0ZGQTUwMCcsXG4gICAgb3JhbmdlcmVkOiAgICAgICAgICAgICcjRkY0NTAwJyxcbiAgICBvcmNoaWQ6ICAgICAgICAgICAgICAgJyNEQTcwRDYnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgICAnI0VFRThBQScsXG4gICAgcGFsZWdyZWVuOiAgICAgICAgICAgICcjOThGQjk4JyxcbiAgICBwYWxldHVycXVvaXNlOiAgICAgICAgJyNBRkVFRUUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICAgICAgICAnI0RCNzA5MycsXG4gICAgcGFwYXlhd2hpcDogICAgICAgICAgICcjRkZFRkQ1JyxcbiAgICBwZWFjaHB1ZmY6ICAgICAgICAgICAgJyNGRkRBQjknLFxuICAgIHBlcnU6ICAgICAgICAgICAgICAgICAnI0NEODUzRicsXG4gICAgcGluazogICAgICAgICAgICAgICAgICcjRkZDMENCJyxcbiAgICBwbHVtOiAgICAgICAgICAgICAgICAgJyNEREEwREQnLFxuICAgIHBvd2RlcmJsdWU6ICAgICAgICAgICAnI0IwRTBFNicsXG4gICAgcHVycGxlOiAgICAgICAgICAgICAgICcjODAwMDgwJyxcbiAgICByZWJlY2NhcHVycGxlOiAgICAgICAgJyM2NjMzOTknLFxuICAgIHJlZDogICAgICAgICAgICAgICAgICAnI0ZGMDAwMCcsXG4gICAgcm9zeWJyb3duOiAgICAgICAgICAgICcjQkM4RjhGJyxcbiAgICByb3lhbGJsdWU6ICAgICAgICAgICAgJyM0MTY5RTEnLFxuICAgIHNhZGRsZWJyb3duOiAgICAgICAgICAnIzhCNDUxMycsXG4gICAgc2FsbW9uOiAgICAgICAgICAgICAgICcjRkE4MDcyJyxcbiAgICBzYW5keWJyb3duOiAgICAgICAgICAgJyNGNEE0NjAnLFxuICAgIHNlYWdyZWVuOiAgICAgICAgICAgICAnIzJFOEI1NycsXG4gICAgc2Vhc2hlbGw6ICAgICAgICAgICAgICcjRkZGNUVFJyxcbiAgICBzaWVubmE6ICAgICAgICAgICAgICAgJyNBMDUyMkQnLFxuICAgIHNpbHZlcjogICAgICAgICAgICAgICAnI0MwQzBDMCcsXG4gICAgc2t5Ymx1ZTogICAgICAgICAgICAgICcjODdDRUVCJyxcbiAgICBzbGF0ZWJsdWU6ICAgICAgICAgICAgJyM2QTVBQ0QnLFxuICAgIHNsYXRlZ3JheTogICAgICAgICAgICAnIzcwODA5MCcsXG4gICAgc2xhdGVncmV5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbm93OiAgICAgICAgICAgICAgICAgJyNGRkZBRkEnLFxuICAgIHNwcmluZ2dyZWVuOiAgICAgICAgICAnIzAwRkY3RicsXG4gICAgc3RlZWxibHVlOiAgICAgICAgICAgICcjNDY4MkI0JyxcbiAgICB0YW46ICAgICAgICAgICAgICAgICAgJyNEMkI0OEMnLFxuICAgIHRlYWw6ICAgICAgICAgICAgICAgICAnIzAwODA4MCcsXG4gICAgdGhpc3RsZTogICAgICAgICAgICAgICcjRDhCRkQ4JyxcbiAgICB0b21hdG86ICAgICAgICAgICAgICAgJyNGRjYzNDcnLFxuICAgIHR1cnF1b2lzZTogICAgICAgICAgICAnIzQwRTBEMCcsXG4gICAgdmlvbGV0OiAgICAgICAgICAgICAgICcjRUU4MkVFJyxcbiAgICB3aGVhdDogICAgICAgICAgICAgICAgJyNGNURFQjMnLFxuICAgIHdoaXRlOiAgICAgICAgICAgICAgICAnI0ZGRkZGRicsXG4gICAgd2hpdGVzbW9rZTogICAgICAgICAgICcjRjVGNUY1JyxcbiAgICB5ZWxsb3c6ICAgICAgICAgICAgICAgJyNGRkZGMDAnLFxuICAgIHllbGxvd2dyZWVuOiAgICAgICAgICAnIzlBQ0QzMidcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICB0ICs9IDE7XG4gICAgfVxuICAgIGlmICh0ID4gMSkge1xuICAgICAgdCAtPSAxO1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBSR0Igb3IgUkdCQSBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSksIHJnYigwJS0xMDAlLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlUkdCYSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsxXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMjU1IDogMSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTApLFxuICAgICAgICBwYXJzZUludChiLCAxMCksXG4gICAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2JhID0gQ29sb3IuZnJvbVJnYjtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMIGZvcm1hdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTI2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSFNMIG9yIEhTTEEgZm9ybWF0LlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpIG9yIGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLCAwLTEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICogQHNlZSBodHRwOi8vaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jaHNsLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVIU0xhKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MCxcbiAgICAgICAgcyA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgbCA9IHBhcnNlRmxvYXQobWF0Y2hbM10pIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgciwgZywgYjtcblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgcCA9IGwgKiAyIC0gcTtcblxuICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5yb3VuZChyICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGIgKiAyNTUpLFxuICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0xBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbGEgPSBDb2xvci5mcm9tSHNsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IEZGNTU1NVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgZXg6IEZGNTU1NSBvciBGRjU1NDRDQyAoUkdCYSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIGlmIChjb2xvci5tYXRjaChDb2xvci5yZUhleCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbG9yLnNsaWNlKGNvbG9yLmluZGV4T2YoJyMnKSArIDEpLFxuICAgICAgICAgIGlzU2hvcnROb3RhdGlvbiA9ICh2YWx1ZS5sZW5ndGggPT09IDMgfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICBpc1JHQmEgPSAodmFsdWUubGVuZ3RoID09PSA4IHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgciA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMCkgKyB2YWx1ZS5jaGFyQXQoMCkpIDogdmFsdWUuc3Vic3RyaW5nKDAsIDIpLFxuICAgICAgICAgIGcgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDEpICsgdmFsdWUuY2hhckF0KDEpKSA6IHZhbHVlLnN1YnN0cmluZygyLCA0KSxcbiAgICAgICAgICBiID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgyKSArIHZhbHVlLmNoYXJBdCgyKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNCwgNiksXG4gICAgICAgICAgYSA9IGlzUkdCYSA/IChpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDMpICsgdmFsdWUuY2hhckF0KDMpKSA6IHZhbHVlLnN1YnN0cmluZyg2LCA4KSkgOiAnRkYnO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBwYXJzZUZsb2F0KChwYXJzZUludChhLCAxNikgLyAyNTUpLnRvRml4ZWQoMikpXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGNvbG9yIGluIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzIwMCwgMTAwLCAxMDAsIDAuNV0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgb0NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgb0NvbG9yLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIHJldHVybiBvQ29sb3I7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHNjYWxlTWFwID0gWydlJywgJ3NlJywgJ3MnLCAnc3cnLCAndycsICdudycsICduJywgJ25lJywgJ2UnXSxcbiAgICAgIHNrZXdNYXAgPSBbJ25zJywgJ25lc3cnLCAnZXcnLCAnbndzZSddLFxuICAgICAgY29udHJvbHMgPSB7fSxcbiAgICAgIExFRlQgPSAnbGVmdCcsIFRPUCA9ICd0b3AnLCBSSUdIVCA9ICdyaWdodCcsIEJPVFRPTSA9ICdib3R0b20nLCBDRU5URVIgPSAnY2VudGVyJyxcbiAgICAgIG9wcG9zaXRlID0ge1xuICAgICAgICB0b3A6IEJPVFRPTSxcbiAgICAgICAgYm90dG9tOiBUT1AsXG4gICAgICAgIGxlZnQ6IFJJR0hULFxuICAgICAgICByaWdodDogTEVGVCxcbiAgICAgICAgY2VudGVyOiBDRU5URVIsXG4gICAgICB9LCByYWRpYW5zVG9EZWdyZWVzID0gZmFicmljLnV0aWwucmFkaWFuc1RvRGVncmVlcyxcbiAgICAgIHNpZ24gPSAoTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7IH0pO1xuXG4gIC8qKlxuICAgKiBDb21iaW5lIGNvbnRyb2wgcG9zaXRpb24gYW5kIG9iamVjdCBhbmdsZSB0byBmaW5kIHRoZSBjb250cm9sIGRpcmVjdGlvbiBjb21wYXJlZFxuICAgKiB0byB0aGUgb2JqZWN0IGNlbnRlci5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCBjbGFzc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAgLSA3IGEgcXVhZHJhbnQgbnVtYmVyXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kQ29ybmVyUXVhZHJhbnQoZmFicmljT2JqZWN0LCBjb250cm9sKSB7XG4gICAgdmFyIGNvcm5lckFuZ2xlID0gZmFicmljT2JqZWN0LmFuZ2xlICsgcmFkaWFuc1RvRGVncmVlcyhNYXRoLmF0YW4yKGNvbnRyb2wueSwgY29udHJvbC54KSkgKyAzNjA7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGNvcm5lckFuZ2xlICUgMzYwKSAvIDQ1KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudChldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBjYW52YXMgPSB0YXJnZXQuY2FudmFzLFxuICAgICAgICBjYW52YXNPcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpO1xuICAgIGNhbnZhc09wdGlvbnMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGNhbnZhcyAmJiBjYW52YXMuZmlyZSgnb2JqZWN0OicgKyBldmVudE5hbWUsIGNhbnZhc09wdGlvbnMpO1xuICAgIHRhcmdldC5maXJlKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCBldmVudCBhbmQgZmFicmljT2JqZWN0IHByb3BlcnRpZXMgdG8gdW5kZXJzdGFuZCBpZiB0aGUgc2NhbGluZyBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGZyb20gdGhlIHVzZXIgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGFib3V0IHRvIHNjYWxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2NhbGUgaXMgcHJvcG9ydGlvbmFsXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZUlzUHJvcG9ydGlvbmFsKGV2ZW50RGF0YSwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIGNhbnZhcyA9IGZhYnJpY09iamVjdC5jYW52YXMsIHVuaVNjYWxlS2V5ID0gY2FudmFzLnVuaVNjYWxlS2V5LFxuICAgICAgICB1bmlmb3JtSXNUb2dnbGVkID0gZXZlbnREYXRhW3VuaVNjYWxlS2V5XTtcbiAgICByZXR1cm4gKGNhbnZhcy51bmlmb3JtU2NhbGluZyAmJiAhdW5pZm9ybUlzVG9nZ2xlZCkgfHxcbiAgICAoIWNhbnZhcy51bmlmb3JtU2NhbGluZyAmJiB1bmlmb3JtSXNUb2dnbGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHJhbnNmb3JtIGlzIGNlbnRlcmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gdHJhbnNmb3JtIGRhdGFcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0cmFuc2Zvcm0gaXMgY2VudGVyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybS5vcmlnaW5YID09PSBDRU5URVIgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IENFTlRFUjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IGZhYnJpY09iamVjdCB0byB1bmRlcnN0YW5kIGlmIHRoZSBjdXJyZW50IHNjYWxpbmcgYWN0aW9uIGlzIGFsbG93ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgYWJvdXQgdG8gc2NhbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5ICd4JyBvciAneScgb3IgJydcbiAgICogQHBhcmFtIHtCb29sZWFufSBzY2FsZVByb3BvcnRpb25hbGx5IHRydWUgaWYgd2UgYXJlIHRyeWluZyB0byBzY2FsZSBwcm9wb3J0aW9uYWxseVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNjYWxpbmcgaXMgbm90IGFsbG93ZWQgYXQgY3VycmVudCBjb25kaXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsaW5nSXNGb3JiaWRkZW4oZmFicmljT2JqZWN0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSkge1xuICAgIHZhciBsb2NrWCA9IGZhYnJpY09iamVjdC5sb2NrU2NhbGluZ1gsIGxvY2tZID0gZmFicmljT2JqZWN0LmxvY2tTY2FsaW5nWTtcbiAgICBpZiAobG9ja1ggJiYgbG9ja1kpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWJ5ICYmIChsb2NrWCB8fCBsb2NrWSkgJiYgc2NhbGVQcm9wb3J0aW9uYWxseSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChsb2NrWCAmJiBieSA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxvY2tZICYmIGJ5ID09PSAneScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBjb3JyZWN0IGN1cnNvciBzdHlsZSBmb3IgdGhlIHNjYWxlIGFjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZUN1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBub3RBbGxvd2VkID0gJ25vdC1hbGxvd2VkJyxcbiAgICAgICAgc2NhbGVQcm9wb3J0aW9uYWxseSA9IHNjYWxlSXNQcm9wb3J0aW9uYWwoZXZlbnREYXRhLCBmYWJyaWNPYmplY3QpLFxuICAgICAgICBieSA9ICcnO1xuICAgIGlmIChjb250cm9sLnggIT09IDAgJiYgY29udHJvbC55ID09PSAwKSB7XG4gICAgICBieSA9ICd4JztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbC54ID09PSAwICYmIGNvbnRyb2wueSAhPT0gMCkge1xuICAgICAgYnkgPSAneSc7XG4gICAgfVxuICAgIGlmIChzY2FsaW5nSXNGb3JiaWRkZW4oZmFicmljT2JqZWN0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSkpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICB2YXIgbiA9IGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpO1xuICAgIHJldHVybiBzY2FsZU1hcFtuXSArICctcmVzaXplJztcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGNvcnJlY3QgY3Vyc29yIHN0eWxlIGZvciB0aGUgc2tldyBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0N1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBub3RBbGxvd2VkID0gJ25vdC1hbGxvd2VkJztcbiAgICBpZiAoY29udHJvbC54ICE9PSAwICYmIGZhYnJpY09iamVjdC5sb2NrU2tld2luZ1kpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICBpZiAoY29udHJvbC55ICE9PSAwICYmIGZhYnJpY09iamVjdC5sb2NrU2tld2luZ1gpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICB2YXIgbiA9IGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpICUgNDtcbiAgICByZXR1cm4gc2tld01hcFtuXSArICctcmVzaXplJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lIHNrZXcgYW5kIHNjYWxlIHN0eWxlIGhhbmRsZXJzIHRvIGNvdmVyIGZhYnJpYyBzdGFuZGFyZCB1c2UgY2FzZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICBpZiAoZXZlbnREYXRhW2ZhYnJpY09iamVjdC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgZXZlbnQsIGNvbnRyb2wgYW5kIGZhYnJpY09iamVjdCB0byByZXR1cm4gdGhlIGNvcnJlY3QgYWN0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGFuIGFjdGlvbiBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9yU2tld0FjdGlvbk5hbWUoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgaXNBbHRlcm5hdGl2ZSA9IGV2ZW50RGF0YVtmYWJyaWNPYmplY3QuY2FudmFzLmFsdEFjdGlvbktleV07XG4gICAgaWYgKGNvbnRyb2wueCA9PT0gMCkge1xuICAgICAgLy8gdGhlbiBpcyBzY2FsZVkgb3Igc2tld1hcbiAgICAgIHJldHVybiBpc0FsdGVybmF0aXZlID8gJ3NrZXdYJyA6ICdzY2FsZVknO1xuICAgIH1cbiAgICBpZiAoY29udHJvbC55ID09PSAwKSB7XG4gICAgICAvLyB0aGVuIGlzIHNjYWxlWSBvciBza2V3WFxuICAgICAgcmV0dXJuIGlzQWx0ZXJuYXRpdmUgPyAnc2tld1knIDogJ3NjYWxlWCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNvcnJlY3Qgc3R5bGUgZm9yIHRoZSBjb250cm9sIHRoYXQgaXMgdXNlZCBmb3Igcm90YXRpb24uXG4gICAqIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1wbGUgYW5kIGl0IGp1c3QgdGFrZSBjYXJlIG9mIG5vdC1hbGxvd2VkIG9yIHN0YW5kYXJkIGN1cnNvclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiByb3RhdGlvblN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIGlmIChmYWJyaWNPYmplY3QubG9ja1JvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gJ25vdC1hbGxvd2VkJztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZTogZXZlbnREYXRhLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBwb2ludGVyOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwIGFuIGFjdGlvbiBoYW5kbGVyIHdpdGggc2F2aW5nL3Jlc3RvcmluZyBvYmplY3QgcG9zaXRpb24gb24gdGhlIHRyYW5zZm9ybS5cbiAgICogdGhpcyBpcyB0aGUgY29kZSB0aGF0IHBlcm1pdHMgdG8gb2JqZWN0cyB0byBrZWVwIHRoZWlyIHBvc2l0aW9uIHdoaWxlIHRyYW5zZm9ybWluZy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uSGFuZGxlciB0aGUgZnVuY3Rpb24gdG8gd3JhcFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB3aXRoIGFuIGFjdGlvbiBoYW5kbGVyIHNpZ25hdHVyZVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcFdpdGhGaXhlZEFuY2hvcihhY3Rpb25IYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY2VudGVyUG9pbnQgPSB0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBjb25zdHJhaW50ID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyUG9pbnQsIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSksXG4gICAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50LCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblkpO1xuICAgICAgcmV0dXJuIGFjdGlvblBlcmZvcm1lZDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYSBwb2ludCBkZXNjcmliZWQgYnkgeCBhbmQgeSBpbiBhIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgb2JqZWN0XG4gICAqIGJvdW5kaW5nIGJveC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtGYWJyaWMuUG9pbnR9IHRoZSBub3JtYWxpemVkIHBvaW50XG4gICAqL1xuICBmdW5jdGlvbiBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgb3JpZ2luWCwgb3JpZ2luWSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW3RyYW5zZm9ybS5jb3JuZXJdLFxuICAgICAgICB6b29tID0gdGFyZ2V0LmNhbnZhcy5nZXRab29tKCksXG4gICAgICAgIHBhZGRpbmcgPSB0YXJnZXQucGFkZGluZyAvIHpvb20sXG4gICAgICAgIGxvY2FsUG9pbnQgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksIG9yaWdpblgsIG9yaWdpblkpO1xuICAgIGlmIChsb2NhbFBvaW50LnggPj0gcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC54IC09IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChsb2NhbFBvaW50LnggPD0gLXBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueCArPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC55ID49IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueSAtPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC55IDw9IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueSArPSBwYWRkaW5nO1xuICAgIH1cbiAgICBsb2NhbFBvaW50LnggLT0gY29udHJvbC5vZmZzZXRYO1xuICAgIGxvY2FsUG9pbnQueSAtPSBjb250cm9sLm9mZnNldFk7XG4gICAgcmV0dXJuIGxvY2FsUG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIHRoZSBmYWJyaWMgb2JqZWN0IGlzIGZsaXBwZWQgb24gb25lIHNpZGUuXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb25lIGZsaXAsIGJ1dCBub3QgdHdvLlxuICAgKi9cbiAgZnVuY3Rpb24gdGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmZsaXBYICE9PSB0YXJnZXQuZmxpcFk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb21wZW5zYXRlIHRoZSBzY2FsZSBmYWN0b3Igd2hlbiBza2V3IGlzIGFwcGxpZWQgb24gYm90aCBheGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wZW5zYXRlU2NhbGVGb3JTa2V3KHRhcmdldCwgb3Bwb3NpdGVTa2V3LCBzY2FsZVRvQ29tcGVuc2F0ZSwgYXhpcywgcmVmZXJlbmNlKSB7XG4gICAgaWYgKHRhcmdldFtvcHBvc2l0ZVNrZXddICE9PSAwKSB7XG4gICAgICB2YXIgbmV3RGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKVtheGlzXTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHJlZmVyZW5jZSAvIG5ld0RpbSAqIHRhcmdldFtzY2FsZVRvQ29tcGVuc2F0ZV07XG4gICAgICB0YXJnZXQuc2V0KHNjYWxlVG9Db21wZW5zYXRlLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBYIGF4aXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdPYmplY3RYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIC8vIGZpbmQgaG93IGJpZyB0aGUgb2JqZWN0IHdvdWxkIGJlLCBpZiB0aGVyZSB3YXMgbm8gc2tld1guIHRha2VzIGluIGFjY291bnQgc2NhbGluZ1xuICAgICAgICBkaW1Ob1NrZXcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygwLCB0YXJnZXQuc2tld1kpLFxuICAgICAgICBsb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSksXG4gICAgICAgIC8vIHRoZSBtb3VzZSBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QsIGFuZCB3ZSB3YW50IGl0IHRvIHN0YXkgdGhlcmUuXG4gICAgICAgIC8vIHNvIHRoZSBvYmplY3Qgd2lsbCBncm93IHR3aWNlIGFzIG11Y2ggYXMgdGhlIG1vdXNlLlxuICAgICAgICAvLyB0aGlzIG1ha2VzIHRoZSBza2V3IGdyb3d0aCB0byBsb2NhbFBvaW50ICogMiAtIGRpbU5vU2tldy5cbiAgICAgICAgdG90YWxTa2V3U2l6ZSA9IE1hdGguYWJzKGxvY2FsUG9pbnQueCAqIDIpIC0gZGltTm9Ta2V3LngsXG4gICAgICAgIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdYLCBuZXdTa2V3O1xuICAgIGlmICh0b3RhbFNrZXdTaXplIDwgMikge1xuICAgICAgLy8gbGV0J3MgbWFrZSBpdCBlYXN5IHRvIGdvIGJhY2sgdG8gcG9zaXRpb24gMC5cbiAgICAgIG5ld1NrZXcgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld1NrZXcgPSByYWRpYW5zVG9EZWdyZWVzKFxuICAgICAgICBNYXRoLmF0YW4yKCh0b3RhbFNrZXdTaXplIC8gdGFyZ2V0LnNjYWxlWCksIChkaW1Ob1NrZXcueSAvIHRhcmdldC5zY2FsZVkpKVxuICAgICAgKTtcbiAgICAgIC8vIG5vdyB3ZSBoYXZlIHRvIGZpbmQgdGhlIHNpZ24gb2YgdGhlIHNrZXcuXG4gICAgICAvLyBpdCBtb3N0bHkgZGVwZW5kIG9uIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24uXG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IExFRlQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IEJPVFRPTSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IFJJR0hUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBUT1ApIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBoYXNTa2V3ZWQgPSBjdXJyZW50U2tldyAhPT0gbmV3U2tldztcbiAgICBpZiAoaGFzU2tld2VkKSB7XG4gICAgICB2YXIgZGltQmVmb3JlU2tld2luZyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXdYJywgbmV3U2tldyk7XG4gICAgICBjb21wZW5zYXRlU2NhbGVGb3JTa2V3KHRhcmdldCwgJ3NrZXdZJywgJ3NjYWxlWScsICd5JywgZGltQmVmb3JlU2tld2luZyk7XG4gICAgICBmaXJlRXZlbnQoJ3NrZXdpbmcnLCBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1NrZXdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBza2V3T2JqZWN0WShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAvLyBmaW5kIGhvdyBiaWcgdGhlIG9iamVjdCB3b3VsZCBiZSwgaWYgdGhlcmUgd2FzIG5vIHNrZXdYLiB0YWtlcyBpbiBhY2NvdW50IHNjYWxpbmdcbiAgICAgICAgZGltTm9Ta2V3ID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnModGFyZ2V0LnNrZXdYLCAwKSxcbiAgICAgICAgbG9jYWxQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpLFxuICAgICAgICAvLyB0aGUgbW91c2UgaXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0LCBhbmQgd2Ugd2FudCBpdCB0byBzdGF5IHRoZXJlLlxuICAgICAgICAvLyBzbyB0aGUgb2JqZWN0IHdpbGwgZ3JvdyB0d2ljZSBhcyBtdWNoIGFzIHRoZSBtb3VzZS5cbiAgICAgICAgLy8gdGhpcyBtYWtlcyB0aGUgc2tldyBncm93dGggdG8gbG9jYWxQb2ludCAqIDIgLSBkaW1Ob1NrZXcuXG4gICAgICAgIHRvdGFsU2tld1NpemUgPSBNYXRoLmFicyhsb2NhbFBvaW50LnkgKiAyKSAtIGRpbU5vU2tldy55LFxuICAgICAgICBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WSwgbmV3U2tldztcbiAgICBpZiAodG90YWxTa2V3U2l6ZSA8IDIpIHtcbiAgICAgIC8vIGxldCdzIG1ha2UgaXQgZWFzeSB0byBnbyBiYWNrIHRvIHBvc2l0aW9uIDAuXG4gICAgICBuZXdTa2V3ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXdTa2V3ID0gcmFkaWFuc1RvRGVncmVlcyhcbiAgICAgICAgTWF0aC5hdGFuMigodG90YWxTa2V3U2l6ZSAvIHRhcmdldC5zY2FsZVkpLCAoZGltTm9Ta2V3LnggLyB0YXJnZXQuc2NhbGVYKSlcbiAgICAgICk7XG4gICAgICAvLyBub3cgd2UgaGF2ZSB0byBmaW5kIHRoZSBzaWduIG9mIHRoZSBza2V3LlxuICAgICAgLy8gaXQgbW9zdGx5IGRlcGVuZCBvbiB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBMRUZUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBCT1RUT00pIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBSSUdIVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gVE9QKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFzU2tld2VkID0gY3VycmVudFNrZXcgIT09IG5ld1NrZXc7XG4gICAgaWYgKGhhc1NrZXdlZCkge1xuICAgICAgdmFyIGRpbUJlZm9yZVNrZXdpbmcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgICB0YXJnZXQuc2V0KCdza2V3WScsIG5ld1NrZXcpO1xuICAgICAgY29tcGVuc2F0ZVNjYWxlRm9yU2tldyh0YXJnZXQsICdza2V3WCcsICdzY2FsZVgnLCAneCcsIGRpbUJlZm9yZVNrZXdpbmcpO1xuICAgICAgZmlyZUV2ZW50KCdza2V3aW5nJywgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNTa2V3ZWQ7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlZCBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzLCB0YWtlcyBjYXJlIG9mIHRoZVxuICAgKiBza2V3IGRpcmVjdGlvbiBhbmQgZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4gZm9yIHRoZSBhbmNob3IgcG9pbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBza2V3SGFuZGxlclgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBzdGVwMSBmaWd1cmUgb3V0IGFuZCBjaGFuZ2UgdHJhbnNmb3JtIG9yaWdpbi5cbiAgICAvLyBpZiBza2V3WCA+IDAgYW5kIG9yaWdpblkgYm90dG9tIHdlIGFuY2hvciBvbiByaWdodFxuICAgIC8vIGlmIHNrZXdYID4gMCBhbmQgb3JpZ2luWSB0b3Agd2UgYW5jaG9yIG9uIGxlZnRcbiAgICAvLyBpZiBza2V3WCA8IDAgYW5kIG9yaWdpblkgYm90dG9tIHdlIGFuY2hvciBvbiBsZWZ0XG4gICAgLy8gaWYgc2tld1ggPCAwIGFuZCBvcmlnaW5ZIHRvcCB3ZSBhbmNob3Igb24gcmlnaHRcbiAgICAvLyBpZiBza2V3WCBpcyAwLCB3ZSBsb29rIGZvciBtb3VzZSBwb3NpdGlvbiB0byB1bmRlcnN0YW5kIHdoZXJlIGFyZSB3ZSBnb2luZy5cbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1gsIG9yaWdpblgsIG9yaWdpblkgPSB0cmFuc2Zvcm0ub3JpZ2luWTtcbiAgICBpZiAodGFyZ2V0LmxvY2tTa2V3aW5nWCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFNrZXcgPT09IDApIHtcbiAgICAgIHZhciBsb2NhbFBvaW50RnJvbUNlbnRlciA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCBDRU5URVIsIENFTlRFUiwgeCwgeSk7XG4gICAgICBpZiAobG9jYWxQb2ludEZyb21DZW50ZXIueCA+IDApIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgcmlnaHQsIGFuY2hvciBsZWZ0O1xuICAgICAgICBvcmlnaW5YID0gTEVGVDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyByaWdodCwgYW5jaG9yIHJpZ2h0XG4gICAgICAgIG9yaWdpblggPSBSSUdIVDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFNrZXcgPiAwKSB7XG4gICAgICAgIG9yaWdpblggPSBvcmlnaW5ZID09PSBUT1AgPyBMRUZUIDogUklHSFQ7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFNrZXcgPCAwKSB7XG4gICAgICAgIG9yaWdpblggPSBvcmlnaW5ZID09PSBUT1AgPyBSSUdIVCA6IExFRlQ7XG4gICAgICB9XG4gICAgICAvLyBpcyB0aGUgb2JqZWN0IGZsaXBwZWQgb24gb25lIHNpZGUgb25seT8gc3dhcCB0aGUgb3JpZ2luLlxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWCA9PT0gTEVGVCA/IFJJR0hUIDogTEVGVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmNlIHdlIGhhdmUgdGhlIG9yaWdpbiwgd2UgZmluZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdHJhbnNmb3JtLm9yaWdpblggPSBvcmlnaW5YO1xuICAgIHZhciBmaW5hbEhhbmRsZXIgPSB3cmFwV2l0aEZpeGVkQW5jaG9yKHNrZXdPYmplY3RYKTtcbiAgICByZXR1cm4gZmluYWxIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVkIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBZIGF4aXMsIHRha2VzIGNhcmUgb2YgdGhlXG4gICAqIHNrZXcgZGlyZWN0aW9uIGFuZCBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbiBmb3IgdGhlIGFuY2hvciBwb2ludFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdIYW5kbGVyWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIHN0ZXAxIGZpZ3VyZSBvdXQgYW5kIGNoYW5nZSB0cmFuc2Zvcm0gb3JpZ2luLlxuICAgIC8vIGlmIHNrZXdZID4gMCBhbmQgb3JpZ2luWCBsZWZ0IHdlIGFuY2hvciBvbiB0b3BcbiAgICAvLyBpZiBza2V3WSA+IDAgYW5kIG9yaWdpblggcmlnaHQgd2UgYW5jaG9yIG9uIGJvdHRvbVxuICAgIC8vIGlmIHNrZXdZIDwgMCBhbmQgb3JpZ2luWCBsZWZ0IHdlIGFuY2hvciBvbiBib3R0b21cbiAgICAvLyBpZiBza2V3WSA8IDAgYW5kIG9yaWdpblggcmlnaHQgd2UgYW5jaG9yIG9uIHRvcFxuICAgIC8vIGlmIHNrZXdZIGlzIDAsIHdlIGxvb2sgZm9yIG1vdXNlIHBvc2l0aW9uIHRvIHVuZGVyc3RhbmQgd2hlcmUgYXJlIHdlIGdvaW5nLlxuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WSwgb3JpZ2luWSwgb3JpZ2luWCA9IHRyYW5zZm9ybS5vcmlnaW5YO1xuICAgIGlmICh0YXJnZXQubG9ja1NrZXdpbmdZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50U2tldyA9PT0gMCkge1xuICAgICAgdmFyIGxvY2FsUG9pbnRGcm9tQ2VudGVyID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIENFTlRFUiwgQ0VOVEVSLCB4LCB5KTtcbiAgICAgIGlmIChsb2NhbFBvaW50RnJvbUNlbnRlci55ID4gMCkge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyBkb3duLCBhbmNob3IgdXA7XG4gICAgICAgIG9yaWdpblkgPSBUT1A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgdXAsIGFuY2hvciBkb3duXG4gICAgICAgIG9yaWdpblkgPSBCT1RUT007XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnRTa2V3ID4gMCkge1xuICAgICAgICBvcmlnaW5ZID0gb3JpZ2luWCA9PT0gTEVGVCA/IFRPUCA6IEJPVFRPTTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50U2tldyA8IDApIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblggPT09IExFRlQgPyBCT1RUT00gOiBUT1A7XG4gICAgICB9XG4gICAgICAvLyBpcyB0aGUgb2JqZWN0IGZsaXBwZWQgb24gb25lIHNpZGUgb25seT8gc3dhcCB0aGUgb3JpZ2luLlxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBvcmlnaW5ZID0gb3JpZ2luWSA9PT0gVE9QID8gQk9UVE9NIDogVE9QO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9uY2Ugd2UgaGF2ZSB0aGUgb3JpZ2luLCB3ZSBmaW5kIHRoZSBhbmNob3IgcG9pbnRcbiAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9IG9yaWdpblk7XG4gICAgdmFyIGZpbmFsSGFuZGxlciA9IHdyYXBXaXRoRml4ZWRBbmNob3Ioc2tld09iamVjdFkpO1xuICAgIHJldHVybiBmaW5hbEhhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyIGZvciByb3RhdGlvbiBhbmQgc25hcHBpbmcsIHdpdGhvdXQgYW5jaG9yIHBvaW50LlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJvdGF0aW9uV2l0aFNuYXBwaW5nKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHQgPSB0cmFuc2Zvcm0sXG4gICAgICAgIHRhcmdldCA9IHQudGFyZ2V0LFxuICAgICAgICBwaXZvdFBvaW50ID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGFyZ2V0LmdldENlbnRlclBvaW50KCksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcblxuICAgIGlmICh0YXJnZXQubG9ja1JvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxhc3RBbmdsZSA9IE1hdGguYXRhbjIodC5leSAtIHBpdm90UG9pbnQueSwgdC5leCAtIHBpdm90UG9pbnQueCksXG4gICAgICAgIGN1ckFuZ2xlID0gTWF0aC5hdGFuMih5IC0gcGl2b3RQb2ludC55LCB4IC0gcGl2b3RQb2ludC54KSxcbiAgICAgICAgYW5nbGUgPSByYWRpYW5zVG9EZWdyZWVzKGN1ckFuZ2xlIC0gbGFzdEFuZ2xlICsgdC50aGV0YSksXG4gICAgICAgIGhhc1JvdGF0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRhcmdldC5zbmFwQW5nbGUgPiAwKSB7XG4gICAgICB2YXIgc25hcEFuZ2xlICA9IHRhcmdldC5zbmFwQW5nbGUsXG4gICAgICAgICAgc25hcFRocmVzaG9sZCAgPSB0YXJnZXQuc25hcFRocmVzaG9sZCB8fCBzbmFwQW5nbGUsXG4gICAgICAgICAgcmlnaHRBbmdsZUxvY2tlZCA9IE1hdGguY2VpbChhbmdsZSAvIHNuYXBBbmdsZSkgKiBzbmFwQW5nbGUsXG4gICAgICAgICAgbGVmdEFuZ2xlTG9ja2VkID0gTWF0aC5mbG9vcihhbmdsZSAvIHNuYXBBbmdsZSkgKiBzbmFwQW5nbGU7XG5cbiAgICAgIGlmIChNYXRoLmFicyhhbmdsZSAtIGxlZnRBbmdsZUxvY2tlZCkgPCBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIGFuZ2xlID0gbGVmdEFuZ2xlTG9ja2VkO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoYW5nbGUgLSByaWdodEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgYW5nbGUgPSByaWdodEFuZ2xlTG9ja2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBhbmdsZSB0byBwb3NpdGl2ZSB2YWx1ZVxuICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgIGFuZ2xlID0gMzYwICsgYW5nbGU7XG4gICAgfVxuICAgIGFuZ2xlICU9IDM2MDtcblxuICAgIGhhc1JvdGF0ZWQgPSB0YXJnZXQuYW5nbGUgIT09IGFuZ2xlO1xuICAgIHRhcmdldC5hbmdsZSA9IGFuZ2xlO1xuICAgIGlmIChoYXNSb3RhdGVkKSB7XG4gICAgICBmaXJlRXZlbnQoJ3JvdGF0aW5nJywgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNSb3RhdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2ljIHNjYWxpbmcgbG9naWMsIHJldXNlZCB3aXRoIGRpZmZlcmVudCBjb25zdHJhaW4gZm9yIHNjYWxpbmcgWCxZLCBmcmVlbHkgb3IgZXF1YWxseS5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBzY2FsaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmJ5ICd4JywgJ3knLCAnZXF1YWxseScgb3IgJycgdG8gaW5kaWNhdGUgdHlwZSBvZiBzY2FsaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIGxvY2tTY2FsaW5nWCA9IHRhcmdldC5sb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSA9IHRhcmdldC5sb2NrU2NhbGluZ1ksXG4gICAgICAgIGJ5ID0gb3B0aW9ucy5ieSwgbmV3UG9pbnQsIHNjYWxlWCwgc2NhbGVZLCBkaW0sXG4gICAgICAgIHNjYWxlUHJvcG9ydGlvbmFsbHkgPSBzY2FsZUlzUHJvcG9ydGlvbmFsKGV2ZW50RGF0YSwgdGFyZ2V0KSxcbiAgICAgICAgZm9yYmlkU2NhbGluZyA9IHNjYWxpbmdJc0ZvcmJpZGRlbih0YXJnZXQsIGJ5LCBzY2FsZVByb3BvcnRpb25hbGx5KSxcbiAgICAgICAgc2lnblgsIHNpZ25ZLCBnZXN0dXJlU2NhbGUgPSB0cmFuc2Zvcm0uZ2VzdHVyZVNjYWxlO1xuXG4gICAgaWYgKGZvcmJpZFNjYWxpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGdlc3R1cmVTY2FsZSkge1xuICAgICAgc2NhbGVYID0gdHJhbnNmb3JtLnNjYWxlWCAqIGdlc3R1cmVTY2FsZTtcbiAgICAgIHNjYWxlWSA9IHRyYW5zZm9ybS5zY2FsZVkgKiBnZXN0dXJlU2NhbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV3UG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KTtcbiAgICAgIC8vIHVzZSBvZiBzaWduOiBXZSB1c2Ugc2lnbiB0byBkZXRlY3QgY2hhbmdlIG9mIGRpcmVjdGlvbiBvZiBhbiBhY3Rpb24uIHNpZ24gdXN1YWxseSBjaGFuZ2Ugd2hlblxuICAgICAgLy8gd2UgY3Jvc3MgdGhlIG9yaWdpbiBwb2ludCB3aXRoIHRoZSBtb3VzZS4gU28gYSBzY2FsZSBmbGlwIGZvciBleGFtcGxlLiBUaGVyZSBpcyBhbiBpc3N1ZSB3aGVuIHNjYWxpbmdcbiAgICAgIC8vIGJ5IGNlbnRlciBhbmQgc2NhbGluZyB1c2luZyBvbmUgbWlkZGxlIGNvbnRyb2wgKCBkZWZhdWx0OiBtciwgbXQsIG1sLCBtYiksIHRoZSBtb3VzZSBtb3ZlbWVudCBjYW4gZWFzaWx5XG4gICAgICAvLyBjcm9zcyBtYW55IHRpbWUgdGhlIG9yaWdpbiBwb2ludCBhbmQgZmxpcCB0aGUgb2JqZWN0LiBzbyB3ZSBuZWVkIGEgd2F5IHRvIGZpbHRlciBvdXQgdGhlIG5vaXNlLlxuICAgICAgLy8gVGhpcyB0ZXJuYXJ5IGhlcmUgc2hvdWxkIGJlIG9rIHRvIGZpbHRlciBvdXQgWCBzY2FsaW5nIHdoZW4gd2Ugd2FudCBZIG9ubHkgYW5kIHZpY2UgdmVyc2EuXG4gICAgICBzaWduWCA9IGJ5ICE9PSAneScgPyBzaWduKG5ld1BvaW50LngpIDogMTtcbiAgICAgIHNpZ25ZID0gYnkgIT09ICd4JyA/IHNpZ24obmV3UG9pbnQueSkgOiAxO1xuICAgICAgaWYgKCF0cmFuc2Zvcm0uc2lnblgpIHtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25YID0gc2lnblg7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zZm9ybS5zaWduWSkge1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblkgPSBzaWduWTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldC5sb2NrU2NhbGluZ0ZsaXAgJiZcbiAgICAgICAgKHRyYW5zZm9ybS5zaWduWCAhPT0gc2lnblggfHwgdHJhbnNmb3JtLnNpZ25ZICE9PSBzaWduWSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGRpbSA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAvLyBtaXNzaW5nIGRldGVjdGlvbiBvZiBmbGlwIGFuZCBsb2dpYyB0byBzd2l0Y2ggdGhlIG9yaWdpblxuICAgICAgaWYgKHNjYWxlUHJvcG9ydGlvbmFsbHkgJiYgIWJ5KSB7XG4gICAgICAgIC8vIHVuaWZvcm0gc2NhbGluZ1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhuZXdQb2ludC54KSArIE1hdGguYWJzKG5ld1BvaW50LnkpLFxuICAgICAgICAgICAgb3JpZ2luYWwgPSB0cmFuc2Zvcm0ub3JpZ2luYWwsXG4gICAgICAgICAgICBvcmlnaW5hbERpc3RhbmNlID0gTWF0aC5hYnMoZGltLnggKiBvcmlnaW5hbC5zY2FsZVggLyB0YXJnZXQuc2NhbGVYKSArXG4gICAgICAgICAgICAgIE1hdGguYWJzKGRpbS55ICogb3JpZ2luYWwuc2NhbGVZIC8gdGFyZ2V0LnNjYWxlWSksXG4gICAgICAgICAgICBzY2FsZSA9IGRpc3RhbmNlIC8gb3JpZ2luYWxEaXN0YW5jZSwgaGFzU2NhbGVkO1xuICAgICAgICBzY2FsZVggPSBvcmlnaW5hbC5zY2FsZVggKiBzY2FsZTtcbiAgICAgICAgc2NhbGVZID0gb3JpZ2luYWwuc2NhbGVZICogc2NhbGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gTWF0aC5hYnMobmV3UG9pbnQueCAqIHRhcmdldC5zY2FsZVggLyBkaW0ueCk7XG4gICAgICAgIHNjYWxlWSA9IE1hdGguYWJzKG5ld1BvaW50LnkgKiB0YXJnZXQuc2NhbGVZIC8gZGltLnkpO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlIHNjYWxpbmcgYnkgY2VudGVyLCB3ZSBuZWVkIHRvIGRvdWJsZSB0aGUgc2NhbGVcbiAgICAgIGlmIChpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkpIHtcbiAgICAgICAgc2NhbGVYICo9IDI7XG4gICAgICAgIHNjYWxlWSAqPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5zaWduWCAhPT0gc2lnblggJiYgYnkgIT09ICd5Jykge1xuICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9IG9wcG9zaXRlW3RyYW5zZm9ybS5vcmlnaW5YXTtcbiAgICAgICAgc2NhbGVYICo9IC0xO1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblggPSBzaWduWDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0uc2lnblkgIT09IHNpZ25ZICYmIGJ5ICE9PSAneCcpIHtcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSBvcHBvc2l0ZVt0cmFuc2Zvcm0ub3JpZ2luWV07XG4gICAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25ZID0gc2lnblk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG1pblNjYWxlIGlzIHRha2VuIGFyZSBpbiB0aGUgc2V0dGVyLlxuICAgIHZhciBvbGRTY2FsZVggPSB0YXJnZXQuc2NhbGVYLCBvbGRTY2FsZVkgPSB0YXJnZXQuc2NhbGVZO1xuICAgIGlmICghYnkpIHtcbiAgICAgICFsb2NrU2NhbGluZ1ggJiYgdGFyZ2V0LnNldCgnc2NhbGVYJywgc2NhbGVYKTtcbiAgICAgICFsb2NrU2NhbGluZ1kgJiYgdGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBmb3JiaWRkZW4gY2FzZXMgYWxyZWFkeSBoYW5kbGVkIG9uIHRvcCBoZXJlLlxuICAgICAgYnkgPT09ICd4JyAmJiB0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpO1xuICAgICAgYnkgPT09ICd5JyAmJiB0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpO1xuICAgIH1cbiAgICBoYXNTY2FsZWQgPSBvbGRTY2FsZVggIT09IHRhcmdldC5zY2FsZVggfHwgb2xkU2NhbGVZICE9PSB0YXJnZXQuc2NhbGVZO1xuICAgIGlmIChoYXNTY2FsZWQpIHtcbiAgICAgIGZpcmVFdmVudCgnc2NhbGluZycsIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzU2NhbGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgc2NhbGluZyBsb2dpYywgdG8gc2NhbGUgZnJvbSBjb3JuZXJzIGVpdGhlciBlcXVhbGx5IG9yIGZyZWVseS5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdEZyb21Db3JuZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4gc2NhbGVPYmplY3QoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxpbmcgbG9naWMgZm9yIHRoZSBYIGF4aXMuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5ICwgeyBieTogJ3gnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxpbmcgbG9naWMgZm9yIHRoZSBZIGF4aXMuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5ICwgeyBieTogJ3knIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2VkIGFjdGlvbiBoYW5kbGVyIHRvIGVpdGhlciBzY2FsZSBZIG9yIHNrZXcgWFxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdZT3JTa2V3aW5nWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIG9rIHNvbWUgc2FmZXR5IG5lZWRlZCBoZXJlLlxuICAgIGlmIChldmVudERhdGFbdHJhbnNmb3JtLnRhcmdldC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdIYW5kbGVyWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsaW5nWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZWQgYWN0aW9uIGhhbmRsZXIgdG8gZWl0aGVyIHNjYWxlIFggb3Igc2tldyBZXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGluZ1hPclNrZXdpbmdZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gb2sgc29tZSBzYWZldHkgbmVlZGVkIGhlcmUuXG4gICAgaWYgKGV2ZW50RGF0YVt0cmFuc2Zvcm0udGFyZ2V0LmNhbnZhcy5hbHRBY3Rpb25LZXldKSB7XG4gICAgICByZXR1cm4gY29udHJvbHMuc2tld0hhbmRsZXJZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xzLnNjYWxpbmdYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciB0byBjaGFuZ2UgdGV4dGJveCB3aWR0aFxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIGNoYW5nZVdpZHRoKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgc3Ryb2tlUGFkZGluZyA9IHRhcmdldC5zdHJva2VXaWR0aCAvICh0YXJnZXQuc3Ryb2tlVW5pZm9ybSA/IHRhcmdldC5zY2FsZVggOiAxKSxcbiAgICAgICAgbXVsdGlwbGllciA9IGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSA/IDIgOiAxLFxuICAgICAgICBvbGRXaWR0aCA9IHRhcmdldC53aWR0aCwgaGFzUmVzaXplZCxcbiAgICAgICAgbmV3V2lkdGggPSBNYXRoLmFicyhsb2NhbFBvaW50LnggKiBtdWx0aXBsaWVyIC8gdGFyZ2V0LnNjYWxlWCkgLSBzdHJva2VQYWRkaW5nO1xuICAgIHRhcmdldC5zZXQoJ3dpZHRoJywgTWF0aC5tYXgobmV3V2lkdGgsIDApKTtcbiAgICBoYXNSZXNpemVkID0gb2xkV2lkdGggIT09IG5ld1dpZHRoO1xuICAgIGlmIChoYXNSZXNpemVkKSB7XG4gICAgICBmaXJlRXZlbnQoJ3Jlc2l6aW5nJywgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNSZXNpemVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gb2NjdXJyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGRyYWdIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIG5ld0xlZnQgPSB4IC0gdHJhbnNmb3JtLm9mZnNldFgsXG4gICAgICAgIG5ld1RvcCA9IHkgLSB0cmFuc2Zvcm0ub2Zmc2V0WSxcbiAgICAgICAgbW92ZVggPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WCcpICYmIHRhcmdldC5sZWZ0ICE9PSBuZXdMZWZ0LFxuICAgICAgICBtb3ZlWSA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRZJykgJiYgdGFyZ2V0LnRvcCAhPT0gbmV3VG9wO1xuICAgIG1vdmVYICYmIHRhcmdldC5zZXQoJ2xlZnQnLCBuZXdMZWZ0KTtcbiAgICBtb3ZlWSAmJiB0YXJnZXQuc2V0KCd0b3AnLCBuZXdUb3ApO1xuICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgZmlyZUV2ZW50KCdtb3ZpbmcnLCBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVYIHx8IG1vdmVZO1xuICB9XG5cbiAgY29udHJvbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIgPSBzY2FsZUN1cnNvclN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMuc2tld0N1cnNvclN0eWxlSGFuZGxlciA9IHNrZXdDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlciA9IHNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMucm90YXRpb25XaXRoU25hcHBpbmcgPSB3cmFwV2l0aEZpeGVkQW5jaG9yKHJvdGF0aW9uV2l0aFNuYXBwaW5nKTtcbiAgY29udHJvbHMuc2NhbGluZ0VxdWFsbHkgPSB3cmFwV2l0aEZpeGVkQW5jaG9yKHNjYWxlT2JqZWN0RnJvbUNvcm5lcik7XG4gIGNvbnRyb2xzLnNjYWxpbmdYID0gd3JhcFdpdGhGaXhlZEFuY2hvcihzY2FsZU9iamVjdFgpO1xuICBjb250cm9scy5zY2FsaW5nWSA9IHdyYXBXaXRoRml4ZWRBbmNob3Ioc2NhbGVPYmplY3RZKTtcbiAgY29udHJvbHMuc2NhbGluZ1lPclNrZXdpbmdYID0gc2NhbGluZ1lPclNrZXdpbmdYO1xuICBjb250cm9scy5zY2FsaW5nWE9yU2tld2luZ1kgPSBzY2FsaW5nWE9yU2tld2luZ1k7XG4gIGNvbnRyb2xzLmNoYW5nZVdpZHRoID0gd3JhcFdpdGhGaXhlZEFuY2hvcihjaGFuZ2VXaWR0aCk7XG4gIGNvbnRyb2xzLnNrZXdIYW5kbGVyWCA9IHNrZXdIYW5kbGVyWDtcbiAgY29udHJvbHMuc2tld0hhbmRsZXJZID0gc2tld0hhbmRsZXJZO1xuICBjb250cm9scy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuICBjb250cm9scy5zY2FsZU9yU2tld0FjdGlvbk5hbWUgPSBzY2FsZU9yU2tld0FjdGlvbk5hbWU7XG4gIGNvbnRyb2xzLnJvdGF0aW9uU3R5bGVIYW5kbGVyID0gcm90YXRpb25TdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLmZpcmVFdmVudCA9IGZpcmVFdmVudDtcbiAgY29udHJvbHMud3JhcFdpdGhGaXhlZEFuY2hvciA9IHdyYXBXaXRoRml4ZWRBbmNob3I7XG4gIGNvbnRyb2xzLmdldExvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50O1xuICBmYWJyaWMuY29udHJvbHNVdGlscyA9IGNvbnRyb2xzO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIGNvbnRyb2xzID0gZmFicmljLmNvbnRyb2xzVXRpbHM7XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHJvdW5kIGNvbnRyb2wsIGFzIHBlciBmYWJyaWMgZmVhdHVyZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgd3JpdHRlbiB0byByZXNwZWN0IG9iamVjdCBwcm9wZXJ0aWVzIGxpa2UgdHJhbnNwYXJlbnRDb3JuZXJzLCBjb3JuZXJTaXplXG4gICAqIGNvcm5lckNvbG9yLCBjb3JuZXJTdHJva2VDb2xvclxuICAgKiBwbHVzIHRoZSBhZGRpdGlvbiBvZiBvZmZzZXRZIGFuZCBvZmZzZXRYLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb3ZlcnJpZGUgZm9yIGZhYnJpYy5PYmplY3QgY29udHJvbHMgc3R5bGVcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlckNpcmNsZUNvbnRyb2wgKGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpIHtcbiAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICB2YXIgeFNpemUgPSB0aGlzLnNpemVYIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgeVNpemUgPSB0aGlzLnNpemVZIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgOiB0aGlzLnRyYW5zcGFyZW50Q29ybmVycyxcbiAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnLFxuICAgICAgICBzdHJva2UgPSAhdHJhbnNwYXJlbnRDb3JuZXJzICYmIChzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvciksXG4gICAgICAgIG15TGVmdCA9IGxlZnQsXG4gICAgICAgIG15VG9wID0gdG9wLCBzaXplO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lckNvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yO1xuICAgIC8vIGFzIHNvb24gYXMgZmFicmljIHJlYWN0IHY1LCByZW1vdmUgaWUxMSwgdXNlIHByb3BlciBlbGxpcHNlIGNvZGUuXG4gICAgaWYgKHhTaXplID4geVNpemUpIHtcbiAgICAgIHNpemUgPSB4U2l6ZTtcbiAgICAgIGN0eC5zY2FsZSgxLjAsIHlTaXplIC8geFNpemUpO1xuICAgICAgbXlUb3AgPSB0b3AgKiB4U2l6ZSAvIHlTaXplO1xuICAgIH1cbiAgICBlbHNlIGlmICh5U2l6ZSA+IHhTaXplKSB7XG4gICAgICBzaXplID0geVNpemU7XG4gICAgICBjdHguc2NhbGUoeFNpemUgLyB5U2l6ZSwgMS4wKTtcbiAgICAgIG15TGVmdCA9IGxlZnQgKiB5U2l6ZSAvIHhTaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNpemUgPSB4U2l6ZTtcbiAgICB9XG4gICAgLy8gdGhpcyBpcyBzdGlsbCB3cm9uZ1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKG15TGVmdCwgbXlUb3AsIHNpemUgLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGN0eFttZXRob2ROYW1lXSgpO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBzcXVhcmUgY29udHJvbCwgYXMgcGVyIGZhYnJpYyBmZWF0dXJlcy5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB3cml0dGVuIHRvIHJlc3BlY3Qgb2JqZWN0IHByb3BlcnRpZXMgbGlrZSB0cmFuc3BhcmVudENvcm5lcnMsIGNvcm5lclNpemVcbiAgICogY29ybmVyQ29sb3IsIGNvcm5lclN0cm9rZUNvbG9yXG4gICAqIHBsdXMgdGhlIGFkZGl0aW9uIG9mIG9mZnNldFkgYW5kIG9mZnNldFguXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgeCBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCB5IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvdmVycmlkZSBmb3IgZmFicmljLk9iamVjdCBjb250cm9scyBzdHlsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIHJlbmRlcmluZyBjb250cm9sc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyU3F1YXJlQ29udHJvbChjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgdmFyIHhTaXplID0gdGhpcy5zaXplWCB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHlTaXplID0gdGhpcy5zaXplWSB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzIDogZmFicmljT2JqZWN0LnRyYW5zcGFyZW50Q29ybmVycyxcbiAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnLFxuICAgICAgICBzdHJva2UgPSAhdHJhbnNwYXJlbnRDb3JuZXJzICYmIChcbiAgICAgICAgICBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvclxuICAgICAgICApLCB4U2l6ZUJ5MiA9IHhTaXplIC8gMiwgeVNpemVCeTIgPSB5U2l6ZSAvIDI7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5zdHJva2VDb3JuZXJDb2xvciB8fCBmYWJyaWNPYmplY3Quc3Ryb2tlQ29ybmVyQ29sb3I7XG4gICAgLy8gdGhpcyBpcyBzdGlsbCB3cm9uZ1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC50cmFuc2xhdGUobGVmdCwgdG9wKTtcbiAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnMoZmFicmljT2JqZWN0LmFuZ2xlKSk7XG4gICAgLy8gdGhpcyBkb2VzIG5vdCB3b3JrLCBhbmQgZml4ZWQgd2l0aCAoICYmICkgZG9lcyBub3QgbWFrZSBzZW5zZS5cbiAgICAvLyB0byBoYXZlIHJlYWwgdHJhbnNwYXJlbnQgY29ybmVycyB3ZSBuZWVkIHRoZSBjb250cm9scyBvbiB1cHBlckNhbnZhc1xuICAgIC8vIHRyYW5zcGFyZW50Q29ybmVycyB8fCBjdHguY2xlYXJSZWN0KC14U2l6ZUJ5MiwgLXlTaXplQnkyLCB4U2l6ZSwgeVNpemUpO1xuICAgIGN0eFttZXRob2ROYW1lICsgJ1JlY3QnXSgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlUmVjdCgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGNvbnRyb2xzLnJlbmRlckNpcmNsZUNvbnRyb2wgPSByZW5kZXJDaXJjbGVDb250cm9sO1xuICBjb250cm9scy5yZW5kZXJTcXVhcmVDb250cm9sID0gcmVuZGVyU3F1YXJlQ29udHJvbDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGZ1bmN0aW9uIENvbnRyb2wob3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgdGhpc1tpXSA9IG9wdGlvbnNbaV07XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbnRyb2wgPSBDb250cm9sO1xuXG4gIGZhYnJpYy5Db250cm9sLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbnRyb2wucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIGtlZXAgdHJhY2sgb2YgY29udHJvbCB2aXNpYmlsaXR5LlxuICAgICAqIG1haW5seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKiBpZiB5b3UgZG8gbm90IHdhbnQgdG8gc2VlIGEgY29udHJvbCwgeW91IGNhbiByZW1vdmUgaXRcbiAgICAgKiBmcm9tIHRoZSBjb250cm9sc2V0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgYWN0aW9uIHRoYXQgdGhlIGNvbnRyb2wgd2lsbCBsaWtlbHkgZXhlY3V0ZS5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsLiBGYWJyaWNKUyB1c2VzIHRvIGlkZW50aWZ5IHdoYXQgdGhlIHVzZXIgaXMgZG9pbmcgZm9yIHNvbWVcbiAgICAgKiBleHRyYSBvcHRpbWl6YXRpb25zLiBJZiB5b3UgYXJlIHdyaXRpbmcgYSBjdXN0b20gY29udHJvbCBhbmQgeW91IHdhbnQgdG8ga25vd1xuICAgICAqIHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIHdoYXQgaXMgZ29pbmcgb24sIHlvdSBjYW4gdXNlIHRoaXMgc3RyaW5nIGhlcmUuXG4gICAgICogeW91IGNhbiBhbHNvIHByb3ZpZGUgYSBjdXN0b20gZ2V0QWN0aW9uTmFtZSBpZiB5b3VyIGNvbnRyb2wgcnVuIG11bHRpcGxlIGFjdGlvbnNcbiAgICAgKiBkZXBlbmRpbmcgb24gc29tZSBleHRlcm5hbCBzdGF0ZS5cbiAgICAgKiBkZWZhdWx0IHRvIHNjYWxlIHNpbmNlIGlzIHRoZSBtb3N0IGNvbW1vbiwgdXNlZCBvbiA0IGNvcm5lcnMgYnkgZGVmYXVsdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3NjYWxlJ1xuICAgICAqL1xuICAgIGFjdGlvbk5hbWU6ICdzY2FsZScsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3aW5nIGFuZ2xlIG9mIHRoZSBjb250cm9sLlxuICAgICAqIE5PVCB1c2VkIGZvciBub3csIGJ1dCBuYW1lIG1hcmtlZCBhcyBuZWVkZWQgZm9yIGludGVybmFsIGxvZ2ljXG4gICAgICogZXhhbXBsZTogdG8gcmV1c2UgdGhlIHNhbWUgZHJhd2luZyBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IHJvdGF0ZWQgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBhbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLiBYXG4gICAgICogMCwwIGlzIHRoZSBjZW50ZXIgb2YgdGhlIE9iamVjdCwgd2hpbGUgLTAuNSAobGVmdCkgb3IgMC41IChyaWdodCkgYXJlIHRoZSBleHRyZW1pdGllc1xuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgeDogMCxcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLiBZXG4gICAgICogMCwwIGlzIHRoZSBjZW50ZXIgb2YgdGhlIE9iamVjdCwgd2hpbGUgLTAuNSAodG9wKSBvciAwLjUgKGJvdHRvbSkgYXJlIHRoZSBleHRyZW1pdGllc1xuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgeTogMCxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IG9mIHRoZSBjb250cm9sIGZyb20gdGhlIGRlZmluZWQgcG9zaXRpb24uIEluIHBpeGVsc1xuICAgICAqIFBvc2l0aXZlIG9mZnNldCBtb3ZlcyB0aGUgY29udHJvbCB0byB0aGUgcmlnaHQsIG5lZ2F0aXZlIHRvIHRoZSBsZWZ0LlxuICAgICAqIEl0IHVzZWQgd2hlbiB5b3Ugd2FudCB0byBoYXZlIHBvc2l0aW9uIG9mIGNvbnRyb2wgdGhhdCBkb2VzIG5vdCBzY2FsZSB3aXRoXG4gICAgICogdGhlIGJvdW5kaW5nIGJveC4gRXhhbXBsZTogcm90YXRpb24gY29udHJvbCBpcyBwbGFjZWQgYXQgeDowLCB5OiAwLjUgb25cbiAgICAgKiB0aGUgYm91bmRpbmRib3gsIHdpdGggYW4gb2Zmc2V0IG9mIDMwIHBpeGVscyB2ZXJ0aWNhbGx5LiBUaG9zZSAzMCBwaXhlbHMgd2lsbFxuICAgICAqIHN0YXkgMzAgcGl4ZWxzIG5vIG1hdHRlciBob3cgdGhlIG9iamVjdCBpcyBiaWcuIEFub3RoZXIgZXhhbXBsZSBpcyBoYXZpbmcgMlxuICAgICAqIGNvbnRyb2xzIGluIHRoZSBjb3JuZXIsIHRoYXQgc3RheSBpbiB0aGUgc2FtZSBwb3NpdGlvbiB3aGVuIHRoZSBvYmplY3Qgc2NhbGUuXG4gICAgICogb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgb2Zmc2V0IG9mIHRoZSBjb250cm9sIGZyb20gdGhlIGRlZmluZWQgcG9zaXRpb24uIEluIHBpeGVsc1xuICAgICAqIFBvc2l0aXZlIG9mZnNldCBtb3ZlcyB0aGUgY29udHJvbCB0byB0aGUgYm90dG9tLCBuZWdhdGl2ZSB0byB0aGUgdG9wLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIGNvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHNpemVYIGFuZCBzaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHNpemVYOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyBjb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCBzaXplWCBhbmQgc2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBzaXplWTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxlbmd0aCBvZiB0aGUgdG91Y2ggYXJlYSBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgdG91Y2hDb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCB0b3VjaFNpemVYIGFuZCB0b3VjaFNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdG91Y2hTaXplWDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgdG91Y2ggYXJlYSBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgdG91Y2hDb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCB0b3VjaFNpemVYIGFuZCB0b3VjaFNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdG91Y2hTaXplWTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENzcyBjdXJzb3Igc3R5bGUgdG8gZGlzcGxheSB3aGVuIHRoZSBjb250cm9sIGlzIGhvdmVyZWQuXG4gICAgICogaWYgdGhlIG1ldGhvZCBgY3Vyc29yU3R5bGVIYW5kbGVyYCBpcyBwcm92aWRlZCwgdGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2Nyb3NzaGFpcidcbiAgICAgKi9cbiAgICBjdXJzb3JTdHlsZTogJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBJZiBjb250cm9scyBoYXMgYW4gb2Zmc2V0WSBvciBvZmZzZXRYLCBkcmF3IGEgbGluZSB0aGF0IGNvbm5lY3RzXG4gICAgICogdGhlIGNvbnRyb2wgdG8gdGhlIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgd2l0aENvbm5lY3Rpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgYWN0aW9uSGFuZGxlciwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIGFjdGlvbiAoIGNvbnRyb2wgYmVpbmcgbW92ZWQgKVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgaGFuZGxlciBmb3IgbW91c2UgZG93biwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIG1vdXNlIGRvd24gb24gY29udHJvbFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIG1vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgbW91c2VVcEhhbmRsZXIsIHByb3ZpZGUgb25lIHRvIGhhbmRsZSBhbiBlZmZlY3Qgb24gbW91c2UgdXAuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbi9ldmVudCBtb2RpZmllZCB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIGFjdGlvbkhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldEFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgbW91c2VEb3duIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldE1vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25IYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgbW91c2VVcCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIGNvbnRyb2wgZm9yIHdoaWNoIHRoZSBhY3Rpb24gaGFuZGxlciBpcyBiZWluZyBhc2tlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgKi9cbiAgICBnZXRNb3VzZVVwSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCBmYWJyaWNPYmplY3QsIGNvbnRyb2wgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlVXBIYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgY3Vyc29yU3R5bGUgZm9yIGNzcyB1c2luZyBjdXJzb3JTdHlsZS4gSWYgeW91IG5lZWQgYSBtb3JlIGVsYWJvcmF0ZVxuICAgICAqIGZ1bmN0aW9uIHlvdSBjYW4gcGFzcyBvbmUgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogdGhlIGN1cnNvclN0eWxlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjdXJyZW50IGNvbnRyb2wgKCBsaWtlbHkgdGhpcylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBmdW5jdGlvbihldmVudERhdGEsIGNvbnRyb2wgLyogZmFicmljT2JqZWN0ICovKSB7XG4gICAgICByZXR1cm4gY29udHJvbC5jdXJzb3JTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aW9uIG5hbWUuIFRoZSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybiB0aGUgYWN0aW9uTmFtZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGN1cnJlbnQgY29udHJvbCAoIGxpa2VseSB0aGlzKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBY3Rpb25OYW1lOiBmdW5jdGlvbihldmVudERhdGEsIGNvbnRyb2wgLyogZmFicmljT2JqZWN0ICovKSB7XG4gICAgICByZXR1cm4gY29udHJvbC5hY3Rpb25OYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2xzIHZpc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBrZXkgd2hlcmUgdGhlIGNvbnRyb2wgaXMgbWVtb3JpemVkIG9uIHRoZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0VmlzaWJpbGl0eTogZnVuY3Rpb24oZmFicmljT2JqZWN0LCBjb250cm9sS2V5KSB7XG4gICAgICB2YXIgb2JqZWN0VmlzaWJpbGl0eSA9IGZhYnJpY09iamVjdC5fY29udHJvbHNWaXNpYmlsaXR5O1xuICAgICAgaWYgKG9iamVjdFZpc2liaWxpdHkgJiYgdHlwZW9mIG9iamVjdFZpc2liaWxpdHlbY29udHJvbEtleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RWaXNpYmlsaXR5W2NvbnRyb2xLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb250cm9scyB2aXNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmlsaXR5IGZvciB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZXRWaXNpYmlsaXR5OiBmdW5jdGlvbih2aXNpYmlsaXR5IC8qIG5hbWUsIGZhYnJpY09iamVjdCAqLykge1xuICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJpbGl0eTtcbiAgICB9LFxuXG5cbiAgICBwb3NpdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGRpbSwgZmluYWxNYXRyaXggLyosIGZhYnJpY09iamVjdCwgY3VycmVudENvbnRyb2wgKi8pIHtcbiAgICAgIHZhciBwb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHtcbiAgICAgICAgeDogdGhpcy54ICogZGltLnggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IHRoaXMueSAqIGRpbS55ICsgdGhpcy5vZmZzZXRZIH0sIGZpbmFsTWF0cml4KTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRzIGZvciB0aGlzIGNvbnRyb2wgYmFzZWQgb24gb2JqZWN0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2JqZWN0QW5nbGUgYW5nbGUgZnJvbSB0aGUgZmFicmljIG9iamVjdCBob2xkaW5nIHRoZSBjb250cm9sXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9iamVjdENvcm5lclNpemUgY29ybmVyU2l6ZSBmcm9tIHRoZSBmYWJyaWMgb2JqZWN0IGhvbGRpbmcgdGhlIGNvbnRyb2wgKG9yIHRvdWNoQ29ybmVyU2l6ZSBpZlxuICAgICAqICAgaXNUb3VjaCBpcyB0cnVlKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXJYIHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRlclkgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVG91Y2ggdHJ1ZSBpZiB0b3VjaCBjb3JuZXIsIGZhbHNlIGlmIG5vcm1hbCBjb3JuZXJcbiAgICAgKi9cbiAgICBjYWxjQ29ybmVyQ29vcmRzOiBmdW5jdGlvbihvYmplY3RBbmdsZSwgb2JqZWN0Q29ybmVyU2l6ZSwgY2VudGVyWCwgY2VudGVyWSwgaXNUb3VjaCkge1xuICAgICAgdmFyIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgc2luSGFsZk9mZnNldCxcbiAgICAgICAgICBjb3NIYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB4U2l6ZSA9IChpc1RvdWNoKSA/IHRoaXMudG91Y2hTaXplWCA6IHRoaXMuc2l6ZVgsXG4gICAgICAgICAgeVNpemUgPSAoaXNUb3VjaCkgPyB0aGlzLnRvdWNoU2l6ZVkgOiB0aGlzLnNpemVZO1xuICAgICAgaWYgKHhTaXplICYmIHlTaXplICYmIHhTaXplICE9PSB5U2l6ZSkge1xuICAgICAgICAvLyBoYW5kbGUgcmVjdGFuZ3VsYXIgY29ybmVyc1xuICAgICAgICB2YXIgY29udHJvbFRyaWFuZ2xlQW5nbGUgPSBNYXRoLmF0YW4yKHlTaXplLCB4U2l6ZSk7XG4gICAgICAgIHZhciBjb3JuZXJIeXBvdGVudXNlID0gTWF0aC5zcXJ0KHhTaXplICogeFNpemUgKyB5U2l6ZSAqIHlTaXplKSAvIDI7XG4gICAgICAgIHZhciBuZXdUaGV0YSA9IGNvbnRyb2xUcmlhbmdsZUFuZ2xlIC0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvYmplY3RBbmdsZSk7XG4gICAgICAgIHZhciBuZXdUaGV0YUNvbXAgPSBNYXRoLlBJIC8gMiAtIGNvbnRyb2xUcmlhbmdsZUFuZ2xlIC0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvYmplY3RBbmdsZSk7XG4gICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhKTtcbiAgICAgICAgc2luSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5zaW4obmV3VGhldGEpO1xuICAgICAgICAvLyB1c2UgY29tcGxlbWVudGFyeSBhbmdsZSBmb3IgdHdvIGNvcm5lcnNcbiAgICAgICAgY29zSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhQ29tcCk7XG4gICAgICAgIHNpbkhhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YUNvbXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBzcXVhcmUgY29ybmVyc1xuICAgICAgICAvLyB1c2UgZGVmYXVsdCBvYmplY3QgY29ybmVyIHNpemUgdW5sZXNzIHNpemUgaXMgZGVmaW5lZFxuICAgICAgICB2YXIgY29ybmVyU2l6ZSA9ICh4U2l6ZSAmJiB5U2l6ZSkgPyB4U2l6ZSA6IG9iamVjdENvcm5lclNpemU7XG4gICAgICAgIC8qIDAuNzA3MTA2NzgxMiBzdGFuZHMgZm9yIHNxcnQoMikvMiAqL1xuICAgICAgICBjb3JuZXJIeXBvdGVudXNlID0gY29ybmVyU2l6ZSAqIDAuNzA3MTA2NzgxMjtcbiAgICAgICAgLy8gY29tcGxlbWVudGFyeSBhbmdsZXMgYXJlIGVxdWFsIHNpbmNlIHRoZXkncmUgYm90aCA0NSBkZWdyZWVzXG4gICAgICAgIHZhciBuZXdUaGV0YSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoNDUgLSBvYmplY3RBbmdsZSk7XG4gICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3NIYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGEpO1xuICAgICAgICBzaW5IYWxmT2Zmc2V0ID0gc2luSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGw6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYIC0gc2luSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgeTogY2VudGVyWSAtIGNvc0hhbGZPZmZzZXRDb21wLFxuICAgICAgICB9LFxuICAgICAgICB0cjoge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHk6IGNlbnRlclkgLSBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgICBibDoge1xuICAgICAgICAgIHg6IGNlbnRlclggLSBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHk6IGNlbnRlclkgKyBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgICBicjoge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB5OiBjZW50ZXJZICsgY29zSGFsZk9mZnNldENvbXAsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJlbmRlciBmdW5jdGlvbiBmb3IgdGhlIGNvbnRyb2wuXG4gICAgKiBXaGVuIHRoaXMgZnVuY3Rpb24gcnVucyB0aGUgY29udGV4dCBpcyB1bnNjYWxlZC4gdW5yb3RhdGUuIEp1c3QgcmV0aW5hIHNjYWxlZC5cbiAgICAqIGFsbCB0aGUgZnVuY3Rpb25zIHdpbGwgaGF2ZSB0byB0cmFuc2xhdGUgdG8gdGhlIHBvaW50IGxlZnQsdG9wIGJlZm9yZSBzdGFydGluZyBEcmF3aW5nXG4gICAgKiBpZiB0aGV5IHdhbnQgdG8gZHJhdyBhIGNvbnRyb2wgd2hlcmUgdGhlIHBvc2l0aW9uIGlzIGRldGVjdGVkLlxuICAgICogbGVmdCBhbmQgdG9wIGFyZSB0aGUgcmVzdWx0IG9mIHRoZSBwb3NpdGlvbkhhbmRsZXIgZnVuY3Rpb25cbiAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdGhlIGNvbnRleHQgd2hlcmUgdGhlIGNvbnRyb2wgd2lsbCBiZSBkcmF3blxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgcG9zaXRpb24gb2YgdGhlIGNhbnZhcyB3aGVyZSB3ZSBhcmUgYWJvdXQgdG8gcmVuZGVyIHRoZSBjb250cm9sLlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBwb3NpdGlvbiBvZiB0aGUgY2FudmFzIHdoZXJlIHdlIGFyZSBhYm91dCB0byByZW5kZXIgdGhlIGNvbnRyb2wuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZVxuICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIG9iamVjdCB3aGVyZSB0aGUgY29udHJvbCBpcyBhYm91dCB0byBiZSByZW5kZXJlZFxuICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHN3aXRjaCAoc3R5bGVPdmVycmlkZS5jb3JuZXJTdHlsZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICBmYWJyaWMuY29udHJvbHNVdGlscy5yZW5kZXJDaXJjbGVDb250cm9sLmNhbGwodGhpcywgY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZmFicmljLmNvbnRyb2xzVXRpbHMucmVuZGVyU3F1YXJlQ29udHJvbC5jYWxsKHRoaXMsIGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICBmdW5jdGlvbiBnZXRDb2xvclN0b3AoZWwsIG11bHRpcGxpZXIpIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyksXG4gICAgICAgIG9mZnNldCA9IGVsLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykgfHwgMCxcbiAgICAgICAgY29sb3IsIGNvbG9yQWxwaGEsIG9wYWNpdHksIGk7XG5cbiAgICAvLyBjb252ZXJ0IHBlcmNlbnRzIHRvIGFic29sdXRlIHZhbHVlc1xuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0KSAvICgvJSQvLnRlc3Qob2Zmc2V0KSA/IDEwMCA6IDEpO1xuICAgIG9mZnNldCA9IG9mZnNldCA8IDAgPyAwIDogb2Zmc2V0ID4gMSA/IDEgOiBvZmZzZXQ7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIga2V5VmFsdWVQYWlycyA9IHN0eWxlLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgaWYgKGtleVZhbHVlUGFpcnNba2V5VmFsdWVQYWlycy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAga2V5VmFsdWVQYWlycy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0ga2V5VmFsdWVQYWlycy5sZW5ndGg7IGktLTsgKSB7XG5cbiAgICAgICAgdmFyIHNwbGl0ID0ga2V5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICBrZXkgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdLnRyaW0oKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnc3RvcC1jb2xvcicpIHtcbiAgICAgICAgICBjb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0b3Atb3BhY2l0eScpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpIHx8ICdyZ2IoMCwwLDApJztcbiAgICB9XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICBvcGFjaXR5ID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICB9XG5cbiAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpO1xuICAgIGNvbG9yQWxwaGEgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgIG9wYWNpdHkgPSBpc05hTihwYXJzZUZsb2F0KG9wYWNpdHkpKSA/IDEgOiBwYXJzZUZsb2F0KG9wYWNpdHkpO1xuICAgIG9wYWNpdHkgKj0gY29sb3JBbHBoYSAqIG11bHRpcGxpZXI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3IudG9SZ2IoKSxcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZWFyQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ3gxJykgfHwgMCxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ3kxJykgfHwgMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ3gyJykgfHwgJzEwMCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgneTInKSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhZGlhbENvb3JkcyhlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogZWwuZ2V0QXR0cmlidXRlKCdmeCcpIHx8IGVsLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnNTAlJyxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z5JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjE6IDAsXG4gICAgICB4MjogZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnNTAlJyxcbiAgICAgIHIyOiBlbC5nZXRBdHRyaWJ1dGUoJ3InKSB8fCAnNTAlJ1xuICAgIH07XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgLyoqXG4gICAqIEdyYWRpZW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuR3JhZGllbnRcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjZ3JhZGllbnRzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuR3JhZGllbnQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5HcmFkaWVudCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkdyYWRpZW50LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIG9mZnNldCBmb3IgYWxpZ25pbmcgZ3JhZGllbnRzIGNvbWluZyBmcm9tIFNWRyB3aGVuIG91dHNpZGUgcGF0aGdyb3Vwc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYW5zZm9ybSBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGdyYWRpZW50IGJlZm9yZSBwYWludGluZy5cbiAgICAgKiBJbXBvcnRlZCBmcm9tIHN2ZyBncmFkaWVudHMsIGlzIG5vdCBhcHBsaWVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtIGluIHRoZSBjZW50ZXIuXG4gICAgICogQmVmb3JlIHRoaXMgdHJhbnNmb3JtIGlzIGFwcGxpZWQsIHRoZSBvcmlnaW4gcG9pbnQgaXMgYXQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgb2JqZWN0XG4gICAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICAgKiBAdHlwZSBOdW1iZXJbXVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBncmFkaWVudFRyYW5zZm9ybTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGNvb3JkaW5hdGVzIHVuaXRzIGZvciBjb29yZHMuXG4gICAgICogSWYgYHBpeGVsc2AsIHRoZSBudW1iZXIgb2YgY29vcmRzIGFyZSBpbiB0aGUgc2FtZSB1bml0IG9mIHdpZHRoIC8gaGVpZ2h0LlxuICAgICAqIElmIHNldCBhcyBgcGVyY2VudGFnZWAgdGhlIGNvb3JkcyBhcmUgc3RpbGwgYSBudW1iZXIsIGJ1dCAxIG1lYW5zIDEwMCUgb2Ygd2lkdGhcbiAgICAgKiBmb3IgdGhlIFggYW5kIDEwMCUgb2YgdGhlIGhlaWdodCBmb3IgdGhlIHkuIEl0IGNhbiBiZSBiaWdnZXIgdGhhbiAxIGFuZCBuZWdhdGl2ZS5cbiAgICAgKiBhbGxvd2VkIHZhbHVlcyBwaXhlbHMgb3IgcGVyY2VudGFnZS5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAncGl4ZWxzJ1xuICAgICAqL1xuICAgIGdyYWRpZW50VW5pdHM6ICdwaXhlbHMnLFxuXG4gICAgLyoqXG4gICAgICogR3JhZGllbnQgdHlwZSBsaW5lYXIgb3IgcmFkaWFsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ3BpeGVscydcbiAgICAgKi9cbiAgICB0eXBlOiAnbGluZWFyJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3Qgd2l0aCB0eXBlLCBjb29yZHMsIGdyYWRpZW50VW5pdHMgYW5kIGNvbG9yU3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHlwZV0gZ3JhZGllbnQgdHlwZSBsaW5lYXIgb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmdyYWRpZW50VW5pdHNdIGdyYWRpZW50IHVuaXRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9mZnNldFhdIFNWRyBpbXBvcnQgY29tcGF0aWJpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vZmZzZXRZXSBTVkcgaW1wb3J0IGNvbXBhdGliaWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvcHRpb25zLmNvbG9yU3RvcHMgY29udGFpbnMgdGhlIGNvbG9yc3RvcHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY29vcmRzIGNvbnRhaW5zIHRoZSBjb29yZHMgb2YgdGhlIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy54MV0gWCBjb29yZGlhbnRlIG9mIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBmb2NhbCBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy55MV0gWSBjb29yZGlhbnRlIG9mIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBmb2NhbCBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy54Ml0gWCBjb29yZGlhbnRlIG9mIHRoZSBzZWNvbmQgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgY2VudGVyIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnkyXSBZIGNvb3JkaWFudGUgb2YgdGhlIHNlY29uZCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMucjFdIG9ubHkgZm9yIHJhZGlhbCBncmFkaWVudCwgcmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnIyXSBvbmx5IGZvciByYWRpYWwgZ3JhZGllbnQsIHJhZGl1cyBvZiB0aGUgZXh0ZXJuYWwgY2lyY2xlXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICBvcHRpb25zLmNvb3JkcyB8fCAob3B0aW9ucy5jb29yZHMgPSB7IH0pO1xuXG4gICAgICB2YXIgY29vcmRzLCBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIHNldHMgZXZlcnl0aGluZywgdGhlbiBjb29yZHMgYW5kIGNvbG9yc3RvcHMgZ2V0IHNldHMgYWdhaW5cbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgIF90aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5pZCArPSAnXycgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIH1cblxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4MTogb3B0aW9ucy5jb29yZHMueDEgfHwgMCxcbiAgICAgICAgeTE6IG9wdGlvbnMuY29vcmRzLnkxIHx8IDAsXG4gICAgICAgIHgyOiBvcHRpb25zLmNvb3Jkcy54MiB8fCAwLFxuICAgICAgICB5Mjogb3B0aW9ucy5jb29yZHMueTIgfHwgMFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgY29vcmRzLnIxID0gb3B0aW9ucy5jb29yZHMucjEgfHwgMDtcbiAgICAgICAgY29vcmRzLnIyID0gb3B0aW9ucy5jb29yZHMucjIgfHwgMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG4gICAgICB0aGlzLmNvbG9yU3RvcHMgPSBvcHRpb25zLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIGNvbG9yU3RvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvclN0b3AgT2JqZWN0IHdpdGggb2Zmc2V0IGFuZCBjb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGFkZENvbG9yU3RvcDogZnVuY3Rpb24oY29sb3JTdG9wcykge1xuICAgICAgZm9yICh2YXIgcG9zaXRpb24gaW4gY29sb3JTdG9wcykge1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yU3RvcHNbcG9zaXRpb25dKTtcbiAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgIG9mZnNldDogcGFyc2VGbG9hdChwb3NpdGlvbiksXG4gICAgICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICAgICAgb3BhY2l0eTogY29sb3IuZ2V0QWxwaGEoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBjb29yZHM6IHRoaXMuY29vcmRzLFxuICAgICAgICBjb2xvclN0b3BzOiB0aGlzLmNvbG9yU3RvcHMsXG4gICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogdGhpcy5vZmZzZXRZLFxuICAgICAgICBncmFkaWVudFVuaXRzOiB0aGlzLmdyYWRpZW50VW5pdHMsXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiB0aGlzLmdyYWRpZW50VHJhbnNmb3JtID8gdGhpcy5ncmFkaWVudFRyYW5zZm9ybS5jb25jYXQoKSA6IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm1cbiAgICAgIH07XG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gZ3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncmFkaWVudCBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudCAobGluZWFyL3JhZGlhbClcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgY29vcmRzID0gY2xvbmUodGhpcy5jb29yZHMsIHRydWUpLCBpLCBsZW4sIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIG1hcmt1cCwgY29tbW9uQXR0cmlidXRlcywgY29sb3JTdG9wcyA9IGNsb25lKHRoaXMuY29sb3JTdG9wcywgdHJ1ZSksXG4gICAgICAgICAgbmVlZHNTd2FwID0gY29vcmRzLnIxID4gY29vcmRzLnIyLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogZmFicmljLmlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgb2Zmc2V0WCA9IC10aGlzLm9mZnNldFgsIG9mZnNldFkgPSAtdGhpcy5vZmZzZXRZLFxuICAgICAgICAgIHdpdGhWaWV3cG9ydCA9ICEhb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtLFxuICAgICAgICAgIGdyYWRpZW50VW5pdHMgPSB0aGlzLmdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnID8gJ3VzZXJTcGFjZU9uVXNlJyA6ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgICAvLyBjb2xvclN0b3BzIG11c3QgYmUgc29ydGVkIGFzY2VuZGluZ1xuICAgICAgY29sb3JTdG9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcpIHtcbiAgICAgICAgb2Zmc2V0WCAvPSBvYmplY3Qud2lkdGg7XG4gICAgICAgIG9mZnNldFkgLz0gb2JqZWN0LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRYICs9IG9iamVjdC53aWR0aCAvIDI7XG4gICAgICAgIG9mZnNldFkgKz0gb2JqZWN0LmhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdwYXRoJyAmJiB0aGlzLmdyYWRpZW50VW5pdHMgIT09ICdwZXJjZW50YWdlJykge1xuICAgICAgICBvZmZzZXRYIC09IG9iamVjdC5wYXRoT2Zmc2V0Lng7XG4gICAgICAgIG9mZnNldFkgLT0gb2JqZWN0LnBhdGhPZmZzZXQueTtcbiAgICAgIH1cblxuXG4gICAgICB0cmFuc2Zvcm1bNF0gLT0gb2Zmc2V0WDtcbiAgICAgIHRyYW5zZm9ybVs1XSAtPSBvZmZzZXRZO1xuXG4gICAgICBjb21tb25BdHRyaWJ1dGVzID0gJ2lkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgJ1wiIGdyYWRpZW50VW5pdHM9XCInICsgZ3JhZGllbnRVbml0cyArICdcIic7XG4gICAgICBjb21tb25BdHRyaWJ1dGVzICs9ICcgZ3JhZGllbnRUcmFuc2Zvcm09XCInICsgKHdpdGhWaWV3cG9ydCA/XG4gICAgICAgIG9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSArICcgJyA6ICcnKSArIGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHRyYW5zZm9ybSkgKyAnXCIgJztcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICc8bGluZWFyR3JhZGllbnQgJyxcbiAgICAgICAgICBjb21tb25BdHRyaWJ1dGVzLFxuICAgICAgICAgICcgeDE9XCInLCBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIHkxPVwiJywgY29vcmRzLnkxLFxuICAgICAgICAgICdcIiB4Mj1cIicsIGNvb3Jkcy54MixcbiAgICAgICAgICAnXCIgeTI9XCInLCBjb29yZHMueTIsXG4gICAgICAgICAgJ1wiPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgLy8gc3ZnIHJhZGlhbCBncmFkaWVudCBoYXMganVzdCAxIHJhZGl1cy4gdGhlIGJpZ2dlc3QuXG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPHJhZGlhbEdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIGN4PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLngxIDogY29vcmRzLngyLFxuICAgICAgICAgICdcIiBjeT1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy55MSA6IGNvb3Jkcy55MixcbiAgICAgICAgICAnXCIgcj1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy5yMSA6IGNvb3Jkcy5yMixcbiAgICAgICAgICAnXCIgZng9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueDIgOiBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIGZ5PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnkyIDogY29vcmRzLnkxLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGlmIChuZWVkc1N3YXApIHtcbiAgICAgICAgICAvLyBzdmcgZ29lcyBmcm9tIGludGVybmFsIHRvIGV4dGVybmFsIHJhZGl1cy4gaWYgcmFkaXVzIGFyZSBpbnZlcnRlZCwgc3dhcCBjb2xvciBzdG9wcy5cbiAgICAgICAgICBjb2xvclN0b3BzID0gY29sb3JTdG9wcy5jb25jYXQoKTtcbiAgICAgICAgICBjb2xvclN0b3BzLnJldmVyc2UoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCA9IDEgLSBjb2xvclN0b3BzW2ldLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblJhZGl1cyA9IE1hdGgubWluKGNvb3Jkcy5yMSwgY29vcmRzLnIyKTtcbiAgICAgICAgaWYgKG1pblJhZGl1cyA+IDApIHtcbiAgICAgICAgICAvLyBpIGhhdmUgdG8gc2hpZnQgYWxsIGNvbG9yU3RvcHMgYW5kIGFkZCBuZXcgb25lIGluIDAuXG4gICAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWF4KGNvb3Jkcy5yMSwgY29vcmRzLnIyKSxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZVNoaWZ0ID0gbWluUmFkaXVzIC8gbWF4UmFkaXVzO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0ICs9IHBlcmNlbnRhZ2VTaGlmdCAqICgxIC0gY29sb3JTdG9wc1tpXS5vZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvclN0b3AgPSBjb2xvclN0b3BzW2ldO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHN0b3AgJyxcbiAgICAgICAgICAnb2Zmc2V0PVwiJywgKGNvbG9yU3RvcC5vZmZzZXQgKiAxMDApICsgJyUnLFxuICAgICAgICAgICdcIiBzdHlsZT1cInN0b3AtY29sb3I6JywgY29sb3JTdG9wLmNvbG9yLFxuICAgICAgICAgICh0eXBlb2YgY29sb3JTdG9wLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnID8gJztzdG9wLW9wYWNpdHk6ICcgKyBjb2xvclN0b3Aub3BhY2l0eSA6ICc7JyksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKCh0aGlzLnR5cGUgPT09ICdsaW5lYXInID8gJzwvbGluZWFyR3JhZGllbnQ+XFxuJyA6ICc8L3JhZGlhbEdyYWRpZW50PlxcbicpKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNHcmFkaWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNHcmFkaWVudH1cbiAgICAgKi9cbiAgICB0b0xpdmU6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGdyYWRpZW50LCBjb29yZHMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5jb29yZHMpLCBpLCBsZW47XG5cbiAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgICAgY29vcmRzLngxLCBjb29yZHMueTEsIGNvb3Jkcy54MiwgY29vcmRzLnkyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgY29vcmRzLngxLCBjb29yZHMueTEsIGNvb3Jkcy5yMSwgY29vcmRzLngyLCBjb29yZHMueTIsIGNvb3Jkcy5yMik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yU3RvcHNbaV0uY29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5ID0gdGhpcy5jb2xvclN0b3BzW2ldLm9wYWNpdHksXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub2Zmc2V0O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpLnNldEFscGhhKG9wYWNpdHkpLnRvUmdiYSgpO1xuICAgICAgICB9XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuR3JhZGllbnQsIHtcblxuICAgIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JhZGllbnR9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5HcmFkaWVudFxuICAgICAqIEBwYXJhbSB7U1ZHR3JhZGllbnRFbGVtZW50fSBlbCBTVkcgZ3JhZGllbnQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BhY2l0eUF0dHIgQSBmaWxsLW9wYWNpdHkgb3Igc3Ryb2tlLW9wYWNpdHkgYXR0cmlidXRlIHRvIG11bHRpcGx5IHRvIGVhY2ggc3RvcCdzIG9wYWNpdHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2Z09wdGlvbnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNpemUgb2YgdGhlIFNWRyBpbiBvcmRlciB0byBwYXJzZSBjb3JyZWN0bHkgZ3JhZGllbnRzXG4gICAgICogdGhhdCB1c2VzIGdyYWRpZW50VW5pdHMgYXMgJ3VzZXJTcGFjZU9uVXNlJyBhbmQgcGVyY2VudGFnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB2aWV3Qm94V2lkdGggd2lkdGggcGFydCBvZiB0aGUgdmlld0JveCBhdHRyaWJ1dGUgb24gc3ZnXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB2aWV3Qm94SGVpZ2h0IGhlaWdodCBwYXJ0IG9mIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSBvbiBzdmdcbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IHdpZHRoIHdpZHRoIHBhcnQgb2YgdGhlIHN2ZyB0YWcgaWYgdmlld0JveCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSBoZWlnaHQgaGVpZ2h0IHBhcnQgb2YgdGhlIHN2ZyB0YWcgaWYgdmlld0JveCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSBHcmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjTGluZWFyR3JhZGllbnRFbGVtZW50XG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcHNlcnZlcnMuaHRtbCNSYWRpYWxHcmFkaWVudEVsZW1lbnRcbiAgICAgKi9cbiAgICBmcm9tRWxlbWVudDogZnVuY3Rpb24oZWwsIGluc3RhbmNlLCBvcGFjaXR5QXR0ciwgc3ZnT3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiAgQGV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogIDxsaW5lYXJHcmFkaWVudCBpZD1cImxpbmVhckdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwiYmxhY2tcIi8+XG4gICAgICAgKiAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDI1NSwyNTUsMjU1KVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDAsMCwwKVwiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMVwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjUwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiIHN0b3Atb3BhY2l0eT1cIjAuNVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIgc3RvcC1vcGFjaXR5PVwiMVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPHJhZGlhbEdyYWRpZW50IGlkPVwicmFkaWFsR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwLjVcIiBzdG9wLWNvbG9yPVwicmdiKDAsMCwwKVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cInJnYigyNTUsMjU1LDI1NSlcIiAvPlxuICAgICAgICogIDwvcmFkaWFsR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHZhciBtdWx0aXBsaWVyID0gcGFyc2VGbG9hdChvcGFjaXR5QXR0cikgLyAoLyUkLy50ZXN0KG9wYWNpdHlBdHRyKSA/IDEwMCA6IDEpO1xuICAgICAgbXVsdGlwbGllciA9IG11bHRpcGxpZXIgPCAwID8gMCA6IG11bHRpcGxpZXIgPiAxID8gMSA6IG11bHRpcGxpZXI7XG4gICAgICBpZiAoaXNOYU4obXVsdGlwbGllcikpIHtcbiAgICAgICAgbXVsdGlwbGllciA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvclN0b3BFbHMgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3RvcCcpLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZ3JhZGllbnRVbml0cyA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpID09PSAndXNlclNwYWNlT25Vc2UnID9cbiAgICAgICAgICAgICdwaXhlbHMnIDogJ3BlcmNlbnRhZ2UnLFxuICAgICAgICAgIGdyYWRpZW50VHJhbnNmb3JtID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpIHx8ICcnLFxuICAgICAgICAgIGNvbG9yU3RvcHMgPSBbXSxcbiAgICAgICAgICBjb29yZHMsIGksIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCxcbiAgICAgICAgICB0cmFuc2Zvcm1NYXRyaXg7XG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcgfHwgZWwubm9kZU5hbWUgPT09ICdMSU5FQVJHUkFESUVOVCcpIHtcbiAgICAgICAgdHlwZSA9ICdsaW5lYXInO1xuICAgICAgICBjb29yZHMgPSBnZXRMaW5lYXJDb29yZHMoZWwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSAncmFkaWFsJztcbiAgICAgICAgY29vcmRzID0gZ2V0UmFkaWFsQ29vcmRzKGVsKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gY29sb3JTdG9wRWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29sb3JTdG9wcy5wdXNoKGdldENvbG9yU3RvcChjb2xvclN0b3BFbHNbaV0sIG11bHRpcGxpZXIpKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtTWF0cml4ID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKGdyYWRpZW50VHJhbnNmb3JtKTtcblxuICAgICAgX19jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIGNvb3Jkcywgc3ZnT3B0aW9ucywgZ3JhZGllbnRVbml0cyk7XG5cbiAgICAgIGlmIChncmFkaWVudFVuaXRzID09PSAncGl4ZWxzJykge1xuICAgICAgICBvZmZzZXRYID0gLWluc3RhbmNlLmxlZnQ7XG4gICAgICAgIG9mZnNldFkgPSAtaW5zdGFuY2UudG9wO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgZmFicmljLkdyYWRpZW50KHtcbiAgICAgICAgaWQ6IGVsLmdldEF0dHJpYnV0ZSgnaWQnKSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgIGNvbG9yU3RvcHM6IGNvbG9yU3RvcHMsXG4gICAgICAgIGdyYWRpZW50VW5pdHM6IGdyYWRpZW50VW5pdHMsXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiB0cmFuc2Zvcm1NYXRyaXgsXG4gICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9fY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKGluc3RhbmNlLCBvcHRpb25zLCBzdmdPcHRpb25zLCBncmFkaWVudFVuaXRzKSB7XG4gICAgdmFyIHByb3BWYWx1ZSwgZmluYWxWYWx1ZTtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHByb3BWYWx1ZSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICBpZiAocHJvcFZhbHVlID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvcFZhbHVlID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICBmaW5hbFZhbHVlID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gcGFyc2VGbG9hdChvcHRpb25zW3Byb3BdLCAxMCk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJyAmJiAvXihcXGQrXFwuXFxkKyklfChcXGQrKSUkLy50ZXN0KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICBmaW5hbFZhbHVlICo9IDAuMDE7XG4gICAgICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnKSB7XG4gICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZml4IHRob3NlIHBlcmNlbnRhZ2VzIGhlcmUgaW4gc3ZnIHBhcnNpbmdcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicgfHwgcHJvcCA9PT0gJ3IyJykge1xuICAgICAgICAgICAgICBmaW5hbFZhbHVlICo9IHN2Z09wdGlvbnMudmlld0JveFdpZHRoIHx8IHN2Z09wdGlvbnMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3kxJyB8fCBwcm9wID09PSAneTInKSB7XG4gICAgICAgICAgICAgIGZpbmFsVmFsdWUgKj0gc3ZnT3B0aW9ucy52aWV3Qm94SGVpZ2h0IHx8IHN2Z09wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9uc1twcm9wXSA9IGZpbmFsVmFsdWU7XG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgLyoqXG4gICAqIFBhdHRlcm4gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vcGF0dGVybnN8UGF0dGVybiBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2R5bmFtaWMtcGF0dGVybnN8RHluYW1pY1BhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdHRlcm4jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG5cblxuICBmYWJyaWMuUGF0dGVybiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm4ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJlcGVhdCBwcm9wZXJ0eSBvZiBhIHBhdHRlcm4gKG9uZSBvZiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSBvciBuby1yZXBlYXQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXBlYXQ6ICdyZXBlYXQnLFxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiBob3Jpem9udGFsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gdmVydGljYWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Jvc3NPcmlnaW46ICcnLFxuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIG1hdHJpeCB0byBjaGFuZ2UgdGhlIHBhdHRlcm4sIGltcG9ydGVkIGZyb20gc3Zncy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0dGVyblRyYW5zZm9ybTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGNhbGxiYWNrIGluaXQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdHRlcm59IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMuc291cmNlIHx8IChvcHRpb25zLnNvdXJjZSAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2UgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGltZyBzcmMgc3RyaW5nXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9wdGlvbnMuc291cmNlLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgICAgICBfdGhpcy5zb3VyY2UgPSBpbWc7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soX3RoaXMsIGlzRXJyb3IpO1xuICAgICAgICB9LCBudWxsLCB0aGlzLmNyb3NzT3JpZ2luKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVybiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBzb3VyY2UsIG9iamVjdDtcblxuICAgICAgLy8gPGltZz4gZWxlbWVudFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIC8vIDxjYW52YXM+IGVsZW1lbnRcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcgJiYgdGhpcy5zb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6ICdwYXR0ZXJuJyxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHJlcGVhdDogdGhpcy5yZXBlYXQsXG4gICAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgICBvZmZzZXRYOiB0b0ZpeGVkKHRoaXMub2Zmc2V0WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgIG9mZnNldFk6IHRvRml4ZWQodGhpcy5vZmZzZXRZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgcGF0dGVyblRyYW5zZm9ybTogdGhpcy5wYXR0ZXJuVHJhbnNmb3JtID8gdGhpcy5wYXR0ZXJuVHJhbnNmb3JtLmNvbmNhdCgpIDogbnVsbFxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBwYXR0ZXJuU291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlLFxuICAgICAgICAgIHBhdHRlcm5XaWR0aCA9IHBhdHRlcm5Tb3VyY2Uud2lkdGggLyBvYmplY3Qud2lkdGgsXG4gICAgICAgICAgcGF0dGVybkhlaWdodCA9IHBhdHRlcm5Tb3VyY2UuaGVpZ2h0IC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSAvIG9iamVjdC5oZWlnaHQsXG4gICAgICAgICAgcGF0dGVybkltZ1NyYyA9ICcnO1xuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXgnIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gMTtcbiAgICAgICAgaWYgKHBhdHRlcm5PZmZzZXRZKSB7XG4gICAgICAgICAgcGF0dGVybkhlaWdodCArPSBNYXRoLmFicyhwYXR0ZXJuT2Zmc2V0WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCB0aGlzLnJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgICAgcGF0dGVybldpZHRoID0gMTtcbiAgICAgICAgaWYgKHBhdHRlcm5PZmZzZXRYKSB7XG4gICAgICAgICAgcGF0dGVybldpZHRoICs9IE1hdGguYWJzKHBhdHRlcm5PZmZzZXRYKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBpZiAocGF0dGVyblNvdXJjZS5zcmMpIHtcbiAgICAgICAgcGF0dGVybkltZ1NyYyA9IHBhdHRlcm5Tb3VyY2Uuc3JjO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGF0dGVyblNvdXJjZS50b0RhdGFVUkwpIHtcbiAgICAgICAgcGF0dGVybkltZ1NyYyA9IHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHBhdHRlcm4gaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB4PVwiJyArIHBhdHRlcm5PZmZzZXRYICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHk9XCInICsgcGF0dGVybk9mZnNldFkgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgd2lkdGg9XCInICsgcGF0dGVybldpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgKyBwYXR0ZXJuSGVpZ2h0ICsgJ1wiPlxcbicgK1xuICAgICAgICAgICAgICAgJzxpbWFnZSB4PVwiMFwiIHk9XCIwXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAnIHdpZHRoPVwiJyArIHBhdHRlcm5Tb3VyY2Uud2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVyblNvdXJjZS5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICdcIiB4bGluazpocmVmPVwiJyArIHBhdHRlcm5JbWdTcmMgK1xuICAgICAgICAgICAgICAgJ1wiPjwvaW1hZ2U+XFxuJyArXG4gICAgICAgICAgICAgJzwvcGF0dGVybj5cXG4nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgQ2FudmFzUGF0dGVyblxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjcmVhdGUgcGF0dGVyblxuICAgICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgIC8vIGlmIHRoZSBpbWFnZSBmYWlsZWQgdG8gbG9hZCwgcmV0dXJuLCBhbmQgYWxsb3cgcmVzdCB0byBjb250aW51ZSBsb2FkaW5nXG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFuIGltYWdlXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZS5zcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghc291cmNlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UubmF0dXJhbFdpZHRoID09PSAwIHx8IHNvdXJjZS5uYXR1cmFsSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4oc291cmNlLCB0aGlzLnJlcGVhdCk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlNoYWRvdykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU2hhZG93IGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogU2hhZG93IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU2hhZG93XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vc2hhZG93c3xTaGFkb3cgZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlNoYWRvdyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlNoYWRvdyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlNoYWRvdy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGNvbG9yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb2xvcjogJ3JnYigwLDAsMCknLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGJsdXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBibHVyOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IHZlcnRpY2FsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHNoYWRvdyBzaG91bGQgYWZmZWN0IHN0cm9rZSBvcGVyYXRpb25zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWZmZWN0U3Ryb2tlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0IHNob3VsZCBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIHRoZSBzaGFkb3cgd2lsbCBzY2FsZSB3aXRoIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBzaGFkb3cncyBvZmZzZXRYLCBvZmZzZXRZLCBhbmQgYmx1ciB3aWxsIG5vdCBiZSBhZmZlY3RlZCBieSB0aGUgb2JqZWN0J3Mgc2NhbGUuXG4gICAgICogZGVmYXVsdCB0byBmYWxzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vblNjYWxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIGFueSBvZiBjb2xvciwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSBwcm9wZXJ0aWVzIG9yIHN0cmluZyAoZS5nLiBcInJnYmEoMCwwLDAsMC4yKSAycHggMnB4IDEwcHhcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUludChvZmZzZXRzQW5kQmx1clsxXSwgMTApIHx8IDAsXG4gICAgICAgIG9mZnNldFk6IHBhcnNlSW50KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VJbnQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwLCBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG5cbiAgICAgIGlmIChvYmplY3Qud2lkdGggJiYgb2JqZWN0LmhlaWdodCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjRmlsdGVyRWZmZWN0c1JlZ2lvblxuICAgICAgICAvLyB3ZSBhZGQgc29tZSBleHRyYSBzcGFjZSB0byBmaWx0ZXIgYm94IHRvIGNvbnRhaW4gdGhlIGJsdXIgKCAyMCApXG4gICAgICAgIGZCb3hYID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LngpICsgdGhpcy5ibHVyKSAvIG9iamVjdC53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgICAgZkJveFkgPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueSkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFgpIHtcbiAgICAgICAgb2Zmc2V0LnggKj0gLTE7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBZKSB7XG4gICAgICAgIG9mZnNldC55ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGZpbHRlciBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICsgJ1wiIHk9XCItJyArIGZCb3hZICsgJyVcIiBoZWlnaHQ9XCInICsgKDEwMCArIDIgKiBmQm94WSkgKyAnJVwiICcgK1xuICAgICAgICAgICd4PVwiLScgKyBmQm94WCArICclXCIgd2lkdGg9XCInICsgKDEwMCArIDIgKiBmQm94WCkgKyAnJVwiICcgKyAnPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIicgK1xuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmJsdXIgPyB0aGlzLmJsdXIgLyAyIDogMCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCI+PC9mZUdhdXNzaWFuQmx1cj5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlT2Zmc2V0IGR4PVwiJyArIHRvRml4ZWQob2Zmc2V0LngsIE5VTV9GUkFDVElPTl9ESUdJVFMpICtcbiAgICAgICAgICAnXCIgZHk9XCInICsgdG9GaXhlZChvZmZzZXQueSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgcmVzdWx0PVwib0JsdXJcIiA+PC9mZU9mZnNldD5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlRmxvb2QgZmxvb2QtY29sb3I9XCInICsgY29sb3IudG9SZ2IoKSArICdcIiBmbG9vZC1vcGFjaXR5PVwiJyArIGNvbG9yLmdldEFscGhhKCkgKyAnXCIvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVDb21wb3NpdGUgaW4yPVwib0JsdXJcIiBvcGVyYXRvcj1cImluXCIgLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlTWVyZ2U+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgJ1xcdDwvZmVNZXJnZT5cXG4nICtcbiAgICAgICAgJzwvZmlsdGVyPlxcbicpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93IGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBibHVyOiB0aGlzLmJsdXIsXG4gICAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgICBhZmZlY3RTdHJva2U6IHRoaXMuYWZmZWN0U3Ryb2tlLFxuICAgICAgICAgIG5vblNjYWxpbmc6IHRoaXMubm9uU2NhbGluZ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHsgfSwgcHJvdG8gPSBmYWJyaWMuU2hhZG93LnByb3RvdHlwZTtcblxuICAgICAgWydjb2xvcicsICdibHVyJywgJ29mZnNldFgnLCAnb2Zmc2V0WScsICdhZmZlY3RTdHJva2UnLCAnbm9uU2NhbGluZyddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gcHJvdG9bcHJvcF0pIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBzaGFkb3cgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1ciAoZXg6IFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiLCBcInJnYigwLDI1NSwwKSAycHggMnB4XCIpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuU2hhZG93XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIgPSAvKD86XFxzfF4pKC0/XFxkKyg/OnB4KT8oPzpcXHM/fCQpKT8oLT9cXGQrKD86cHgpPyg/Olxccz98JCkpPyhcXGQrKD86cHgpPyk/KD86XFxzP3wkKSg/OiR8XFxzKS87XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoZmFicmljLlN0YXRpY0NhbnZhcykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU3RhdGljQ2FudmFzIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhbGlhc2VzIGZvciBmYXN0ZXIgcmVzb2x1dGlvblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGdldEVsZW1lbnRPZmZzZXQgPSBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0LFxuICAgICAgcmVtb3ZlRnJvbUFycmF5ID0gZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50LFxuICAgICAgaW52ZXJ0VHJhbnNmb3JtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtLFxuICAgICAgZ2V0Tm9kZUNhbnZhcyA9IGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXMsXG4gICAgICBjcmVhdGVDYW52YXNFbGVtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCxcblxuICAgICAgQ0FOVkFTX0lOSVRfRVJST1IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIGBjYW52YXNgIGVsZW1lbnQnKTtcblxuICAvKipcbiAgICogU3RhdGljIGNhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlN0YXRpY0NhbnZhc1xuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vc3RhdGljX2NhbnZhc3xTdGF0aWNDYW52YXMgZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAZmlyZXMgYmVmb3JlOnJlbmRlclxuICAgKiBAZmlyZXMgYWZ0ZXI6cmVuZGVyXG4gICAqIEBmaXJlcyBjYW52YXM6Y2xlYXJlZFxuICAgKiBAZmlyZXMgb2JqZWN0OmFkZGVkXG4gICAqIEBmaXJlcyBvYmplY3Q6cmVtb3ZlZFxuICAgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0QmFja2dyb3VuZENvbG9yfS5cbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogc2luY2UgMi40LjAgaW1hZ2UgY2FjaGluZyBpcyBhY3RpdmUsIHBsZWFzZSB3aGVuIHB1dHRpbmcgYW4gaW1hZ2UgYXMgYmFja2dyb3VuZCwgYWRkIHRvIHRoZVxuICAgICAqIGNhbnZhcyBwcm9wZXJ0eSBhIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzIGl0IGlzIG9uLiBPdGhlcndpc2UgdGhlIGltYWdlIGNhbm5vdCBkZXRlY3QgdGhlIHpvb21cbiAgICAgKiB2YWxlLiBBcyBhbiBhbHRlcm5hdGl2ZSB5b3UgY2FuIGRpc2FibGUgaW1hZ2Ugb2JqZWN0Q2FjaGluZ1xuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZEltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0T3ZlcmxheUNvbG9yfVxuICAgICAqIEBzaW5jZSAxLjMuOVxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBzaW5jZSAyLjQuMCBpbWFnZSBjYWNoaW5nIGlzIGFjdGl2ZSwgcGxlYXNlIHdoZW4gcHV0dGluZyBhbiBpbWFnZSBhcyBvdmVybGF5LCBhZGQgdG8gdGhlXG4gICAgICogY2FudmFzIHByb3BlcnR5IGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgaXQgaXMgb24uIE90aGVyd2lzZSB0aGUgaW1hZ2UgY2Fubm90IGRldGVjdCB0aGUgem9vbVxuICAgICAqIHZhbGUuIEFzIGFuIGFsdGVybmF0aXZlIHlvdSBjYW4gZGlzYWJsZSBpbWFnZSBvYmplY3RDYWNoaW5nXG4gICAgICogQHR5cGUgZmFicmljLkltYWdlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5SW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdC90b0RhdGFsZXNzT2JqZWN0IHNob3VsZCBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogaWYgc2V0IHRvIGZhbHNlLCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIG9iamVjdCB2YWx1ZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMnIHN0YXRlIHNob3VsZCBiZSBzYXZlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0YXRlZnVsOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5hZGR9LCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uaW5zZXJ0QXR9IGFuZCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24ucmVtb3ZlfSxcbiAgICAgKiB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5tb3ZlVG99LCB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5jbGVhcn0gYW5kIG1hbnkgbW9yZSwgc2hvdWxkIGFsc28gcmUtcmVuZGVyIGNhbnZhcy5cbiAgICAgKiBEaXNhYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBub3QgZ2l2ZSBhIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gYWRkaW5nL3JlbW92aW5nIGEgbG90IG9mIG9iamVjdHMgdG8vZnJvbSBjYW52YXMgYXQgb25jZVxuICAgICAqIHNpbmNlIHRoZSByZW5kZXJzIGFyZSBxdWVxdWVkIGFuZCBleGVjdXRlZCBvbmUgcGVyIGZyYW1lLlxuICAgICAqIERpc2FibGluZyBpcyBzdWdnZXN0ZWQgYW55d2F5IGFuZCBtYW5hZ2luZyB0aGUgcmVuZGVycyBvZiB0aGUgYXBwIG1hbnVhbGx5IGlzIG5vdCBhIGJpZyBlZmZvcnQgKCBjYW52YXMucmVxdWVzdFJlbmRlckFsbCgpIClcbiAgICAgKiBMZWZ0IGRlZmF1bHQgdG8gdHJ1ZSB0byBkbyBub3QgYnJlYWsgZG9jdW1lbnRhdGlvbiBhbmQgb2xkIGFwcCwgZmlkZGxlcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZW5kZXJPbkFkZFJlbW92ZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdCBjb250cm9scyAoYm9yZGVycy9jb250cm9scykgYXJlIHJlbmRlcmVkIGFib3ZlIG92ZXJsYXkgaW1hZ2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250cm9sc0Fib3ZlT3ZlcmxheTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYnJvd3NlciBjYW4gYmUgc2Nyb2xsZWQgd2hlbiB1c2luZyBhIHRvdWNoc2NyZWVuIGFuZCBkcmFnZ2luZyBvbiB0aGUgY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWxsb3dUb3VjaFNjcm9sbGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcsIHRoaXMgaXMgb24gYnkgZGVmYXVsdCBpbiBicm93c2Vyc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm1hdGlvbiAoaW4gdGhlIGZvcm1hdCBvZiBDYW52YXMgdHJhbnNmb3JtKSB3aGljaCBmb2N1c2VzIHRoZSB2aWV3cG9ydFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aWV3cG9ydFRyYW5zZm9ybTogZmFicmljLmlNYXRyaXguY29uY2F0KCksXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2UgYmFja2dyb3VuZCBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZFZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGlmIHNldCB0byBmYWxzZSBvdmVybHlhIGltYWdlIGlzIG5vdCBhZmZlY3RlZCBieSB2aWV3cG9ydCB0cmFuc2Zvcm1cbiAgICAgKiBAc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5VnB0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBjYW52YXMgaXMgc2NhbGVkIGJ5IGRldmljZVBpeGVsUmF0aW8gZm9yIGJldHRlciByZW5kZXJpbmcgb24gcmV0aW5hIHNjcmVlbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlbmFibGVSZXRpbmFTY2FsaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgY2FudmFzIGVsZW1lbnQgZXh0ZW5zaW9uIG92ZXIgZGVzaWduXG4gICAgICogcHJvcGVydGllcyBhcmUgdGwsdHIsYmwsYnIuXG4gICAgICogaWYgY2FudmFzIGlzIG5vdCB6b29tZWQvcGFubmVkIHRob3NlIHBvaW50cyBhcmUgdGhlIGZvdXIgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIGlmIGNhbnZhcyBpcyB2aWV3cG9ydFRyYW5zZm9ybWVkIHlvdSB0aG9zZSBwb2ludHMgaW5kaWNhdGUgdGhlIGV4dGVuc2lvblxuICAgICAqIG9mIGNhbnZhcyBlbGVtZW50IGluIHBsYWluIHVudHJhc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIFRoZSBjb29yZGluYXRlcyBnZXQgdXBkYXRlZCB3aXRoIEBtZXRob2QgY2FsY1ZpZXdwb3J0Qm91bmRhcmllcy5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2cHRDb29yZHM6IHsgfSxcblxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHZwdENvb3JkcyBhbmQgb2JqZWN0LmFDb29yZHMsIHNraXAgcmVuZGVyaW5nIG9mIG9iamVjdHMgdGhhdFxuICAgICAqIGFyZSBub3QgaW5jbHVkZWQgaW4gY3VycmVudCB2aWV3cG9ydC5cbiAgICAgKiBNYXkgZ3JlYXRseSBoZWxwIGluIGFwcGxpY2F0aW9ucyB3aXRoIGNyb3dkZWQgY2FudmFzIGFuZCB1c2Ugb2Ygem9vbS9wYW5cbiAgICAgKiBJZiBPbmUgb2YgdGhlIGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBvYmplY3QgaXMgb24gdGhlIGNhbnZhc1xuICAgICAqIHRoZSBvYmplY3RzIGdldCByZW5kZXJlZC5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2lwT2Zmc2NyZWVuOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogYSBmYWJyaWNPYmplY3QgdGhhdCwgd2l0aG91dCBzdHJva2UgZGVmaW5lIGEgY2xpcHBpbmcgYXJlYSB3aXRoIHRoZWlyIHNoYXBlLiBmaWxsZWQgaW4gYmxhY2tcbiAgICAgKiB0aGUgY2xpcFBhdGggb2JqZWN0IGdldHMgdXNlZCB3aGVuIHRoZSBjYW52YXMgaGFzIHJlbmRlcmVkLCBhbmQgdGhlIGNvbnRleHQgaXMgcGxhY2VkIGluIHRoZVxuICAgICAqIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzLlxuICAgICAqIGNsaXBQYXRoIHdpbGwgY2xpcCBhd2F5IGNvbnRyb2xzLCBpZiB5b3UgZG8gbm90IHdhbnQgdGhpcyB0byBoYXBwZW4gdXNlIGNvbnRyb2xzQWJvdmVPdmVybGF5ID0gdHJ1ZVxuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICBjbGlwUGF0aDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRTdGF0aWM6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2IgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZDtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHRoaXMuX2NyZWF0ZUxvd2VyQ2FudmFzKGVsKTtcbiAgICAgIHRoaXMuX2luaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgLy8gb25seSBpbml0aWFsaXplIHJldGluYSBzY2FsaW5nIG9uY2VcbiAgICAgIGlmICghdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5SW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5SW1hZ2Uob3B0aW9ucy5vdmVybGF5SW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRJbWFnZShvcHRpb25zLmJhY2tncm91bmRJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5Q29sb3Iob3B0aW9ucy5vdmVybGF5Q29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1JldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gMSAmJiB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmV0aW5hU2NhbGluZyBpZiBhcHBsaWVkLCBvdGhlcndpc2UgMTtcbiAgICAgKi9cbiAgICBnZXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JldGluYVNjYWxpbmcoKSA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2NhbGVSYXRpbyA9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgdGhpcy5fX2luaXRSZXRpbmFTY2FsaW5nKHNjYWxlUmF0aW8sIHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5fX2luaXRSZXRpbmFTY2FsaW5nKHNjYWxlUmF0aW8sIHRoaXMudXBwZXJDYW52YXNFbCwgdGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX19pbml0UmV0aW5hU2NhbGluZzogZnVuY3Rpb24oc2NhbGVSYXRpbywgY2FudmFzLCBjb250ZXh0KSB7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBzY2FsZVJhdGlvKTtcbiAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0ICogc2NhbGVSYXRpbyk7XG4gICAgICBjb250ZXh0LnNjYWxlKHNjYWxlUmF0aW8sIHNjYWxlUmF0aW8pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY2FudmFzIGVsZW1lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gYXR0YWNoZWQgYXMgXCJyZXNpemVcIiBldmVudCBoYW5kbGVyIG9mIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5IGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxvdmVybGF5IGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTW56SFQvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldE92ZXJsYXlJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ292ZXJsYXlJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmQgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBiYWNrZ3JvdW5kIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGJhY2tncm91bmQgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9kam5yOG83YS8yOC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZEltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgLy8gVE9ETzogZml4IHN0cmV0Y2hlZCBleGFtcGxlc1xuICAgIHNldEJhY2tncm91bmRJbWFnZTogZnVuY3Rpb24gKGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlJbWFnZSgnYmFja2dyb3VuZEltYWdlJywgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8Zm9yZWdyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gb3ZlcmxheUNvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGZvcmVncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBmb3JlZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wQjU1aC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgb3ZlcmxheUNvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0T3ZlcmxheUNvbG9yOiBmdW5jdGlvbihvdmVybGF5Q29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdvdmVybGF5Q29sb3InLCBvdmVybGF5Q29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gYmFja2dyb3VuZENvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGJhY2tncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBiYWNrZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9oWHp2ay98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZENvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdiYWNrZ3JvdW5kQ29sb3InLCBiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kSW1hZ2V8YmFja2dyb3VuZEltYWdlfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5SW1hZ2V9KVxuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmd8bnVsbCl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSwgVVJMIG9mIGFuIGltYWdlIG9yIG51bGwgdG8gc2V0IGJhY2tncm91bmQgb3Igb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGJhY2tncm91bmQgb3Igb3ZlcmxheS4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBjcmVhdGVkIGltYWdlLCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZXJyb3Igb2NjdXJyZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGltYWdlfS5cbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUltYWdlOiBmdW5jdGlvbihwcm9wZXJ0eSwgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UoaW1hZ2UsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICAgIGlmIChpbWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpbnN0YW5jZS5jYW52YXMgPSB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWcsIGlzRXJyb3IpO1xuICAgICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgJiYgaW1hZ2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbWFnZTtcbiAgICAgICAgaW1hZ2UgJiYgKGltYWdlLmNhbnZhcyA9IHRoaXMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWFnZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZENvbG9yfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxvdmVybGF5Q29sb3J9KVxuICAgICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IGNvbG9yIE9iamVjdCB3aXRoIHBhdHRlcm4gaW5mb3JtYXRpb24sIGNvbG9yIHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBjb2xvciBpcyBzZXRcbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihwcm9wZXJ0eSwgY29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IGNvbG9yO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KGNvbG9yLCBwcm9wZXJ0eSk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihjb2xvciwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUgPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Q29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGxvd2VyQ2FudmFzRWwgPSB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCB8fCBwYXJzZUludChsb3dlckNhbnZhc0VsLndpZHRoLCAxMCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgcGFyc2VJbnQobG93ZXJDYW52YXNFbC5oZWlnaHQsIDEwKSB8fCAwO1xuXG4gICAgICBpZiAoIXRoaXMubG93ZXJDYW52YXNFbC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvd2VyQ2FudmFzRWwud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgbG93ZXJDYW52YXNFbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgbG93ZXJDYW52YXNFbC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgbG93ZXJDYW52YXNFbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBib3R0b20gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbY2FudmFzRWxdXG4gICAgICovXG4gICAgX2NyZWF0ZUxvd2VyQ2FudmFzOiBmdW5jdGlvbiAoY2FudmFzRWwpIHtcbiAgICAgIC8vIGNhbnZhc0VsID09PSAnSFRNTENhbnZhc0VsZW1lbnQnIGRvZXMgbm90IHdvcmsgb24ganNkb20vbm9kZVxuICAgICAgaWYgKGNhbnZhc0VsICYmIGNhbnZhc0VsLmdldENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gY2FudmFzRWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gZmFicmljLnV0aWwuZ2V0QnlJZChjYW52YXNFbCkgfHwgdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLmxvd2VyQ2FudmFzRWwsICdsb3dlci1jYW52YXMnKTtcblxuICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlDYW52YXNTdHlsZSh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHRDb250YWluZXIgPSB0aGlzLmxvd2VyQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgd2lkdGggKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIGhlaWdodCAoaW4gcHgpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdpZHRoIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZSB0byBzZXQgd2lkdGggdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXREaW1lbnNpb25zKHsgd2lkdGg6IHZhbHVlIH0sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGhlaWdodCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IGhlaWdodCB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJhY2tzdG9yZU9ubHk9ZmFsc2VdIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNhbnZhcyBiYWNrc3RvcmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuY3NzT25seT1mYWxzZV0gICAgICAgU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY3NzIGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldEhlaWdodDogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXREaW1lbnNpb25zKHsgaGVpZ2h0OiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBkaW1lbnNpb25zICh3aWR0aCwgaGVpZ2h0KSBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZS4gd2hlbiBvcHRpb25zLmNzc09ubHkgZmxhZyBhY3RpdmUgeW91IHNob3VsZCBhbHNvIHN1cHBseSB0aGUgdW5pdCBvZiBtZWFzdXJlIChweC8lL2VtKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgZGltZW5zaW9ucyAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtkaW1lbnNpb25zLndpZHRoXSAgICAgICAgICAgIFdpZHRoIG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy5oZWlnaHRdICAgICAgICAgICBIZWlnaHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbiAoZGltZW5zaW9ucywgb3B0aW9ucykge1xuICAgICAgdmFyIGNzc1ZhbHVlO1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgIGNzc1ZhbHVlID0gZGltZW5zaW9uc1twcm9wXTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuY3NzT25seSkge1xuICAgICAgICAgIHRoaXMuX3NldEJhY2tzdG9yZURpbWVuc2lvbihwcm9wLCBkaW1lbnNpb25zW3Byb3BdKTtcbiAgICAgICAgICBjc3NWYWx1ZSArPSAncHgnO1xuICAgICAgICAgIHRoaXMuaGFzTG9zdENvbnRleHQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmJhY2tzdG9yZU9ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRDc3NEaW1lbnNpb24ocHJvcCwgY3NzVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3NldEJydXNoU3R5bGVzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5jc3NPbmx5KSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBzZXR0aW5nIHdpZHRoL2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgcHJvcGVydHkgKHdpZHRofGhlaWdodClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBfc2V0QmFja3N0b3JlRGltZW5zaW9uOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYWNoZUNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMuY2FjaGVDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgY3NzIHdpZHRoL2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgcHJvcGVydHkgKHdpZHRofGhlaWdodClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBfc2V0Q3NzRGltZW5zaW9uOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy53cmFwcGVyRWwpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHpvb20gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmlld3BvcnQgdHJhbnNmb3JtIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdnB0IHRoZSB0cmFuc2Zvcm0gaW4gdGhlIGZvcm0gb2YgY29udGV4dC50cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbiAodnB0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGJhY2tncm91bmRPYmplY3QgPSB0aGlzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICBvdmVybGF5T2JqZWN0ID0gdGhpcy5vdmVybGF5SW1hZ2UsXG4gICAgICAgICAgb2JqZWN0LCBpLCBsZW47XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnB0O1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICBvYmplY3QuZ3JvdXAgfHwgb2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgaWYgKGJhY2tncm91bmRPYmplY3QpIHtcbiAgICAgICAgYmFja2dyb3VuZE9iamVjdC5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheU9iamVjdCkge1xuICAgICAgICBvdmVybGF5T2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UsIHRoZSB6b29tIGNlbnRlcmVkIGFyb3VuZCBwb2ludFxuICAgICAqIG1lYW5pbmcgdGhhdCBmb2xsb3dpbmcgem9vbSB0byBwb2ludCB3aXRoIHRoZSBzYW1lIHBvaW50IHdpbGwgaGF2ZSB0aGUgdmlzdWFsXG4gICAgICogZWZmZWN0IG9mIHRoZSB6b29tIG9yaWdpbmF0aW5nIGZyb20gdGhhdCBwb2ludC4gVGhlIHBvaW50IHdvbid0IG1vdmUuXG4gICAgICogSXQgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCBjYW52YXMgY2VudGVyIG9yIHZpc3VhbCBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byB6b29tIHdpdGggcmVzcGVjdCB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB0byBzZXQgem9vbSB0bywgbGVzcyB0aGFuIDEgem9vbXMgb3V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICB6b29tVG9Qb2ludDogZnVuY3Rpb24gKHBvaW50LCB2YWx1ZSkge1xuICAgICAgLy8gVE9ETzoganVzdCBjaGFuZ2UgdGhlIHNjYWxlLCBwcmVzZXJ2ZSBvdGhlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHZhciBiZWZvcmUgPSBwb2ludCwgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHBvaW50ID0gdHJhbnNmb3JtUG9pbnQocG9pbnQsIGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSk7XG4gICAgICB2cHRbMF0gPSB2YWx1ZTtcbiAgICAgIHZwdFszXSA9IHZhbHVlO1xuICAgICAgdmFyIGFmdGVyID0gdHJhbnNmb3JtUG9pbnQocG9pbnQsIHZwdCk7XG4gICAgICB2cHRbNF0gKz0gYmVmb3JlLnggLSBhZnRlci54O1xuICAgICAgdnB0WzVdICs9IGJlZm9yZS55IC0gYWZ0ZXIueTtcbiAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0VHJhbnNmb3JtKHZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB0byBzZXQgem9vbSB0bywgbGVzcyB0aGFuIDEgem9vbXMgb3V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRab29tOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuem9vbVRvUG9pbnQobmV3IGZhYnJpYy5Qb2ludCgwLCAwKSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbiB2aWV3cG9ydCBzbyBhcyB0byBwbGFjZSBwb2ludCBhdCB0b3AgbGVmdCBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIGFic29sdXRlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKDApO1xuICAgICAgdnB0WzRdID0gLXBvaW50Lng7XG4gICAgICB2cHRbNV0gPSAtcG9pbnQueTtcbiAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0VHJhbnNmb3JtKHZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbnMgdmlld3BvaW50IHJlbGF0aXZlbHlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgKHBvc2l0aW9uIHZlY3RvcikgdG8gbW92ZSBieVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgcmVsYXRpdmVQYW46IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVQYW4obmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgLXBvaW50LnggLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzRdLFxuICAgICAgICAtcG9pbnQueSAtIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bNV1cbiAgICAgICkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGlzIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG93ZXJDYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgYWRkZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB0aGlzLnN0YXRlZnVsICYmIG9iai5zZXR1cFN0YXRlKCk7XG4gICAgICBvYmouX3NldCgnY2FudmFzJywgdGhpcyk7XG4gICAgICBvYmouc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDphZGRlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICBvYmouZmlyZSgnYWRkZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6cmVtb3ZlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICBvYmouZmlyZSgncmVtb3ZlZCcpO1xuICAgICAgZGVsZXRlIG9iai5jYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBzcGVjaWZpZWQgY29udGV4dCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjbGVhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXJDb250ZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiBjYW52YXMgd2hlcmUgb2JqZWN0cyBhcmUgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjb250ZXh0cyAoYmFja2dyb3VuZCwgbWFpbiwgdG9wKSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29iamVjdHMubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMub3ZlcmxheUltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJyc7XG4gICAgICB0aGlzLm92ZXJsYXlDb2xvciA9ICcnO1xuICAgICAgaWYgKHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5vZmYoJ21vdXNlOnVwJywgdGhpcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzSVRleHRIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIHRoaXMuZmlyZSgnY2FudmFzOmNsZWFyZWQnKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY2FudmFzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fb2JqZWN0cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY3JlYXRlZCB0byBiZSBpbnN0YW5jZSBib3VuZCBhdCBpbml0aWFsaXphdGlvblxuICAgICAqIHVzZWQgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJlbmRlcmluZ1xuICAgICAqIExldCB0aGUgZmFicmljSlMgY2FsbCBpdC4gSWYgeW91IGNhbGwgaXQgbWFudWFsbHkgeW91IGNvdWxkIGhhdmUgbW9yZVxuICAgICAqIGFuaW1hdGlvbkZyYW1lIHN0YWNraW5nIG9uIHRvIG9mIGVhY2ggb3RoZXJcbiAgICAgKiBmb3IgYW4gaW1wZXJhdGl2ZSByZW5kZXJpbmcsIHVzZSBjYW52YXMucmVuZGVyQWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbmRSZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIHJlbmRlckFsbCByZXF1ZXN0IHRvIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIHVubGVzcyBvbmUgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgaW4gdGhhdCBjYXNlIG5vdGhpbmcgaXMgZG9uZVxuICAgICAqIGEgYm9vbGVhbiBmbGFnIHdpbGwgYXZvaWQgYXBwZW5kaW5nIG1vcmUuXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVxdWVzdFJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgNCBjb3JuZXIgb2YgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBoZWxwcyB0byBkZXRlcm1pbmF0ZSB3aGVuIGFuIG9iamVjdCBpcyBpbiB0aGUgY3VycmVudCByZW5kZXJpbmcgdmlld3BvcnQgdXNpbmdcbiAgICAgKiBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXMgKCBhQ29vcmRzIClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvaW50cy50bFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjVmlld3BvcnRCb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSB7IH0sIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHBvaW50cy50bCA9IHRyYW5zZm9ybVBvaW50KHsgeDogMCwgeTogMCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy5iciA9IHRyYW5zZm9ybVBvaW50KHsgeDogd2lkdGgsIHk6IGhlaWdodCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy50ciA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLmJyLngsIHBvaW50cy50bC55KTtcbiAgICAgIHBvaW50cy5ibCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLnRsLngsIHBvaW50cy5ici55KTtcbiAgICAgIHRoaXMudnB0Q29vcmRzID0gcG9pbnRzO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgY2FuY2VsUmVxdWVzdGVkUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLmlzUmVuZGVyaW5nKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYmFja2dyb3VuZCwgb2JqZWN0cywgb3ZlcmxheSBhbmQgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHZhciB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgcGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICB0aGlzLmNhbmNlbFJlcXVlc3RlZFJlbmRlcigpO1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nRW5hYmxlZCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpyZW5kZXInLCB7IGN0eDogY3R4LCB9KTtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vYXBwbHkgdmlld3BvcnQgdHJhbnNmb3JtIG9uY2UgZm9yIGFsbCByZW5kZXJpbmcgcHJvY2Vzc1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRoaXMuX3JlbmRlck9iamVjdHMoY3R4LCBvYmplY3RzKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBpZiAoIXRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aC5jYW52YXMgPSB0aGlzO1xuICAgICAgICAvLyBuZWVkZWQgdG8gc2V0dXAgYSBjb3VwbGUgb2YgdmFyaWFibGVzXG4gICAgICAgIHBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgICAgcGF0aC5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICAgIHBhdGgucmVuZGVyQ2FjaGUoeyBmb3JDbGlwcGluZzogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kcmF3Q2xpcFBhdGhPbkNhbnZhcyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInLCB7IGN0eDogY3R4LCB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjbGlwUGF0aCBvbiB0aGUgbG93ZXJDYW52YXNFbFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2xpcFBhdGhPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAvLyBERUJVRzogdW5jb21tZW50IHRoaXMgbGluZSwgY29tbWVudCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjQ7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIHBhdGgudHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguc2NhbGUoMSAvIHBhdGguem9vbVgsIDEgLyBwYXRoLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UocGF0aC5fY2FjaGVDYW52YXMsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25YLCAtcGF0aC5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqL1xuICAgIF9yZW5kZXJPYmplY3RzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHZhciBpLCBsZW47XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXS5yZW5kZXIoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5ICdiYWNrZ3JvdW5kJyBvciAnb3ZlcmxheSdcbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheTogZnVuY3Rpb24oY3R4LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGZpbGwgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ10sIG9iamVjdCA9IHRoaXNbcHJvcGVydHkgKyAnSW1hZ2UnXSxcbiAgICAgICAgICB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgbmVlZHNWcHQgPSB0aGlzW3Byb3BlcnR5ICsgJ1ZwdCddO1xuICAgICAgaWYgKCFmaWxsICYmICFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKHRoaXMud2lkdGgsIDApO1xuICAgICAgICBjdHgubGluZVRvKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9MaXZlXG4gICAgICAgICAgPyBmaWxsLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiBmaWxsO1xuICAgICAgICBpZiAobmVlZHNWcHQpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgZmlsbC5vZmZzZXRYIHx8IDAsIGZpbGwub2Zmc2V0WSB8fCAwKTtcbiAgICAgICAgdmFyIG0gPSBmaWxsLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGwucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgICAgbSAmJiBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAobmVlZHNWcHQpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5yZW5kZXIoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdiYWNrZ3JvdW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnb3ZlcmxheScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgY2VudGVyIG9mIGNhbnZhcy5cbiAgICAgKiBSZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0b3AgYW5kIGxlZnQgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIGxlZnQ6IHRoaXMud2lkdGggLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHRoaXMuZ2V0Q2VudGVyKCkubGVmdCwgb2JqZWN0LmdldENlbnRlclBvaW50KCkueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLngsIHRoaXMuZ2V0Q2VudGVyKCkudG9wKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQoY2VudGVyLmxlZnQsIGNlbnRlci50b3ApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCB2cENlbnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG4gICAgICB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHZwQ2VudGVyLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBWZXJ0aWNhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtUG9pbnQoeyB4OiBjZW50ZXIubGVmdCwgeTogY2VudGVyLnRvcCB9LCBpVnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBDZW50ZXIgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9jZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3MgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBqc29uIHN0cmluZ1xuICAgICAqL1xuICAgIHRvRGF0YWxlc3NKU09OOiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3RNZXRob2QoJ3RvRGF0YWxlc3NPYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3RNZXRob2Q6IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG5cbiAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgsIGRhdGEgPSB7XG4gICAgICAgIHZlcnNpb246IGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICBvYmplY3RzOiB0aGlzLl90b09iamVjdHMobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSksXG4gICAgICB9O1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGRhdGEuY2xpcFBhdGggPSB0aGlzLl90b09iamVjdCh0aGlzLmNsaXBQYXRoLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChkYXRhLCB0aGlzLl9fc2VyaWFsaXplQmdPdmVybGF5KG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBkYXRhLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0czogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIW9iamVjdC5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3QoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWU7XG5cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3QgPSBpbnN0YW5jZVttZXRob2ROYW1lXShwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fc2VyaWFsaXplQmdPdmVybGF5OiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZGF0YSA9IHsgfSwgYmdJbWFnZSA9IHRoaXMuYmFja2dyb3VuZEltYWdlLCBvdmVybGF5ID0gdGhpcy5vdmVybGF5SW1hZ2U7XG5cbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICBkYXRhLmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmRDb2xvci50b09iamVjdFxuICAgICAgICAgID8gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgICA6IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5ID0gdGhpcy5vdmVybGF5Q29sb3IudG9PYmplY3RcbiAgICAgICAgICA/IHRoaXMub3ZlcmxheUNvbG9yLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICAgOiB0aGlzLm92ZXJsYXlDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChiZ0ltYWdlICYmICFiZ0ltYWdlLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIGRhdGEuYmFja2dyb3VuZEltYWdlID0gdGhpcy5fdG9PYmplY3QoYmdJbWFnZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheSAmJiAhb3ZlcmxheS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLm92ZXJsYXlJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KG92ZXJsYXksIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGdldFN2Z1RyYW5zZm9ybSgpIHdpbGwgYXBwbHkgdGhlIFN0YXRpY0NhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSB0byB0aGUgU1ZHIHRyYW5zZm9ybWF0aW9uLiBXaGVuIHRydWUsXG4gICAgICogYSB6b29tZWQgY2FudmFzIHdpbGwgdGhlbiBwcm9kdWNlIHpvb21lZCBTVkcgb3V0cHV0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IGZvciBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlPWZhbHNlXSBJZiB0cnVlIHhtbCB0YWcgaXMgbm90IGluY2x1ZGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnZpZXdCb3hdIFNWRyB2aWV3Ym94IG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnhdIHgtY29vcmRpbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueV0geS1jb29yZGluYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC53aWR0aF0gV2lkdGggb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LmhlaWdodF0gSGVpZ2h0IG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9VVRGLThdIEVuY29kaW5nIG9mIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMud2lkdGhdIGRlc2lyZWQgd2lkdGggb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5oZWlnaHRdIGRlc2lyZWQgaGVpZ2h0IG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNvbnZlcnRlZCBpbnRvIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyBzdHJpbmdcbiAgICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvalEzWlovfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIFNWRyBvdXRwdXQ8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRygpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aG91dCBwcmVhbWJsZSAod2l0aG91dCAmbHQ7P3htbCAuLi8+KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtzdXBwcmVzc1ByZWFtYmxlOiB0cnVlfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIHZpZXdCb3ggYXR0cmlidXRlPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe1xuICAgICAqICAgdmlld0JveDoge1xuICAgICAqICAgICB4OiAxMDAsXG4gICAgICogICAgIHk6IDEwMCxcbiAgICAgKiAgICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAzMDBcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggZGlmZmVyZW50IGVuY29kaW5nIChkZWZhdWx0OiBVVEYtOCk8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7ZW5jb2Rpbmc6ICdJU08tODg1OS0xJ30pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1vZGlmeSBTVkcgb3V0cHV0IHdpdGggcmV2aXZlciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKG51bGwsIGZ1bmN0aW9uKHN2Zykge1xuICAgICAqICAgcmV0dXJuIHN2Zy5yZXBsYWNlKCdzdHJva2UtZGFzaGFycmF5OiA7IHN0cm9rZS1saW5lY2FwOiBidXR0OyBzdHJva2UtbGluZWpvaW46IG1pdGVyOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7ICcsICcnKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob3B0aW9ucywgcmV2aXZlcikge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICBvcHRpb25zLnJldml2ZXIgPSByZXZpdmVyO1xuICAgICAgdmFyIG1hcmt1cCA9IFtdO1xuXG4gICAgICB0aGlzLl9zZXRTVkdQcmVhbWJsZShtYXJrdXAsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0U1ZHSGVhZGVyKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaCgnPGcgY2xpcC1wYXRoPVwidXJsKCMnICsgdGhpcy5jbGlwUGF0aC5jbGlwUGF0aElkICsgJylcIiA+XFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdiYWNrZ3JvdW5kJyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdiYWNrZ3JvdW5kSW1hZ2UnLCByZXZpdmVyKTtcbiAgICAgIHRoaXMuX3NldFNWR09iamVjdHMobWFya3VwLCByZXZpdmVyKTtcbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlDb2xvcihtYXJrdXAsICdvdmVybGF5Jyk7XG4gICAgICB0aGlzLl9zZXRTVkdCZ092ZXJsYXlJbWFnZShtYXJrdXAsICdvdmVybGF5SW1hZ2UnLCByZXZpdmVyKTtcblxuICAgICAgbWFya3VwLnB1c2goJzwvc3ZnPicpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdQcmVhbWJsZTogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1ByZWFtYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiJywgKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ1VURi04JyksICdcIiBzdGFuZGFsb25lPVwibm9cIiA/PlxcbicsXG4gICAgICAgICc8IURPQ1RZUEUgc3ZnIFBVQkxJQyBcIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOXCIgJyxcbiAgICAgICAgJ1wiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkXCI+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHSGVhZGVyOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgICB2cHQsIHZpZXdCb3ggPSAndmlld0JveD1cIjAgMCAnICsgdGhpcy53aWR0aCArICcgJyArIHRoaXMuaGVpZ2h0ICsgJ1wiICcsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgaWYgKG9wdGlvbnMudmlld0JveCkge1xuICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnkgKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC53aWR0aCArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LmhlaWdodCArICdcIiAnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgICB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzRdIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNV0gLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxzdmcgJyxcbiAgICAgICAgJ3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnLFxuICAgICAgICAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJyxcbiAgICAgICAgJ3ZlcnNpb249XCIxLjFcIiAnLFxuICAgICAgICAnd2lkdGg9XCInLCB3aWR0aCwgJ1wiICcsXG4gICAgICAgICdoZWlnaHQ9XCInLCBoZWlnaHQsICdcIiAnLFxuICAgICAgICB2aWV3Qm94LFxuICAgICAgICAneG1sOnNwYWNlPVwicHJlc2VydmVcIj5cXG4nLFxuICAgICAgICAnPGRlc2M+Q3JlYXRlZCB3aXRoIEZhYnJpYy5qcyAnLCBmYWJyaWMudmVyc2lvbiwgJzwvZGVzYz5cXG4nLFxuICAgICAgICAnPGRlZnM+XFxuJyxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdGb250RmFjZXNNYXJrdXAoKSxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwKG9wdGlvbnMpLFxuICAgICAgICAnPC9kZWZzPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoLmNsaXBQYXRoSWQgPSAnQ0xJUFBBVEhfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgcmV0dXJuICAnPGNsaXBQYXRoIGlkPVwiJyArIGNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnXCIgPlxcbicgK1xuICAgICAgICAgIHRoaXMuY2xpcFBhdGgudG9DbGlwUGF0aFNWRyhvcHRpb25zLnJldml2ZXIpICtcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyByZWZlcmVuY2VkIGVsZW1lbnRzIGxpa2UgcGF0dGVybnMsIGdyYWRpZW50cyBldGMuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgbWFya3VwID0gWydiYWNrZ3JvdW5kJywgJ292ZXJsYXknXS5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBfdGhpc1twcm9wICsgJ0NvbG9yJ107XG4gICAgICAgICAgICBpZiAoZmlsbCAmJiBmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgICAgICB2YXIgc2hvdWxkVHJhbnNmb3JtID0gX3RoaXNbcHJvcCArICdWcHQnXSwgdnB0ID0gX3RoaXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICBvYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfdGhpcy53aWR0aCAvIChzaG91bGRUcmFuc2Zvcm0gPyB2cHRbMF0gOiAxKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5oZWlnaHQgLyAoc2hvdWxkVHJhbnNmb3JtID8gdnB0WzNdIDogMSlcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBmaWxsLnRvU1ZHKFxuICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICB7IGFkZGl0aW9uYWxUcmFuc2Zvcm06IHNob3VsZFRyYW5zZm9ybSA/IGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHZwdCkgOiAnJyB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1hcmt1cCBjb250YWluaW5nIFNWRyBmb250IGZhY2VzLFxuICAgICAqIGZvbnQgVVJMcyBmb3IgZm9udCBmYWNlcyBtdXN0IGJlIGNvbGxlY3RlZCBieSBkZXZlbG9wZXJzXG4gICAgICogYW5kIGFyZSBub3QgZXh0cmFjdGVkIGZyb20gdGhlIERPTSBieSBmYWJyaWNqc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgQXJyYXkgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3JlYXRlU1ZHRm9udEZhY2VzTWFya3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrdXAgPSAnJywgZm9udExpc3QgPSB7IH0sIG9iaiwgZm9udEZhbWlseSxcbiAgICAgICAgICBzdHlsZSwgcm93LCByb3dJbmRleCwgX2NoYXIsIGNoYXJJbmRleCwgaSwgbGVuLFxuICAgICAgICAgIGZvbnRQYXRocyA9IGZhYnJpYy5mb250UGF0aHMsIG9iamVjdHMgPSBbXTtcblxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QuX29iamVjdHMpIHtcbiAgICAgICAgICBvYmplY3QuX29iamVjdHMuZm9yRWFjaChhZGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmogPSBvYmplY3RzW2ldO1xuICAgICAgICBmb250RmFtaWx5ID0gb2JqLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmIChvYmoudHlwZS5pbmRleE9mKCd0ZXh0JykgPT09IC0xIHx8IGZvbnRMaXN0W2ZvbnRGYW1pbHldIHx8ICFmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb250TGlzdFtmb250RmFtaWx5XSA9IHRydWU7XG4gICAgICAgIGlmICghb2JqLnN0eWxlcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlID0gb2JqLnN0eWxlcztcbiAgICAgICAgZm9yIChyb3dJbmRleCBpbiBzdHlsZSkge1xuICAgICAgICAgIHJvdyA9IHN0eWxlW3Jvd0luZGV4XTtcbiAgICAgICAgICBmb3IgKGNoYXJJbmRleCBpbiByb3cpIHtcbiAgICAgICAgICAgIF9jaGFyID0gcm93W2NoYXJJbmRleF07XG4gICAgICAgICAgICBmb250RmFtaWx5ID0gX2NoYXIuZm9udEZhbWlseTtcbiAgICAgICAgICAgIGlmICghZm9udExpc3RbZm9udEZhbWlseV0gJiYgZm9udFBhdGhzW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiBpbiBmb250TGlzdCkge1xuICAgICAgICBtYXJrdXAgKz0gW1xuICAgICAgICAgICdcXHRcXHRAZm9udC1mYWNlIHtcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRmb250LWZhbWlseTogXFwnJywgaiwgJ1xcJztcXG4nLFxuICAgICAgICAgICdcXHRcXHRcXHRzcmM6IHVybChcXCcnLCBmb250UGF0aHNbal0sICdcXCcpO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdH1cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICdcXHQ8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+JyxcbiAgICAgICAgICAnPCFbQ0RBVEFbXFxuJyxcbiAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgJ11dPicsXG4gICAgICAgICAgJzwvc3R5bGU+XFxuJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3RzOiBmdW5jdGlvbihtYXJrdXAsIHJldml2ZXIpIHtcbiAgICAgIHZhciBpbnN0YW5jZSwgaSwgbGVuLCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoaW5zdGFuY2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdPYmplY3QobWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgbWFya3VwLnB1c2goaW5zdGFuY2UudG9TVkcocmV2aXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSwgcmV2aXZlcikge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICYmICF0aGlzW3Byb3BlcnR5XS5leGNsdWRlRnJvbUV4cG9ydCAmJiB0aGlzW3Byb3BlcnR5XS50b1NWRykge1xuICAgICAgICBtYXJrdXAucHVzaCh0aGlzW3Byb3BlcnR5XS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0JnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihtYXJrdXAsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsbGVyID0gdGhpc1twcm9wZXJ0eSArICdDb2xvciddLCB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBmaW5hbFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBmaW5hbEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgaWYgKCFmaWxsZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgdmFyIHJlcGVhdCA9IGZpbGxlci5yZXBlYXQsIGlWcHQgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odnB0KSwgc2hvdWxkSW52ZXJ0ID0gdGhpc1twcm9wZXJ0eSArICdWcHQnXSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBzaG91bGRJbnZlcnQgPyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyhpVnB0KSA6ICcnO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgdHJhbnNmb3JtPVwiJyArIGFkZGl0aW9uYWxUcmFuc2Zvcm0gKyAnIHRyYW5zbGF0ZSgnLCBmaW5hbFdpZHRoIC8gMiwgJywnLCBmaW5hbEhlaWdodCAvIDIsICcpXCInLFxuICAgICAgICAgICcgeD1cIicsIGZpbGxlci5vZmZzZXRYIC0gZmluYWxXaWR0aCAvIDIsXG4gICAgICAgICAgJ1wiIHk9XCInLCBmaWxsZXIub2Zmc2V0WSAtIGZpbmFsSGVpZ2h0IC8gMiwgJ1wiICcsXG4gICAgICAgICAgJ3dpZHRoPVwiJyxcbiAgICAgICAgICAocmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHJlcGVhdCA9PT0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS53aWR0aFxuICAgICAgICAgICAgOiBmaW5hbFdpZHRoICksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2UuaGVpZ2h0XG4gICAgICAgICAgICA6IGZpbmFsSGVpZ2h0KSxcbiAgICAgICAgICAnXCIgZmlsbD1cInVybCgjU1ZHSURfJyArIGZpbGxlci5pZCArICcpXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiAnLFxuICAgICAgICAgICdmaWxsPVwiJywgZmlsbGVyLCAnXCInLFxuICAgICAgICAgICc+PC9yZWN0PlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kIHRvIGJhY2tcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnVuc2hpZnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIHRoZSBvYmplY3RzIG9mIGEgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICogdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIG9ianM7XG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEFuIG9wdGlvbmFsIHBhcmFtZXRlciwgaW50ZXJzZWN0aW5nIGFsbG93cyB0byBtb3ZlIHRoZSBvYmplY3QgaW4gYmVoaW5kXG4gICAgICogdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGJlaGluZCBuZXh0IGxvd2VyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianMsIG9ianNNb3ZlZCA9IDA7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggPiAwICsgb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggLSAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IDApIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRoZSBib3R0b20gb2Ygc3RhY2tcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3TG93ZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld0xvd2VySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHgsIGk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIGRvd24gdGhlIHN0YWNrIGxvb2tpbmcgZm9yIHRoZSBuZWFyZXN0IGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgICAgZm9yIChpID0gaWR4IC0gMTsgaSA+PSAwOyAtLWkpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW1ldGVyLCBpbnRlcnNlY3RpbmcgYWxsb3dzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBmcm9udFxuICAgICAqIG9mIHRoZSBmaXJzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0LiBXaGVyZSBpbnRlcnNlY3Rpb24gaXMgY2FsY3VsYXRlZCB3aXRoXG4gICAgICogYm91bmRpbmcgYm94LiBJZiBubyBpbnRlcnNlY3Rpb24gaXMgZm91bmQsIHRoZXJlIHdpbGwgbm90IGJlIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBzdGFjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nRm9yd2FyZDogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSBvYmpzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA8IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSAtIG9ianNNb3ZlZCkge1xuICAgICAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpzTW92ZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICBpZiAoaWR4ICE9PSB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBpZiBvYmplY3QgaXMgbm90IG9uIHRvcCBvZiBzdGFjayAobGFzdCBpdGVtIGluIGFuIGFycmF5KVxuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdVcHBlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3VXBwZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaSwgbGVuO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeDtcblxuICAgICAgICAvLyB0cmF2ZXJzZSB1cCB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggKyAxLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgICB2YXIgaXNJbnRlcnNlY3RpbmcgPSBvYmplY3QuaW50ZXJzZWN0c1dpdGhPYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SWR4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gc3BlY2lmaWVkIGxldmVsIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBQb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtb3ZlVG86IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4KSB7XG4gICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhIGNhbnZhcyBlbGVtZW50IGFuZCBkaXNwb3NlIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNhbmNlbCBldmVudHVhbGx5IG9uZ29pbmcgcmVuZGVyc1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UgJiYgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlICYmIHRoaXMuYmFja2dyb3VuZEltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSBudWxsO1xuICAgICAgaWYgKHRoaXMub3ZlcmxheUltYWdlICYmIHRoaXMub3ZlcmxheUltYWdlLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5SW1hZ2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vdmVybGF5SW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5faVRleHRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gbnVsbDtcbiAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5DYW52YXMgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpOiAnICtcbiAgICAgICAgICAgICAgICd7IG9iamVjdHM6ICcgKyB0aGlzLl9vYmplY3RzLmxlbmd0aCArICcgfT4nO1xuICAgIH1cbiAgfSk7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkNvbGxlY3Rpb24pO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5EYXRhVVJMRXhwb3J0ZXIpO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgRU1QVFlfSlNPTjogJ3tcIm9iamVjdHNcIjogW10sIFwiYmFja2dyb3VuZFwiOiBcIndoaXRlXCJ9JyxcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIGNoZWNrIHN1cHBvcnQgb2Ygc29tZSBvZiB0aGUgY2FudmFzIG1ldGhvZHNcbiAgICAgKiAoZWl0aGVyIHRob3NlIG9mIEhUTUxDYW52YXNFbGVtZW50IGl0c2VsZiwgb3IgcmVuZGVyaW5nIGNvbnRleHQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgdG8gY2hlY2sgc3VwcG9ydCBmb3I7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQ291bGQgYmUgb25lIG9mIFwic2V0TGluZURhc2hcIlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW4gfCBudWxsfSBgdHJ1ZWAgaWYgbWV0aG9kIGlzIHN1cHBvcnRlZCAob3IgYXQgbGVhc3QgZXhpc3RzKSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYG51bGxgIGlmIGNhbnZhcyBlbGVtZW50IG9yIGNvbnRleHQgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIHN1cHBvcnRzOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGVsID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuXG4gICAgICBpZiAoIWVsIHx8ICFlbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKG1ldGhvZE5hbWUpIHtcblxuICAgICAgICBjYXNlICdzZXRMaW5lRGFzaCc6XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjdHguc2V0TGluZURhc2ggIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAqIHRoaXMgYWxpYXMgaXMgcHJvdmlkZWQgYmVjYXVzZSBpZiB5b3UgY2FsbCBKU09OLnN0cmluZ2lmeSBvbiBhbiBpbnN0YW5jZSxcbiAgICogdGhlIHRvSlNPTiBvYmplY3Qgd2lsbCBiZSBpbnZva2VkIGlmIGl0IGV4aXN0cy5cbiAgICogSGF2aW5nIGEgdG9KU09OIG1ldGhvZCBtZWFucyB5b3UgY2FuIGRvIEpTT04uc3RyaW5naWZ5KG15Q2FudmFzKVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gY29tcGF0aWJsZSBvYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wZWM4Ni98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGFkZGl0aW9uYWwgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW5jbHVkZWQ8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTihbJ2xvY2tNb3ZlbWVudFgnLCAnbG9ja01vdmVtZW50WScsICdsb2NrUm90YXRpb24nLCAnbG9ja1NjYWxpbmdYJywgJ2xvY2tTY2FsaW5nWSddKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRob3V0IGRlZmF1bHQgdmFsdWVzPC9jYXB0aW9uPlxuICAgKiBjYW52YXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBmYWxzZTtcbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKCk7XG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b0pTT04gPSBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS50b09iamVjdDtcblxuICBpZiAoZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmNyZWF0ZVBOR1N0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltcGwgPSBnZXROb2RlQ2FudmFzKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gaW1wbCAmJiBpbXBsLmNyZWF0ZVBOR1N0cmVhbSgpO1xuICAgIH07XG4gICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlSlBFR1N0cmVhbSA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgIHZhciBpbXBsID0gZ2V0Tm9kZUNhbnZhcyh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIGltcGwgJiYgaW1wbC5jcmVhdGVKUEVHU3RyZWFtKG9wdHMpO1xuICAgIH07XG4gIH1cbn0pKCk7XG5cblxuLyoqXG4gKiBCYXNlQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuQmFzZUJydXNoXG4gKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZyZWVkcmF3aW5nfEZyZWVkcmF3aW5nIGRlbW99XG4gKi9cbmZhYnJpYy5CYXNlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5CYXNlQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQ29sb3Igb2YgYSBicnVzaFxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGNvbG9yOiAncmdiKDAsIDAsIDApJyxcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBicnVzaCwgaGFzIHRvIGJlIGEgTnVtYmVyLCBubyBzdHJpbmcgbGl0ZXJhbHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogMSxcblxuICAvKipcbiAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGUuXG4gICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJzaGFkb3dDb2xvclwiIChTdHJpbmcpLCBcInNoYWRvd09mZnNldFhcIiAoTnVtYmVyKSxcbiAgICogXCJzaGFkb3dPZmZzZXRZXCIgKE51bWJlcikgYW5kIFwic2hhZG93Qmx1clwiIChOdW1iZXIpIHNpbmNlIHYxLjIuMTJcbiAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc2hhZG93OiBudWxsLFxuXG4gIC8qKlxuICAgKiBMaW5lIGVuZGluZ3Mgc3R5bGUgb2YgYSBicnVzaCAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTGluZUNhcDogJ3JvdW5kJyxcblxuICAvKipcbiAgICogQ29ybmVyIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJldmVsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVKb2luOiAncm91bmQnLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG1pdGVyIGxlbmd0aCAodXNlZCBmb3Igc3Ryb2tlTGluZUpvaW4gPSBcIm1pdGVyXCIpIG9mIGEgYnJ1c2gnc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgMTAsXG5cbiAgLyoqXG4gICAqIFN0cm9rZSBEYXNoIEFycmF5LlxuICAgKiBAdHlwZSBBcnJheVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlRGFzaEFycmF5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEJydXNoU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgaWYgKGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJykpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLnN0cm9rZURhc2hBcnJheSB8fCBbXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvbiBnaXZlbiBjb250ZXh0XG4gICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJkfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlQW5kVHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICB2YXIgdiA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzLFxuICAgICAgICBzaGFkb3cgPSB0aGlzLnNoYWRvdyxcbiAgICAgICAgY3R4ID0gY2FudmFzLmNvbnRleHRUb3AsXG4gICAgICAgIHpvb20gPSBjYW52YXMuZ2V0Wm9vbSgpO1xuICAgIGlmIChjYW52YXMgJiYgY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgem9vbSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1ciAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0WCAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WSAqIHpvb207XG4gIH0sXG5cbiAgbmVlZHNGdWxsUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpO1xuICAgIHJldHVybiBjb2xvci5nZXRBbHBoYSgpIDwgMSB8fCAhIXRoaXMuc2hhZG93O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBQZW5jaWxCcnVzaCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBlbmNpbEJydXNoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAgICovXG4gIGZhYnJpYy5QZW5jaWxCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlBlbmNpbEJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkIHBvaW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gYGRlY2ltYXRlYCBwaXhlbCBkaXN0YW50IGZyb20gZWFjaCBvdGhlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuNFxuICAgICAqL1xuICAgIGRlY2ltYXRlOiAwLjQsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAgICogQHJldHVybiB7ZmFicmljLlBlbmNpbEJydXNofSBJbnN0YW5jZSBvZiBhIHBlbmNpbCBicnVzaFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLl9wb2ludHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBpbnNpZGUgb24gbW91c2UgZG93biBhbmQgbW91c2UgbW92ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgX2RyYXdTZWdtZW50OiBmdW5jdGlvbiAoY3R4LCBwMSwgcDIpIHtcbiAgICAgIHZhciBtaWRQb2ludCA9IHAxLm1pZFBvaW50RnJvbShwMik7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwMS54LCBwMS55LCBtaWRQb2ludC54LCBtaWRQb2ludC55KTtcbiAgICAgIHJldHVybiBtaWRQb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlciwgb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9wcmVwYXJlRm9yRHJhd2luZyhwb2ludGVyKTtcbiAgICAgIC8vIGNhcHR1cmUgY29vcmRpbmF0ZXMgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHRoaXMgYWxsb3dzIHRvIGRyYXcgZG90cyAod2hlbiBtb3ZlbWVudCBuZXZlciBvY2N1cnMpXG4gICAgICB0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcik7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlciwgb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2FwdHVyZURyYXdpbmdQYXRoKHBvaW50ZXIpICYmIHRoaXMuX3BvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzRnVsbFJlbmRlcigpKSB7XG4gICAgICAgICAgLy8gcmVkcmF3IGN1cnZlXG4gICAgICAgICAgLy8gY2xlYXIgdG9wIGNhbnZhc1xuICAgICAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoLCBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgICAgIC8vIGRyYXcgdGhlIGN1cnZlIHVwZGF0ZVxuICAgICAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICBpZiAodGhpcy5vbGRFbmQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5vbGRFbmQueCwgdGhpcy5vbGRFbmQueSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub2xkRW5kID0gdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwb2ludHNbbGVuZ3RoIC0gMl0sIHBvaW50c1tsZW5ndGggLSAxXSwgdHJ1ZSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2xkRW5kID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZmluYWxpemVBbmRBZGRQYXRoKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgQWN0dWFsIG1vdXNlIHBvc2l0aW9uIHJlbGF0ZWQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfcHJlcGFyZUZvckRyYXdpbmc6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcblxuICAgICAgdmFyIHAgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcblxuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHRoaXMuX2FkZFBvaW50KHApO1xuICAgICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBiZSBhZGRlZCB0byBwb2ludHMgYXJyYXlcbiAgICAgKi9cbiAgICBfYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEgJiYgcG9pbnQuZXEodGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHBvaW50cyBhcnJheSBhbmQgc2V0IGNvbnRleHRUb3AgY2FudmFzIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xuICAgICAgdGhpcy5fc2V0QnJ1c2hTdHlsZXMoKTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX2NhcHR1cmVEcmF3aW5nUGF0aDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ZXJQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZFBvaW50KHBvaW50ZXJQb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBzbW9vdGggcGF0aCBvbiB0aGUgdG9wQ2FudmFzIHVzaW5nIHF1YWRyYXRpY0N1cnZlVG9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0eCAgPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW4sXG4gICAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbMF0sXG4gICAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbMV07XG5cbiAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIC8vaWYgd2Ugb25seSBoYXZlIDIgcG9pbnRzIGluIHRoZSBwYXRoIGFuZCB0aGV5IGFyZSB0aGUgc2FtZVxuICAgICAgLy9pdCBtZWFucyB0aGF0IHRoZSB1c2VyIG9ubHkgY2xpY2tlZCB0aGUgY2FudmFzIHdpdGhvdXQgbW92aW5nIHRoZSBtb3VzZVxuICAgICAgLy90aGVuIHdlIHNob3VsZCBiZSBkcmF3aW5nIGEgZG90LiBBIHBhdGggaXNuJ3QgZHJhd24gYmV0d2VlbiB0d28gaWRlbnRpY2FsIGRvdHNcbiAgICAgIC8vdGhhdCdzIHdoeSB3ZSBzZXQgdGhlbSBhcGFydCBhIGJpdFxuICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPT09IDIgJiYgcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggLyAxMDAwO1xuICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocDEueCwgcDEueSk7XG4gICAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwMi54LCBwMi55KTtcbiAgICAgICAgcDEueCAtPSB3aWR0aDtcbiAgICAgICAgcDIueCArPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG5cbiAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyB3ZSBwaWNrIHRoZSBwb2ludCBiZXR3ZWVuIHBpICsgMSAmIHBpICsgMiBhcyB0aGVcbiAgICAgICAgLy8gZW5kIHBvaW50IGFuZCBwMSBhcyBvdXIgY29udHJvbCBwb2ludC5cbiAgICAgICAgdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwMSwgcDIpO1xuICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gRHJhdyBsYXN0IGxpbmUgYXMgYSBzdHJhaWdodCBsaW5lIHdoaWxlXG4gICAgICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBwb2ludCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gdGhlIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcG9pbnRzIHRvIFNWRyBwYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHBhdGhcbiAgICAgKi9cbiAgICBjb252ZXJ0UG9pbnRzVG9TVkdQYXRoOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgIHZhciBwYXRoID0gW10sIGksIHdpZHRoID0gdGhpcy53aWR0aCAvIDEwMDAsXG4gICAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSksXG4gICAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSksXG4gICAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCwgbXVsdFNpZ25YID0gMSwgbXVsdFNpZ25ZID0gMCwgbWFueVBvaW50cyA9IGxlbiA+IDI7XG5cbiAgICAgIGlmIChtYW55UG9pbnRzKSB7XG4gICAgICAgIG11bHRTaWduWCA9IHBvaW50c1syXS54IDwgcDIueCA/IC0xIDogcG9pbnRzWzJdLnggPT09IHAyLnggPyAwIDogMTtcbiAgICAgICAgbXVsdFNpZ25ZID0gcG9pbnRzWzJdLnkgPCBwMi55ID8gLTEgOiBwb2ludHNbMl0ueSA9PT0gcDIueSA/IDAgOiAxO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKCdNICcsIHAxLnggLSBtdWx0U2lnblggKiB3aWR0aCwgJyAnLCBwMS55IC0gbXVsdFNpZ25ZICogd2lkdGgsICcgJyk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFwMS5lcShwMikpIHtcbiAgICAgICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgICAgIC8vIHAxIGlzIG91ciBiZXppZXIgY29udHJvbCBwb2ludFxuICAgICAgICAgIC8vIG1pZHBvaW50IGlzIG91ciBlbmRwb2ludFxuICAgICAgICAgIC8vIHN0YXJ0IHBvaW50IGlzIHAoaS0xKSB2YWx1ZS5cbiAgICAgICAgICBwYXRoLnB1c2goJ1EgJywgcDEueCwgJyAnLCBwMS55LCAnICcsIG1pZFBvaW50LngsICcgJywgbWlkUG9pbnQueSwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBwMSA9IHBvaW50c1tpXTtcbiAgICAgICAgaWYgKChpICsgMSkgPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgcDIgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFueVBvaW50cykge1xuICAgICAgICBtdWx0U2lnblggPSBwMS54ID4gcG9pbnRzW2kgLSAyXS54ID8gMSA6IHAxLnggPT09IHBvaW50c1tpIC0gMl0ueCA/IDAgOiAtMTtcbiAgICAgICAgbXVsdFNpZ25ZID0gcDEueSA+IHBvaW50c1tpIC0gMl0ueSA/IDEgOiBwMS55ID09PSBwb2ludHNbaSAtIDJdLnkgPyAwIDogLTE7XG4gICAgICB9XG4gICAgICBwYXRoLnB1c2goJ0wgJywgcDEueCArIG11bHRTaWduWCAqIHdpZHRoLCAnICcsIHAxLnkgKyBtdWx0U2lnblkgKiB3aWR0aCk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBmYWJyaWMuUGF0aCBvYmplY3QgdG8gYWRkIG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoRGF0YSBQYXRoIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aH0gUGF0aCB0byBhZGQgb24gY2FudmFzXG4gICAgICovXG4gICAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gbmV3IGZhYnJpYy5QYXRoKHBhdGhEYXRhLCB7XG4gICAgICAgIGZpbGw6IG51bGwsXG4gICAgICAgIHN0cm9rZTogdGhpcy5jb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIHN0cm9rZUxpbmVDYXA6IHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogdGhpcy5zdHJva2VNaXRlckxpbWl0LFxuICAgICAgICBzdHJva2VMaW5lSm9pbjogdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiB0aGlzLnN0cm9rZURhc2hBcnJheSxcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSA9IHRydWU7XG4gICAgICAgIHBhdGguc2hhZG93ID0gbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaW1hdGUgcG9pbnRzIGFycmF5IHdpdGggdGhlIGRlY2ltYXRlIHZhbHVlXG4gICAgICovXG4gICAgZGVjaW1hdGVQb2ludHM6IGZ1bmN0aW9uKHBvaW50cywgZGlzdGFuY2UpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgIH1cbiAgICAgIHZhciB6b29tID0gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpLCBhZGp1c3RlZERpc3RhbmNlID0gTWF0aC5wb3coZGlzdGFuY2UgLyB6b29tLCAyKSxcbiAgICAgICAgICBpLCBsID0gcG9pbnRzLmxlbmd0aCAtIDEsIGxhc3RQb2ludCA9IHBvaW50c1swXSwgbmV3UG9pbnRzID0gW2xhc3RQb2ludF0sXG4gICAgICAgICAgY0Rpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjRGlzdGFuY2UgPSBNYXRoLnBvdyhsYXN0UG9pbnQueCAtIHBvaW50c1tpXS54LCAyKSArIE1hdGgucG93KGxhc3RQb2ludC55IC0gcG9pbnRzW2ldLnksIDIpO1xuICAgICAgICBpZiAoY0Rpc3RhbmNlID49IGFkanVzdGVkRGlzdGFuY2UpIHtcbiAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgbmV3UG9pbnRzLnB1c2gobGFzdFBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld1BvaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3IGZhYnJpYy5Qb2ludChuZXdQb2ludHNbMF0ueCwgbmV3UG9pbnRzWzBdLnkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNldXAgYWZ0ZXIgZHJhd2luZyB0aGUgcGF0aCBvbiBjb250ZXh0VG9wIGNhbnZhc1xuICAgICAqIHdlIHVzZSB0aGUgcG9pbnRzIGNhcHR1cmVkIHRvIGNyZWF0ZSBhbiBuZXcgZmFicmljIHBhdGggb2JqZWN0XG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgZmFicmljIGNhbnZhcy5cbiAgICAgKi9cbiAgICBfZmluYWxpemVBbmRBZGRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgaWYgKHRoaXMuZGVjaW1hdGUpIHtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gdGhpcy5kZWNpbWF0ZVBvaW50cyh0aGlzLl9wb2ludHMsIHRoaXMuZGVjaW1hdGUpO1xuICAgICAgfVxuICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5jb252ZXJ0UG9pbnRzVG9TVkdQYXRoKHRoaXMuX3BvaW50cykuam9pbignJyk7XG4gICAgICBpZiAocGF0aERhdGEgPT09ICdNIDAgMCBRIDAgMCAwIDAgTCAwIDAnKSB7XG4gICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgMCB3aWR0aC9oZWlnaHQgcGF0aHMsIGFzIHRoZXkgYXJlXG4gICAgICAgIC8vIHJlbmRlcmVkIGluY29uc2lzdGVudGx5IGFjcm9zcyBicm93c2Vyc1xuICAgICAgICAvLyBGaXJlZm94IDQsIGZvciBleGFtcGxlLCByZW5kZXJzIGEgZG90LFxuICAgICAgICAvLyB3aGVyZWFzIENocm9tZSAxMCByZW5kZXJzIG5vdGhpbmdcbiAgICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoID0gdGhpcy5jcmVhdGVQYXRoKHBhdGhEYXRhKTtcbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ2JlZm9yZTpwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgICB0aGlzLmNhbnZhcy5hZGQocGF0aCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICBwYXRoLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcblxuXG4gICAgICAvLyBmaXJlIGV2ZW50ICdwYXRoJyBjcmVhdGVkXG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IHBhdGggfSk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuLyoqXG4gKiBDaXJjbGVCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5DaXJjbGVCcnVzaFxuICovXG5mYWJyaWMuQ2lyY2xlQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGVCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEwLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlQnJ1c2h9IEluc3RhbmNlIG9mIGEgY2lyY2xlIGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGluc2lkZSBvbiBtb3VzZSBkb3duIGFuZCBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBkcmF3RG90OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5hZGRQb2ludChwb2ludGVyKSxcbiAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgdGhpcy5kb3QoY3R4LCBwb2ludCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uKGN0eCwgcG9pbnQpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gcG9pbnQuZmlsbDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBwb2ludC5yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9zZXRTaGFkb3coKTtcbiAgICB0aGlzLmRyYXdEb3QocG9pbnRlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgZnVsbCBzdGF0ZSBvZiB0aGUgYnJ1c2hcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuLFxuICAgICAgICBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRvdChjdHgsIHBvaW50c1tpXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICBpZiAodGhpcy5uZWVkc0Z1bGxSZW5kZXIoKSkge1xuICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5hZGRQb2ludChwb2ludGVyKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd0RvdChwb2ludGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICovXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSwgaSwgbGVuO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgY2lyY2xlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnRzW2ldLFxuICAgICAgICAgIGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgIHJhZGl1czogcG9pbnQucmFkaXVzLFxuICAgICAgICAgICAgbGVmdDogcG9pbnQueCxcbiAgICAgICAgICAgIHRvcDogcG9pbnQueSxcbiAgICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICBmaWxsOiBwb2ludC5maWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc2hhZG93ICYmIChjaXJjbGUuc2hhZG93ID0gbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpKTtcblxuICAgICAgY2lyY2xlcy5wdXNoKGNpcmNsZSk7XG4gICAgfVxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAoY2lyY2xlcyk7XG4gICAgZ3JvdXAuY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IEp1c3QgYWRkZWQgcG9pbnRlciBwb2ludFxuICAgKi9cbiAgYWRkUG9pbnQ6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnRlclBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG5cbiAgICAgICAgY2lyY2xlUmFkaXVzID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIE1hdGgubWF4KDAsIHRoaXMud2lkdGggLSAyMCksIHRoaXMud2lkdGggKyAyMCkgLyAyLFxuXG4gICAgICAgIGNpcmNsZUNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKVxuICAgICAgICAgIC5zZXRBbHBoYShmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMClcbiAgICAgICAgICAudG9SZ2JhKCk7XG5cbiAgICBwb2ludGVyUG9pbnQucmFkaXVzID0gY2lyY2xlUmFkaXVzO1xuICAgIHBvaW50ZXJQb2ludC5maWxsID0gY2lyY2xlQ29sb3I7XG5cbiAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50ZXJQb2ludCk7XG5cbiAgICByZXR1cm4gcG9pbnRlclBvaW50O1xuICB9XG59KTtcblxuXG4vKipcbiAqIFNwcmF5QnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuU3ByYXlCcnVzaFxuICovXG5mYWJyaWMuU3ByYXlCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKCBmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5TcHJheUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgc3ByYXlcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogICAgICAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBEZW5zaXR5IG9mIGEgc3ByYXkgKG51bWJlciBvZiBkb3RzIHBlciBjaHVuaylcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkZW5zaXR5OiAgICAgICAgICAgIDIwLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGg6ICAgICAgICAgICAxLFxuXG4gIC8qKlxuICAgKiBXaWR0aCB2YXJpYW5jZSBvZiBzcHJheSBkb3RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZG90V2lkdGhWYXJpYW5jZTogICAxLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9wYWNpdHkgb2YgYSBkb3Qgc2hvdWxkIGJlIHJhbmRvbVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICByYW5kb21PcGFjaXR5OiAgICAgICAgZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3ZlcmxhcHBpbmcgZG90cyAocmVjdGFuZ2xlcykgc2hvdWxkIGJlIHJlbW92ZWQgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKVxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBvcHRpbWl6ZU92ZXJsYXBwaW5nOiAgdHJ1ZSxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLlNwcmF5QnJ1c2h9IEluc3RhbmNlIG9mIGEgc3ByYXkgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc3ByYXlDaHVua3MgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG5cbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciByZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFyIHNwcmF5Q2h1bmsgPSB0aGlzLnNwcmF5Q2h1bmtzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IHNwcmF5Q2h1bmsubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3Qoe1xuICAgICAgICAgIHdpZHRoOiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBsZWZ0OiBzcHJheUNodW5rW2pdLnggKyAxLFxuICAgICAgICAgIHRvcDogc3ByYXlDaHVua1tqXS55ICsgMSxcbiAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICByZWN0cy5wdXNoKHJlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGltaXplT3ZlcmxhcHBpbmcpIHtcbiAgICAgIHJlY3RzID0gdGhpcy5fZ2V0T3B0aW1pemVkUmVjdHMocmVjdHMpO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IG5ldyBmYWJyaWMuR3JvdXAocmVjdHMpO1xuICAgIHRoaXMuc2hhZG93ICYmIGdyb3VwLnNldCgnc2hhZG93JywgbmV3IGZhYnJpYy5TaGFkb3codGhpcy5zaGFkb3cpKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGQoZ3JvdXApO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG5cbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fcmVzZXRTaGFkb3coKTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmU7XG4gICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZWN0c1xuICAgKi9cbiAgX2dldE9wdGltaXplZFJlY3RzOiBmdW5jdGlvbihyZWN0cykge1xuXG4gICAgLy8gYXZvaWQgY3JlYXRpbmcgZHVwbGljYXRlIHJlY3RzIGF0IHRoZSBzYW1lIGNvb3JkaW5hdGVzXG4gICAgdmFyIHVuaXF1ZVJlY3RzID0geyB9LCBrZXksIGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSByZWN0c1tpXS5sZWZ0ICsgJycgKyByZWN0c1tpXS50b3A7XG4gICAgICBpZiAoIXVuaXF1ZVJlY3RzW2tleV0pIHtcbiAgICAgICAgdW5pcXVlUmVjdHNba2V5XSA9IHJlY3RzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdW5pcXVlUmVjdHNBcnJheSA9IFtdO1xuICAgIGZvciAoa2V5IGluIHVuaXF1ZVJlY3RzKSB7XG4gICAgICB1bmlxdWVSZWN0c0FycmF5LnB1c2godW5pcXVlUmVjdHNba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXF1ZVJlY3RzQXJyYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBuZXcgY2h1bmsgb2Ygc3ByYXkgYnJ1c2hcbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24oc3ByYXlDaHVuaykge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSBzcHJheUNodW5rW2ldO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludC5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBwb2ludC5vcGFjaXR5O1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxSZWN0KHBvaW50LngsIHBvaW50LnksIHBvaW50LndpZHRoLCBwb2ludC53aWR0aCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbGwgc3ByYXkgY2h1bmtzXG4gICAqL1xuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgaWxlbjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcblxuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rc1tpXSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBhZGRTcHJheUNodW5rOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5zcHJheUNodW5rUG9pbnRzID0gW107XG5cbiAgICB2YXIgeCwgeSwgd2lkdGgsIHJhZGl1cyA9IHRoaXMud2lkdGggLyAyLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGVuc2l0eTsgaSsrKSB7XG5cbiAgICAgIHggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci54IC0gcmFkaXVzLCBwb2ludGVyLnggKyByYWRpdXMpO1xuICAgICAgeSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnkgLSByYWRpdXMsIHBvaW50ZXIueSArIHJhZGl1cyk7XG5cbiAgICAgIGlmICh0aGlzLmRvdFdpZHRoVmFyaWFuY2UpIHtcbiAgICAgICAgd2lkdGggPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgLy8gYm90dG9tIGNsYW1wIHdpZHRoIHRvIDFcbiAgICAgICAgICBNYXRoLm1heCgxLCB0aGlzLmRvdFdpZHRoIC0gdGhpcy5kb3RXaWR0aFZhcmlhbmNlKSxcbiAgICAgICAgICB0aGlzLmRvdFdpZHRoICsgdGhpcy5kb3RXaWR0aFZhcmlhbmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aWR0aCA9IHRoaXMuZG90V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgICBwb2ludC53aWR0aCA9IHdpZHRoO1xuXG4gICAgICBpZiAodGhpcy5yYW5kb21PcGFjaXR5KSB7XG4gICAgICAgIHBvaW50Lm9wYWNpdHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoMCwgMTAwKSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zcHJheUNodW5rUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc3ByYXlDaHVua3MucHVzaCh0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9XG59KTtcblxuXG4vKipcbiAqIFBhdHRlcm5CcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuQnJ1c2hcbiAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqL1xuZmFicmljLlBhdHRlcm5CcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5QZW5jaWxCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybkJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgZ2V0UGF0dGVyblNyYzogZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZG90V2lkdGggPSAyMCxcbiAgICAgICAgZG90RGlzdGFuY2UgPSA1LFxuICAgICAgICBwYXR0ZXJuQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgcGF0dGVybkNhbnZhcy53aWR0aCA9IHBhdHRlcm5DYW52YXMuaGVpZ2h0ID0gZG90V2lkdGggKyBkb3REaXN0YW5jZTtcblxuICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBwYXR0ZXJuQ3R4LmJlZ2luUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguYXJjKGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgcGF0dGVybkN0eC5jbG9zZVBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmZpbGwoKTtcblxuICAgIHJldHVybiBwYXR0ZXJuQ2FudmFzO1xuICB9LFxuXG4gIGdldFBhdHRlcm5TcmNGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldFBhdHRlcm5TcmMpLnJlcGxhY2UoJ3RoaXMuY29sb3InLCAnXCInICsgdGhpcy5jb2xvciArICdcIicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFwicGF0dGVyblwiIGluc3RhbmNlIHByb3BlcnR5XG4gICAqL1xuICBnZXRQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMuY29udGV4dFRvcC5jcmVhdGVQYXR0ZXJuKHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyYygpLCAncmVwZWF0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqL1xuICBfc2V0QnJ1c2hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0QnJ1c2hTdHlsZXMnKTtcbiAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLnN0cm9rZVN0eWxlID0gdGhpcy5nZXRQYXR0ZXJuKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcGF0aFxuICAgKi9cbiAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuY2FsbFN1cGVyKCdjcmVhdGVQYXRoJywgcGF0aERhdGEpLFxuICAgICAgICB0b3BMZWZ0ID0gcGF0aC5fZ2V0TGVmdFRvcENvb3JkcygpLnNjYWxhckFkZChwYXRoLnN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICBwYXRoLnN0cm9rZSA9IG5ldyBmYWJyaWMuUGF0dGVybih7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyY0Z1bmN0aW9uKCksXG4gICAgICBvZmZzZXRYOiAtdG9wTGVmdC54LFxuICAgICAgb2Zmc2V0WTogLXRvcExlZnQueVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdldFBvaW50ZXIgPSBmYWJyaWMudXRpbC5nZXRQb2ludGVyLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBhYnMgPSBNYXRoLmFicyxcbiAgICAgIHN1cHBvcnRMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyksXG4gICAgICBpc1RvdWNoRXZlbnQgPSBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQsXG4gICAgICBTVFJPS0VfT0ZGU0VUID0gMC41O1xuXG4gIC8qKlxuICAgKiBDYW52YXMgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5DYW52YXNcbiAgICogQGV4dGVuZHMgZmFicmljLlN0YXRpY0NhbnZhc1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNjYW52YXN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DYW52YXMjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogQGZpcmVzIG9iamVjdDptb2RpZmllZCBhdCB0aGUgZW5kIG9mIGEgdHJhbnNmb3JtIG9yIGFueSBjaGFuZ2Ugd2hlbiBzdGF0ZWZ1bGwgaXMgdHJ1ZVxuICAgKiBAZmlyZXMgb2JqZWN0OnJvdGF0aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyByb3RhdGVkIGZyb20gdGhlIGNvbnRyb2xcbiAgICogQGZpcmVzIG9iamVjdDpzY2FsaW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBzY2FsZWQgYnkgY29udHJvbHNcbiAgICogQGZpcmVzIG9iamVjdDptb3Zpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIGRyYWdnZWRcbiAgICogQGZpcmVzIG9iamVjdDpza2V3aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBza2V3ZWQgZnJvbSB0aGUgY29udHJvbHNcbiAgICpcbiAgICogQGZpcmVzIGJlZm9yZTp0cmFuc2Zvcm0gYmVmb3JlIGEgdHJhbnNmb3JtIGlzIGlzIHN0YXJ0ZWRcbiAgICogQGZpcmVzIGJlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjp1cGRhdGVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y3JlYXRlZFxuICAgKlxuICAgKiBAZmlyZXMgcGF0aDpjcmVhdGVkIGFmdGVyIGEgZHJhd2luZyBvcGVyYXRpb24gZW5kcyBhbmQgdGhlIHBhdGggaXMgYWRkZWRcbiAgICogQGZpcmVzIG1vdXNlOmRvd25cbiAgICogQGZpcmVzIG1vdXNlOm1vdmVcbiAgICogQGZpcmVzIG1vdXNlOnVwXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duOmJlZm9yZSAgb24gbW91c2UgZG93biwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6bW92ZTpiZWZvcmUgb24gbW91c2UgbW92ZSwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6dXA6YmVmb3JlIG9uIG1vdXNlIHVwLCBiZWZvcmUgdGhlIGlubmVyIGZhYnJpYyBsb2dpYyBydW5zXG4gICAqIEBmaXJlcyBtb3VzZTpvdmVyXG4gICAqIEBmaXJlcyBtb3VzZTpvdXRcbiAgICogQGZpcmVzIG1vdXNlOmRibGNsaWNrIHdoZW5ldmVyIGEgbmF0aXZlIGRibCBjbGljayBldmVudCBmaXJlcyBvbiB0aGUgY2FudmFzLlxuICAgKlxuICAgKiBAZmlyZXMgZHJhZ292ZXJcbiAgICogQGZpcmVzIGRyYWdlbnRlclxuICAgKiBAZmlyZXMgZHJhZ2xlYXZlXG4gICAqIEBmaXJlcyBkcm9wXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXIgYXQgdGhlIGVuZCBvZiB0aGUgcmVuZGVyIHByb2Nlc3MsIHJlY2VpdmVzIHRoZSBjb250ZXh0IGluIHRoZSBjYWxsYmFja1xuICAgKiBAZmlyZXMgYmVmb3JlOnJlbmRlciBhdCBzdGFydCB0aGUgcmVuZGVyIHByb2Nlc3MsIHJlY2VpdmVzIHRoZSBjb250ZXh0IGluIHRoZSBjYWxsYmFja1xuICAgKlxuICAgKiB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgZGVwcmVjYXRlZDpcbiAgICogQGZpcmVzIG9iamVjdDpyb3RhdGVkIGF0IHRoZSBlbmQgb2YgYSByb3RhdGlvbiB0cmFuc2Zvcm1cbiAgICogQGZpcmVzIG9iamVjdDpzY2FsZWQgYXQgdGhlIGVuZCBvZiBhIHNjYWxlIHRyYW5zZm9ybVxuICAgKiBAZmlyZXMgb2JqZWN0Om1vdmVkIGF0IHRoZSBlbmQgb2YgdHJhbnNsYXRpb24gdHJhbnNmb3JtXG4gICAqIEBmaXJlcyBvYmplY3Q6c2tld2VkIGF0IHRoZSBlbmQgb2YgYSBza2V3IHRyYW5zZm9ybVxuICAgKi9cbiAgZmFicmljLkNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5TdGF0aWNDYW52YXMsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kID0gdGhpcy5yZW5kZXJBbmRSZXNldC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEludGVyYWN0aXZlKCk7XG4gICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgY2FuIGJlIHRyYW5zZm9ybWVkIGJ5IG9uZSBzaWRlICh1bnByb3BvcnRpb25hbGx5KVxuICAgICAqIHdoZW4gZHJhZ2dlZCBvbiB0aGUgY29ybmVycyB0aGF0IG5vcm1hbGx5IHdvdWxkIG5vdCBkbyB0aGF0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBzaW5jZSBmYWJyaWMgNC4wIC8vIGNoYW5nZWQgbmFtZSBhbmQgZGVmYXVsdCB2YWx1ZVxuICAgICAqL1xuICAgIHVuaWZvcm1TY2FsaW5nOiAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IHN3aXRjaGVzIHVuaWZvcm0gc2NhbGluZy5cbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiB0b3RhbGx5IHdyb25nIG5hbWVkLiB0aGlzIHNvdW5kcyBsaWtlIGB1bmlmb3JtIHNjYWxpbmdgXG4gICAgICogaWYgQ2FudmFzLnVuaWZvcm1TY2FsaW5nIGlzIHRydWUsIHByZXNzaW5nIHRoaXMgd2lsbCBzZXQgaXQgdG8gZmFsc2VcbiAgICAgKiBhbmQgdmljZXZlcnNhLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdW5pU2NhbGVLZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiBzY2FsZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkU2NhbGluZzogICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiByb3RhdGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFJvdGF0aW9uOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGNlbnRlcmVkIFRyYW5zZm9ybVxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZEtleTogICAgICAgICAgICdhbHRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgYWx0ZXJuYXRlIGFjdGlvbiBvbiBjb3JuZXJcbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZCBmZWF0dXJlIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0QWN0aW9uS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGNhbnZhcyBpcyBpbnRlcmFjdGl2ZS4gVGhpcyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIGNoYW5nZWQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW50ZXJhY3RpdmU6ICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGdyb3VwIHNlbGVjdGlvbiBzaG91bGQgYmUgZW5hYmxlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbjogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IG9yIGtleXMgZW5hYmxlIG11bHRpcGxlIGNsaWNrIHNlbGVjdGlvblxuICAgICAqIFBhc3MgdmFsdWUgYXMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgZW1wdHkgb3IgY29udGFpbmluZyBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmd8QXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbktleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgKiBpbiBjYXNlIG9mIHRhcmdldCBvdmVybGFwcGluZyB3aXRoIGFjdGl2ZSBvYmplY3RcbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogRm9yIGEgc2VyaWVzIG9mIHJlYXNvbiB0aGF0IGNvbWUgZnJvbSB0aGUgZ2VuZXJhbCBleHBlY3RhdGlvbnMgb24gaG93XG4gICAgICogdGhpbmdzIHNob3VsZCB3b3JrLCB0aGlzIGZlYXR1cmUgd29ya3Mgb25seSBmb3IgcHJlc2VydmVPYmplY3RTdGFja2luZyB0cnVlLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQHR5cGUgbnVsbHxTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsdFNlbGVjdGlvbktleTogICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNvbG9yOiAgICAgICAgICdyZ2JhKDEwMCwgMTAwLCAyNTUsIDAuMyknLCAvLyBibHVlXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGRhc2ggYXJyYXkgcGF0dGVyblxuICAgICAqIElmIG5vdCBlbXB0eSB0aGUgc2VsZWN0aW9uIGJvcmRlciBpcyBkYXNoZWRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHNlbGVjdGlvbkRhc2hBcnJheTogICAgIFtdLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGhlIGJvcmRlciBvZiBzZWxlY3Rpb24gKHVzdWFsbHkgc2xpZ2h0bHkgZGFya2VyIHRoYW4gY29sb3Igb2Ygc2VsZWN0aW9uIGl0c2VsZilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkJvcmRlckNvbG9yOiAgICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyknLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBsaW5lIHVzZWQgaW4gb2JqZWN0L2dyb3VwIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uTGluZVdpZHRoOiAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBvbmx5IHNoYXBlcyB0aGF0IGFyZSBmdWxseSBjb250YWluZWQgaW4gdGhlIGRyYWdnZWQgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25GdWxseUNvbnRhaW5lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gaG92ZXJpbmcgb3ZlciBhbiBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAnbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIGFuIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vdmVDdXJzb3I6ICAgICAgICAgICAgICdtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgZm9yIHRoZSBlbnRpcmUgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkZWZhdWx0Q3Vyc29yOiAgICAgICAgICAnZGVmYXVsdCcsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBkdXJpbmcgZnJlZSBkcmF3aW5nXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmcmVlRHJhd2luZ0N1cnNvcjogICAgICAnY3Jvc3NoYWlyJyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGZvciByb3RhdGlvbiBwb2ludFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpb25DdXJzb3I6ICAgICAgICAgJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBmb3IgZGlzYWJsZWQgZWxlbWVudHMgKCBjb3JuZXJzIHdpdGggZGlzYWJsZWQgYWN0aW9uIClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vdEFsbG93ZWRDdXJzb3I6ICAgICAgICAgJ25vdC1hbGxvd2VkJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZWxlbWVudCBjbGFzcyB0aGF0J3MgZ2l2ZW4gdG8gd3JhcHBlciAoZGl2KSBlbGVtZW50IG9mIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udGFpbmVyQ2xhc3M6ICAgICAgICAgJ2NhbnZhcy1jb250YWluZXInLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3QgZGV0ZWN0aW9uIGhhcHBlbnMgb24gcGVyLXBpeGVsIGJhc2lzIHJhdGhlciB0aGFuIG9uIHBlci1ib3VuZGluZy1ib3hcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwZXJQaXhlbFRhcmdldEZpbmQ6ICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBwaXhlbHMgYXJvdW5kIHRhcmdldCBwaXhlbCB0byB0b2xlcmF0ZSAoY29uc2lkZXIgYWN0aXZlKSBkdXJpbmcgb2JqZWN0IGRldGVjdGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGFyZ2V0RmluZFRvbGVyYW5jZTogICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGFyZ2V0IGRldGVjdGlvbiBpcyBza2lwcGVkLiBUYXJnZXQgZGV0ZWN0aW9uIHdpbGwgcmV0dXJuIGFsd2F5cyB1bmRlZmluZWQuXG4gICAgICogY2xpY2sgc2VsZWN0aW9uIHdvbid0IHdvcmsgYW55bW9yZSwgZXZlbnRzIHdpbGwgZmlyZSB3aXRoIG5vIHRhcmdldHMuXG4gICAgICogaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkIGJlZm9yZSBzZXR0aW5nIGl0IHRvIHRydWUsIGl0IHdpbGwgYmUgZGVzZWxlY3RlZCBhdCB0aGUgZmlyc3QgY2xpY2suXG4gICAgICogYXJlYSBzZWxlY3Rpb24gd2lsbCBzdGlsbCB3b3JrLiBjaGVjayB0aGUgYHNlbGVjdGlvbmAgcHJvcGVydHkgdG9vLlxuICAgICAqIGlmIHlvdSBkZWFjdGl2YXRlIGJvdGgsIHlvdSBzaG91bGQgbG9vayBpbnRvIHN0YXRpY0NhbnZhcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2lwVGFyZ2V0RmluZDogICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgbW91c2UgZXZlbnRzIG9uIGNhbnZhcyAobW91c2Vkb3duL21vdXNlbW92ZS9tb3VzZXVwKSByZXN1bHQgaW4gZnJlZSBkcmF3aW5nLlxuICAgICAqIEFmdGVyIG1vdXNlZG93biwgbW91c2Vtb3ZlIGNyZWF0ZXMgYSBzaGFwZSxcbiAgICAgKiBhbmQgdGhlbiBtb3VzZXVwIGZpbmFsaXplcyBpdCBhbmQgYWRkcyBhbiBpbnN0YW5jZSBvZiBgZmFicmljLlBhdGhgIG9udG8gY2FudmFzLlxuICAgICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC00I2ZyZWVfZHJhd2luZ31cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0RyYXdpbmdNb2RlOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMgc2hvdWxkIHJlbWFpbiBpbiBjdXJyZW50IHN0YWNrIHBvc2l0aW9uIHdoZW4gc2VsZWN0ZWQuXG4gICAgICogV2hlbiBmYWxzZSBvYmplY3RzIGFyZSBicm91Z2h0IHRvIHRvcCBhbmQgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgc2VsZWN0aW9uIGdyb3VwXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcHJlc2VydmVPYmplY3RTdGFja2luZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGFuZ2xlIHRoYXQgYW4gb2JqZWN0IHdpbGwgbG9jayB0byB3aGlsZSByb3RhdGluZy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAc2luY2UgMS42LjdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNuYXBBbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc25hcEFuZ2xlIHRoZSByb3RhdGlvbiB3aWxsIGxvY2sgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBXaGVuIGBudWxsYCwgdGhlIHNuYXBUaHJlc2hvbGQgd2lsbCBkZWZhdWx0IHRvIHRoZSBzbmFwQW5nbGUuXG4gICAgICogQHR5cGUgbnVsbHxOdW1iZXJcbiAgICAgKiBAc2luY2UgMS42LjdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNuYXBUaHJlc2hvbGQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHJpZ2h0IGNsaWNrIG9uIGNhbnZhcyBjYW4gb3V0cHV0IHRoZSBjb250ZXh0IG1lbnUgb3Igbm90XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3RvcENvbnRleHRNZW51OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2FudmFzIGNhbiBmaXJlIHJpZ2h0IGNsaWNrIGV2ZW50c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpcmVSaWdodENsaWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2FudmFzIGNhbiBmaXJlIG1pZGRsZSBjbGljayBldmVudHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNy44XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaXJlTWlkZGxlQ2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiB0aGUgc3ViVGFyZ2V0cyBmb3IgTW91c2UgRXZlbnRzXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFtdXG4gICAgICovXG4gICAgdGFyZ2V0czogW10sXG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIHRoZSBob3ZlcmVkIHRhcmdldFxuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ob3ZlcmVkVGFyZ2V0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogaG9sZCB0aGUgbGlzdCBvZiBuZXN0ZWQgdGFyZ2V0cyBob3ZlcmVkXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFtdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaG92ZXJlZFRhcmdldHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEludGVyYWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9pbml0V3JhcHBlckVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2NyZWF0ZVVwcGVyQ2FudmFzKCk7XG4gICAgICB0aGlzLl9pbml0RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcblxuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoID0gZmFicmljLlBlbmNpbEJydXNoICYmIG5ldyBmYWJyaWMuUGVuY2lsQnJ1c2godGhpcyk7XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIG9iamVjdHMgaW4gdHdvIGdyb3Vwcywgb25lIHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAqIGFuZCBvbmUgdG8gcmVuZGVyIGFzIGFjdGl2ZUdyb3VwLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlciBpbW1lZGlhdGVseSBhbmQgcHVzaGVzIHRoZSBvdGhlciBpbiB0aGUgYWN0aXZlR3JvdXAuXG4gICAgICovXG4gICAgX2Nob29zZU9iamVjdHNUb1JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIG9iamVjdCwgb2Jqc1RvUmVuZGVyLCBhY3RpdmVHcm91cE9iamVjdHM7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDAgJiYgIXRoaXMucHJlc2VydmVPYmplY3RTdGFja2luZykge1xuICAgICAgICBvYmpzVG9SZW5kZXIgPSBbXTtcbiAgICAgICAgYWN0aXZlR3JvdXBPYmplY3RzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgICBpZiAoYWN0aXZlT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xICkge1xuICAgICAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0Ll9vYmplY3RzID0gYWN0aXZlR3JvdXBPYmplY3RzO1xuICAgICAgICB9XG4gICAgICAgIG9ianNUb1JlbmRlci5wdXNoLmFwcGx5KG9ianNUb1JlbmRlciwgYWN0aXZlR3JvdXBPYmplY3RzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvYmpzVG9SZW5kZXIgPSB0aGlzLl9vYmplY3RzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ianNUb1JlbmRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBib3RoIHRoZSB0b3AgY2FudmFzIGFuZCB0aGUgc2Vjb25kYXJ5IGNvbnRhaW5lciBjYW52YXMuXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0VG9wRGlydHkgJiYgIXRoaXMuX2dyb3VwU2VsZWN0b3IgJiYgIXRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzTG9zdENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUb3BMYXllcih0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX2Nob29zZU9iamVjdHNUb1JlbmRlcigpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW5kZXJUb3BMYXllcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoICYmIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5fcmVuZGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHJlbmRlciB0aGUgdG9wIGNvbnRleHQgLSBsYXN0IG9iamVjdFxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZHJhd1NlbGVjdGlvbihjdHgpO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcmVuZGVyIG9ubHkgdGhlIHRvcCBjYW52YXMuXG4gICAgICogQWxzbyB1c2VkIHRvIHJlbmRlciB0aGUgZ3JvdXAgc2VsZWN0aW9uIGJveC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlclRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFRvcDtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLnJlbmRlclRvcExheWVyKGN0eCk7XG4gICAgICB0aGlzLmZpcmUoJ2FmdGVyOnJlbmRlcicpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZVBvaW50ZXI6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBtID0gb2JqZWN0LmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBpbnZlcnRlZE0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0obSksXG4gICAgICAgICAgdnB0UG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQocG9pbnRlcik7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodnB0UG9pbnRlciwgaW52ZXJ0ZWRNKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyB0cmFuc3BhcmVudCBhdCBhIGNlcnRhaW4gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBPYmplY3QgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUYXJnZXRUcmFuc3BhcmVudDogZnVuY3Rpb24gKHRhcmdldCwgeCwgeSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgdGFyZ2V0IGlzIHRoZSBhY3RpdmVPYmplY3QsIHdlIGNhbm5vdCBleGVjdXRlIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gZHJhdyBjb250cm9scyB0b28uXG4gICAgICBpZiAodGFyZ2V0LnNob3VsZENhY2hlKCkgJiYgdGFyZ2V0Ll9jYWNoZUNhbnZhcyAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFBvaW50ZXIgPSB0aGlzLl9ub3JtYWxpemVQb2ludGVyKHRhcmdldCwge3g6IHgsIHk6IHl9KSxcbiAgICAgICAgICAgIHRhcmdldFJlbGF0aXZlWCA9IE1hdGgubWF4KHRhcmdldC5jYWNoZVRyYW5zbGF0aW9uWCArIChub3JtYWxpemVkUG9pbnRlci54ICogdGFyZ2V0Lnpvb21YKSwgMCksXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVkgPSBNYXRoLm1heCh0YXJnZXQuY2FjaGVUcmFuc2xhdGlvblkgKyAobm9ybWFsaXplZFBvaW50ZXIueSAqIHRhcmdldC56b29tWSksIDApO1xuXG4gICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgICB0YXJnZXQuX2NhY2hlQ29udGV4dCwgTWF0aC5yb3VuZCh0YXJnZXRSZWxhdGl2ZVgpLCBNYXRoLnJvdW5kKHRhcmdldFJlbGF0aXZlWSksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgICAgcmV0dXJuIGlzVHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRDYWNoZSxcbiAgICAgICAgICBvcmlnaW5hbENvbG9yID0gdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciwgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICAgIHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgPSAnJztcblxuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0YXJnZXQucmVuZGVyKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0YXJnZXQuX3JlbmRlckNvbnRyb2xzKGN0eCwge1xuICAgICAgICBoYXNCb3JkZXJzOiBmYWxzZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBoYXNCb3JkZXJzOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gb3JpZ2luYWxDb2xvcjtcblxuICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSBmYWJyaWMudXRpbC5pc1RyYW5zcGFyZW50KFxuICAgICAgICBjdHgsIHgsIHksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyBhbiBldmVudCBhbmQgZGV0ZXJtaW5lcyBpZiBzZWxlY3Rpb24ga2V5IGhhcyBiZWVuIHByZXNzZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2lzU2VsZWN0aW9uS2V5UHJlc3NlZDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHNlbGVjdGlvbktleVByZXNzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLnNlbGVjdGlvbktleSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgc2VsZWN0aW9uS2V5UHJlc3NlZCA9ICEhdGhpcy5zZWxlY3Rpb25LZXkuZmluZChmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGVba2V5XSA9PT0gdHJ1ZTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IGVbdGhpcy5zZWxlY3Rpb25LZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0aW9uS2V5UHJlc3NlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgIXRhcmdldFxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0cy5pbmRleE9mKHRhcmdldCkgPT09IC0xICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQgJiZcbiAgICAgICAgICAhdGhpcy5faXNTZWxlY3Rpb25LZXlQcmVzc2VkKGUpKVxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmICF0YXJnZXQuZXZlbnRlZClcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJlxuICAgICAgICAgICF0YXJnZXQuc2VsZWN0YWJsZSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0KVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2VudGVyZWRTY2FsaW5nIGZyb20gb2JqZWN0IGNhbid0IG92ZXJyaWRlIGNlbnRlcmVkU2NhbGluZyBmcm9tIGNhbnZhcy5cbiAgICAgKiB0aGlzIHNob3VsZCBiZSBmaXhlZCwgc2luY2Ugb2JqZWN0IHNldHRpbmcgc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIGNhbnZhcy5cbiAgICAgKiBhbHNvIHRoaXMgc2hvdWxkIGJlIHNvbWV0aGluZyB0aGF0IHdpbGwgYmUgbWlncmF0ZWQgaW4gdGhlIGNvbnRyb2wgcHJvcGVydGllcy5cbiAgICAgKiBhcyBhYmlsaXR5IHRvIGRlZmluZSB0aGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGF0IHRoZSBjb250cm9sIHByb3ZpZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFsdEtleVxuICAgICAqL1xuICAgIF9zaG91bGRDZW50ZXJUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQsIGFjdGlvbiwgYWx0S2V5KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXJUcmFuc2Zvcm07XG5cbiAgICAgIGlmIChhY3Rpb24gPT09ICdzY2FsZScgfHwgYWN0aW9uID09PSAnc2NhbGVYJyB8fCBhY3Rpb24gPT09ICdzY2FsZVknIHx8IGFjdGlvbiA9PT0gJ3Jlc2l6aW5nJykge1xuICAgICAgICBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLmNlbnRlcmVkU2NhbGluZyB8fCB0YXJnZXQuY2VudGVyZWRTY2FsaW5nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAncm90YXRlJykge1xuICAgICAgICBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLmNlbnRlcmVkUm90YXRpb24gfHwgdGFyZ2V0LmNlbnRlcmVkUm90YXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjZW50ZXJUcmFuc2Zvcm0gPyAhYWx0S2V5IDogYWx0S2V5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaG91bGQgZGlzYXBwZWFyIGJlZm9yZSByZWxlYXNlIDQuMFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE9yaWdpbkZyb21Db3JuZXI6IGZ1bmN0aW9uKHRhcmdldCwgY29ybmVyKSB7XG4gICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICB4OiB0YXJnZXQub3JpZ2luWCxcbiAgICAgICAgeTogdGFyZ2V0Lm9yaWdpbllcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICdtbCcgfHwgY29ybmVyID09PSAndGwnIHx8IGNvcm5lciA9PT0gJ2JsJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtcicgfHwgY29ybmVyID09PSAndHInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdtdCcgfHwgY29ybmVyID09PSAndHInKSB7XG4gICAgICAgIG9yaWdpbi55ID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdibCcgfHwgY29ybmVyID09PSAnbWInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICd0b3AnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscmVhZHlTZWxlY3RlZCB0cnVlIGlmIHRhcmdldCBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvcm5lciBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvcm5lciBtbCwgbXIsIHRsIC4uLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbdGFyZ2V0XSBpbnNlcnRlZCBiYWNrIHRvIGhlbHAgb3ZlcnJpZGluZy4gVW51c2VkXG4gICAgICovXG4gICAgX2dldEFjdGlvbkZyb21Db3JuZXI6IGZ1bmN0aW9uKGFscmVhZHlTZWxlY3RlZCwgY29ybmVyLCBlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghY29ybmVyIHx8ICFhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICdkcmFnJztcbiAgICAgIH1cbiAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl07XG4gICAgICByZXR1cm4gY29udHJvbC5nZXRBY3Rpb25OYW1lKGUsIGNvbnRyb2wsIHRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zZXR1cEN1cnJlbnRUcmFuc2Zvcm06IGZ1bmN0aW9uIChlLCB0YXJnZXQsIGFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSwgY29ybmVyID0gdGFyZ2V0Ll9fY29ybmVyLFxuICAgICAgICAgIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXSxcbiAgICAgICAgICBhY3Rpb25IYW5kbGVyID0gKGFscmVhZHlTZWxlY3RlZCAmJiBjb3JuZXIpID9cbiAgICAgICAgICAgIGNvbnRyb2wuZ2V0QWN0aW9uSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpIDogZmFicmljLmNvbnRyb2xzVXRpbHMuZHJhZ0hhbmRsZXIsXG4gICAgICAgICAgYWN0aW9uID0gdGhpcy5fZ2V0QWN0aW9uRnJvbUNvcm5lcihhbHJlYWR5U2VsZWN0ZWQsIGNvcm5lciwgZSwgdGFyZ2V0KSxcbiAgICAgICAgICBvcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5Gcm9tQ29ybmVyKHRhcmdldCwgY29ybmVyKSxcbiAgICAgICAgICBhbHRLZXkgPSBlW3RoaXMuY2VudGVyZWRLZXldLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBhY3Rpb25IYW5kbGVyOiBhY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgICAgIC8vIHVzZWQgYnkgdHJhbnNhdGlvblxuICAgICAgICAgICAgb2Zmc2V0WDogcG9pbnRlci54IC0gdGFyZ2V0LmxlZnQsXG4gICAgICAgICAgICBvZmZzZXRZOiBwb2ludGVyLnkgLSB0YXJnZXQudG9wLFxuICAgICAgICAgICAgb3JpZ2luWDogb3JpZ2luLngsXG4gICAgICAgICAgICBvcmlnaW5ZOiBvcmlnaW4ueSxcbiAgICAgICAgICAgIGV4OiBwb2ludGVyLngsXG4gICAgICAgICAgICBleTogcG9pbnRlci55LFxuICAgICAgICAgICAgbGFzdFg6IHBvaW50ZXIueCxcbiAgICAgICAgICAgIGxhc3RZOiBwb2ludGVyLnksXG4gICAgICAgICAgICAvLyB1bnN1cmUgdGhleSBhcmUgdXNlZnVsIGFueW1vcmUuXG4gICAgICAgICAgICAvLyBsZWZ0OiB0YXJnZXQubGVmdCxcbiAgICAgICAgICAgIC8vIHRvcDogdGFyZ2V0LnRvcCxcbiAgICAgICAgICAgIHRoZXRhOiBkZWdyZWVzVG9SYWRpYW5zKHRhcmdldC5hbmdsZSksXG4gICAgICAgICAgICAvLyBlbmQgb2YgdW5zdXJlXG4gICAgICAgICAgICB3aWR0aDogdGFyZ2V0LndpZHRoICogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgYWx0S2V5OiBhbHRLZXksXG4gICAgICAgICAgICBvcmlnaW5hbDogZmFicmljLnV0aWwuc2F2ZU9iamVjdFRyYW5zZm9ybSh0YXJnZXQpLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9zaG91bGRDZW50ZXJUcmFuc2Zvcm0odGFyZ2V0LCBhY3Rpb24sIGFsdEtleSkpIHtcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5vcmlnaW5hbC5vcmlnaW5YID0gb3JpZ2luLng7XG4gICAgICB0cmFuc2Zvcm0ub3JpZ2luYWwub3JpZ2luWSA9IG9yaWdpbi55O1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuX2JlZm9yZVRyYW5zZm9ybShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJzb3IgdHlwZSBvZiB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgQ3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50LlxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy11aS8jY3Vyc29yXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMudXBwZXJDYW52YXNFbC5zdHlsZS5jdXJzb3IgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRvIGRyYXcgdGhlIHNlbGVjdGlvbiBvblxuICAgICAqL1xuICAgIF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3IsXG4gICAgICAgICAgbGVmdCA9IGdyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB0b3AgPSBncm91cFNlbGVjdG9yLnRvcCxcbiAgICAgICAgICBhbGVmdCA9IGFicyhsZWZ0KSxcbiAgICAgICAgICBhdG9wID0gYWJzKHRvcCk7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkNvbG9yKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuXG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBncm91cFNlbGVjdG9yLmV4IC0gKChsZWZ0ID4gMCkgPyAwIDogLWxlZnQpLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXkgLSAoKHRvcCA+IDApID8gMCA6IC10b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aCB8fCAhdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yO1xuXG4gICAgICAvLyBzZWxlY3Rpb24gYm9yZGVyXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkubGVuZ3RoID4gMSAmJiAhc3VwcG9ydExpbmVEYXNoKSB7XG5cbiAgICAgICAgdmFyIHB4ID0gZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgICBweSA9IGdyb3VwU2VsZWN0b3IuZXkgKyBTVFJPS0VfT0ZGU0VUIC0gKCh0b3AgPiAwKSA/IDAgOiBhdG9wKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4ICsgYWxlZnQsIHB5LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5ICsgYXRvcCAtIDEsIHB4ICsgYWxlZnQsIHB5ICsgYXRvcCAtIDEsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCwgcHksIHB4LCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBweCArIGFsZWZ0IC0gMSwgcHksIHB4ICsgYWxlZnQgLSAxLCBweSArIGF0b3AsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5fc2V0TGluZURhc2guY2FsbCh0aGlzLCBjdHgsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leCArIFNUUk9LRV9PRkZTRVQgLSAoKGxlZnQgPiAwKSA/IDAgOiBhbGVmdCksXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leSArIFNUUk9LRV9PRkZTRVQgLSAoKHRvcCA+IDApID8gMCA6IGF0b3ApLFxuICAgICAgICAgIGFsZWZ0LFxuICAgICAgICAgIGF0b3BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IG9iamVjdCB3ZSBhcmUgY2xpY2tpbmcgb25cbiAgICAgKiB0aGUgc2tpcEdyb3VwIHBhcmFtZXRlciBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBuZWVkZWQgZm9yIHNoaWZ0K2NsaWNrIGFjdGlvblxuICAgICAqIDExLzA5LzIwMTggVE9ETzogd291bGQgYmUgY29vbCBpZiBmaW5kVGFyZ2V0IGNvdWxkIGRpc2Nlcm4gYmV0d2VlbiBiZWluZyBhIGZ1bGwgdGFyZ2V0XG4gICAgICogb3IgdGhlIG91dHNpZGUgcGFydCBvZiB0aGUgY29ybmVyLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBHcm91cCB3aGVuIHRydWUsIGFjdGl2ZUdyb3VwIGlzIHNraXBwZWQgYW5kIG9ubHkgb2JqZWN0cyBhcmUgdHJhdmVyc2VkIHRocm91Z2hcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGUgdGFyZ2V0IGZvdW5kXG4gICAgICovXG4gICAgZmluZFRhcmdldDogZnVuY3Rpb24gKGUsIHNraXBHcm91cCkge1xuICAgICAgaWYgKHRoaXMuc2tpcFRhcmdldEZpbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWdub3JlWm9vbSA9IHRydWUsXG4gICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCBpZ25vcmVab29tKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgYU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhY3RpdmVUYXJnZXQsIGFjdGl2ZVRhcmdldFN1YnMsXG4gICAgICAgICAgaXNUb3VjaCA9IGlzVG91Y2hFdmVudChlKTtcblxuICAgICAgLy8gZmlyc3QgY2hlY2sgY3VycmVudCBncm91cCAoaWYgb25lIGV4aXN0cylcbiAgICAgIC8vIGFjdGl2ZSBncm91cCBkb2VzIG5vdCBjaGVjayBzdWIgdGFyZ2V0cyBsaWtlIG5vcm1hbCBncm91cHMuXG4gICAgICAvLyBpZiBhY3RpdmUgZ3JvdXAganVzdCBleGl0cy5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID4gMSAmJiAhc2tpcEdyb3VwICYmIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgaGl0IHRoZSBjb3JuZXIgb2YgYW4gYWN0aXZlT2JqZWN0LCBsZXQncyByZXR1cm4gdGhhdC5cbiAgICAgIGlmIChhT2JqZWN0cy5sZW5ndGggPT09IDEgJiYgYWN0aXZlT2JqZWN0Ll9maW5kVGFyZ2V0Q29ybmVyKHBvaW50ZXIsIGlzVG91Y2gpKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVPYmplY3RTdGFja2luZykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0ID0gYWN0aXZlT2JqZWN0O1xuICAgICAgICAgIGFjdGl2ZVRhcmdldFN1YnMgPSB0aGlzLnRhcmdldHM7XG4gICAgICAgICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGhpcy5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICBpZiAoZVt0aGlzLmFsdFNlbGVjdGlvbktleV0gJiYgdGFyZ2V0ICYmIGFjdGl2ZVRhcmdldCAmJiB0YXJnZXQgIT09IGFjdGl2ZVRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSBhY3RpdmVUYXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IGFjdGl2ZVRhcmdldFN1YnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRvIHRlc3QgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZ2xvYmFsUG9pbnRlcl0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjYW52YXMgdXNlZCB0byBzZWFyY2ggcGVyIHBpeGVsIHRhcmdldC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gYXJlYSBvZiBnaXZlbiBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1RhcmdldDogZnVuY3Rpb24ocG9pbnRlciwgb2JqLCBnbG9iYWxQb2ludGVyKSB7XG4gICAgICBpZiAob2JqICYmXG4gICAgICAgICAgb2JqLnZpc2libGUgJiZcbiAgICAgICAgICBvYmouZXZlbnRlZCAmJlxuICAgICAgICAgIC8vIGh0dHA6Ly93d3cuZ2VvZy51YmMuY2EvY291cnNlcy9rbGluay9naXMubm90ZXMvbmNnaWEvdTMyLmh0bWxcbiAgICAgICAgICAvLyBodHRwOi8vaWRhdi51Y2RhdmlzLmVkdS9+b2tyZXlsb3MvVEFzaGlwL1NwcmluZzIwMDAvUG9pbnRJblBvbHlnb24uaHRtbFxuICAgICAgICAgIChvYmouY29udGFpbnNQb2ludChwb2ludGVyKSB8fCAhIW9iai5fZmluZFRhcmdldENvcm5lcihwb2ludGVyKSlcbiAgICAgICkge1xuICAgICAgICBpZiAoKHRoaXMucGVyUGl4ZWxUYXJnZXRGaW5kIHx8IG9iai5wZXJQaXhlbFRhcmdldEZpbmQpICYmICFvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSB0aGlzLmlzVGFyZ2V0VHJhbnNwYXJlbnQob2JqLCBnbG9iYWxQb2ludGVyLngsIGdsb2JhbFBvaW50ZXIueSk7XG4gICAgICAgICAgaWYgKCFpc1RyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBzZWFyY2ggaW5zaWRlIG9iamVjdHMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlciBpbiBib3VuZGluZyBib3ggb3IgdGhhdCBjb250YWlucyBwb2ludGVyT25DYW52YXMgd2hlbiBwYWludGVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29iamVjdHNdIG9iamVjdHMgYXJyYXkgdG8gbG9vayBpbnRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlYXJjaFBvc3NpYmxlVGFyZ2V0czogZnVuY3Rpb24ob2JqZWN0cywgcG9pbnRlcikge1xuICAgICAgLy8gQ2FjaGUgYWxsIHRhcmdldHMgd2hlcmUgdGhlaXIgYm91bmRpbmcgYm94IGNvbnRhaW5zIHBvaW50LlxuICAgICAgdmFyIHRhcmdldCwgaSA9IG9iamVjdHMubGVuZ3RoLCBzdWJUYXJnZXQ7XG4gICAgICAvLyBEbyBub3QgY2hlY2sgZm9yIGN1cnJlbnRseSBncm91cGVkIG9iamVjdHMsIHNpbmNlIHdlIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXAgaXRzZWxmLlxuICAgICAgLy8gdW50aWwgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHNwZWNpZmljYWxseSB0byBzZWFyY2ggaW5zaWRlIHRoZSBhY3RpdmVHcm91cFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgb2JqVG9DaGVjayA9IG9iamVjdHNbaV07XG4gICAgICAgIHZhciBwb2ludGVyVG9Vc2UgPSBvYmpUb0NoZWNrLmdyb3VwID9cbiAgICAgICAgICB0aGlzLl9ub3JtYWxpemVQb2ludGVyKG9ialRvQ2hlY2suZ3JvdXAsIHBvaW50ZXIpIDogcG9pbnRlcjtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVGFyZ2V0KHBvaW50ZXJUb1VzZSwgb2JqVG9DaGVjaywgcG9pbnRlcikpIHtcbiAgICAgICAgICB0YXJnZXQgPSBvYmplY3RzW2ldO1xuICAgICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2sgJiYgdGFyZ2V0IGluc3RhbmNlb2YgZmFicmljLkdyb3VwKSB7XG4gICAgICAgICAgICBzdWJUYXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGFyZ2V0Ll9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCAmJiB0aGlzLnRhcmdldHMucHVzaChzdWJUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgdGhlIGVmZmVjdCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIHJlc3RvcmVQb2ludGVyVnB0OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcy5cbiAgICAgKiBDYW4gcmV0dXJuIGNvb3JkaW5hdGVzIHdpdGggb3Igd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBpZ25vcmVab29tIGZhbHNlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgdGhhdCByZXByZXNlbnRcbiAgICAgKiB0aGUgcG9pbnQgY2xpY2tlZCBvbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgZ2l2ZXMgYmFjayBjb29yZGluYXRlcyBhZnRlciBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBieSB0aGUgdmlld3BvcnRUcmFuc2Zvcm0gKCBzb3J0IG9mIGNvb3JkaW5hdGVzIG9mIHdoYXQgaXMgZGlzcGxheWVkXG4gICAgICogb24gdGhlIGNhbnZhcyB3aGVyZSB5b3UgYXJlIGNsaWNraW5nLlxuICAgICAqIGlnbm9yZVpvb20gdHJ1ZSA9IEhUTUxFbGVtZW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRvcCxsZWZ0XG4gICAgICogaWdub3JlWm9vbSBmYWxzZSwgZGVmYXVsdCA9IGZhYnJpYyBzcGFjZSBjb29yZGluYXRlcywgdGhlIHNhbWUgdXNlZCBmb3Igc2hhcGUgcG9zaXRpb25cbiAgICAgKiBUbyBpbnRlcmFjdCB3aXRoIHlvdXIgc2hhcGVzIHRvcCBhbmQgbGVmdCB5b3Ugd2FudCB0byB1c2UgaWdub3JlWm9vbSB0cnVlXG4gICAgICogbW9zdCBvZiB0aGUgdGltZSwgd2hpbGUgaWdub3JlWm9vbSBmYWxzZSB3aWxsIGdpdmUgeW91IGNvb3JkaW5hdGVzXG4gICAgICogY29tcGF0aWJsZSB3aXRoIHRoZSBvYmplY3Qub0Nvb3JkcyBzeXN0ZW0uXG4gICAgICogb2YgdGhlIHRpbWUuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlWm9vbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiAoZSwgaWdub3JlWm9vbSkge1xuICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZXMgaWYgd2UgYXJlIGluIHRoZSBldmVudCBwcm9jZXNzaW5nIGNoYWluXG4gICAgICBpZiAodGhpcy5fYWJzb2x1dGVQb2ludGVyICYmICFpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9pbnRlciAmJiBpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBib3VuZHMgPSB1cHBlckNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kc1dpZHRoID0gYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzLmhlaWdodCB8fCAwLFxuICAgICAgICAgIGNzc1NjYWxlO1xuXG4gICAgICBpZiAoIWJvdW5kc1dpZHRoIHx8ICFib3VuZHNIZWlnaHQgKSB7XG4gICAgICAgIGlmICgndG9wJyBpbiBib3VuZHMgJiYgJ2JvdHRvbScgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gTWF0aC5hYnMoIGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyaWdodCcgaW4gYm91bmRzICYmICdsZWZ0JyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IE1hdGguYWJzKCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgICAgcG9pbnRlci54ID0gcG9pbnRlci54IC0gdGhpcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwb2ludGVyLnkgPSBwb2ludGVyLnkgLSB0aGlzLl9vZmZzZXQudG9wO1xuICAgICAgaWYgKCFpZ25vcmVab29tKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0aW5hU2NhbGluZyA9IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpO1xuICAgICAgaWYgKHJldGluYVNjYWxpbmcgIT09IDEpIHtcbiAgICAgICAgcG9pbnRlci54IC89IHJldGluYVNjYWxpbmc7XG4gICAgICAgIHBvaW50ZXIueSAvPSByZXRpbmFTY2FsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRzV2lkdGggPT09IDAgfHwgYm91bmRzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSAoaS5lLiBub3QgdmlzaWJsZSksIGRvIG5vdCBhcHBseSBzY2FsZS5cbiAgICAgICAgY3NzU2NhbGUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjc3NTY2FsZSA9IHtcbiAgICAgICAgICB3aWR0aDogdXBwZXJDYW52YXNFbC53aWR0aCAvIGJvdW5kc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJDYW52YXNFbC5oZWlnaHQgLyBib3VuZHNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRlci54ICogY3NzU2NhbGUud2lkdGgsXG4gICAgICAgIHk6IHBvaW50ZXIueSAqIGNzc1NjYWxlLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtDQU5WQVNfSU5JVF9FUlJPUn0gSWYgY2FudmFzIGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVXBwZXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0NsYXNzID0gdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqbG93ZXItY2FudmFzXFxzKi8sICcnKSxcbiAgICAgICAgICBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsID0gdGhpcy51cHBlckNhbnZhc0VsO1xuXG4gICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB1cHBlckNhbnZhcyBlbGVtZW50IGlmIHdlIGhhdmUgYWxyZWFkeSBvbmUuXG4gICAgICBpZiAodXBwZXJDYW52YXNFbCkge1xuICAgICAgICB1cHBlckNhbnZhc0VsLmNsYXNzTmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbCA9IHVwcGVyQ2FudmFzRWw7XG4gICAgICB9XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh1cHBlckNhbnZhc0VsLCAndXBwZXItY2FudmFzICcgKyBsb3dlckNhbnZhc0NsYXNzKTtcblxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodXBwZXJDYW52YXNFbCk7XG5cbiAgICAgIHRoaXMuX2NvcHlDYW52YXNTdHlsZShsb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSB1cHBlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jb250ZXh0Q2FjaGUgPSB0aGlzLmNhY2hlQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLndyYXBwZXJFbCA9IGZhYnJpYy51dGlsLndyYXBFbGVtZW50KHRoaXMubG93ZXJDYW52YXNFbCwgJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogdGhpcy5jb250YWluZXJDbGFzc1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZSh0aGlzLndyYXBwZXJFbCwge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgKyAncHgnLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSh0aGlzLndyYXBwZXJFbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBjYW52YXMgZWxlbWVudCB0byBhcHBseSBzdHlsZXMgb25cbiAgICAgKi9cbiAgICBfYXBwbHlDYW52YXNTdHlsZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcblxuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgICd0b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJyxcbiAgICAgICAgJy1tcy10b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICBlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoZSBlbnRpcmUgaW5saW5lIHN0eWxlIGZyb20gb25lIGVsZW1lbnQgKGZyb21FbCkgdG8gYW5vdGhlciAodG9FbClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbUVsIEVsZW1lbnQgc3R5bGUgaXMgY29waWVkIGZyb21cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRvRWwgRWxlbWVudCBjb3BpZWQgc3R5bGUgaXMgYXBwbGllZCB0b1xuICAgICAqL1xuICAgIF9jb3B5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHRvRWwuc3R5bGUuY3NzVGV4dCA9IGZyb21FbC5zdHlsZS5jc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0VG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgb24gd2hpY2ggb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGN1cnJlbnQgc2VsZWN0ZWQgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGFjdGl2ZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVPYmplY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWN0aXZlID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBpZiAoYWN0aXZlLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIGFjdGl2ZS5fb2JqZWN0cykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmUuX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFthY3RpdmVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIHJlbW92aW5nIGFjdGl2ZSBvYmplY3Qgc2hvdWxkIGZpcmUgXCJzZWxlY3Rpb246Y2xlYXJlZFwiIGV2ZW50c1xuICAgICAgaWYgKG9iaiA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgb2JqLmZpcmUoJ2Rlc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2hvdmVyZWRUYXJnZXQpe1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfb25PYmplY3RSZW1vdmVkJywgb2JqKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDb21wYXJlcyB0aGUgb2xkIGFjdGl2ZU9iamVjdCB3aXRoIHRoZSBjdXJyZW50IG9uZSBhbmQgZmlyZXMgY29ycmVjdCBldmVudHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBvbGQgYWN0aXZlT2JqZWN0XG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25FdmVudHM6IGZ1bmN0aW9uKG9sZE9iamVjdHMsIGUpIHtcbiAgICAgIHZhciBzb21ldGhpbmdDaGFuZ2VkID0gZmFsc2UsIG9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhZGRlZCA9IFtdLCByZW1vdmVkID0gW10sIG9wdCA9IHsgZTogZSB9O1xuICAgICAgb2xkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9sZE9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0cy5pbmRleE9mKG9sZE9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgb2xkT2JqZWN0LmZpcmUoJ2Rlc2VsZWN0ZWQnLCBvcHQpO1xuICAgICAgICAgIHJlbW92ZWQucHVzaChvbGRPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9sZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuICAgICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIG9iamVjdC5maXJlKCdzZWxlY3RlZCcsIG9wdCk7XG4gICAgICAgICAgYWRkZWQucHVzaChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDAgJiYgb2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdC5zZWxlY3RlZCA9IGFkZGVkO1xuICAgICAgICBvcHQuZGVzZWxlY3RlZCA9IHJlbW92ZWQ7XG4gICAgICAgIC8vIGFkZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIG9wdC51cGRhdGVkID0gYWRkZWRbMF0gfHwgcmVtb3ZlZFswXTtcbiAgICAgICAgb3B0LnRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCAmJiB0aGlzLmZpcmUoJ3NlbGVjdGlvbjp1cGRhdGVkJywgb3B0KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBvcHQuc2VsZWN0ZWQgPSBhZGRlZDtcbiAgICAgICAgLy8gYWRkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgb3B0LnRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIG9wdCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0LmRlc2VsZWN0ZWQgPSByZW1vdmVkO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgb3B0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBnaXZlbiBvYmplY3QgYXMgdGhlIG9ubHkgYWN0aXZlIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2V0IGFzIGFuIGFjdGl2ZSBvbmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0LCBlKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZXMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKTtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChvYmplY3QsIGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNldCBhcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNlbGVjdGlvbiBoYXBwZW5lZFxuICAgICAqL1xuICAgIF9zZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgZSkge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlLCBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qub25TZWxlY3QoeyBlOiBlIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG9iamVjdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbihlLCBvYmplY3QpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIC8vIG9uRGVzZWxlY3QgcmV0dXJuIFRSVUUgdG8gY2FuY2VsIHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG9iai5vbkRlc2VsZWN0KHsgZTogZSwgb2JqZWN0OiBvYmplY3QgfSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkcyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdCBhbmQgZmlyZSBldmVudHMuIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgZmFicmljXG4gICAgICogYXMgYSBjb25zZXF1ZW5jZSBvZiBhIG1vdXNlIGV2ZW50LCB0aGUgZXZlbnQgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGFuZFxuICAgICAqIHNlbnQgdG8gdGhlIGZpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXN0b20gZXZlbnRzLiBXaGVuIHVzZWQgYXMgYSBtZXRob2QgdGhlXG4gICAgICogZSBwYXJhbSBkb2VzIG5vdCBoYXZlIGFueSBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIGFjdGl2ZU9iamVjdCA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCk7XG4gICAgICBpZiAoY3VycmVudEFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IGFjdGl2ZU9iamVjdCwgZTogZSB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSBjYW52YXMgZWxlbWVudCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlckVsO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IG51bGw7XG4gICAgICBbJ3VwcGVyQ2FudmFzRWwnLCAnY2FjaGVDYW52YXNFbCddLmZvckVhY2goKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSh0aGlzW2VsZW1lbnRdKTtcbiAgICAgICAgdGhpc1tlbGVtZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgICAgaWYgKHdyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy53cmFwcGVyRWwpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMud3JhcHBlckVsO1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzLmRpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdjbGVhcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBvYmplY3RzJyBjb250cm9scyAoYm9yZGVycy9jb250cm9scylcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIGNvbnRyb2xzIG9uXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0Ll9yZW5kZXJDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBncm91cCwgaXQgc2hvdWxkXG4gICAgICAvL2JlIHRyYW5zZm9ybWVkIGFwcHJvcHJpYXRlbHlcbiAgICAgIC8vaS5lLiBpdCBzaG91bGQgYmUgc2VyaWFsaXNlZCBhcyBpdCB3b3VsZCBhcHBlYXIgaWYgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAgLy93ZXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSksXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5jYWxsU3VwZXIoJ190b09iamVjdCcsIGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIC8vVW5kbyB0aGUgZGFtYWdlIHdlIGRpZCBieSBjaGFuZ2luZyBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyBhbiBvYmplY3QncyBncm91cCB0cmFuc2Zvcm1hdGlvbiBvbiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSB3aGljaCB3ZXJlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZ3JvdXAgJiYgaW5zdGFuY2UuZ3JvdXAudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgJiYgdGhpcy5fYWN0aXZlT2JqZWN0ID09PSBpbnN0YW5jZS5ncm91cCkge1xuICAgICAgICB2YXIgbGF5b3V0UHJvcHMgPSBbJ2FuZ2xlJywgJ2ZsaXBYJywgJ2ZsaXBZJywgJ2xlZnQnLCAnc2NhbGVYJywgJ3NjYWxlWScsICdza2V3WCcsICdza2V3WScsICd0b3AnXTtcbiAgICAgICAgLy9Db3B5IGFsbCB0aGUgcG9zaXRpb25hbGx5IHJlbGV2YW50IHByb3BlcnRpZXMgYWNyb3NzIG5vd1xuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZXMgPSB7fTtcbiAgICAgICAgbGF5b3V0UHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZXNbcHJvcF0gPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5yZWFsaXplVHJhbnNmb3JtKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWVzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgY2hhbmdlZCBwcm9wZXJ0aWVzIG9mIGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IFtpbnN0YW5jZV0gdGhlIG9iamVjdCB0byB1bi10cmFuc2Zvcm0gKGdldHMgbXV0YXRlZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29yaWdpbmFsVmFsdWVzXSB0aGUgb3JpZ2luYWwgdmFsdWVzIG9mIGluc3RhbmNlLCBhcyByZXR1cm5lZCBieSBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3RcbiAgICAgKi9cbiAgICBfdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICBpZiAob3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0KG9yaWdpbmFsVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0OiBmdW5jdGlvbihtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgaW4gYSBzZWxlY3Rpb24gZ3JvdXAsIHNpbXVsYXRlIHdoYXQgd291bGQgaGFwcGVuIHRvIHRoYXRcbiAgICAgIC8vb2JqZWN0IHdoZW4gdGhlIGdyb3VwIGlzIGRlc2VsZWN0ZWRcbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldFNWR09iamVjdCcsIG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpO1xuICAgICAgdGhpcy5fdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSwgb3JpZ2luYWxQcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNldFZpZXdwb3J0VHJhbnNmb3JtLmNhbGwodGhpcywgdnB0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvcHlpbmcgc3RhdGljIHByb3BlcnRpZXMgbWFudWFsbHkgdG8gd29yayBhcm91bmQgT3BlcmEncyBidWcsXG4gIC8vIHdoZXJlIFwicHJvdG90eXBlXCIgcHJvcGVydHkgaXMgZW51bWVyYWJsZSBhbmQgb3ZlcnJpZGVzIGV4aXN0aW5nIHByb3RvdHlwZVxuICBmb3IgKHZhciBwcm9wIGluIGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIGZhYnJpYy5DYW52YXNbcHJvcF0gPSBmYWJyaWMuU3RhdGljQ2FudmFzW3Byb3BdO1xuICAgIH1cbiAgfVxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGFkZExpc3RlbmVyID0gZmFicmljLnV0aWwuYWRkTGlzdGVuZXIsXG4gICAgICByZW1vdmVMaXN0ZW5lciA9IGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyLFxuICAgICAgUklHSFRfQ0xJQ0sgPSAzLCBNSURETEVfQ0xJQ0sgPSAyLCBMRUZUX0NMSUNLID0gMSxcbiAgICAgIGFkZEV2ZW50T3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGUuYnV0dG9uICYmIChlLmJ1dHRvbiA9PT0gdmFsdWUgLSAxKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgdGhlIGlkIG9mIHRoZSB0b3VjaCBldmVudCB0aGF0IG93bnMgdGhlIGZhYnJpYyB0cmFuc2Zvcm1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1haW5Ub3VjaElkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtb3VzZSBsaXN0ZW5lcnMgdG8gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpbiBjYXNlIHdlIGluaXRpYWxpemVkIHRoZSBjbGFzcyB0d2ljZS4gVGhpcyBzaG91bGQgbm90IGhhcHBlbiBub3JtYWxseVxuICAgICAgLy8gYnV0IGluIHNvbWUga2luZCBvZiBhcHBsaWNhdGlvbnMgd2hlcmUgdGhlIGNhbnZhcyBlbGVtZW50IG1heSBiZSBjaGFuZ2VkXG4gICAgICAvLyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB0byBoYXZpbmcgZG91YmxlIGxpc3RlbmVycy5cbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKGFkZExpc3RlbmVyLCAnYWRkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhbiBldmVudCBwcmVmaXggcG9pbnRlciBvciBtb3VzZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRFdmVudFByZWZpeDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyJyA6ICdtb3VzZSc7XG4gICAgfSxcblxuICAgIGFkZE9yUmVtb3ZlOiBmdW5jdGlvbihmdW5jdG9yLCBldmVudGpzRnVuY3Rvcikge1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIGZ1bmN0b3IoZmFicmljLndpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ2Rvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdvdXQnLCB0aGlzLl9vbk1vdXNlT3V0KTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ2VudGVyJywgdGhpcy5fb25Nb3VzZUVudGVyKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ3doZWVsJywgdGhpcy5fb25Nb3VzZVdoZWVsKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2spO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9vbkRyYWdPdmVyKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdlbnRlcicsIHRoaXMuX29uRHJhZ0VudGVyKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdsZWF2ZScsIHRoaXMuX29uRHJhZ0xlYXZlKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2Ryb3AnLCB0aGlzLl9vbkRyb3ApO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZXZlbnRqcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZlbnRqc0Z1bmN0b3IgaW4gZXZlbnRqcykge1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnZ2VzdHVyZScsIHRoaXMuX29uR2VzdHVyZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ29yaWVudGF0aW9uJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdzaGFrZScsIHRoaXMuX29uU2hha2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnbG9uZ3ByZXNzJywgdGhpcy5fb25Mb25nUHJlc3MpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRPclJlbW92ZShyZW1vdmVMaXN0ZW5lciwgJ3JlbW92ZScpO1xuICAgICAgLy8gaWYgeW91IGRpc3Bvc2Ugb24gYSBtb3VzZURvd24sIGJlZm9yZSBtb3VzZSB1cCwgeW91IG5lZWQgdG8gY2xlYW4gZG9jdW1lbnQgdG8uLi5cbiAgICAgIHZhciBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRzQm91bmQpIHtcbiAgICAgICAgLy8gZm9yIGFueSByZWFzb24gd2UgcGFzcyBoZXJlIHR3aWNlIHdlIGRvIG5vdCB3YW50IHRvIGJpbmQgZXZlbnRzIHR3aWNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblRvdWNoU3RhcnQgPSB0aGlzLl9vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VVcCA9IHRoaXMuX29uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Ub3VjaEVuZCA9IHRoaXMuX29uVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR2VzdHVyZSA9IHRoaXMuX29uR2VzdHVyZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblNoYWtlID0gdGhpcy5fb25TaGFrZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Mb25nUHJlc3MgPSB0aGlzLl9vbkxvbmdQcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VXaGVlbCA9IHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU91dCA9IHRoaXMuX29uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VFbnRlciA9IHRoaXMuX29uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Db250ZXh0TWVudSA9IHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRG91YmxlQ2xpY2sgPSB0aGlzLl9vbkRvdWJsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRyYWdPdmVyID0gdGhpcy5fb25EcmFnT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnRW50ZXIgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2VudGVyJyk7XG4gICAgICB0aGlzLl9vbkRyYWdMZWF2ZSA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcmFnbGVhdmUnKTtcbiAgICAgIHRoaXMuX29uRHJvcCA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcm9wJyk7XG4gICAgICB0aGlzLmV2ZW50c0JvdW5kID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uR2VzdHVyZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZSAmJiB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZHJhZ1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25EcmFnOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25EcmFnICYmIHRoaXMuX19vbkRyYWcoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiB3aGVlbCBldmVudFxuICAgICAqL1xuICAgIF9vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlV2hlZWwoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VPdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0O1xuICAgICAgdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMuZm9yRWFjaChmdW5jdGlvbihfdGFyZ2V0KXtcbiAgICAgICAgX3RoaXMuZmlyZSgnbW91c2U6b3V0JywgeyB0YXJnZXQ6IHRhcmdldCwgZTogZSB9KTtcbiAgICAgICAgX3RhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2VvdXQnLCB7IGU6IGUgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIGlmIChvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBvYmouaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZW50ZXJcbiAgICAgKi9cbiAgICBfb25Nb3VzZUVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBUaGlzIGZpbmQgdGFyZ2V0IGFuZCBjb25zZXF1ZW50ICdtb3VzZTpvdmVyJyBpcyB1c2VkIHRvXG4gICAgICAvLyBjbGVhciBvbGQgaW5zdGFuY2VzIG9uIGhvdmVyZWQgdGFyZ2V0LlxuICAgICAgLy8gY2FsbGluZyBmaW5kVGFyZ2V0IGhhcyB0aGUgc2lkZSBlZmZlY3Qgb2Yga2lsbGluZyB0YXJnZXQuX19jb3JuZXIuXG4gICAgICAvLyBhcyBhIHNob3J0IHRlcm0gZml4IHdlIGFyZSBub3QgZmlyaW5nIHRoaXMgaWYgd2UgYXJlIGN1cnJlbnRseSB0cmFuc2Zvcm1pbmcuXG4gICAgICAvLyBhcyBhIGxvbmcgdGVybSBmaXggd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgYWN0aW9uIG9mIGZpbmRpbmcgYSB0YXJnZXQgd2l0aCB0aGVcbiAgICAgIC8vIHNpZGUgZWZmZWN0cyB3ZSBhZGRlZCB0byBpdC5cbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRyYW5zZm9ybSAmJiAhdGhpcy5maW5kVGFyZ2V0KGUpKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3ZlcicsIHsgdGFyZ2V0OiBudWxsLCBlOiBlIH0pO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIG9yaWVudGF0aW9uIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UgJiYgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25TaGFrZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uU2hha2UgJiYgdGhpcy5fX29uU2hha2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25Mb25nUHJlc3M6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkxvbmdQcmVzcyAmJiB0aGlzLl9fb25Mb25nUHJlc3MoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByZXZlbnQgZGVmYXVsdCB0byBhbGxvdyBkcm9wIGV2ZW50IHRvIGJlIGZpcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICovXG4gICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2RyYWdvdmVyJywgZSk7XG4gICAgICB0aGlzLl9maXJlRW50ZXJMZWF2ZUV2ZW50cyh0YXJnZXQsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuc3RvcENvbnRleHRNZW51KSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2RibGNsaWNrJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdGhlIGlkIG9mIGFuIGV2ZW50LlxuICAgICAqIHJldHVybnMgZWl0aGVyIHRoZSBwb2ludGVySWQgb3IgdGhlIGlkZW50aWZpZXIgb3IgMCBmb3IgdGhlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldnQgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0UG9pbnRlcklkOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IGV2dC5jaGFuZ2VkVG91Y2hlcztcblxuICAgICAgaWYgKGNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkVG91Y2hlc1swXSAmJiBjaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lbmFibGVQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBldnQucG9pbnRlcklkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYW4gZXZlbnQgaGFzIHRoZSBpZCBvZiB0aGUgZXZlbnQgdGhhdCBpcyBjb25zaWRlcmVkIG1haW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZXZ0fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfaXNNYWluRXZlbnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKGV2dC5pc1ByaW1hcnkgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LmlzUHJpbWFyeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC50eXBlID09PSAndG91Y2hlbmQnICYmIGV2dC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGV2dC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyID09PSB0aGlzLm1haW5Ub3VjaElkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uVG91Y2hTdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMubWFpblRvdWNoSWQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5tYWluVG91Y2hJZCA9IHRoaXMuZ2V0UG9pbnRlcklkKGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX29uTW91c2VEb3duKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIC8vIFVuYmluZCBtb3VzZWRvd24gdG8gcHJldmVudCBkb3VibGUgdHJpZ2dlcnMgZnJvbSB0b3VjaCBkZXZpY2VzXG4gICAgICByZW1vdmVMaXN0ZW5lcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICd1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBzdG9wIGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fX29uTW91c2VVcChlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB0aGlzLm1haW5Ub3VjaElkID0gbnVsbDtcbiAgICAgIHZhciBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX3dpbGxBZGRNb3VzZURvd24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3dpbGxBZGRNb3VzZURvd24pO1xuICAgICAgfVxuICAgICAgdGhpcy5fd2lsbEFkZE1vdXNlRG93biA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdhaXQgNDAwbXMgYmVmb3JlIHJlYmluZGluZyBtb3VzZWRvd24gdG8gcHJldmVudCBkb3VibGUgdHJpZ2dlcnNcbiAgICAgICAgLy8gZnJvbSB0b3VjaCBkZXZpY2VzXG4gICAgICAgIGFkZExpc3RlbmVyKF90aGlzLnVwcGVyQ2FudmFzRWwsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgX3RoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgX3RoaXMuX3dpbGxBZGRNb3VzZURvd24gPSAwO1xuICAgICAgfSwgNDAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlVXAoZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIGlmICh0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICd1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgICAgYWRkTGlzdGVuZXIoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIGluIG1vdXNldXAgYW5kIG1vdXNlZG93biBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZFJlbmRlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICBpZiAoXG4gICAgICAgICEhYWN0aXZlT2JqZWN0ICE9PSAhIXRhcmdldCB8fFxuICAgICAgICAoYWN0aXZlT2JqZWN0ICYmIHRhcmdldCAmJiAoYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIHRoaXMgY292ZXJzOiBzd2l0Y2ggb2YgdGFyZ2V0LCBmcm9tIHRhcmdldCB0byBubyB0YXJnZXQsIHNlbGVjdGlvbiBvZiB0YXJnZXRcbiAgICAgICAgLy8gbXVsdGlTZWxlY3Rpb24gd2l0aCBrZXkgYW5kIG1vdXNlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aXZlT2JqZWN0ICYmIGFjdGl2ZU9iamVjdC5pc0VkaXRpbmcpIHtcbiAgICAgICAgLy8gaWYgd2UgbW91c2UgdXAvZG93biBvdmVyIGEgZWRpdGluZyB0ZXh0Ym94IGEgY3Vyc29yIGNoYW5nZSxcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byByZSByZW5kZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgcmVsZWFzZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMsIHN0b3JlIHRoZSBpbWFnZSBjb3JuZXJcbiAgICAgKiBwb3NpdGlvbiBpbiB0aGUgaW1hZ2Ugb2JqZWN0IGFuZCByZW5kZXIgdGhlIGNhbnZhcyBvbiB0b3AuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdGFyZ2V0LCB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLCBzaG91bGRSZW5kZXIgPSBmYWxzZSxcbiAgICAgICAgICBpc0NsaWNrID0gKCFncm91cFNlbGVjdG9yIHx8IChncm91cFNlbGVjdG9yLmxlZnQgPT09IDAgJiYgZ3JvdXBTZWxlY3Rvci50b3AgPT09IDApKTtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwOmJlZm9yZScpO1xuICAgICAgLy8gaWYgcmlnaHQvbWlkZGxlIGNsaWNrIGp1c3QgZmlyZSBldmVudHMgYW5kIHJldHVyblxuICAgICAgLy8gdGFyZ2V0IHVuZGVmaW5lZCB3aWxsIG1ha2UgdGhlIF9oYW5kbGVFdmVudCBzZWFyY2ggdGhlIHRhcmdldFxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgUklHSFRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBNSURETEVfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZVVwSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVDdXJyZW50VHJhbnNmb3JtKGUpO1xuICAgICAgICBzaG91bGRSZW5kZXIgPSB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0NsaWNrKSB7XG4gICAgICAgIHZhciB0YXJnZXRXYXNBY3RpdmUgPSB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgdGhpcy5fbWF5YmVHcm91cE9iamVjdHMoZSk7XG4gICAgICAgIGlmICghc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVyID0gKFxuICAgICAgICAgICAgdGhpcy5fc2hvdWxkUmVuZGVyKHRhcmdldCkgfHxcbiAgICAgICAgICAgICghdGFyZ2V0V2FzQWN0aXZlICYmIHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lcihcbiAgICAgICAgICB0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSksXG4gICAgICAgICAgZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50KGUpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgICBtb3VzZVVwSGFuZGxlciA9IGNvbnRyb2wgJiYgY29udHJvbC5nZXRNb3VzZVVwSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpO1xuICAgICAgICBpZiAobW91c2VVcEhhbmRsZXIpIHtcbiAgICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgICAgICBtb3VzZVVwSGFuZGxlcihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEN1cnNvckZyb21FdmVudChlLCB0YXJnZXQpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgTEVGVF9DTElDSywgaXNDbGljayk7XG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgLy8gcmVzZXQgdGhlIHRhcmdldCBpbmZvcm1hdGlvbiBhYm91dCB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgIHRhcmdldCAmJiAodGFyZ2V0Ll9fY29ybmVyID0gMCk7XG4gICAgICBpZiAoc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzQ2xpY2spIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUb3AoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBIYW5kbGUgZXZlbnQgZmlyaW5nIGZvciB0YXJnZXQgYW5kIHN1YnRhcmdldHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICogQHJldHVybiB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHJldHVybiB0aGUgdGhlIHRhcmdldCBmb3VuZCwgZm9yIGludGVybmFsIHJlYXNvbnMuXG4gICAgICovXG4gICAgX3NpbXBsZUV2ZW50SGFuZGxlcjogZnVuY3Rpb24oZXZlbnRUeXBlLCBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpLFxuICAgICAgICAgIHRhcmdldHMgPSB0aGlzLnRhcmdldHMsXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIHN1YlRhcmdldHM6IHRhcmdldHMsXG4gICAgICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICBpZiAoIXRhcmdldHMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXRzW2ldLmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSGFuZGxlIGV2ZW50IGZpcmluZyBmb3IgdGFyZ2V0IGFuZCBzdWJ0YXJnZXRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0T2JqIHJlY2VpdmluZyBldmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYnV0dG9uXSBidXR0b24gdXNlZCBpbiB0aGUgZXZlbnQgMSA9IGxlZnQsIDIgPSBtaWRkbGUsIDMgPSByaWdodFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbGljayBmb3IgbGVmdCBidXR0b24gb25seSwgaW5kaWNhdGVzIHRoYXQgdGhlIG1vdXNlIHVwIGhhcHBlbmVkIHdpdGhvdXQgbW92ZS5cbiAgICAgKi9cbiAgICBfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUsIGV2ZW50VHlwZSwgYnV0dG9uLCBpc0NsaWNrKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0LFxuICAgICAgICAgIHRhcmdldHMgPSB0aGlzLnRhcmdldHMgfHwgW10sXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIHN1YlRhcmdldHM6IHRhcmdldHMsXG4gICAgICAgICAgICBidXR0b246IGJ1dHRvbiB8fCBMRUZUX0NMSUNLLFxuICAgICAgICAgICAgaXNDbGljazogaXNDbGljayB8fCBmYWxzZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHRoaXMuX3BvaW50ZXIsXG4gICAgICAgICAgICBhYnNvbHV0ZVBvaW50ZXI6IHRoaXMuX2Fic29sdXRlUG9pbnRlcixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fY3VycmVudFRyYW5zZm9ybVxuICAgICAgICAgIH07XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSAndXAnKSB7XG4gICAgICAgIG9wdGlvbnMuY3VycmVudFRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKTtcbiAgICAgICAgb3B0aW9ucy5jdXJyZW50U3ViVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6JyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgc2VuZCB0aGUgbW91c2UgZXZlbnQgdGhhdCBnZW5lcmF0ZSB0aGUgZmluYWxpemUgZG93biwgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlIGV2ZW50XG4gICAgICovXG4gICAgX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICBhY3Rpb246IHRyYW5zZm9ybS5hY3Rpb24sXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldC5fc2NhbGluZykge1xuICAgICAgICB0YXJnZXQuX3NjYWxpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnNldENvb3JkcygpO1xuXG4gICAgICBpZiAodHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCB8fCAodGhpcy5zdGF0ZWZ1bCAmJiB0YXJnZXQuaGFzU3RhdGVDaGFuZ2VkKCkpKSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBub3QgZnJpZW5kbHkgdG8gdGhlIG5ldyBjb250cm9sIGFwaS5cbiAgICAgICAgICAvLyBpcyBkZXByZWNhdGVkLlxuICAgICAgICAgIGV2ZW50TmFtZSA9IHRoaXMuX2FkZEV2ZW50T3B0aW9ucyhvcHRpb25zLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIHRoaXMuX2ZpcmUoZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlKCdtb2RpZmllZCcsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdXRhdGUgb3B0aW9uIG9iamVjdCBpbiBvcmRlciB0byBhZGQgYnkgcHJvcGVydHkgYW5kIGdpdmUgYmFjayB0aGUgZXZlbnQgbmFtZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDQuMi4wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gbXV0YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB0byBpbnNwZWN0IGFjdGlvbiBmcm9tXG4gICAgICovXG4gICAgX2FkZEV2ZW50T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucywgdHJhbnNmb3JtKSB7XG4gICAgICAvLyB3ZSBjYW4gcHJvYmFibHkgYWRkIG1vcmUgZGV0YWlscyBhdCBsb3cgY29zdFxuICAgICAgLy8gc2NhbGUgY2hhbmdlLCByb3RhdGlvbiBjaGFuZ2VzLCB0cmFuc2xhdGlvbiBjaGFuZ2VzXG4gICAgICB2YXIgZXZlbnROYW1lLCBieTtcbiAgICAgIHN3aXRjaCAodHJhbnNmb3JtLmFjdGlvbikge1xuICAgICAgICBjYXNlICdzY2FsZVgnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ3gnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY2FsZVknOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ3knO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3NrZXdlZCc7XG4gICAgICAgICAgYnkgPSAneCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnc2tld2VkJztcbiAgICAgICAgICBieSA9ICd5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdzY2FsZWQnO1xuICAgICAgICAgIGJ5ID0gJ2VxdWFsbHknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdyb3RhdGVkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZHJhZyc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ21vdmVkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuYnkgPSBieTtcbiAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmdldEFjdGl2ZU9iamVjdCgpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKS5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlRG93bihwb2ludGVyLCB7IGU6IGUsIHBvaW50ZXI6IHBvaW50ZXIgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlTW92ZShwb2ludGVyLCB7IGU6IGUsIHBvaW50ZXI6IHBvaW50ZXIgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmZyZWVEcmF3aW5nQ3Vyc29yKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IHRoaXMuZnJlZURyYXdpbmdCcnVzaC5vbk1vdXNlVXAoeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBjbGlja2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIGluaXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMgYW5kIHJlbmRlcnMgYWxsIHRoZVxuICAgICAqIGNhbnZhcyBzbyB0aGUgY3VycmVudCBpbWFnZSBjYW4gYmUgcGxhY2VkIG9uIHRoZSB0b3AgY2FudmFzIGFuZCB0aGUgcmVzdFxuICAgICAqIGluIG9uIHRoZSBjb250YWluZXIgb25lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX19vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd246YmVmb3JlJyk7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgLy8gaWYgcmlnaHQgY2xpY2sganVzdCBmaXJlIGV2ZW50c1xuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCBSSUdIVF9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBNSURETEVfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVNaWRkbGVDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgTUlERExFX0NMSUNLKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZ25vcmUgaWYgc29tZSBvYmplY3QgaXMgYmVpbmcgdHJhbnNmb3JtZWQgYXQgdGhpcyBtb21lbnRcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLl9wb2ludGVyO1xuICAgICAgLy8gc2F2ZSBwb2ludGVyIGZvciBjaGVjayBpbiBfX29uTW91c2VVcCBldmVudFxuICAgICAgdGhpcy5fcHJldmlvdXNQb2ludGVyID0gcG9pbnRlcjtcbiAgICAgIHZhciBzaG91bGRSZW5kZXIgPSB0aGlzLl9zaG91bGRSZW5kZXIodGFyZ2V0KSxcbiAgICAgICAgICBzaG91bGRHcm91cCA9IHRoaXMuX3Nob3VsZEdyb3VwKGUsIHRhcmdldCk7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJTZWxlY3Rpb24oZSwgdGFyZ2V0KSkge1xuICAgICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaG91bGRHcm91cCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVHcm91cGluZyhlLCB0YXJnZXQpO1xuICAgICAgICB0YXJnZXQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiAoIXRhcmdldCB8fFxuICAgICAgICAoIXRhcmdldC5zZWxlY3RhYmxlICYmICF0YXJnZXQuaXNFZGl0aW5nICYmIHRhcmdldCAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0KSkpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IHtcbiAgICAgICAgICBleDogcG9pbnRlci54LFxuICAgICAgICAgIGV5OiBwb2ludGVyLnksXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB2YXIgYWxyZWFkeVNlbGVjdGVkID0gdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIGlmICh0YXJnZXQuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHRhcmdldCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lcihcbiAgICAgICAgICB0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSksXG4gICAgICAgICAgZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50KGUpXG4gICAgICAgICk7XG4gICAgICAgIHRhcmdldC5fX2Nvcm5lciA9IGNvcm5lcjtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIChjb3JuZXIgfHwgIXNob3VsZEdyb3VwKSkge1xuICAgICAgICAgIHRoaXMuX3NldHVwQ3VycmVudFRyYW5zZm9ybShlLCB0YXJnZXQsIGFscmVhZHlTZWxlY3RlZCk7XG4gICAgICAgICAgdmFyIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXSxcbiAgICAgICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICAgICAgbW91c2VEb3duSGFuZGxlciA9IGNvbnRyb2wgJiYgY29udHJvbC5nZXRNb3VzZURvd25IYW5kbGVyKGUsIHRhcmdldCwgY29udHJvbCk7XG4gICAgICAgICAgaWYgKG1vdXNlRG93bkhhbmRsZXIpIHtcbiAgICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIoZSwgdGhpcy5fY3VycmVudFRyYW5zZm9ybSwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nKTtcbiAgICAgIC8vIHdlIG11c3QgcmVuZGVyQWxsIHNvIHRoYXQgd2UgdXBkYXRlIHRoZSB2aXN1YWxzXG4gICAgICAoc2hvdWxkUmVuZGVyIHx8IHNob3VsZEdyb3VwKSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgY2FjaGUgZm9ybSBjb21tb24gaW5mb3JtYXRpb24gbmVlZGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgY29tbW9uIGluZm9ybWF0aW9uIG5lZWRlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gZXZlbnRcbiAgICAgKi9cbiAgICBfY2FjaGVUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIHJlc2V0IGluIG9yZGVyIHRvIGF2b2lkIHN0YWxlIGNhY2hpbmdcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB0aGlzLl9wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdCh0aGlzLl9wb2ludGVyKTtcbiAgICAgIHRoaXMuX3RhcmdldCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPyB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLnRhcmdldCA6IHRoaXMuZmluZFRhcmdldChlKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iZWZvcmVUcmFuc2Zvcm06IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgdC50YXJnZXQuc2F2ZVN0YXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTp0cmFuc2Zvcm0nLCB7XG4gICAgICAgIGU6IGUsXG4gICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgaG92ZXJpbmcgdGhlIGNhbnZhcy5cbiAgICAgKiBUaGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXIgd2lsbCBkZWZpbmUgd2hldGhlciB0aGUgdXNlciBpcyByb3RhdGluZy9zY2FsaW5nL3RyYW5zbGF0aW5nXG4gICAgICogYW4gaW1hZ2Ugb3IgbmVpdGhlciBvZiB0aGVtIChvbmx5IGhvdmVyaW5nKS4gQSBncm91cCBzZWxlY3Rpb24gaXMgYWxzbyBwb3NzaWJsZSBhbmQgd291bGQgY2FuY2VsXG4gICAgICogYWxsIGFueSBvdGhlciB0eXBlIG9mIGFjdGlvbi5cbiAgICAgKiBJbiBjYXNlIG9mIGFuIGltYWdlIHRyYW5zZm9ybWF0aW9uIG9ubHkgdGhlIHRvcCBjYW52YXMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9fb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZTpiZWZvcmUnKTtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdmFyIHRhcmdldCwgcG9pbnRlcjtcblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcjtcblxuICAgICAgLy8gV2UgaW5pdGlhbGx5IGNsaWNrZWQgaW4gYW4gZW1wdHkgYXJlYSwgc28gd2UgZHJhdyBhIGJveCBmb3IgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICBpZiAoZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICBwb2ludGVyID0gdGhpcy5fcG9pbnRlcjtcblxuICAgICAgICBncm91cFNlbGVjdG9yLmxlZnQgPSBwb2ludGVyLnggLSBncm91cFNlbGVjdG9yLmV4O1xuICAgICAgICBncm91cFNlbGVjdG9yLnRvcCA9IHBvaW50ZXIueSAtIGdyb3VwU2VsZWN0b3IuZXk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCF0aGlzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKSB8fCBudWxsO1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQoZSwgdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fZmlyZU92ZXJPdXRFdmVudHModGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PYmplY3QoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZScpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBtb3VzZW91dCwgbW91c2VvdmVyIGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3Qgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBtb3VzZW1vdmUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlT3Zlck91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgX2hvdmVyZWRUYXJnZXQgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0LFxuICAgICAgICAgIF9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMuX2hvdmVyZWRUYXJnZXRzLCB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIGxlbmd0aCA9IE1hdGgubWF4KF9ob3ZlcmVkVGFyZ2V0cy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoKTtcblxuICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXQsXG4gICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgY2FudmFzRXZ0T3V0OiAnbW91c2U6b3V0JyxcbiAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgICBjYW52YXNFdnRJbjogJ21vdXNlOm92ZXInLFxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0c1tpXSwgZSwge1xuICAgICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXRzW2ldLFxuICAgICAgICAgIGV2dE91dDogJ21vdXNlb3V0JyxcbiAgICAgICAgICBldnRJbjogJ21vdXNlb3ZlcicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIGRyYWdFbnRlciwgZHJhZ0xlYXZlIGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgb25EcmFnIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gb25kcmFnXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUVudGVyTGVhdmVFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIF9kcmFnZ2Vkb3ZlclRhcmdldCA9IHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0LFxuICAgICAgICAgIF9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMuX2hvdmVyZWRUYXJnZXRzLCB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIGxlbmd0aCA9IE1hdGgubWF4KF9ob3ZlcmVkVGFyZ2V0cy5sZW5ndGgsIHRhcmdldHMubGVuZ3RoKTtcblxuICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0LCBlLCB7XG4gICAgICAgIG9sZFRhcmdldDogX2RyYWdnZWRvdmVyVGFyZ2V0LFxuICAgICAgICBldnRPdXQ6ICdkcmFnbGVhdmUnLFxuICAgICAgICBldnRJbjogJ2RyYWdlbnRlcicsXG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljSW5PdXRFdmVudHModGFyZ2V0c1tpXSwgZSwge1xuICAgICAgICAgIG9sZFRhcmdldDogX2hvdmVyZWRUYXJnZXRzW2ldLFxuICAgICAgICAgIGV2dE91dDogJ2RyYWdsZWF2ZScsXG4gICAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RyYWdnZWRvdmVyVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIHN5bnRoZXRpYyBpbi9vdXQgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdHMgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBzdXBwb3J0ZWQgZXZlbnRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmdW5jdGlvbiB0byB3b3JrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50YXJnZXROYW1lIHByb3BlcnR5IG9uIHRoZSBjYW52YXMgd2hlcmUgdGhlIG9sZCB0YXJnZXQgaXMgc3RvcmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0T3V0XSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5ldnRPdXQgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3Igb3V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuY2FudmFzRXZ0SW5dIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgYXQgY2FudmFzIGxldmVsIGZvciBpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0SW4gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBmb3IgaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNJbk91dEV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlLCBjb25maWcpIHtcbiAgICAgIHZhciBpbk9wdCwgb3V0T3B0LCBvbGRUYXJnZXQgPSBjb25maWcub2xkVGFyZ2V0LCBvdXRGaXJlcywgaW5GaXJlcyxcbiAgICAgICAgICB0YXJnZXRDaGFuZ2VkID0gb2xkVGFyZ2V0ICE9PSB0YXJnZXQsIGNhbnZhc0V2dEluID0gY29uZmlnLmNhbnZhc0V2dEluLCBjYW52YXNFdnRPdXQgPSBjb25maWcuY2FudmFzRXZ0T3V0O1xuICAgICAgaWYgKHRhcmdldENoYW5nZWQpIHtcbiAgICAgICAgaW5PcHQgPSB7IGU6IGUsIHRhcmdldDogdGFyZ2V0LCBwcmV2aW91c1RhcmdldDogb2xkVGFyZ2V0IH07XG4gICAgICAgIG91dE9wdCA9IHsgZTogZSwgdGFyZ2V0OiBvbGRUYXJnZXQsIG5leHRUYXJnZXQ6IHRhcmdldCB9O1xuICAgICAgfVxuICAgICAgaW5GaXJlcyA9IHRhcmdldCAmJiB0YXJnZXRDaGFuZ2VkO1xuICAgICAgb3V0RmlyZXMgPSBvbGRUYXJnZXQgJiYgdGFyZ2V0Q2hhbmdlZDtcbiAgICAgIGlmIChvdXRGaXJlcykge1xuICAgICAgICBjYW52YXNFdnRPdXQgJiYgdGhpcy5maXJlKGNhbnZhc0V2dE91dCwgb3V0T3B0KTtcbiAgICAgICAgb2xkVGFyZ2V0LmZpcmUoY29uZmlnLmV2dE91dCwgb3V0T3B0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbkZpcmVzKSB7XG4gICAgICAgIGNhbnZhc0V2dEluICYmIHRoaXMuZmlyZShjYW52YXNFdnRJbiwgaW5PcHQpO1xuICAgICAgICB0YXJnZXQuZmlyZShjb25maWcuZXZ0SW4sIGluT3B0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyBhY3Rpb25zIHdoZW4gYW4gRXZlbnQgTW91c2UgV2hlZWxcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlV2hlZWw6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3doZWVsJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX3RyYW5zZm9ybU9iamVjdDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgdHJhbnNmb3JtLnJlc2V0ID0gZmFsc2U7XG4gICAgICB0cmFuc2Zvcm0udGFyZ2V0LmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgIHRyYW5zZm9ybS5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG4gICAgICB0cmFuc2Zvcm0uYWx0S2V5ID0gZVt0aGlzLmNlbnRlcmVkS2V5XTtcblxuICAgICAgdGhpcy5fcGVyZm9ybVRyYW5zZm9ybUFjdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpO1xuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGVyZm9ybVRyYW5zZm9ybUFjdGlvbjogZnVuY3Rpb24oZSwgdHJhbnNmb3JtLCBwb2ludGVyKSB7XG4gICAgICB2YXIgeCA9IHBvaW50ZXIueCxcbiAgICAgICAgICB5ID0gcG9pbnRlci55LFxuICAgICAgICAgIGFjdGlvbiA9IHRyYW5zZm9ybS5hY3Rpb24sXG4gICAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gZmFsc2UsXG4gICAgICAgICAgYWN0aW9uSGFuZGxlciA9IHRyYW5zZm9ybS5hY3Rpb25IYW5kbGVyO1xuICAgICAgICAgIC8vIHRoaXMgb2JqZWN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgZnVuY3Rpb24gaW4gdGhlIGNvbnRyb2wgaGFuZGxlcnNcblxuXG4gICAgICBpZiAoYWN0aW9uSGFuZGxlcikge1xuICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBhY3Rpb25IYW5kbGVyKGUsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uID09PSAnZHJhZycgJiYgYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRyYW5zZm9ybS50YXJnZXQubW92ZUN1cnNvciB8fCB0aGlzLm1vdmVDdXJzb3IpO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCA9IHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgYWN0aW9uUGVyZm9ybWVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlOiBmYWJyaWMuY29udHJvbHNVdGlscy5maXJlRXZlbnQsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJzb3IgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZSBjYW52YXMgaXMgYmVpbmcgaG92ZXJlZC5cbiAgICAgKiBOb3RlOiB2ZXJ5IGJ1Z2d5IGluIE9wZXJhXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0aGF0IHRoZSBtb3VzZSBpcyBob3ZlcmluZywgaWYgc28uXG4gICAgICovXG4gICAgX3NldEN1cnNvckZyb21FdmVudDogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5kZWZhdWx0Q3Vyc29yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGhvdmVyQ3Vyc29yID0gdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgICAgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2FjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyA/XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QgOiBudWxsLFxuICAgICAgICAgIC8vIG9ubHkgc2hvdyBwcm9wZXIgY29ybmVyIHdoZW4gZ3JvdXAgc2VsZWN0aW9uIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgICBjb3JuZXIgPSAoIWFjdGl2ZVNlbGVjdGlvbiB8fCAhYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpXG4gICAgICAgICAgLy8gaGVyZSB3ZSBjYWxsIGZpbmRUYXJnZXRDb3JuZXIgYWx3YXlzIHdpdGggdW5kZWZpbmVkIGZvciB0aGUgdG91Y2ggcGFyYW1ldGVyLlxuICAgICAgICAgIC8vIHdlIGFzc3VtZSB0aGF0IGlmIHlvdSBhcmUgdXNpbmcgYSBjdXJzb3IgeW91IGRvIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGhcbiAgICAgICAgICAvLyB0aGUgYmlnZ2VyIHRvdWNoIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICYmIHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpO1xuXG4gICAgICBpZiAoIWNvcm5lcikge1xuICAgICAgICBpZiAodGFyZ2V0LnN1YlRhcmdldENoZWNrKXtcbiAgICAgICAgICAvLyBob3ZlckN1cnNvciBzaG91bGQgY29tZSBmcm9tIHRvcC1tb3N0IHN1YlRhcmdldCxcbiAgICAgICAgICAvLyBzbyB3ZSB3YWxrIHRoZSBhcnJheSBiYWNrd2FyZHNcbiAgICAgICAgICB0aGlzLnRhcmdldHMuY29uY2F0KCkucmV2ZXJzZSgpLm1hcChmdW5jdGlvbihfdGFyZ2V0KXtcbiAgICAgICAgICAgIGhvdmVyQ3Vyc29yID0gX3RhcmdldC5ob3ZlckN1cnNvciB8fCBob3ZlckN1cnNvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEN1cnNvcihob3ZlckN1cnNvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5nZXRDb3JuZXJDdXJzb3IoY29ybmVyLCB0YXJnZXQsIGUpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdO1xuICAgICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGVIYW5kbGVyKGUsIGNvbnRyb2wsIHRhcmdldCk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBfc2hvdWxkR3JvdXA6IGZ1bmN0aW9uKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIHJldHVybiBhY3RpdmVPYmplY3QgJiYgdGhpcy5faXNTZWxlY3Rpb25LZXlQcmVzc2VkKGUpICYmIHRhcmdldCAmJiB0YXJnZXQuc2VsZWN0YWJsZSAmJiB0aGlzLnNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgKGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0IHx8IGFjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykgJiYgIXRhcmdldC5vblNlbGVjdCh7IGU6IGUgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9oYW5kbGVHcm91cGluZzogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIC8vIGF2b2lkIG11bHRpIHNlbGVjdCB3aGVuIHNoaWZ0IGNsaWNrIG9uIGEgY29ybmVyXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0Ll9fY29ybmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgPT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZ3JvdXAsIGZpbmQgdGFyZ2V0IGFnYWluLCB1c2luZyBhY3RpdmVHcm91cCBvYmplY3RzXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlLCB0cnVlKTtcbiAgICAgICAgLy8gaWYgZXZlbiBvYmplY3QgaXMgbm90IGZvdW5kIG9yIHdlIGFyZSBvbiBhY3RpdmVPYmplY3RDb3JuZXIsIGJhaWwgb3V0XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlU2VsZWN0aW9uKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQWN0aXZlU2VsZWN0aW9uKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGN1cnJlbnRBY3RpdmVPYmplY3RzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzLnNsaWNlKDApO1xuICAgICAgaWYgKGFjdGl2ZVNlbGVjdGlvbi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIGFjdGl2ZVNlbGVjdGlvbi5yZW1vdmVXaXRoVXBkYXRlKHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLnNpemUoKSA9PT0gMSkge1xuICAgICAgICAgIC8vIGFjdGl2YXRlIGxhc3QgcmVtYWluaW5nIG9iamVjdFxuICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChhY3RpdmVTZWxlY3Rpb24uaXRlbSgwKSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24uYWRkV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZU9iamVjdHMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIGdyb3VwID0gdGhpcy5fY3JlYXRlR3JvdXAodGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBncm91cDtcbiAgICAgIC8vIElTU1VFIDQxMTU6IHNob3VsZCB3ZSBjb25zaWRlciBzdWJUYXJnZXRzIGhlcmU/XG4gICAgICAvLyB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgICAgLy8gdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3QoZ3JvdXAsIGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9jcmVhdGVHcm91cDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgICAgaXNBY3RpdmVMb3dlciA9IG9iamVjdHMuaW5kZXhPZih0aGlzLl9hY3RpdmVPYmplY3QpIDwgb2JqZWN0cy5pbmRleE9mKHRhcmdldCksXG4gICAgICAgICAgZ3JvdXBPYmplY3RzID0gaXNBY3RpdmVMb3dlclxuICAgICAgICAgICAgPyBbdGhpcy5fYWN0aXZlT2JqZWN0LCB0YXJnZXRdXG4gICAgICAgICAgICA6IFt0YXJnZXQsIHRoaXMuX2FjdGl2ZU9iamVjdF07XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nICYmIHRoaXMuX2FjdGl2ZU9iamVjdC5leGl0RWRpdGluZygpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwT2JqZWN0cywge1xuICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBfZ3JvdXBTZWxlY3RlZE9iamVjdHM6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuX2NvbGxlY3RPYmplY3RzKGUpLFxuICAgICAgICAgIGFHcm91cDtcblxuICAgICAgLy8gZG8gbm90IGNyZWF0ZSBncm91cCBmb3IgMSBlbGVtZW50IG9ubHlcbiAgICAgIGlmIChncm91cC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoZ3JvdXBbMF0sIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICBhR3JvdXAgPSBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihncm91cC5yZXZlcnNlKCksIHtcbiAgICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGFHcm91cCwgZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NvbGxlY3RPYmplY3RzOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBjdXJyZW50T2JqZWN0LFxuICAgICAgICAgIHgxID0gdGhpcy5fZ3JvdXBTZWxlY3Rvci5leCxcbiAgICAgICAgICB5MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXksXG4gICAgICAgICAgeDIgPSB4MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB5MiA9IHkxICsgdGhpcy5fZ3JvdXBTZWxlY3Rvci50b3AsXG4gICAgICAgICAgc2VsZWN0aW9uWDFZMSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKHgxLCB4MiksIG1pbih5MSwgeTIpKSxcbiAgICAgICAgICBzZWxlY3Rpb25YMlkyID0gbmV3IGZhYnJpYy5Qb2ludChtYXgoeDEsIHgyKSwgbWF4KHkxLCB5MikpLFxuICAgICAgICAgIGFsbG93SW50ZXJzZWN0ID0gIXRoaXMuc2VsZWN0aW9uRnVsbHlDb250YWluZWQsXG4gICAgICAgICAgaXNDbGljayA9IHgxID09PSB4MiAmJiB5MSA9PT0geTI7XG4gICAgICAvLyB3ZSBpdGVyYXRlIHJldmVyc2Ugb3JkZXIgdG8gY29sbGVjdCB0b3AgZmlyc3QgaW4gY2FzZSBvZiBjbGljay5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY3VycmVudE9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG5cbiAgICAgICAgaWYgKCFjdXJyZW50T2JqZWN0IHx8ICFjdXJyZW50T2JqZWN0LnNlbGVjdGFibGUgfHwgIWN1cnJlbnRPYmplY3QudmlzaWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmludGVyc2VjdHNXaXRoUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyKSkgfHxcbiAgICAgICAgICAgIGN1cnJlbnRPYmplY3QuaXNDb250YWluZWRXaXRoaW5SZWN0KHNlbGVjdGlvblgxWTEsIHNlbGVjdGlvblgyWTIpIHx8XG4gICAgICAgICAgICAoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5jb250YWluc1BvaW50KHNlbGVjdGlvblgxWTEpKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMlkyKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChjdXJyZW50T2JqZWN0KTtcbiAgICAgICAgICAvLyBvbmx5IGFkZCBvbmUgb2JqZWN0IGlmIGl0J3MgYSBjbGlja1xuICAgICAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cC5maWx0ZXIoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuICFvYmplY3Qub25TZWxlY3QoeyBlOiBlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYXliZUdyb3VwT2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RlZE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgLy8gY2xlYXIgc2VsZWN0aW9uIGFuZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRXhwb3J0cyBjYW52YXMgZWxlbWVudCB0byBhIGRhdGF1cmwgaW1hZ2UuIE5vdGUgdGhhdCB3aGVuIG11bHRpcGxpZXIgaXMgdXNlZCwgY3JvcHBpbmcgaXMgc2NhbGVkIGFwcHJvcHJpYXRlbHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnksIHRvIGhhdmUgY29uc2lzdGVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAyLjAuMFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTmZaVmIvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUganBlZyBkYXRhVVJMIHdpdGggbG93ZXIgcXVhbGl0eTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAnanBlZycsXG4gICAgICogICBxdWFsaXR5OiAwLjhcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBjcm9wcGVkIHBuZyBkYXRhVVJMIChjbGlwcGluZyBvZiBjYW52YXMpPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDAsXG4gICAgICogICB3aWR0aDogMjAwLFxuICAgICAqICAgaGVpZ2h0OiAyMDBcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBkb3VibGUgc2NhbGVkIHBuZyBkYXRhVVJMPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbXVsdGlwbGllcjogMlxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ3BuZycsXG4gICAgICAgICAgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSB8fCAxLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSAob3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEpICogKG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpIDogMSksXG4gICAgICAgICAgY2FudmFzRWwgPSB0aGlzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0RhdGFVUkwoY2FudmFzRWwsIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVE1MQ2FudmFzIGVsZW1lbnQgcGFpbnRlZCB3aXRoIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZW50LlxuICAgICAqIE5vIG5lZWQgdG8gcmVzaXplIHRoZSBhY3R1YWwgb25lIG9yIHJlcGFpbnQgaXQuXG4gICAgICogV2lsbCB0cmFuc2ZlciBvYmplY3Qgb3duZXJzaGlwIHRvIGEgbmV3IGNhbnZhcywgcGFpbnQgaXQsIGFuZCBzZXQgZXZlcnl0aGluZyBiYWNrLlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAgdXNlZCB0byBnZXQgdG8gYSBkYXRhVXJsIGJ1dCBhbHNvIGl0IGlzIHVzZWZ1bCB0b1xuICAgICAqIGNyZWF0ZSBxdWljayBpbWFnZSBjb3BpZXMgb2YgYSBjYW52YXMgd2l0aG91dCBwYXNzaW5nIGZvciB0aGUgZGF0YVVybCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW211bHRpcGxpZXJdIGEgem9vbSBmYWN0b3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjcm9wcGluZ10gQ3JvcHBpbmcgaW5mb3JtYXRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLndpZHRoXSBDcm9wcGluZyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LlxuICAgICAqL1xuICAgIHRvQ2FudmFzRWxlbWVudDogZnVuY3Rpb24obXVsdGlwbGllciwgY3JvcHBpbmcpIHtcbiAgICAgIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyIHx8IDE7XG4gICAgICBjcm9wcGluZyA9IGNyb3BwaW5nIHx8IHsgfTtcbiAgICAgIHZhciBzY2FsZWRXaWR0aCA9IChjcm9wcGluZy53aWR0aCB8fCB0aGlzLndpZHRoKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgc2NhbGVkSGVpZ2h0ID0gKGNyb3BwaW5nLmhlaWdodCB8fCB0aGlzLmhlaWdodCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICBvcmlnaW5hbFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBvcmlnaW5hbEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIG5ld1pvb20gPSB6b29tICogbXVsdGlwbGllcixcbiAgICAgICAgICB2cCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdHJhbnNsYXRlWCA9ICh2cFs0XSAtIChjcm9wcGluZy5sZWZ0IHx8IDApKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9ICh2cFs1XSAtIChjcm9wcGluZy50b3AgfHwgMCkpICogbXVsdGlwbGllcixcbiAgICAgICAgICBvcmlnaW5hbEludGVyYWN0aXZlID0gdGhpcy5pbnRlcmFjdGl2ZSxcbiAgICAgICAgICBuZXdWcCA9IFtuZXdab29tLCAwLCAwLCBuZXdab29tLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSxcbiAgICAgICAgICBvcmlnaW5hbFJldGluYSA9IHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBvcmlnaW5hbENvbnRleHRUb3AgPSB0aGlzLmNvbnRleHRUb3A7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gbnVsbDtcbiAgICAgIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IG5ld1ZwO1xuICAgICAgdGhpcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksIHRoaXMuX29iamVjdHMpO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IHZwO1xuICAgICAgdGhpcy53aWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gb3JpZ2luYWxJbnRlcmFjdGl2ZTtcbiAgICAgIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA9IG9yaWdpbmFsUmV0aW5hO1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gb3JpZ2luYWxDb250ZXh0VG9wO1xuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogUG9wdWxhdGVzIGNhbnZhcyB3aXRoIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIEpTT04uXG4gICAqIEpTT04gZm9ybWF0IG11c3QgY29uZm9ybSB0byB0aGUgb25lIG9mIHtAbGluayBmYWJyaWMuQ2FudmFzI3RvSlNPTn1cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjaywgaW52b2tlZCB3aGVuIGpzb24gaXMgcGFyc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb3JyZXNwb25kaW5nIG9iamVjdHMgKGUuZzoge0BsaW5rIGZhYnJpYy5JbWFnZX0pXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBpbml0aWFsaXplZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgSlNPTiBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2Rlc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9mbWdYdC98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OIHdpdGggcmV2aXZlcjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwgZnVuY3Rpb24obywgb2JqZWN0KSB7XG4gICAqICAgLy8gYG9gID0ganNvbiBvYmplY3RcbiAgICogICAvLyBgb2JqZWN0YCA9IGZhYnJpYy5PYmplY3QgaW5zdGFuY2VcbiAgICogICAvLyAuLi4gZG8gc29tZSBzdHVmZiAuLi5cbiAgICogfSk7XG4gICAqL1xuICBsb2FkRnJvbUpTT046IGZ1bmN0aW9uIChqc29uLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNlcmlhbGl6ZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeVxuICAgIHZhciBzZXJpYWxpemVkID0gKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcbiAgICAgID8gSlNPTi5wYXJzZShqc29uKVxuICAgICAgOiBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoanNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBjbGlwUGF0aCA9IHNlcmlhbGl6ZWQuY2xpcFBhdGgsXG4gICAgICAgIHJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZTtcblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmNsaXBQYXRoO1xuXG4gICAgdGhpcy5fZW5saXZlbk9iamVjdHMoc2VyaWFsaXplZC5vYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgIF90aGlzLl9zZXRCZ092ZXJsYXkoc2VyaWFsaXplZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICBfdGhpcy5fZW5saXZlbk9iamVjdHMoW2NsaXBQYXRoXSwgZnVuY3Rpb24gKGVubGl2ZW5lZENhbnZhc0NsaXApIHtcbiAgICAgICAgICAgIF90aGlzLmNsaXBQYXRoID0gZW5saXZlbmVkQ2FudmFzQ2xpcFswXTtcbiAgICAgICAgICAgIF90aGlzLl9fc2V0dXBDYW52YXMuY2FsbChfdGhpcywgc2VyaWFsaXplZCwgZW5saXZlbmVkT2JqZWN0cywgcmVuZGVyT25BZGRSZW1vdmUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fX3NldHVwQ2FudmFzLmNhbGwoX3RoaXMsIHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHJldml2ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZCBPYmplY3Qgd2l0aCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3RvcmVkIGNhbnZhcyBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhY2hlZCByZW5kZXJPbkFkZFJlbW92ZSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIGFmdGVyIGFsbCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGltYWdlcy9wYXR0ZXJucyBsb2FkZWRcbiAgICovXG4gIF9fc2V0dXBDYW52YXM6IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZW5saXZlbmVkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaiwgaW5kZXgpIHtcbiAgICAgIC8vIHdlIHNwbGljZSB0aGUgYXJyYXkganVzdCBpbiBjYXNlIHNvbWUgY3VzdG9tIGNsYXNzZXMgcmVzdG9yZWQgZnJvbSBKU09OXG4gICAgICAvLyB3aWxsIGFkZCBtb3JlIG9iamVjdCB0byBjYW52YXMgYXQgY2FudmFzIGluaXQuXG4gICAgICBfdGhpcy5pbnNlcnRBdChvYmosIGluZGV4KTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlID0gcmVuZGVyT25BZGRSZW1vdmU7XG4gICAgLy8gcmVtb3ZlIHBhcnRzIGkgY2Fubm90IHNldCBhcyBvcHRpb25zXG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub2JqZWN0cztcbiAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2U7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmQ7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheTtcbiAgICAvLyB0aGlzLl9pbml0T3B0aW9ucyBkb2VzIHRvbyBtYW55IHRoaW5ncyB0byBqdXN0XG4gICAgLy8gY2FsbCBpdC4gTm9ybWFsbHkgbG9hZGluZyBhbiBPYmplY3QgZnJvbSBKU09OXG4gICAgLy8gY3JlYXRlIHRoZSBPYmplY3QgaW5zdGFuY2UuIEhlcmUgdGhlIENhbnZhcyBpc1xuICAgIC8vIGFscmVhZHkgYW4gaW5zdGFuY2UgYW5kIHdlIGFyZSBqdXN0IGxvYWRpbmcgdGhpbmdzIG92ZXIgaXRcbiAgICB0aGlzLl9zZXRPcHRpb25zKHNlcmlhbGl6ZWQpO1xuICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGl6ZWQgT2JqZWN0IHdpdGggYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIGFmdGVyIGFsbCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGltYWdlcy9wYXR0ZXJucyBsb2FkZWRcbiAgICovXG4gIF9zZXRCZ092ZXJsYXk6IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxvYWRlZCA9IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogZmFsc2UsXG4gICAgICBvdmVybGF5Q29sb3I6IGZhbHNlLFxuICAgICAgYmFja2dyb3VuZEltYWdlOiBmYWxzZSxcbiAgICAgIG92ZXJsYXlJbWFnZTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKCFzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZSAmJiAhc2VyaWFsaXplZC5vdmVybGF5SW1hZ2UgJiYgIXNlcmlhbGl6ZWQuYmFja2dyb3VuZCAmJiAhc2VyaWFsaXplZC5vdmVybGF5KSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYklmTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGxvYWRlZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgbG9hZGVkLm92ZXJsYXlJbWFnZSAmJiBsb2FkZWQuYmFja2dyb3VuZENvbG9yICYmIGxvYWRlZC5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnYmFja2dyb3VuZEltYWdlJywgc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnb3ZlcmxheUltYWdlJywgc2VyaWFsaXplZC5vdmVybGF5SW1hZ2UsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnYmFja2dyb3VuZENvbG9yJywgc2VyaWFsaXplZC5iYWNrZ3JvdW5kLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlDb2xvcicsIHNlcmlhbGl6ZWQub3ZlcmxheSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoYmFja2dyb3VuZEltYWdlLCBvdmVybGF5SW1hZ2UsIGJhY2tncm91bmRDb2xvciwgb3ZlcmxheUNvbG9yKVxuICAgKiBAcGFyYW0geyhPYmplY3R8U3RyaW5nKX0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkZWQgU2V0IGxvYWRlZCBwcm9wZXJ0eSB0byB0cnVlIGlmIHByb3BlcnR5IGlzIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIHByb3BlcnR5IGlzIHNldFxuICAgKi9cbiAgX19zZXRCZ092ZXJsYXk6IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSwgbG9hZGVkLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5ID09PSAnYmFja2dyb3VuZEltYWdlJyB8fCBwcm9wZXJ0eSA9PT0gJ292ZXJsYXlJbWFnZScpIHtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFt2YWx1ZV0sIGZ1bmN0aW9uKGVubGl2ZWRPYmplY3Qpe1xuICAgICAgICBfdGhpc1twcm9wZXJ0eV0gPSBlbmxpdmVkT2JqZWN0WzBdO1xuICAgICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbJ3NldCcgKyBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShwcm9wZXJ0eSwgdHJ1ZSldKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdXG4gICAqL1xuICBfZW5saXZlbk9iamVjdHM6IGZ1bmN0aW9uIChvYmplY3RzLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghb2JqZWN0cyB8fCBvYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgIH0sIG51bGwsIHJldml2ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMOiBmdW5jdGlvbiAoZm9ybWF0LCBjYWxsYmFjaykge1xuICAgIHRoaXMuY2xvbmUoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICBjYWxsYmFjayhjbG9uZS50b0RhdGFVUkwoZm9ybWF0KSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpcGxpZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF90b0RhdGFVUkxXaXRoTXVsdGlwbGllcjogZnVuY3Rpb24gKGZvcm1hdCwgbXVsdGlwbGllciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMV2l0aE11bHRpcGxpZXIoZm9ybWF0LCBtdWx0aXBsaWVyKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyBjYW52YXMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja10gUmVjZWl2ZXMgY2xvbmVkIGluc3RhbmNlIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNdIEFycmF5IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSBpbiB0aGUgY2xvbmVkIGNhbnZhcyBhbmQgY2hpbGRyZW5cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKHByb3BlcnRpZXMpKTtcbiAgICB0aGlzLmNsb25lV2l0aG91dERhdGEoZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgIGNsb25lLmxvYWRGcm9tSlNPTihkYXRhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyBjYW52YXMgaW5zdGFuY2Ugd2l0aG91dCBjbG9uaW5nIGV4aXN0aW5nIGRhdGEuXG4gICAqIFRoaXMgZXNzZW50aWFsbHkgY29waWVzIGNhbnZhcyBkaW1lbnNpb25zLCBjbGlwcGluZyBwcm9wZXJ0aWVzLCBldGMuXG4gICAqIGJ1dCBsZWF2ZXMgZGF0YSBlbXB0eSAoc28gdGhhdCB5b3UgY2FuIHBvcHVsYXRlIGl0IHdpdGggeW91ciBvd24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBjbG9uZVdpdGhvdXREYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBlbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgIGVsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBlbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHZhciBjbG9uZSA9IG5ldyBmYWJyaWMuQ2FudmFzKGVsKTtcbiAgICBpZiAodGhpcy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgIGNsb25lLnNldEJhY2tncm91bmRJbWFnZSh0aGlzLmJhY2tncm91bmRJbWFnZS5zcmMsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbG9uZS5yZW5kZXJBbGwoKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgICAgfSk7XG4gICAgICBjbG9uZS5iYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5ID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5O1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlU3RyZXRjaCA9IHRoaXMuYmFja2dyb3VuZEltYWdlU3RyZXRjaDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgfVxuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgY2FwaXRhbGl6ZSA9IGZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBzdXBwb3J0c0xpbmVEYXNoID0gZmFicmljLlN0YXRpY0NhbnZhcy5zdXBwb3J0cygnc2V0TGluZURhc2gnKSxcbiAgICAgIG9iamVjdENhY2hpbmcgPSAhZmFicmljLmlzTGlrZWx5Tm9kZSxcbiAgICAgIEFMSUFTSU5HX0xJTUlUID0gMjtcblxuICBpZiAoZmFicmljLk9iamVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb290IG9iamVjdCBjbGFzcyBmcm9tIHdoaWNoIGFsbCAyZCBzaGFwZSBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICAgKiBAY2xhc3MgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNvYmplY3RzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuT2JqZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBhZGRlZFxuICAgKiBAZmlyZXMgcmVtb3ZlZFxuICAgKlxuICAgKiBAZmlyZXMgc2VsZWN0ZWRcbiAgICogQGZpcmVzIGRlc2VsZWN0ZWRcbiAgICogQGZpcmVzIG1vZGlmaWVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW92ZWRcbiAgICogQGZpcmVzIHNjYWxlZFxuICAgKiBAZmlyZXMgcm90YXRlZFxuICAgKiBAZmlyZXMgc2tld2VkXG4gICAqXG4gICAqIEBmaXJlcyByb3RhdGluZ1xuICAgKiBAZmlyZXMgc2NhbGluZ1xuICAgKiBAZmlyZXMgbW92aW5nXG4gICAqIEBmaXJlcyBza2V3aW5nXG4gICAqXG4gICAqIEBmaXJlcyBtb3VzZWRvd25cbiAgICogQGZpcmVzIG1vdXNldXBcbiAgICogQGZpcmVzIG1vdXNlb3ZlclxuICAgKiBAZmlyZXMgbW91c2VvdXRcbiAgICogQGZpcmVzIG1vdXNld2hlZWxcbiAgICogQGZpcmVzIG1vdXNlZGJsY2xpY2tcbiAgICpcbiAgICogQGZpcmVzIGRyYWdvdmVyXG4gICAqIEBmaXJlcyBkcmFnZW50ZXJcbiAgICogQGZpcmVzIGRyYWdsZWF2ZVxuICAgKiBAZmlyZXMgZHJvcFxuICAgKi9cbiAgZmFicmljLk9iamVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0IChyZWN0LCBjaXJjbGUsIHBhdGgsIGV0Yy4pLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIG1lYW50IHRvIGJlIHJlYWQtb25seSBhbmQgbm90IG1lYW50IHRvIGJlIG1vZGlmaWVkLlxuICAgICAqIElmIHlvdSBtb2RpZnksIGNlcnRhaW4gcGFydHMgb2YgRmFicmljIChzdWNoIGFzIEpTT04gbG9hZGluZykgd29uJ3Qgd29yayBjb3JyZWN0bHkuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5YOiAgICAgICAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBvYmplY3QgKG9uZSBvZiBcInRvcFwiLCBcImJvdHRvbVwiLCBcImNlbnRlclwiKVxuICAgICAqIFNlZSBodHRwOi8vanNmaWRkbGUubmV0LzFvdzAyZ2VhLzI0NC8gb24gaG93IG9yaWdpblgvb3JpZ2luWSBhZmZlY3Qgb2JqZWN0cyBpbiBncm91cHNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9yaWdpblk6ICAgICAgICAgICAgICAgICAgJ3RvcCcsXG5cbiAgICAvKipcbiAgICAgKiBUb3AgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBOb3RlIHRoYXQgYnkgZGVmYXVsdCBpdCdzIHJlbGF0aXZlIHRvIG9iamVjdCB0b3AuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgc2V0dGluZyBvcmlnaW5ZPXt0b3AvY2VudGVyL2JvdHRvbX1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRvcDogICAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIExlZnQgcG9zaXRpb24gb2YgYW4gb2JqZWN0LiBOb3RlIHRoYXQgYnkgZGVmYXVsdCBpdCdzIHJlbGF0aXZlIHRvIG9iamVjdCBsZWZ0LiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWD17bGVmdC9jZW50ZXIvcmlnaHR9XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsZWZ0OiAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgd2lkdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBzY2FsZSBmYWN0b3IgKGhvcml6b250YWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yICh2ZXJ0aWNhbClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIGFzIGZsaXBwZWQgaG9yaXpvbnRhbGx5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmxpcFg6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIGFzIGZsaXBwZWQgdmVydGljYWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3BhY2l0eTogICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygcm90YXRpb24gb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYW5nbGU6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygc2tldyBvbiB4IGF4ZXMgb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tld1g6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQW5nbGUgb2Ygc2tldyBvbiB5IGF4ZXMgb2YgYW4gb2JqZWN0IChpbiBkZWdyZWVzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tld1k6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBvYmplY3QncyBjb250cm9sbGluZyBjb3JuZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTaXplOiAgICAgICAgICAgICAgIDEzLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiBvYmplY3QncyBjb250cm9sbGluZyBjb3JuZXJzIHdoZW4gdG91Y2ggaW50ZXJhY3Rpb24gaXMgZGV0ZWN0ZWRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRvdWNoQ29ybmVyU2l6ZTogICAgICAgICAgICAgICAyNCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyBhcmUgcmVuZGVyZWQgYXMgdHJhbnNwYXJlbnQgaW5zaWRlIChpLmUuIHN0cm9rZSBpbnN0ZWFkIG9mIGZpbGwpXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHJhbnNwYXJlbnRDb3JuZXJzOiAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhpcyBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW92ZUN1cnNvcjogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyBiZXR3ZWVuIG9iamVjdCBhbmQgaXRzIGNvbnRyb2xsaW5nIGJvcmRlcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhZGRpbmc6ICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGJvcmRlcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyQ29sb3I6ICAgICAgICAgICAgICAncmdiKDE3OCwyMDQsMjU1KScsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBib3JkZXJzIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgYm9yZGVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJDb2xvcjogICAgICAgICAgICAgICdyZ2IoMTc4LDIwNCwyNTUpJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlIGFuZCB0cmFuc3BhcmVudENvcm5lcnMgZmFsc2UpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb3JuZXJTdHJva2VDb2xvcjogICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0eWxlIG9mIGNvbnRyb2wsICdyZWN0JyBvciAnY2lyY2xlJ1xuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGNvcm5lclN0eWxlOiAgICAgICAgICAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBjb250cm9sIChoYXNCb3JkZXIgbXVzdCBiZSB0cnVlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29ybmVyRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgc2NhbGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGlzIG9iamVjdCB3aWxsIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvblxuICAgICAqIHdoZW4gYmVpbmcgcm90YXRlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygb2JqZWN0J3MgZmlsbFxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHJ1bGUgdXNlZCB0byBmaWxsIGFuIG9iamVjdFxuICAgICAqIGFjY2VwdGVkIHZhbHVlcyBhcmUgbm9uemVybywgZXZlbm9kZFxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIHVzZWQgZm9yIHNldHRpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHVudGlsIHYxLjQuMTIgKHVzZSBgZmFicmljLk9iamVjdCNnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25gIGluc3RlYWQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgICdub256ZXJvJyxcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2l0ZSBydWxlIHVzZWQgZm9yIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogJ3NvdXJjZS1vdmVyJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LlxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGlvbiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGFuIG9iamVjdC4gY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCB3aGVuIGl0IGlzIGFjdGl2ZS5cbiAgICAgKiBkb2VzIG5vdCBtaXggZ29vZCB3aXRoIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBtZXRob2RzLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yOiAgICAgICAgICAnJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvclxuICAgICAqIHRha2VzIGNzcyBjb2xvcnMgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci0zL1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBzdHJva2UgdXNlZCB0byByZW5kZXIgdGhpcyBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAoc3Ryb2tlIG11c3QgYmUgZGVmaW5lZClcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0cm9rZURhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIExpbmUgb2Zmc2V0IG9mIGFuIG9iamVjdCdzIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUNhcDogICAgICAgICAgICAnYnV0dCcsXG5cbiAgICAvKipcbiAgICAgKiBDb3JuZXIgc3R5bGUgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChvbmUgb2YgXCJiZXZlbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgJ21pdGVyJyxcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIDQsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZVxuICAgICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNoYWRvdzogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyB3aGVuIG9iamVjdCBpcyBhY3RpdmUgYW5kIG1vdmluZ1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyT3BhY2l0eVdoZW5Nb3Zpbmc6ICAwLjQsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3Igb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVyc1xuICAgICAqIGJpZ2dlciBudW1iZXIgd2lsbCBtYWtlIGEgdGhpY2tlciBib3JkZXJcbiAgICAgKiBib3JkZXIgaXMgMSwgc28gdGhpcyBpcyBiYXNpY2FsbHkgYSBib3JkZXIgdGhpY2tuZXNzXG4gICAgICogc2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIGNoYW5nZSB0aGUgYm9yZGVyIGl0c2VsZi5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlclNjYWxlRmFjdG9yOiAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gYWxsb3dlZCBzY2FsZSB2YWx1ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pblNjYWxlTGltaXQ6ICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBjYW4gbm90IGJlIHNlbGVjdGVkIGZvciBtb2RpZmljYXRpb24gKHVzaW5nIGVpdGhlciBwb2ludC1jbGljay1iYXNlZCBvciBncm91cC1iYXNlZCBzZWxlY3Rpb24pLlxuICAgICAqIEJ1dCBldmVudHMgc3RpbGwgZmlyZSBvbiBpdC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3RhYmxlOiAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBhIHRhcmdldCBvZiBldmVudHMuIEFsbCBldmVudHMgcHJvcGFnYXRlIHRocm91Z2ggaXQuIEludHJvZHVjZWQgaW4gdjEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXZlbnRlZDogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGlzIG5vdCByZW5kZXJlZCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aXNpYmxlOiAgICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBvYmplY3QncyBjb250cm9scyBhcmUgbm90IGRpc3BsYXllZCBhbmQgY2FuIG5vdCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgb2JqZWN0XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQ29udHJvbHM6ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbGxpbmcgYm9yZGVycyBhcmUgbm90IHJlbmRlcmVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGFzQm9yZGVyczogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBvYmplY3RzIGFyZSBcImZvdW5kXCIgb24gY2FudmFzIG9uIHBlci1waXhlbCBiYXNpcyByYXRoZXIgdGhhbiBhY2NvcmRpbmcgdG8gYm91bmRpbmcgYm94XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGVyUGl4ZWxUYXJnZXRGaW5kOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGZhbHNlYCwgZGVmYXVsdCBvYmplY3QncyB2YWx1ZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiBpdHMgc2VyaWFsaXphdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRYOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCB2ZXJ0aWNhbCBtb3ZlbWVudCBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrTW92ZW1lbnRZOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCByb3RhdGlvbiBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrUm90YXRpb246ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdYOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1k6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBjYW5ub3QgYmUgZmxpcHBlZCBieSBzY2FsaW5nIGludG8gbmVnYXRpdmUgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgbm90IGV4cG9ydGVkIGluIE9CSkVDVC9KU09OXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZXhjbHVkZUZyb21FeHBvcnQ6ICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaXMgY2FjaGVkIG9uIGFuIGFkZGl0aW9uYWwgY2FudmFzLlxuICAgICAqIFdoZW4gYGZhbHNlYCwgb2JqZWN0IGlzIG5vdCBjYWNoZWQgdW5sZXNzIG5lY2Vzc2FyeSAoIGNsaXBQYXRoIClcbiAgICAgKiBkZWZhdWx0IHRvIHRydWVcbiAgICAgKiBAc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG9iamVjdENhY2hpbmc6ICAgICAgICAgICAgb2JqZWN0Q2FjaGluZyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBmb3IgY2FjaGUgaW52YWxpZGF0aW9uLiBJbiBzb21lIHBhcnRpY3VsYXJcbiAgICAgKiBzaXR1YXRpb24geW91IG1heSB3YW50IHRoaXMgdG8gYmUgZGlzYWJsZWQgKCBzcHJheSBicnVzaCwgdmVyeSBiaWcsIGdyb3VwcylcbiAgICAgKiBvciBpZiB5b3VyIGFwcGxpY2F0aW9uIGRvZXMgbm90IGFsbG93IHlvdSB0byBtb2RpZnkgcHJvcGVydGllcyBmb3IgZ3JvdXBzIGNoaWxkIHlvdSB3YW50XG4gICAgICogdG8gZGlzYWJsZSBpdCBmb3IgZ3JvdXBzLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXRlZnVsbENhY2hlOiAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIGNhY2hlIGRvZXMgbm90IGdldCB1cGRhdGVkIGR1cmluZyBzY2FsaW5nLiBUaGUgcGljdHVyZSB3aWxsIGdldCBibG9ja3kgaWYgc2NhbGVkXG4gICAgICogdG9vIG11Y2ggYW5kIHdpbGwgYmUgcmVkcmF3biB3aXRoIGNvcnJlY3QgZGV0YWlscyBhdCB0aGUgZW5kIG9mIHNjYWxpbmcuXG4gICAgICogdGhpcyBzZXR0aW5nIGlzIHBlcmZvcm1hbmNlIGFuZCBhcHBsaWNhdGlvbiBkZXBlbmRhbnQuXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIHRoZSBzdG9rZSB3aWR0aCB3aWxsIHNjYWxlIHdpdGggdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIHN0cm9rZSB3aWxsIGFsd2F5cyBtYXRjaCB0aGUgZXhhY3QgcGl4ZWwgc2l6ZSBlbnRlcmVkIGZvciBzdHJva2Ugd2lkdGguXG4gICAgICogZGVmYXVsdCB0byBmYWxzZVxuICAgICAqIEBzaW5jZSAyLjYuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0cm9rZVVuaWZvcm06ICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0J3MgY2FjaGUgd2lsbCBiZSByZXJlbmRlcmVkIG5leHQgcmVuZGVyIGNhbGwuXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGRpcnR5OiAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICoga2VlcHMgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IGhvdmVyZWQgY29ybmVyIGR1cmluZyBtb3VzZSBtb3ZlLlxuICAgICAqIDAgaXMgbm8gY29ybmVyLCBvciAnbXQnLCAnbWwnLCAnbXRyJyBldGMuLlxuICAgICAqIEl0IHNob3VsZCBiZSBwcml2YXRlLCBidXQgdGhlcmUgaXMgbm8gaGFybSBpbiB1c2luZyBpdCBhc1xuICAgICAqIGEgcmVhZC1vbmx5IHByb3BlcnR5LlxuICAgICAqIEB0eXBlIG51bWJlcnxzdHJpbmd8YW55XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIF9fY29ybmVyOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZmlsbCBvciB0aGUgc3Ryb2tlIGlzIGRyYXduIGZpcnN0IChvbmUgb2YgXCJmaWxsXCIgb3IgXCJzdHJva2VcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhaW50Rmlyc3Q6ICAgICAgICAgICAnZmlsbCcsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZVxuICAgICAqIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkIChmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZClcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IChcbiAgICAgICd0b3AgbGVmdCB3aWR0aCBoZWlnaHQgc2NhbGVYIHNjYWxlWSBmbGlwWCBmbGlwWSBvcmlnaW5YIG9yaWdpblkgdHJhbnNmb3JtTWF0cml4ICcgK1xuICAgICAgJ3N0cm9rZSBzdHJva2VXaWR0aCBzdHJva2VEYXNoQXJyYXkgc3Ryb2tlTGluZUNhcCBzdHJva2VEYXNoT2Zmc2V0IHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgJyArXG4gICAgICAnYW5nbGUgb3BhY2l0eSBmaWxsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBzaGFkb3cgdmlzaWJsZSBiYWNrZ3JvdW5kQ29sb3IgJyArXG4gICAgICAnc2tld1ggc2tld1kgZmlsbFJ1bGUgcGFpbnRGaXJzdCBjbGlwUGF0aCBzdHJva2VVbmlmb3JtJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIGNhY2hlIG5lZWRzIHJlZnJlc2hcbiAgICAgKiBUaG9zZSBwcm9wZXJ0aWVzIGFyZSBjaGVja2VkIGJ5IHN0YXRlZnVsbENhY2hlIE9OICggb3IgbGF6eSBtb2RlIGlmIHdlIHdhbnQgKSBvciBmcm9tIHNpbmdsZVxuICAgICAqIGNhbGxzIHRvIE9iamVjdC5zZXQoa2V5LCB2YWx1ZSkuIElmIHRoZSBrZXkgaXMgaW4gdGhpcyBsaXN0LCB0aGUgb2JqZWN0IGlzIG1hcmtlZCBhcyBkaXJ0eVxuICAgICAqIGFuZCByZWZyZXNoZWQgYXQgdGhlIG5leHQgcmVuZGVyXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IChcbiAgICAgICdmaWxsIHN0cm9rZSBzdHJva2VXaWR0aCBzdHJva2VEYXNoQXJyYXkgd2lkdGggaGVpZ2h0IHBhaW50Rmlyc3Qgc3Ryb2tlVW5pZm9ybScgK1xuICAgICAgJyBzdHJva2VMaW5lQ2FwIHN0cm9rZURhc2hPZmZzZXQgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCBiYWNrZ3JvdW5kQ29sb3IgY2xpcFBhdGgnXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIGZvciBhbmltYXRpbmcgY29sb3JzLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29sb3JQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2UgYmFja2dyb3VuZENvbG9yJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIGEgZmFicmljT2JqZWN0IHRoYXQsIHdpdGhvdXQgc3Ryb2tlIGRlZmluZSBhIGNsaXBwaW5nIGFyZWEgd2l0aCB0aGVpciBzaGFwZS4gZmlsbGVkIGluIGJsYWNrXG4gICAgICogdGhlIGNsaXBQYXRoIG9iamVjdCBnZXRzIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGhhcyByZW5kZXJlZCwgYW5kIHRoZSBjb250ZXh0IGlzIHBsYWNlZCBpbiB0aGUgY2VudGVyXG4gICAgICogb2YgdGhlIG9iamVjdCBjYWNoZUNhbnZhcy5cbiAgICAgKiBJZiB5b3Ugd2FudCAwLDAgb2YgYSBjbGlwUGF0aCB0byBhbGlnbiB3aXRoIGFuIG9iamVjdCBjZW50ZXIsIHVzZSBjbGlwUGF0aC5vcmlnaW5YL1kgdG8gJ2NlbnRlcidcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgY2xpcFBhdGg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBtYWtlIHRoZSBvYmplY3QgY2xpcCB0byB0aGUgb3V0c2lkZSBvZiB0aGUgY2xpcFBhdGhcbiAgICAgKiBzaW5jZSAyLjQuMFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGludmVydGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBoYXZlIGl0cyB0b3AgYW5kIGxlZnQgcmVsYXRpdmUgdG8gY2FudmFzLCBhbmQgd2lsbFxuICAgICAqIG5vdCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBvYmplY3QgdHJhbnNmb3JtLiBUaGlzIHdpbGwgbWFrZSB0aGUgY2xpcFBhdGggcmVsYXRpdmVcbiAgICAgKiB0byB0aGUgY2FudmFzLCBidXQgY2xpcHBpbmcganVzdCBhIHBhcnRpY3VsYXIgb2JqZWN0LlxuICAgICAqIFdBUk5JTkcgdGhpcyBpcyBiZXRhLCB0aGlzIGZlYXR1cmUgbWF5IGNoYW5nZSBvciBiZSByZW5hbWVkLlxuICAgICAqIHNpbmNlIDIuNC4wXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgYWJzb2x1dGVQb3NpdGlvbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGhlIGNhbnZhcyB1c2VkIHRvIGtlZXAgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWNoZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gdGhpcy5fY2FjaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAvLyBpZiBjYW52YXMgZ2V0cyBjcmVhdGVkLCBpcyBlbXB0eSwgc28gZGlydHkuXG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGltaXQgdGhlIGNhY2hlIGRpbWVuc2lvbnMgc28gdGhhdCBYICogWSBkbyBub3QgY3Jvc3MgZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbFxuICAgICAqIGFuZCBlYWNoIHNpZGUgZG8gbm90IGNyb3NzIGZhYnJpYy5jYWNoZVNpZGVMaW1pdFxuICAgICAqIHRob3NlIG51bWJlcnMgYXJlIGNvbmZpZ3VyYWJsZSBzbyB0aGF0IHlvdSBjYW4gZ2V0IGFzIG11Y2ggZGV0YWlsIGFzIHlvdSB3YW50XG4gICAgICogbWFraW5nIGJhcmdhaW4gd2l0aCBwZXJmb3JtYW5jZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9saW1pdENhY2hlU2l6ZTogZnVuY3Rpb24oZGltcykge1xuICAgICAgdmFyIHBlcmZMaW1pdFNpemVUb3RhbCA9IGZhYnJpYy5wZXJmTGltaXRTaXplVG90YWwsXG4gICAgICAgICAgd2lkdGggPSBkaW1zLndpZHRoLCBoZWlnaHQgPSBkaW1zLmhlaWdodCxcbiAgICAgICAgICBtYXggPSBmYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQsIG1pbiA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdDtcbiAgICAgIGlmICh3aWR0aCA8PSBtYXggJiYgaGVpZ2h0IDw9IG1heCAmJiB3aWR0aCAqIGhlaWdodCA8PSBwZXJmTGltaXRTaXplVG90YWwpIHtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWluKSB7XG4gICAgICAgICAgZGltcy53aWR0aCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgbWluKSB7XG4gICAgICAgICAgZGltcy5oZWlnaHQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICB9XG4gICAgICB2YXIgYXIgPSB3aWR0aCAvIGhlaWdodCwgbGltaXRlZERpbXMgPSBmYWJyaWMudXRpbC5saW1pdERpbXNCeUFyZWEoYXIsIHBlcmZMaW1pdFNpemVUb3RhbCksXG4gICAgICAgICAgY2FwVmFsdWUgPSBmYWJyaWMudXRpbC5jYXBWYWx1ZSxcbiAgICAgICAgICB4ID0gY2FwVmFsdWUobWluLCBsaW1pdGVkRGltcy54LCBtYXgpLFxuICAgICAgICAgIHkgPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLnksIG1heCk7XG4gICAgICBpZiAod2lkdGggPiB4KSB7XG4gICAgICAgIGRpbXMuem9vbVggLz0gd2lkdGggLyB4O1xuICAgICAgICBkaW1zLndpZHRoID0geDtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCA+IHkpIHtcbiAgICAgICAgZGltcy56b29tWSAvPSBoZWlnaHQgLyB5O1xuICAgICAgICBkaW1zLmhlaWdodCA9IHk7XG4gICAgICAgIGRpbXMuY2FwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpbWVuc2lvbiBhbmQgdGhlIHpvb20gbGV2ZWwgbmVlZGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGNhbnZhc1xuICAgICAqIGJpZyBlbm91Z2ggdG8gaG9zdCB0aGUgb2JqZWN0IHRvIGJlIGNhY2hlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ueCB3aWR0aCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS55IGhlaWdodCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCksXG4gICAgICAgICAgLy8gY2FjdWxhdGUgZGltZW5zaW9ucyB3aXRob3V0IHNrZXdpbmdcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoMCwgMCksXG4gICAgICAgICAgbmVlZGVkWCA9IGRpbS54ICogb2JqZWN0U2NhbGUuc2NhbGVYIC8gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgbmVlZGVkWSA9IGRpbS55ICogb2JqZWN0U2NhbGUuc2NhbGVZIC8gdGhpcy5zY2FsZVk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBmb3Igc3VyZSB0aGlzIEFMSUFTSU5HX0xJTUlUIGlzIHNsaWdodGx5IGNyZWF0aW5nIHByb2JsZW1cbiAgICAgICAgLy8gaW4gc2l0dWF0aW9uIGluIHdoaWNoIHRoZSBjYWNoZSBjYW52YXMgZ2V0cyBhbiB1cHBlciBsaW1pdFxuICAgICAgICAvLyBhbHNvIG9iamVjdFNjYWxlIGNvbnRhaW5zIGFscmVhZHkgc2NhbGVYIGFuZCBzY2FsZVlcbiAgICAgICAgd2lkdGg6IG5lZWRlZFggKyBBTElBU0lOR19MSU1JVCxcbiAgICAgICAgaGVpZ2h0OiBuZWVkZWRZICsgQUxJQVNJTkdfTElNSVQsXG4gICAgICAgIHpvb21YOiBvYmplY3RTY2FsZS5zY2FsZVgsXG4gICAgICAgIHpvb21ZOiBvYmplY3RTY2FsZS5zY2FsZVksXG4gICAgICAgIHg6IG5lZWRlZFgsXG4gICAgICAgIHk6IG5lZWRlZFlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjYW52YXMgZm9yIGNhY2hlXG4gICAgICogcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGNhbnZhcyBuZWVkZWQgcmVzaXplLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRhcmdldENhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgaWYgKHRoaXMubm9TY2FsZUNhY2hlICYmIHRhcmdldENhbnZhcyAmJiB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldENhbnZhcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgICBhY3Rpb24gPSB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0uYWN0aW9uO1xuICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIGFjdGlvbi5zbGljZSAmJiBhY3Rpb24uc2xpY2UoMCwgNSkgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYWNoZUNhbnZhcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIG1pbkNhY2hlU2l6ZSA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LCBkcmF3aW5nV2lkdGgsIGRyYXdpbmdIZWlnaHQsXG4gICAgICAgICAgem9vbVggPSBkaW1zLnpvb21YLCB6b29tWSA9IGRpbXMuem9vbVksXG4gICAgICAgICAgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gdGhpcy5jYWNoZVdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5jYWNoZUhlaWdodCxcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRoaXMuem9vbVggIT09IHpvb21YIHx8IHRoaXMuem9vbVkgIT09IHpvb21ZLFxuICAgICAgICAgIHNob3VsZFJlZHJhdyA9IGRpbWVuc2lvbnNDaGFuZ2VkIHx8IHpvb21DaGFuZ2VkLFxuICAgICAgICAgIGFkZGl0aW9uYWxXaWR0aCA9IDAsIGFkZGl0aW9uYWxIZWlnaHQgPSAwLCBzaG91bGRSZXNpemVDYW52YXMgPSBmYWxzZTtcbiAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLl9jYWNoZUNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IHRoaXMuX2NhY2hlQ2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHNpemVHcm93aW5nID0gd2lkdGggPiBjYW52YXNXaWR0aCB8fCBoZWlnaHQgPiBjYW52YXNIZWlnaHQsXG4gICAgICAgICAgICBzaXplU2hyaW5raW5nID0gKHdpZHRoIDwgY2FudmFzV2lkdGggKiAwLjkgfHwgaGVpZ2h0IDwgY2FudmFzSGVpZ2h0ICogMC45KSAmJlxuICAgICAgICAgICAgICBjYW52YXNXaWR0aCA+IG1pbkNhY2hlU2l6ZSAmJiBjYW52YXNIZWlnaHQgPiBtaW5DYWNoZVNpemU7XG4gICAgICAgIHNob3VsZFJlc2l6ZUNhbnZhcyA9IHNpemVHcm93aW5nIHx8IHNpemVTaHJpbmtpbmc7XG4gICAgICAgIGlmIChzaXplR3Jvd2luZyAmJiAhZGltcy5jYXBwZWQgJiYgKHdpZHRoID4gbWluQ2FjaGVTaXplIHx8IGhlaWdodCA+IG1pbkNhY2hlU2l6ZSkpIHtcbiAgICAgICAgICBhZGRpdGlvbmFsV2lkdGggPSB3aWR0aCAqIDAuMTtcbiAgICAgICAgICBhZGRpdGlvbmFsSGVpZ2h0ID0gaGVpZ2h0ICogMC4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVkcmF3KSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNpemVDYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGggKyBhZGRpdGlvbmFsV2lkdGgpO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICsgYWRkaXRpb25hbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2luZ1dpZHRoID0gZGltcy54IC8gMjtcbiAgICAgICAgZHJhd2luZ0hlaWdodCA9IGRpbXMueSAvIDI7XG4gICAgICAgIHRoaXMuY2FjaGVUcmFuc2xhdGlvblggPSBNYXRoLnJvdW5kKGNhbnZhcy53aWR0aCAvIDIgLSBkcmF3aW5nV2lkdGgpICsgZHJhd2luZ1dpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChjYW52YXMuaGVpZ2h0IC8gMiAtIGRyYXdpbmdIZWlnaHQpICsgZHJhd2luZ0hlaWdodDtcbiAgICAgICAgdGhpcy5jYWNoZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC50cmFuc2xhdGUodGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5zY2FsZSh6b29tWCwgem9vbVkpO1xuICAgICAgICB0aGlzLnpvb21YID0gem9vbVg7XG4gICAgICAgIHRoaXMuem9vbVkgPSB6b29tWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5zdHJva2UsICdzdHJva2UnKTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKG9wdGlvbnMuZmlsbCwgJ2ZpbGwnKTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29udGV4dCB3aGVuIHJlbmRlcmluZyBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHRcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIG5lZWRGdWxsVHJhbnNmb3JtID0gKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHx8XG4gICAgICAgICAodGhpcy5ncm91cCAmJiB0aGlzLmNhbnZhcyAmJiBjdHggPT09IHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdmFyIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoIW5lZWRGdWxsVHJhbnNmb3JtKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuXG4gICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgdHlwZTogICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAgICAgICAgICAgICAgICAgIGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQ6ICAgICAgICAgdGhpcy5zdHJva2VEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICAgICAgc3Ryb2tlVW5pZm9ybTogICAgICAgICAgICB0aGlzLnN0cm9rZVVuaWZvcm0sXG4gICAgICAgICAgICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIHRvRml4ZWQodGhpcy5zdHJva2VNaXRlckxpbWl0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgYW5nbGU6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuYW5nbGUsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgZmxpcFg6ICAgICAgICAgICAgICAgICAgICB0aGlzLmZsaXBYLFxuICAgICAgICAgICAgZmxpcFk6ICAgICAgICAgICAgICAgICAgICB0aGlzLmZsaXBZLFxuICAgICAgICAgICAgb3BhY2l0eTogICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMub3BhY2l0eSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzaGFkb3c6ICAgICAgICAgICAgICAgICAgICh0aGlzLnNoYWRvdyAmJiB0aGlzLnNoYWRvdy50b09iamVjdCkgPyB0aGlzLnNoYWRvdy50b09iamVjdCgpIDogdGhpcy5zaGFkb3csXG4gICAgICAgICAgICB2aXNpYmxlOiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJ1bGUsXG4gICAgICAgICAgICBwYWludEZpcnN0OiAgICAgICAgICAgICAgIHRoaXMucGFpbnRGaXJzdCxcbiAgICAgICAgICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24sXG4gICAgICAgICAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aC50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoLmludmVydGVkID0gdGhpcy5jbGlwUGF0aC5pbnZlcnRlZDtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCA9IHRoaXMuY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fcmVtb3ZlRGVmYXVsdFZhbHVlcyhvYmplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIChkYXRhbGVzcykgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBzdWJjbGFzc2VzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICovXG4gICAgX3JlbW92ZURlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHByb3RvdHlwZSA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG9iamVjdC50eXBlKS5wcm90b3R5cGUsXG4gICAgICAgICAgc3RhdGVQcm9wZXJ0aWVzID0gcHJvdG90eXBlLnN0YXRlUHJvcGVydGllcztcbiAgICAgIHN0YXRlUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdsZWZ0JyB8fCBwcm9wID09PSAndG9wJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0W3Byb3BdID09PSBwcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FycmF5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdFtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XScgJiZcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvdG90eXBlW3Byb3BdKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuICAgICAgICAvLyBiYXNpY2FsbHkgYSBjaGVjayBmb3IgW10gPT09IFtdXG4gICAgICAgIGlmIChpc0FycmF5ICYmIG9iamVjdFtwcm9wXS5sZW5ndGggPT09IDAgJiYgcHJvdG90eXBlW3Byb3BdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuJyArIGNhcGl0YWxpemUodGhpcy50eXBlKSArICc+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgc2NhbGUgZmFjdG9yIGNvdW50aW5nIGFsc28gdGhlIGdyb3VwIHNjYWxpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIHNjYWxlWCBhbmQgc2NhbGVZIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UodGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBNYXRoLmFicyhvcHRpb25zLnNjYWxlWCksIHNjYWxlWTogTWF0aC5hYnMob3B0aW9ucy5zY2FsZVkpIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nLCB6b29tIGFuZCByZXRpbmFcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIHNjYWxlWCBhbmQgc2NhbGVZIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRUb3RhbE9iamVjdFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCksIHNjYWxlWCA9IHNjYWxlLnNjYWxlWCwgc2NhbGVZID0gc2NhbGUuc2NhbGVZO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHZhciB6b29tID0gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpO1xuICAgICAgICB2YXIgcmV0aW5hID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpO1xuICAgICAgICBzY2FsZVggKj0gem9vbSAqIHJldGluYTtcbiAgICAgICAgc2NhbGVZICo9IHpvb20gKiByZXRpbmE7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgb3BhY2l0eSBjb3VudGluZyBhbHNvIHRoZSBncm91cCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRPYmplY3RPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgb3BhY2l0eSAqPSB0aGlzLmdyb3VwLmdldE9iamVjdE9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzaG91bGRDb25zdHJhaW5WYWx1ZSA9IChrZXkgPT09ICdzY2FsZVgnIHx8IGtleSA9PT0gJ3NjYWxlWScpLFxuICAgICAgICAgIGlzQ2hhbmdlZCA9IHRoaXNba2V5XSAhPT0gdmFsdWUsIGdyb3VwTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZENvbnN0cmFpblZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fY29uc3RyYWluU2NhbGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NjYWxlWCcgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMuZmxpcFggPSAhdGhpcy5mbGlwWDtcbiAgICAgICAgdmFsdWUgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdzY2FsZVknICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBZID0gIXRoaXMuZmxpcFk7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2hhZG93JyAmJiB2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgZmFicmljLlNoYWRvdykpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgZmFicmljLlNoYWRvdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdkaXJ0eScgJiYgdGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgIGdyb3VwTmVlZHNVcGRhdGUgPSB0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdyb3VwTmVlZHNVcGRhdGUgJiYgdGhpcy5zdGF0ZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHRoZSBwYXJlbnQgZ3JvdXAgb2YgYW4gb2JqZWN0IGV2ZXJ5XG4gICAgICogdGltZSBhIG5vbi1kZWxlZ2F0ZWQgcHJvcGVydHkgY2hhbmdlcyBvbiB0aGUgZ3JvdXAuIEl0IGlzIHBhc3NlZCB0aGUga2V5XG4gICAgICogYW5kIHZhbHVlIGFzIHBhcmFtZXRlcnMuIE5vdCBhZGRpbmcgaW4gdGhpcyBmdW5jdGlvbidzIHNpZ25hdHVyZSB0byBhdm9pZFxuICAgICAqIFRyYXZpcyBidWlsZCBlcnJvciBhYm91dCB1bnVzZWQgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIHNldE9uR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHZpZXdwb3J0VHJhbnNmb3JtIGZyb20gT2JqZWN0J3MgY2FudmFzIGlmIHBvc3NpYmxlXG4gICAgICogQG1ldGhvZCBnZXRWaWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZXR1cm4gaWYgdGhlIG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGluIHJlbmRlcmluZ1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOb3RWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT09IDAgfHxcbiAgICAgICAgKCF0aGlzLndpZHRoICYmICF0aGlzLmhlaWdodCAmJiB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB8fFxuICAgICAgICAhdGhpcy52aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIG9iamVjdCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGlmIHdpZHRoL2hlaWdodCBhcmUgemVyb3Mgb3Igb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAodGhpcy5pc05vdFZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uKGN0eCk7XG4gICAgICB0aGlzLmRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5fc2V0T3BhY2l0eShjdHgpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KGN0eCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5zaG91bGRDYWNoZSgpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5kcmF3Q2FjaGVPbkNhbnZhcyhjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmF3T2JqZWN0KGN0eCk7XG4gICAgICAgIGlmICh0aGlzLm9iamVjdENhY2hpbmcgJiYgdGhpcy5zdGF0ZWZ1bGxDYWNoZSkge1xuICAgICAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICByZW5kZXJDYWNoZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIXRoaXMuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0NhY2hlRGlydHkoKSkge1xuICAgICAgICB0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICB0aGlzLmRyYXdPYmplY3QodGhpcy5fY2FjaGVDb250ZXh0LCBvcHRpb25zLmZvckNsaXBwaW5nKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY2FjaGVDYW52YXMgYW5kIGl0cyBkaW1lbnNpb25zIGZyb20gdGhlIG9iamVjdHNcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jYWNoZVdpZHRoID0gMDtcbiAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHdpbGwgZHJhdyBhIHN0cm9rZVxuICAgICAqIERvZXMgbm90IGNvbnNpZGVyIHRleHQgc3R5bGVzLiBUaGlzIGlzIGp1c3QgYSBzaG9ydGN1dCB1c2VkIGF0IHJlbmRlcmluZyB0aW1lXG4gICAgICogV2Ugd2FudCBpdCB0byBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCBiZSBmYXN0LlxuICAgICAqIHdyb3RlIHRvIGF2b2lkIGV4dHJhIGNhY2hpbmcsIGl0IGhhcyB0byByZXR1cm4gdHJ1ZSB3aGVuIHN0cm9rZSBoYXBwZW5zLFxuICAgICAqIGNhbiBndWVzcyB3aGVuIGl0IHdpbGwgbm90IGhhcHBlbiBhdCAxMDAlIGNoYW5jZSwgZG9lcyBub3QgbWF0dGVyIGlmIGl0IG1pc3Nlc1xuICAgICAqIHNvbWUgdXNlIGNhc2Ugd2hlcmUgdGhlIHN0cm9rZSBpcyBpbnZpc2libGUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqL1xuICAgIGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UgIT09ICd0cmFuc3BhcmVudCcgJiYgdGhpcy5zdHJva2VXaWR0aCAhPT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCB3aWxsIGRyYXcgYSBmaWxsXG4gICAgICogRG9lcyBub3QgY29uc2lkZXIgdGV4dCBzdHlsZXMuIFRoaXMgaXMganVzdCBhIHNob3J0Y3V0IHVzZWQgYXQgcmVuZGVyaW5nIHRpbWVcbiAgICAgKiBXZSB3YW50IGl0IHRvIGJlIGFuIGFwcHJveGltYXRpb24gYW5kIGJlIGZhc3QuXG4gICAgICogd3JvdGUgdG8gYXZvaWQgZXh0cmEgY2FjaGluZywgaXQgaGFzIHRvIHJldHVybiB0cnVlIHdoZW4gZmlsbCBoYXBwZW5zLFxuICAgICAqIGNhbiBndWVzcyB3aGVuIGl0IHdpbGwgbm90IGhhcHBlbiBhdCAxMDAlIGNoYW5jZSwgZG9lcyBub3QgbWF0dGVyIGlmIGl0IG1pc3Nlc1xuICAgICAqIHNvbWUgdXNlIGNhc2Ugd2hlcmUgdGhlIGZpbGwgaXMgaW52aXNpYmxlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKi9cbiAgICBoYXNGaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGwgJiYgdGhpcy5maWxsICE9PSAndHJhbnNwYXJlbnQnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIGZvcmNlIHRoZSBvYmplY3QgdG8gaGF2ZSBpdHMgb3duIGNhY2hlLCBldmVuIGlmIGl0IGlzIGluc2lkZSBhIGdyb3VwXG4gICAgICogaXQgbWF5IGJlIG5lZWRlZCB3aGVuIHlvdXIgb2JqZWN0IGJlaGF2ZSBpbiBhIHBhcnRpY3VsYXIgd2F5IG9uIHRoZSBjYWNoZSBhbmQgYWx3YXlzIG5lZWRzXG4gICAgICogaXRzIG93biBpc29sYXRlZCBjYW52YXMgdG8gcmVuZGVyIGNvcnJlY3RseS5cbiAgICAgKiBDcmVhdGVkIHRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKiBzaW5jZSAxLjcuMTJcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICovXG4gICAgbmVlZHNJdHNPd25DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJyAmJlxuICAgICAgICB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpICYmIHR5cGVvZiB0aGlzLnNoYWRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIFJlYWQgYXM6IGNhY2hlIGlmIGlzIG5lZWRlZCwgb3IgaWYgdGhlIGZlYXR1cmUgaXMgZW5hYmxlZCBidXQgd2UgYXJlIG5vdCBhbHJlYWR5IGNhY2hpbmcuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm93bkNhY2hpbmcgPSB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKSB8fCAoXG4gICAgICAgIHRoaXMub2JqZWN0Q2FjaGluZyAmJlxuICAgICAgICAoIXRoaXMuZ3JvdXAgfHwgIXRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLm93bkNhY2hpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIHVzZWQgYnkgR3JvdXAuc2hvdWxkQ2FjaGUgdG8ga25vdyBpZiBjaGlsZCBoYXMgYSBzaGFkb3cgcmVjdXJzaXZlbHlcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHdpbGxEcmF3U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2hhZG93ICYmICh0aGlzLnNoYWRvdy5vZmZzZXRYICE9PSAwIHx8IHRoaXMuc2hhZG93Lm9mZnNldFkgIT09IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IGNsaXBQYXRoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDbGlwUGF0aE9uQ2FjaGU6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIERFQlVHOiB1bmNvbW1lbnQgdGhpcyBsaW5lLCBjb21tZW50IHRoZSBmb2xsb3dpbmdcbiAgICAgIC8vIGN0eC5nbG9iYWxBbHBoYSA9IDAuNFxuICAgICAgaWYgKHBhdGguaW52ZXJ0ZWQpIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgICAgfVxuICAgICAgLy9jdHguc2NhbGUoMSAvIDIsIDEgLyAyKTtcbiAgICAgIGlmIChwYXRoLmFic29sdXRlUG9zaXRpb25lZCkge1xuICAgICAgICB2YXIgbSA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICB9XG4gICAgICBwYXRoLnRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyBwYXRoLnpvb21YLCAxIC8gcGF0aC56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHBhdGguX2NhY2hlQ2FudmFzLCAtcGF0aC5jYWNoZVRyYW5zbGF0aW9uWCwgLXBhdGguY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdPYmplY3Q6IGZ1bmN0aW9uKGN0eCwgZm9yQ2xpcHBpbmcpIHtcbiAgICAgIHZhciBvcmlnaW5hbEZpbGwgPSB0aGlzLmZpbGwsIG9yaWdpbmFsU3Ryb2tlID0gdGhpcy5zdHJva2U7XG4gICAgICBpZiAoZm9yQ2xpcHBpbmcpIHtcbiAgICAgICAgdGhpcy5maWxsID0gJ2JsYWNrJztcbiAgICAgICAgdGhpcy5zdHJva2UgPSAnJztcbiAgICAgICAgdGhpcy5fc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZChjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyKGN0eCk7XG4gICAgICB0aGlzLl9kcmF3Q2xpcFBhdGgoY3R4KTtcbiAgICAgIHRoaXMuZmlsbCA9IG9yaWdpbmFsRmlsbDtcbiAgICAgIHRoaXMuc3Ryb2tlID0gb3JpZ2luYWxTdHJva2U7XG4gICAgfSxcblxuICAgIF9kcmF3Q2xpcFBhdGg6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgaWYgKCFwYXRoKSB7IHJldHVybjsgfVxuICAgICAgLy8gbmVlZGVkIHRvIHNldHVwIGEgY291cGxlIG9mIHZhcmlhYmxlc1xuICAgICAgLy8gcGF0aCBjYW52YXMgZ2V0cyBvdmVycmlkZGVuIHdpdGggdGhpcyBvbmUuXG4gICAgICAvLyBUT0RPIGZpbmQgYSBiZXR0ZXIgc29sdXRpb24/XG4gICAgICBwYXRoLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgcGF0aC5zaG91bGRDYWNoZSgpO1xuICAgICAgcGF0aC5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICBwYXRoLnJlbmRlckNhY2hlKHsgZm9yQ2xpcHBpbmc6IHRydWUgfSk7XG4gICAgICB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FjaGUoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3Qgb24gdGhlIHRhcmdldCBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2FjaGVPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguc2NhbGUoMSAvIHRoaXMuem9vbVgsIDEgLyB0aGlzLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fY2FjaGVDYW52YXMsIC10aGlzLmNhY2hlVHJhbnNsYXRpb25YLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGRpcnR5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwQ2FudmFzIHNraXAgY2FudmFzIGNoZWNrcyBiZWNhdXNlIHRoaXMgb2JqZWN0IGlzIHBhaW50ZWRcbiAgICAgKiBvbiBwYXJlbnQgY2FudmFzLlxuICAgICAqL1xuICAgIGlzQ2FjaGVEaXJ0eTogZnVuY3Rpb24oc2tpcENhbnZhcykge1xuICAgICAgaWYgKHRoaXMuaXNOb3RWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzICYmICFza2lwQ2FudmFzICYmIHRoaXMuX3VwZGF0ZUNhY2hlQ2FudmFzKCkpIHtcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRoZSBjb250ZXh0IGlzIGFscmVhZHkgY2xlYXJlZC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgfHxcbiAgICAgICAgICAodGhpcy5jbGlwUGF0aCAmJiB0aGlzLmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCkgfHxcbiAgICAgICAgICAodGhpcy5zdGF0ZWZ1bGxDYWNoZSAmJiB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnY2FjaGVQcm9wZXJ0aWVzJykpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcyAmJiAhc2tpcENhbnZhcykge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYWNoZVdpZHRoIC8gdGhpcy56b29tWDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhY2hlSGVpZ2h0IC8gdGhpcy56b29tWTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGJhY2tncm91bmQgZm9yIHRoZSBvYmplY3QgYmlnIGFzIGl0cyB1bnRyYW5zZm9ybWVkIGRpbWVuc2lvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAtZGltLnggLyAyLFxuICAgICAgICAtZGltLnkgLyAyLFxuICAgICAgICBkaW0ueCxcbiAgICAgICAgZGltLnlcbiAgICAgICk7XG4gICAgICAvLyBpZiB0aGVyZSBpcyBiYWNrZ3JvdW5kIGNvbG9yIG5vIG90aGVyIHNoYWRvd3NcbiAgICAgIC8vIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0T3BhY2l0eTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5ncm91cCAmJiAhdGhpcy5ncm91cC5fdHJhbnNmb3JtRG9uZSkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmdldE9iamVjdE9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0U3Ryb2tlU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIHZhciBzdHJva2UgPSBkZWNsLnN0cm9rZTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gZGVjbC5zdHJva2VMaW5lQ2FwO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkZWNsLnN0cm9rZURhc2hPZmZzZXQ7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGRlY2wuc3Ryb2tlTGluZUpvaW47XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gZGVjbC5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgICBpZiAoc3Ryb2tlLnRvTGl2ZSkge1xuICAgICAgICAgIGlmIChzdHJva2UuZ3JhZGllbnRVbml0cyA9PT0gJ3BlcmNlbnRhZ2UnIHx8IHN0cm9rZS5ncmFkaWVudFRyYXNuZm9ybSB8fCBzdHJva2UucGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFuc2Zvcm0gZ3JhZGllbnQgaW4gYSBwYXR0ZXJuLlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNsb3cgcHJvY2Vzcy4gSWYgeW91IGFyZSBoaXR0aW5nIHRoaXMgY29kZXBhdGgsIGFuZCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAvLyBpcyBub3QgdXNpbmcgY2FjaGluZywgeW91IHNob3VsZCBjb25zaWRlciBzd2l0Y2hpbmcgaXQgb24uXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgY2FudmFzIGFzIGJpZyBhcyB0aGUgY3VycmVudCBvYmplY3QgY2FjaGluZyBjYW52YXMuXG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5Gb3JUcmFuc2Zvcm1lZEdyYWRpZW50KGN0eCwgc3Ryb2tlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyBhIHNpbXBsZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIHN0cm9rZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGlzIGEgY29sb3JcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBkZWNsLnN0cm9rZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0RmlsbFN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICB2YXIgZmlsbCA9IGRlY2wuZmlsbDtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGlmIChmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgZGVjbC5maWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXRzIGxpbmUgZGFzaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBzZXQgdGhlIGRhc2ggbGluZSBvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhc2hBcnJheSBhcnJheSByZXByZXNlbnRpbmcgZGFzaGVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWx0ZXJuYXRpdmUgZnVuY3Rpb24gdG8gY2FsbCBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbGluZURhc2hcbiAgICAgKi9cbiAgICBfc2V0TGluZURhc2g6IGZ1bmN0aW9uKGN0eCwgZGFzaEFycmF5LCBhbHRlcm5hdGl2ZSkge1xuICAgICAgaWYgKCFkYXNoQXJyYXkgfHwgZGFzaEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTcGVjIHJlcXVpcmVzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHR3byBjb3BpZXMgdGhlIGRhc2ggbGlzdCB3aGVuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgb2RkXG4gICAgICBpZiAoMSAmIGRhc2hBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgZGFzaEFycmF5LnB1c2guYXBwbHkoZGFzaEFycmF5LCBkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzTGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWx0ZXJuYXRpdmUgJiYgYWx0ZXJuYXRpdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMsIGRyYXdCb3JkZXJzLCBkcmF3Q29udHJvbHM7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7IH07XG4gICAgICBkcmF3Qm9yZGVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0JvcmRlcnMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzIDogdGhpcy5oYXNCb3JkZXJzO1xuICAgICAgZHJhd0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHM7XG4gICAgICBtYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHZwdCwgbWF0cml4KTtcbiAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShtYXRyaXgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEgKiB0aGlzLmJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZU92ZXJyaWRlLmZvckFjdGl2ZVNlbGVjdGlvbikge1xuICAgICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5hbmdsZSkpO1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzSW5Hcm91cChjdHgsIG9wdGlvbnMsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICAgIGRyYXdCb3JkZXJzICYmIHRoaXMuZHJhd0JvcmRlcnMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGRyYXdDb250cm9scyAmJiB0aGlzLmRyYXdDb250cm9scyhjdHgsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldFNoYWRvdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYWRvdyA9IHRoaXMuc2hhZG93LCBjYW52YXMgPSB0aGlzLmNhbnZhcywgc2NhbGluZyxcbiAgICAgICAgICBtdWx0WCA9IChjYW52YXMgJiYgY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzBdKSB8fCAxLFxuICAgICAgICAgIG11bHRZID0gKGNhbnZhcyAmJiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm1bM10pIHx8IDE7XG4gICAgICBpZiAoc2hhZG93Lm5vblNjYWxpbmcpIHtcbiAgICAgICAgc2NhbGluZyA9IHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgICAgbXVsdFggKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIG11bHRZICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfVxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gc2hhZG93LmNvbG9yO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1ciAqIGZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ICpcbiAgICAgICAgKG11bHRYICsgbXVsdFkpICogKHNjYWxpbmcuc2NhbGVYICsgc2NhbGluZy5zY2FsZVkpIC8gNDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFggKiBtdWx0WCAqIHNjYWxpbmcuc2NhbGVYO1xuICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WSAqIG11bHRZICogc2NhbGluZy5zY2FsZVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGxlciBmYWJyaWMuUGF0dGVybiBvciBmYWJyaWMuR3JhZGllbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9mZnNldC5vZmZzZXRYIG9mZnNldCBmb3IgdGV4dCByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9mZnNldC5vZmZzZXRZIG9mZnNldCBmb3IgdGV4dCByZW5kZXJpbmdcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCwgZmlsbGVyKSB7XG4gICAgICBpZiAoIWZpbGxlciB8fCAhZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICByZXR1cm4geyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgICB9XG4gICAgICB2YXIgdCA9IGZpbGxlci5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsZXIucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgIHZhciBvZmZzZXRYID0gLXRoaXMud2lkdGggLyAyICsgZmlsbGVyLm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMiArIGZpbGxlci5vZmZzZXRZIHx8IDA7XG5cbiAgICAgIGlmIChmaWxsZXIuZ3JhZGllbnRVbml0cyA9PT0gJ3BlcmNlbnRhZ2UnKSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odGhpcy53aWR0aCwgMCwgMCwgdGhpcy5oZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICB9XG4gICAgICBpZiAodCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKHRbMF0sIHRbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogb2Zmc2V0WCwgb2Zmc2V0WTogb2Zmc2V0WSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyUGFpbnRJbk9yZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgPT09ICdzdHJva2UnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGFjdHVhbGx5IHJlbmRlciBzb21ldGhpbmcgb24gdGhlIGNvbnRleHQuXG4gICAgICogZW1wdHkgaGVyZSB0byBhbGxvdyBPYmVjdHMgdG8gd29yayBvbiB0ZXN0cyB0byBiZW5jaG1hcmsgZmFicmljIGZ1bmN0aW9uYWxpdGVzXG4gICAgICogbm90IHJlbGF0ZWQgdG8gcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKC8qIGN0eCAqLykge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIGlmICh0aGlzLmZpbGxSdWxlID09PSAnZXZlbm9kZCcpIHtcbiAgICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZVVuaWZvcm0gJiYgdGhpcy5ncm91cCkge1xuICAgICAgICB2YXIgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxpbmcuc2NhbGVYLCAxIC8gc2NhbGluZy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJva2VVbmlmb3JtKSB7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8gdGhpcy5zY2FsZVgsIDEgLyB0aGlzLnNjYWxlWSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5LCB0aGlzLl9yZW5kZXJEYXNoZWRTdHJva2UpO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgdGhpcyk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyeSB0byBwYXRjaCB0aGUgbWlzc2luZyBncmFkaWVudFRyYW5zZm9ybSBvbiBjYW52YXMgZ3JhZGllbnRzLlxuICAgICAqIHRyYW5zZm9ybWluZyBhIGNvbnRleHQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCwgaXMgZ29pbmcgdG8gdHJhbnNmb3JtIHRoZSBzdHJva2UgdG9vLlxuICAgICAqIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCBidXQgbm90IHRoZSBzdHJva2Ugb3BlcmF0aW9uLCBzbyB3ZSBjcmVhdGVcbiAgICAgKiBhIHRyYW5zZm9ybWVkIGdyYWRpZW50IG9uIGEgcGF0dGVybiBhbmQgdGhlbiB3ZSB1c2UgdGhlIHBhdHRlcm4gaW5zdGVhZCBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGRyd2FiYWNrczogaXMgc2xvdywgaXMgaW4gbG93IHJlc29sdXRpb24sIG5lZWRzIGEgcGF0Y2ggZm9yIHdoZW4gdGhlIHNpemVcbiAgICAgKiBpcyBsaW1pdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLkdyYWRpZW50fSBmaWxsZXIgYSBmYWJyaWMgZ3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudDogZnVuY3Rpb24oY3R4LCBmaWxsZXIpIHtcbiAgICAgIHZhciBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIHBDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksIHBDdHgsIHJldGluYVNjYWxpbmcgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksXG4gICAgICAgICAgd2lkdGggPSBkaW1zLnggLyB0aGlzLnNjYWxlWCAvIHJldGluYVNjYWxpbmcsIGhlaWdodCA9IGRpbXMueSAvIHRoaXMuc2NhbGVZIC8gcmV0aW5hU2NhbGluZztcbiAgICAgIHBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LnNjYWxlKFxuICAgICAgICBkaW1zLnpvb21YIC8gdGhpcy5zY2FsZVggLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICBkaW1zLnpvb21ZIC8gdGhpcy5zY2FsZVkgLyByZXRpbmFTY2FsaW5nXG4gICAgICApO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0ocEN0eCwgZmlsbGVyKTtcbiAgICAgIHBDdHguZmlsbFN0eWxlID0gZmlsbGVyLnRvTGl2ZShjdHgpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10aGlzLndpZHRoIC8gMiAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIpO1xuICAgICAgY3R4LnNjYWxlKFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVggLyBkaW1zLnpvb21YLFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVkgLyBkaW1zLnpvb21ZXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0IGluIHRoZSBzdmdcbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBwb2ludCBmcm9tIGVsZW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBfZmluZENlbnRlckZyb21FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMubGVmdCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgZGVjb21wb3NlIHRoZSB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBhbmQgYXNzaWduIHByb3BlcnRpZXMgdG8gb2JqZWN0LlxuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UodGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICAgIHRoaXMuc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgICB0aGlzLnNrZXdZID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJlbW92ZXMgdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBhbmQgc2V0IHRvIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgZmFicmljanMgY2FuIGhhbmRsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zXG4gICAgICogQHJldHVybiB7dGhpc0FyZ31cbiAgICAgKi9cbiAgICBfcmVtb3ZlVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucykge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2ZpbmRDZW50ZXJGcm9tRWxlbWVudCgpO1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHRoaXMuX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzKCk7XG4gICAgICAgIGNlbnRlciA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KGNlbnRlciwgdGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBudWxsO1xuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NhbGVYICo9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLnNjYWxlWDtcbiAgICAgICAgdGhpcy5zY2FsZVkgKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVZO1xuICAgICAgICB0aGlzLmNyb3BYID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuY3JvcFg7XG4gICAgICAgIHRoaXMuY3JvcFkgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWTtcbiAgICAgICAgY2VudGVyLnggKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0TGVmdDtcbiAgICAgICAgY2VudGVyLnkgKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0VG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGFuIGluc3RhbmNlLCB1c2luZyBhIGNhbGxiYWNrIG1ldGhvZCB3aWxsIHdvcmsgZm9yIGV2ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpcyBpbnZva2VkIHdpdGggYSBjbG9uZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihjYWxsYmFjaywgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdEZvcm0gPSB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3Qob2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ09iamVjdCcsIG9iamVjdEZvcm0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2Ugb3V0IG9mIGFuIG9iamVjdFxuICAgICAqIG1ha2VzIHVzZSBvZiB0b0NhbnZhc0VsZW1lbnQuXG4gICAgICogT25jZSB0aGlzIG1ldGhvZCB3YXMgYmFzZWQgb24gdG9EYXRhVXJsIGFuZCBsb2FkSW1hZ2UsIHNvIGl0IGFsc28gaGFkIGEgcXVhbGl0eVxuICAgICAqIGFuZCBmb3JtYXQgb3B0aW9uLiB0b0NhbnZhc0VsZW1lbnQgaXMgZmFzdGVyIGFuZCBwcm9kdWNlIG5vIGxvc3Mgb2YgcXVhbGl0eS5cbiAgICAgKiBJZiB5b3UgbmVlZCB0byBnZXQgYSByZWFsIEpwZWcgb3IgUG5nIGZyb20gYW4gb2JqZWN0LCB1c2luZyB0b0RhdGFVUkwgaXMgdGhlIHJpZ2h0IHdheSB0byBkbyBpdC5cbiAgICAgKiB0b0NhbnZhc0VsZW1lbnQgYW5kIHRoZW4gdG9CbG9iIGZyb20gdGhlIG9idGFpbmVkIGNhbnZhcyBpcyBhbHNvIGEgZ29vZCBvcHRpb24uXG4gICAgICogVGhpcyBtZXRob2QgaXMgc3luYyBub3csIGJ1dCBzdGlsbCBzdXBwb3J0IHRoZSBjYWxsYmFjayBiZWNhdXNlIHdlIGRpZCBub3Qgd2FudCB0byBicmVhay5cbiAgICAgKiBXaGVuIGZhYnJpY0pTIDUuMCB3aWxsIGJlIHBsYW5uZWQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZSBjaGFuZ2VkIHRvIG5vdCBoYXZlIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2ssIGludm9rZWQgd2l0aCBhbiBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBmb3IgY2xvbmUgYXMgaW1hZ2UsIHBhc3NlZCB0byB0b0RhdGFVUkxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0VHJhbnNmb3JtXSBSZW1vdmUgY3VycmVudCBvYmplY3QgdHJhbnNmb3JtICggbm8gc2NhbGUgLCBubyBhbmdsZSwgbm8gZmxpcCwgbm8gc2tldyApLiBJbnRyb2R1Y2VkIGluIDIuMy40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0U2hhZG93XSBSZW1vdmUgY3VycmVudCBvYmplY3Qgc2hhZG93LiBJbnRyb2R1Y2VkIGluIDIuNC4yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNsb25lQXNJbWFnZTogZnVuY3Rpb24oY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYW52YXNFbCA9IHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UoY2FudmFzRWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEhUTUxDYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBSZXR1cm5zIERPTSBlbGVtZW50IDxjYW52YXM+IHdpdGggdGhlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICB0b0NhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgdXRpbHMgPSBmYWJyaWMudXRpbCwgb3JpZ1BhcmFtcyA9IHV0aWxzLnNhdmVPYmplY3RUcmFuc2Zvcm0odGhpcyksXG4gICAgICAgICAgb3JpZ2luYWxHcm91cCA9IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgb3JpZ2luYWxTaGFkb3cgPSB0aGlzLnNoYWRvdywgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgbXVsdGlwbGllciA9IChvcHRpb25zLm11bHRpcGxpZXIgfHwgMSkgKiAob3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nID8gZmFicmljLmRldmljZVBpeGVsUmF0aW8gOiAxKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3VwO1xuICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICB1dGlscy5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndpdGhvdXRTaGFkb3cpIHtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgLy8gc2tpcCBjYW52YXMgem9vbSBhbmQgY2FsY3VsYXRlIHdpdGggc2V0Q29vcmRzIG5vdy5cbiAgICAgICAgICBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0cnVlLCB0cnVlKSxcbiAgICAgICAgICBzaGFkb3cgPSB0aGlzLnNoYWRvdywgc2NhbGluZyxcbiAgICAgICAgICBzaGFkb3dPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfSwgc2hhZG93Qmx1cixcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIHNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcbiAgICAgICAgaWYgKHNoYWRvdy5ub25TY2FsaW5nKSB7XG4gICAgICAgICAgc2NhbGluZyA9IHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc2lkZXIgbm9uIHNjYWxpbmcgc2hhZG93LlxuICAgICAgICBzaGFkb3dPZmZzZXQueCA9IDIgKiBNYXRoLnJvdW5kKGFicyhzaGFkb3cub2Zmc2V0WCkgKyBzaGFkb3dCbHVyKSAqIChhYnMoc2NhbGluZy5zY2FsZVgpKTtcbiAgICAgICAgc2hhZG93T2Zmc2V0LnkgPSAyICogTWF0aC5yb3VuZChhYnMoc2hhZG93Lm9mZnNldFkpICsgc2hhZG93Qmx1cikgKiAoYWJzKHNjYWxpbmcuc2NhbGVZKSk7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCArIHNoYWRvd09mZnNldC54O1xuICAgICAgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCArIHNoYWRvd09mZnNldC55O1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgd2lkdGgvaGVpZ2h0IGlzIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgaXQgc28uXG4gICAgICBlbC53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgICBlbC5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICAgIHZhciBjYW52YXMgPSBuZXcgZmFicmljLlN0YXRpY0NhbnZhcyhlbCwge1xuICAgICAgICBlbmFibGVSZXRpbmFTY2FsaW5nOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmU6IGZhbHNlLFxuICAgICAgICBza2lwT2Zmc2NyZWVuOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnanBlZycpIHtcbiAgICAgICAgY2FudmFzLmJhY2tncm91bmRDb2xvciA9ICcjZmZmJztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbihuZXcgZmFicmljLlBvaW50KGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKSwgJ2NlbnRlcicsICdjZW50ZXInKTtcblxuICAgICAgdmFyIG9yaWdpbmFsQ2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKHRoaXMpO1xuICAgICAgdmFyIGNhbnZhc0VsID0gY2FudmFzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyIHx8IDEsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zaGFkb3cgPSBvcmlnaW5hbFNoYWRvdztcbiAgICAgIHRoaXMuc2V0KCdjYW52YXMnLCBvcmlnaW5hbENhbnZhcyk7XG4gICAgICBpZiAob3JpZ2luYWxHcm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwID0gb3JpZ2luYWxHcm91cDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgLy8gY2FudmFzLmRpc3Bvc2Ugd2lsbCBjYWxsIGltYWdlLmRpc3Bvc2UgdGhhdCB3aWxsIG51bGxpZnkgdGhlIGVsZW1lbnRzXG4gICAgICAvLyBzaW5jZSB0aGlzIGNhbnZhcyBpcyBhIHNpbXBsZSBlbGVtZW50IGZvciB0aGUgcHJvY2Vzcywgd2UgcmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIC8vIHRvIG9iamVjdHMgaW4gdGhpcyB3YXkgaW4gb3JkZXIgdG8gYXZvaWQgb2JqZWN0IHRyYXNoaW5nLlxuICAgICAgY2FudmFzLl9vYmplY3RzID0gW107XG4gICAgICBjYW52YXMuZGlzcG9zZSgpO1xuICAgICAgY2FudmFzID0gbnVsbDtcblxuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudG9EYXRhVVJMKHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpLCBvcHRpb25zLmZvcm1hdCB8fCAncG5nJywgb3B0aW9ucy5xdWFsaXR5IHx8IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlIChpcyAxIHVubGVzcyBzdWJjbGFzc2VkKVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJhbmdsZVwiIG9mIGFuIGluc3RhbmNlIHdpdGggY2VudGVyZWQgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgQW5nbGUgdmFsdWUgKGluIGRlZ3JlZXMpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICB2YXIgc2hvdWxkQ2VudGVyT3JpZ2luID0gKHRoaXMub3JpZ2luWCAhPT0gJ2NlbnRlcicgfHwgdGhpcy5vcmlnaW5ZICE9PSAnY2VudGVyJykgJiYgdGhpcy5jZW50ZXJlZFJvdGF0aW9uO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3NldE9yaWdpblRvQ2VudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCdhbmdsZScsIGFuZ2xlKTtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9yZXNldE9yaWdpbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXMgd2FzIGFkZGVkIGxhc3RcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3Qgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciByZWxhdGl2ZSB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIG9wZXJhdGUgdXBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0gUG9pbnRlciB0byBvcGVyYXRlIHVwb24gKGluc3RlYWQgb2YgZXZlbnQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgKHgsIHkpXG4gICAgICovXG4gICAgZ2V0TG9jYWxQb2ludGVyOiBmdW5jdGlvbihlLCBwb2ludGVyKSB7XG4gICAgICBwb2ludGVyID0gcG9pbnRlciB8fCB0aGlzLmNhbnZhcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdmFyIHBDbGlja2VkID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG4gICAgICAgICAgb2JqZWN0TGVmdFRvcCA9IHRoaXMuX2dldExlZnRUb3BDb29yZHMoKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHBDbGlja2VkID0gZmFicmljLnV0aWwucm90YXRlUG9pbnQoXG4gICAgICAgICAgcENsaWNrZWQsIG9iamVjdExlZnRUb3AsIGRlZ3JlZXNUb1JhZGlhbnMoLXRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBDbGlja2VkLnggLSBvYmplY3RMZWZ0VG9wLngsXG4gICAgICAgIHk6IHBDbGlja2VkLnkgLSBvYmplY3RMZWZ0VG9wLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBmb3Igc3BlY2lmaWMgb2JqZWN0XG4gICAgICogY3VzdG9tIGNvbXBvc2l0aW9uIG9wZXJhdGlvbiBmb3IgdGhlIHBhcnRpY3VsYXIgb2JqZWN0IGNhbiBiZSBzcGVjaWZpZWQgdXNpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBSZW5kZXJpbmcgY2FudmFzIGNvbnRleHRcbiAgICAgKi9cbiAgICBfc2V0dXBDb21wb3NpdGVPcGVyYXRpb246IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbikge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5PYmplY3QpO1xuXG4gIGV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIHVzZSB3aGVuIHNlcmlhbGl6aW5nIG9iamVjdCB2YWx1ZXMuXG4gICAqIFlvdSBjYW4gdXNlIGl0IHRvIGluY3JlYXNlL2RlY3JlYXNlIHByZWNpc2lvbiBvZiBzdWNoIHZhbHVlcyBsaWtlIGxlZnQsIHRvcCwgc2NhbGVYLCBzY2FsZVksIGV0Yy5cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMgPSAyO1xuXG4gIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QgPSBmdW5jdGlvbihjbGFzc05hbWUsIG9iamVjdCwgY2FsbGJhY2ssIGV4dHJhUGFyYW0pIHtcbiAgICB2YXIga2xhc3MgPSBmYWJyaWNbY2xhc3NOYW1lXTtcbiAgICBvYmplY3QgPSBjbG9uZShvYmplY3QsIHRydWUpO1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5QYXR0ZXJucyhbb2JqZWN0LmZpbGwsIG9iamVjdC5zdHJva2VdLCBmdW5jdGlvbihwYXR0ZXJucykge1xuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuc1swXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LmZpbGwgPSBwYXR0ZXJuc1swXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zdHJva2UgPSBwYXR0ZXJuc1sxXTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtvYmplY3QuY2xpcFBhdGhdLCBmdW5jdGlvbihlbmxpdmVkUHJvcHMpIHtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoID0gZW5saXZlZFByb3BzWzBdO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBleHRyYVBhcmFtID8gbmV3IGtsYXNzKG9iamVjdFtleHRyYVBhcmFtXSwgb2JqZWN0KSA6IG5ldyBrbGFzcyhvYmplY3QpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVW5pcXVlIGlkIHVzZWQgaW50ZXJuYWxseSB3aGVuIGNyZWF0aW5nIFNWRyBlbGVtZW50c1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5fX3VpZCA9IDA7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG9yaWdpblhPZmZzZXQgPSB7XG4gICAgICAgIGxlZnQ6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgcmlnaHQ6IDAuNVxuICAgICAgfSxcbiAgICAgIG9yaWdpbllPZmZzZXQgPSB7XG4gICAgICAgIHRvcDogLTAuNSxcbiAgICAgICAgY2VudGVyOiAwLFxuICAgICAgICBib3R0b206IDAuNVxuICAgICAgfTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gYSBzZXQgb2Ygb3JpZ2luIHRvIGFub3RoZXIgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21PcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbU9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9PcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9PcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW46IGZ1bmN0aW9uKHBvaW50LCBmcm9tT3JpZ2luWCwgZnJvbU9yaWdpblksIHRvT3JpZ2luWCwgdG9PcmlnaW5ZKSB7XG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgICAgb2Zmc2V0WCwgb2Zmc2V0WSwgZGltO1xuXG4gICAgICBpZiAodHlwZW9mIGZyb21PcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcm9tT3JpZ2luWCA9IG9yaWdpblhPZmZzZXRbZnJvbU9yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZyb21PcmlnaW5YIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b09yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvT3JpZ2luWCA9IG9yaWdpblhPZmZzZXRbdG9PcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b09yaWdpblggLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBvZmZzZXRYID0gdG9PcmlnaW5YIC0gZnJvbU9yaWdpblg7XG5cbiAgICAgIGlmICh0eXBlb2YgZnJvbU9yaWdpblkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21PcmlnaW5ZID0gb3JpZ2luWU9mZnNldFtmcm9tT3JpZ2luWV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZnJvbU9yaWdpblkgLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRvT3JpZ2luWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9PcmlnaW5ZID0gb3JpZ2luWU9mZnNldFt0b09yaWdpblldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvT3JpZ2luWSAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldFkgPSB0b09yaWdpblkgLSBmcm9tT3JpZ2luWTtcblxuICAgICAgaWYgKG9mZnNldFggfHwgb2Zmc2V0WSkge1xuICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgICAgeCA9IHBvaW50LnggKyBvZmZzZXRYICogZGltLng7XG4gICAgICAgIHkgPSBwb2ludC55ICsgb2Zmc2V0WSAqIGRpbS55O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBvcmlnaW4gdG8gY2VudGVyIGNvb3JkaW5hdGVzIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb0NlbnRlclBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4ocG9pbnQsIG9yaWdpblgsIG9yaWdpblksICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocCwgcG9pbnQsIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gY2VudGVyIHRvIG9yaWdpbiBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gY2VudGVyIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9PcmlnaW5Qb2ludDogZnVuY3Rpb24oY2VudGVyLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJywgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocCwgY2VudGVyLCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWFsIGNlbnRlciBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZWZ0VG9wID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQobGVmdFRvcCwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIGNlbnRlciBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIC8vIGdldE9yaWdpblBvaW50OiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYXMgaWYgaXQgaGFzIGEgZGlmZmVyZW50IG9yaWdpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRQb2ludEJ5T3JpZ2luOiBmdW5jdGlvbihvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBpbiBsb2NhbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGdsb2JhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0b0xvY2FsUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIHAsIHAyO1xuXG4gICAgICBpZiAodHlwZW9mIG9yaWdpblggIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcmlnaW5ZICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJywgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcCA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gICAgICB9XG5cbiAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHAyID0gZmFicmljLnV0aWwucm90YXRlUG9pbnQocDIsIGNlbnRlciwgLWRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAyLnN1YnRyYWN0RXF1YWxzKHApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBpbiBnbG9iYWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICAvLyB0b0dsb2JhbFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgIC8vICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHBvaW50LCB0aGlzLmdldENlbnRlclBvaW50KCksIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpLmFkZEVxdWFscyhuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBvYmplY3QncyBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9zIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgc2V0UG9zaXRpb25CeU9yaWdpbjogZnVuY3Rpb24ocG9zLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KHBvcywgb3JpZ2luWCwgb3JpZ2luWSksXG4gICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgICB0aGlzLnNldCgnbGVmdCcsIHBvc2l0aW9uLngpO1xuICAgICAgdGhpcy5zZXQoJ3RvcCcsIHBvc2l0aW9uLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG8gT25lIG9mICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgKi9cbiAgICBhZGp1c3RQb3NpdGlvbjogZnVuY3Rpb24odG8pIHtcbiAgICAgIHZhciBhbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgaHlwb3RGdWxsID0gdGhpcy5nZXRTY2FsZWRXaWR0aCgpLFxuICAgICAgICAgIHhGdWxsID0gZmFicmljLnV0aWwuY29zKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICB5RnVsbCA9IGZhYnJpYy51dGlsLnNpbihhbmdsZSkgKiBoeXBvdEZ1bGwsXG4gICAgICAgICAgb2Zmc2V0RnJvbSwgb2Zmc2V0VG87XG5cbiAgICAgIC8vVE9ETzogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb25zaWRlciBtaXhlZCBzaXR1YXRpb24gbGlrZSB0b3AsIGNlbnRlci5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICBvZmZzZXRGcm9tID0gb3JpZ2luWE9mZnNldFt0aGlzLm9yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldEZyb20gPSB0aGlzLm9yaWdpblggLSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJykge1xuICAgICAgICBvZmZzZXRUbyA9IG9yaWdpblhPZmZzZXRbdG9dO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldFRvID0gdG8gLSAwLjU7XG4gICAgICB9XG4gICAgICB0aGlzLmxlZnQgKz0geEZ1bGwgKiAob2Zmc2V0VG8gLSBvZmZzZXRGcm9tKTtcbiAgICAgIHRoaXMudG9wICs9IHlGdWxsICogKG9mZnNldFRvIC0gb2Zmc2V0RnJvbSk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5vcmlnaW5YID0gdG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9yaWdpbi9wb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGl0J3MgY2VudGVyIHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9zZXRPcmlnaW5Ub0NlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblggPSB0aGlzLm9yaWdpblg7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkgPSB0aGlzLm9yaWdpblk7XG5cbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG5cbiAgICAgIHRoaXMub3JpZ2luWCA9ICdjZW50ZXInO1xuICAgICAgdGhpcy5vcmlnaW5ZID0gJ2NlbnRlcic7XG5cbiAgICAgIHRoaXMubGVmdCA9IGNlbnRlci54O1xuICAgICAgdGhpcy50b3AgPSBjZW50ZXIueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBvcmlnaW4vcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0byBpdCdzIG9yaWdpbmFsIG9yaWdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfcmVzZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9yaWdpblBvaW50ID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KFxuICAgICAgICB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZKTtcblxuICAgICAgdGhpcy5vcmlnaW5YID0gdGhpcy5fb3JpZ2luYWxPcmlnaW5YO1xuICAgICAgdGhpcy5vcmlnaW5ZID0gdGhpcy5fb3JpZ2luYWxPcmlnaW5ZO1xuXG4gICAgICB0aGlzLmxlZnQgPSBvcmlnaW5Qb2ludC54O1xuICAgICAgdGhpcy50b3AgPSBvcmlnaW5Qb2ludC55O1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblggPSBudWxsO1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGVmdFRvcENvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgJ2xlZnQnLCAndG9wJyk7XG4gICAgfSxcbiAgfSk7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIGFycmF5RnJvbUNvb3Jkcyhjb29yZHMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMudGwueCwgY29vcmRzLnRsLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMudHIueCwgY29vcmRzLnRyLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMuYnIueCwgY29vcmRzLmJyLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMuYmwueCwgY29vcmRzLmJsLnkpXG4gICAgXTtcbiAgfVxuXG4gIHZhciB1dGlsID0gZmFicmljLnV0aWwsXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gdXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgbXVsdGlwbHlNYXRyaWNlcyA9IHV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcbiAgICAgIHRyYW5zZm9ybVBvaW50ID0gdXRpbC50cmFuc2Zvcm1Qb2ludDtcblxuICB1dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBlbGVtZW50IGNvb3JkaW5hdGVzLlxuICAgICAqIHByb3BlcnRpZXMgYXJlIGRlcGVuZGluZyBvbiBjb250cm9sIGtleXMgYW5kIHBhZGRpbmcgdGhlIG1haW4gY29udHJvbHMuXG4gICAgICogZWFjaCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB4LCB5IGFuZCBjb3JuZXIuXG4gICAgICogVGhlIGBjb3JuZXJgIHByb3BlcnR5IGNvbnRhaW5zIGluIGEgc2ltaWxhciBtYW5uZXIgdGhlIDQgcG9pbnRzIG9mIHRoZVxuICAgICAqIGludGVyYWN0aXZlIGFyZWEgb2YgdGhlIGNvcm5lci5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZGVwZW5kcyBmcm9tIHRoZSBjb250cm9scyBwb3NpdGlvbkhhbmRsZXIgYW5kIGFyZSB1c2VkXG4gICAgICogdG8gZHJhdyBhbmQgbG9jYXRlIGNvbnRyb2xzXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgb0Nvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgb2JqZWN0IGFic29sdXRlIGNvb3JkaW5hdGVzXG4gICAgICogcHJvcGVydGllcyBhcmUgdGwsdHIsYmwsYnIgYW5kIGRlc2NyaWJlIHRoZSBmb3VyIG1haW4gY29ybmVyLlxuICAgICAqIGVhY2ggcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggeCwgeSwgaW5zdGFuY2Ugb2YgRmFicmljLlBvaW50LlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBkZXBlbmRzIGZyb20gdGhpcyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0LCBzY2FsZVgsIHNjYWxlWVxuICAgICAqIHNrZXdYLCBza2V3WSwgYW5nbGUsIHN0cm9rZVdpZHRoLCB0b3AsIGxlZnQuXG4gICAgICogVGhvc2UgY29vcmRpbmF0ZXMgYXJlIHVzZWZ1bCB0byB1bmRlcnN0YW5kIHdoZXJlIGFuIG9iamVjdCBpcy4gVGhleSBnZXQgdXBkYXRlZFxuICAgICAqIHdpdGggb0Nvb3JkcyBidXQgdGhleSBkbyBub3QgbmVlZCB0byBiZSB1cGRhdGVkIHdoZW4gem9vbSBvciBwYW5uaW5nIGNoYW5nZS5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIHNldENvb3Jkcy5cbiAgICAgKiBZb3UgY2FuIGNhbGN1bGF0ZSB0aGVtIHdpdGhvdXQgdXBkYXRpbmcgd2l0aCBAbWV0aG9kIGNhbGNBQ29vcmRzKCk7XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgYUNvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgZWxlbWVudCBjb29yZGluYXRlcy5cbiAgICAgKiBpbmNsdWRlcyBwYWRkaW5nLiBVc2VkIG9mIG9iamVjdCBkZXRlY3Rpb24uXG4gICAgICogc2V0IGFuZCByZWZyZXNoZWQgd2l0aCBzZXRDb29yZHMgYW5kIGNhbGNDb29yZHMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgbGluZUNvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHN0b3JhZ2UgZm9yIG9iamVjdCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgb3duTWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgZnVsbCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgbWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBjdXN0b20gY29udHJvbHMgaW50ZXJmYWNlXG4gICAgICogY29udHJvbHMgYXJlIGFkZGVkIGJ5IGRlZmF1bHRfY29udHJvbHMuanNcbiAgICAgKi9cbiAgICBjb250cm9sczogeyB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNvcnJlY3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGZvciBpbnRlcnNlY3Rpb25cbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIGVpdGhlciBhQ29vcmRzIG9yIGxpbmVDb29yZHMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSB3aWxsIHJldHVybiBhQ29vcmRzIGlmIHRydWUgb3IgbGluZUNvb3Jkc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0ge3RsLCB0ciwgYnIsIGJsfSBwb2ludHNcbiAgICAgKi9cbiAgICBfZ2V0Q29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoY2FsY3VsYXRlKSB7XG4gICAgICAgIHJldHVybiAoYWJzb2x1dGUgPyB0aGlzLmNhbGNBQ29vcmRzKCkgOiB0aGlzLmNhbGNMaW5lQ29vcmRzKCkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmFDb29yZHMgfHwgIXRoaXMubGluZUNvb3Jkcykge1xuICAgICAgICB0aGlzLnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoYWJzb2x1dGUgPyB0aGlzLmFDb29yZHMgOiB0aGlzLmxpbmVDb29yZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gY29ycmVjdCBzZXQgb2YgY29vcmRpbmF0ZXMgZm9yIGludGVyc2VjdGlvblxuICAgICAqIHRoaXMgd2lsbCByZXR1cm4gZWl0aGVyIGFDb29yZHMgb3IgbGluZUNvb3Jkcy5cbiAgICAgKiBUaGUgY29vcmRzIGFyZSByZXR1cm5lZCBpbiBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gW3RsLCB0ciwgYnIsIGJsXSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBnZXRDb29yZHM6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHJldHVybiBhcnJheUZyb21Db29yZHModGhpcy5fZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aFJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUoXG4gICAgICAgICAgICBjb29yZHMsXG4gICAgICAgICAgICBwb2ludFRMLFxuICAgICAgICAgICAgcG9pbnRCUlxuICAgICAgICAgICk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnN0YXR1cyA9PT0gJ0ludGVyc2VjdGlvbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIE9iamVjdCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgb2JqZWN0XG4gICAgICovXG4gICAgaW50ZXJzZWN0c1dpdGhPYmplY3Q6IGZ1bmN0aW9uKG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbihcbiAgICAgICAgdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgIG90aGVyLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbi5zdGF0dXMgPT09ICdJbnRlcnNlY3Rpb24nXG4gICAgICAgIHx8IG90aGVyLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMsIGFic29sdXRlLCBjYWxjdWxhdGUpXG4gICAgICAgIHx8IHRoaXMuaXNDb250YWluZWRXaXRoaW5PYmplY3Qob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBvZiBhbm90aGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBPYmplY3QgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBvZiBhbm90aGVyIG9iamVjdFxuICAgICAqL1xuICAgIGlzQ29udGFpbmVkV2l0aGluT2JqZWN0OiBmdW5jdGlvbihvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICAgIG90aGVyQ29vcmRzID0gYWJzb2x1dGUgPyBvdGhlci5hQ29vcmRzIDogb3RoZXIubGluZUNvb3JkcyxcbiAgICAgICAgICBpID0gMCwgbGluZXMgPSBvdGhlci5fZ2V0SW1hZ2VMaW5lcyhvdGhlckNvb3Jkcyk7XG4gICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBpZiAoIW90aGVyLmNvbnRhaW5zUG9pbnQocG9pbnRzW2ldLCBsaW5lcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5SZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ID49IHBvaW50VEwueCAmJlxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCArIGJvdW5kaW5nUmVjdC53aWR0aCA8PSBwb2ludEJSLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCA+PSBwb2ludFRMLnkgJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCArIGJvdW5kaW5nUmVjdC5oZWlnaHQgPD0gcG9pbnRCUi55XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGluZXNdIG9iamVjdCByZXR1cm5lZCBmcm9tIEBtZXRob2QgX2dldEltYWdlTGluZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQsIGxpbmVzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5fZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICAgIGxpbmVzID0gbGluZXMgfHwgdGhpcy5fZ2V0SW1hZ2VMaW5lcyhjb29yZHMpLFxuICAgICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMocG9pbnQsIGxpbmVzKTtcbiAgICAgIC8vIGlmIHhQb2ludHMgaXMgb2RkIHRoZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgIHJldHVybiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIHRoZSBjaGVjayBpcyBkb25lIHN0b3BwaW5nIGF0IGZpcnN0IHBvaW50IHRoYXQgYXBwZWFycyBvbiBzY3JlZW5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLmFDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBvciBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiBjYW52YXNcbiAgICAgKi9cbiAgICBpc09uU2NyZWVuOiBmdW5jdGlvbihjYWxjdWxhdGUpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50VEwgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMudGwsIHBvaW50QlIgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMuYnI7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRDb29yZHModHJ1ZSwgY2FsY3VsYXRlKTtcbiAgICAgIC8vIGlmIHNvbWUgcG9pbnQgaXMgb24gc2NyZWVuLCB0aGUgb2JqZWN0IGlzIG9uIHNjcmVlbi5cbiAgICAgIGlmIChwb2ludHMuc29tZShmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA8PSBwb2ludEJSLnggJiYgcG9pbnQueCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgcG9pbnQueSA8PSBwb2ludEJSLnkgJiYgcG9pbnQueSA+PSBwb2ludFRMLnk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIG5vIHBvaW50cyBvbiBzY3JlZW4sIGNoZWNrIGludGVyc2VjdGlvbiB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzXG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzV2l0aFJlY3QocG9pbnRUTCwgcG9pbnRCUiwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluc0NlbnRlck9mQ2FudmFzKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBtaWRwb2ludCBiZXR3ZWVuIGNhbnZhcyBleHRyZW1pdGllc1xuICAgICAqIERvZXMgbm90IG1ha2Ugc2Vuc2Ugb3V0c2lkZSB0aGUgY29udGV4dCBvZiBpc09uU2NyZWVuIGFuZCBpc1BhcnRpYWxseU9uU2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRUTCBUb3AgTGVmdCBwb2ludFxuICAgICAqIEBwYXJhbSB7RmFicmljLlBvaW50fSBwb2ludEJSIFRvcCBSaWdodCBwb2ludFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FsY3VsYXRlIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIHBvaW50XG4gICAgICovXG4gICAgX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXM6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSkge1xuICAgICAgLy8gd29yc3QgY2FzZSBzY2VuYXJpbyB0aGUgb2JqZWN0IGlzIHNvIGJpZyB0aGF0IGNvbnRhaW5zIHRoZSBzY3JlZW5cbiAgICAgIHZhciBjZW50ZXJQb2ludCA9IHsgeDogKHBvaW50VEwueCArIHBvaW50QlIueCkgLyAyLCB5OiAocG9pbnRUTC55ICsgcG9pbnRCUi55KSAvIDIgfTtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQoY2VudGVyUG9pbnQsIG51bGwsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiBjYW52YXNcbiAgICAgKi9cbiAgICBpc1BhcnRpYWxseU9uU2NyZWVuOiBmdW5jdGlvbihjYWxjdWxhdGUpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50VEwgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMudGwsIHBvaW50QlIgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMuYnI7XG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzV2l0aFJlY3QocG9pbnRUTCwgcG9pbnRCUiwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBhbGxQb2ludHNBcmVPdXRzaWRlID0gdGhpcy5nZXRDb29yZHModHJ1ZSwgY2FsY3VsYXRlKS5ldmVyeShmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKHBvaW50LnggPj0gcG9pbnRCUi54IHx8IHBvaW50LnggPD0gcG9pbnRUTC54KSAmJlxuICAgICAgICAocG9pbnQueSA+PSBwb2ludEJSLnkgfHwgcG9pbnQueSA8PSBwb2ludFRMLnkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWxsUG9pbnRzQXJlT3V0c2lkZSAmJiB0aGlzLl9jb250YWluc0NlbnRlck9mQ2FudmFzKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIG9iamVjdCBlZGdlcyBpbiBpdCwgZ2l2ZW4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb0Nvb3JkcyBDb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGNvcm5lcnNcbiAgICAgKi9cbiAgICBfZ2V0SW1hZ2VMaW5lczogZnVuY3Rpb24ob0Nvb3Jkcykge1xuXG4gICAgICB2YXIgbGluZXMgPSB7XG4gICAgICAgIHRvcGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudHJcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50cixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJyXG4gICAgICAgIH0sXG4gICAgICAgIGJvdHRvbWxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYmxcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudGxcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gLy8gZGVidWdnaW5nXG4gICAgICAvLyBpZiAodGhpcy5jYW52YXMuY29udGV4dFRvcCkge1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuZC54LCBsaW5lcy5ib3R0b21saW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5vLngsIGxpbmVzLmJvdHRvbWxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuZC54LCBsaW5lcy5sZWZ0bGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLm8ueCwgbGluZXMubGVmdGxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5kLngsIGxpbmVzLnRvcGxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLm8ueCwgbGluZXMudG9wbGluZS5vLnksIDIsIDIpO1xuICAgICAgLy9cbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuZC54LCBsaW5lcy5yaWdodGxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuby54LCBsaW5lcy5yaWdodGxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBob3cgbWFueSBjcm9zcyBwb2ludHMgYXJlIGJldHdlZW4gdGhlIDQgb2JqZWN0IGVkZ2VzXG4gICAgICogYW5kIHRoZSBob3Jpem9udGFsIGxpbmUgZGV0ZXJtaW5lZCBieSBhIHBvaW50IG9uIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpbmVzIENvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmVpbmcgZXZhbHVhdGVkXG4gICAgICovXG4gICAgLy8gcmVtb3ZlIHlpLCBub3QgdXNlZCBidXQgbGVmdCBjb2RlIGhlcmUganVzdCBpbiBjYXNlLlxuICAgIF9maW5kQ3Jvc3NQb2ludHM6IGZ1bmN0aW9uKHBvaW50LCBsaW5lcykge1xuICAgICAgdmFyIGIxLCBiMiwgYTEsIGEyLCB4aSwgLy8geWksXG4gICAgICAgICAgeGNvdW50ID0gMCxcbiAgICAgICAgICBpTGluZTtcblxuICAgICAgZm9yICh2YXIgbGluZUtleSBpbiBsaW5lcykge1xuICAgICAgICBpTGluZSA9IGxpbmVzW2xpbmVLZXldO1xuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMTogbGluZSBiZWxvdyBwb2ludC4gbm8gY3Jvc3NcbiAgICAgICAgaWYgKChpTGluZS5vLnkgPCBwb2ludC55KSAmJiAoaUxpbmUuZC55IDwgcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMjogbGluZSBhYm92ZSBwb2ludC4gbm8gY3Jvc3NcbiAgICAgICAgaWYgKChpTGluZS5vLnkgPj0gcG9pbnQueSkgJiYgKGlMaW5lLmQueSA+PSBwb2ludC55KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAzOiB2ZXJ0aWNhbCBsaW5lIGNhc2VcbiAgICAgICAgaWYgKChpTGluZS5vLnggPT09IGlMaW5lLmQueCkgJiYgKGlMaW5lLm8ueCA+PSBwb2ludC54KSkge1xuICAgICAgICAgIHhpID0gaUxpbmUuby54O1xuICAgICAgICAgIC8vIHlpID0gcG9pbnQueTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBiMSA9IDA7XG4gICAgICAgICAgYjIgPSAoaUxpbmUuZC55IC0gaUxpbmUuby55KSAvIChpTGluZS5kLnggLSBpTGluZS5vLngpO1xuICAgICAgICAgIGExID0gcG9pbnQueSAtIGIxICogcG9pbnQueDtcbiAgICAgICAgICBhMiA9IGlMaW5lLm8ueSAtIGIyICogaUxpbmUuby54O1xuXG4gICAgICAgICAgeGkgPSAtKGExIC0gYTIpIC8gKGIxIC0gYjIpO1xuICAgICAgICAgIC8vIHlpID0gYTEgKyBiMSAqIHhpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbnQgY291bnQgeGkgPCBwb2ludC54IGNhc2VzXG4gICAgICAgIGlmICh4aSA+PSBwb2ludC54KSB7XG4gICAgICAgICAgeGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDQ6IHNwZWNpZmljIGZvciBzcXVhcmUgaW1hZ2VzXG4gICAgICAgIGlmICh4Y291bnQgPT09IDIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHhjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiB0aGUgYm94IGlzIGludGVuZGVkIGFzIGFsaWduZWQgdG8gYXhpcyBvZiBjYW52YXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzIC8gLmFDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbihhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG4gICAgICByZXR1cm4gdXRpbC5tYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzKGNvb3Jkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldFdpZHRoKCk7XG4gICAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlaWdodCBvZiBhbiBvYmplY3QgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldEhlaWdodCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0U2NhbGVkSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBzY2FsZSBpcyB2YWxpZCBhbmQgbW9kaWZpZXMgaXQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgX2NvbnN0cmFpblNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IHRoaXMubWluU2NhbGVMaW1pdCkge1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC10aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWluU2NhbGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCAoZXF1YWxseSBieSB4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBTY2FsZSBmYWN0b3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVgnLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9zZXQoJ3NjYWxlWScsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gd2lkdGgsIHdpdGggcmVzcGVjdCB0byBib3VuZGluZyBib3ggKHNjYWxpbmcgYnkgeC95IGVxdWFsbHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE5ldyB3aWR0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvV2lkdGg6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkud2lkdGggLyB0aGlzLmdldFNjYWxlZFdpZHRoKCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMud2lkdGggLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gaGVpZ2h0LCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgaGVpZ2h0IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSBpZ25vcmUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9IZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkuaGVpZ2h0IC8gdGhpcy5nZXRTY2FsZWRIZWlnaHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy5oZWlnaHQgLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSAuY29vcmRzIG9mIGFuIG9iamVjdC5cbiAgICAgKiB1bnVzZWQgYnkgdGhlIGxpYnJhcnksIG9ubHkgZm9yIHRoZSBlbmQgZGV2LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggdGwsIHRyLCBiciwgYmwgLi4uLlxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGNhbGNDb29yZHM6IGZ1bmN0aW9uKGFic29sdXRlKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgY29tcGF0aWJpbGl0eSBmdW5jdGlvbiB0byBhdm9pZCByZW1vdmluZyBjYWxjQ29vcmRzIG5vdy5cbiAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjQUNvb3JkcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsY09Db29yZHMoKTtcbiAgICB9LFxuXG4gICAgY2FsY0xpbmVDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBwYWRkaW5nID0gdGhpcy5wYWRkaW5nLCBhbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgY29zID0gdXRpbC5jb3MoYW5nbGUpLCBzaW4gPSB1dGlsLnNpbihhbmdsZSksXG4gICAgICAgICAgY29zUCA9IGNvcyAqIHBhZGRpbmcsIHNpblAgPSBzaW4gKiBwYWRkaW5nLCBjb3NQU2luUCA9IGNvc1AgKyBzaW5QLFxuICAgICAgICAgIGNvc1BNaW51c1NpblAgPSBjb3NQIC0gc2luUCwgYUNvb3JkcyA9IHRoaXMuY2FsY0FDb29yZHMoKTtcblxuICAgICAgdmFyIGxpbmVDb29yZHMgPSB7XG4gICAgICAgIHRsOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLnRsLCB2cHQpLFxuICAgICAgICB0cjogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy50ciwgdnB0KSxcbiAgICAgICAgYmw6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMuYmwsIHZwdCksXG4gICAgICAgIGJyOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLmJyLCB2cHQpLFxuICAgICAgfTtcblxuICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgbGluZUNvb3Jkcy50bC54IC09IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMudGwueSAtPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy50ci54ICs9IGNvc1BTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLnRyLnkgLT0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ibC54IC09IGNvc1BTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJsLnkgKz0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ici54ICs9IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYnIueSArPSBjb3NQU2luUDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmVDb29yZHM7XG4gICAgfSxcblxuICAgIGNhbGNPQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCksXG4gICAgICAgICAgdHJhbnNsYXRlTWF0cml4ID0gdGhpcy5fY2FsY1RyYW5zbGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBzdGFydE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModnB0LCB0cmFuc2xhdGVNYXRyaXgpLFxuICAgICAgICAgIGZpbmFsTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhzdGFydE1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMoZmluYWxNYXRyaXgsIFsxIC8gdnB0WzBdLCAwLCAwLCAxIC8gdnB0WzNdLCAwLCAwXSksXG4gICAgICAgICAgZGltID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBjb29yZHMgPSB7fTtcbiAgICAgIHRoaXMuZm9yRWFjaENvbnRyb2woZnVuY3Rpb24oY29udHJvbCwga2V5LCBmYWJyaWNPYmplY3QpIHtcbiAgICAgICAgY29vcmRzW2tleV0gPSBjb250cm9sLnBvc2l0aW9uSGFuZGxlcihkaW0sIGZpbmFsTWF0cml4LCBmYWJyaWNPYmplY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRlYnVnIGNvZGVcbiAgICAgIC8vIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIC8vIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGNhbnZhcy5jb250ZXh0VG9wLmNsZWFyUmVjdCgwLCAwLCA3MDAsIDcwMCk7XG4gICAgICAvLyAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxTdHlsZSA9ICdncmVlbic7XG4gICAgICAvLyAgIE9iamVjdC5rZXlzKGNvb3JkcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIC8vICAgICB2YXIgY29udHJvbCA9IGNvb3Jkc1trZXldO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGNvbnRyb2wueCwgY29udHJvbC55LCAzLCAzKTtcbiAgICAgIC8vICAgfSk7XG4gICAgICAvLyB9LCA1MCk7XG4gICAgICByZXR1cm4gY29vcmRzO1xuICAgIH0sXG5cbiAgICBjYWxjQUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm90YXRlTWF0cml4ID0gdGhpcy5fY2FsY1JvdGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModHJhbnNsYXRlTWF0cml4LCByb3RhdGVNYXRyaXgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHcgPSBkaW0ueCAvIDIsIGggPSBkaW0ueSAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBjb3JuZXJzXG4gICAgICAgIHRsOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgIHRyOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IHcsIHk6IC1oIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgYmw6IHRyYW5zZm9ybVBvaW50KHsgeDogLXcsIHk6IGggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICBicjogdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiBoIH0sIGZpbmFsTWF0cml4KVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb3JuZXIgYW5kIGNvbnRyb2xzIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGJhc2VkIG9uIGN1cnJlbnQgYW5nbGUsIHdpZHRoIGFuZCBoZWlnaHQsIGxlZnQgYW5kIHRvcC5cbiAgICAgKiBvQ29vcmRzIGFyZSB1c2VkIHRvIGZpbmQgdGhlIGNvcm5lcnNcbiAgICAgKiBhQ29vcmRzIGFyZSB1c2VkIHRvIHF1aWNrbHkgZmluZCBhbiBvYmplY3Qgb24gdGhlIGNhbnZhc1xuICAgICAqIGxpbmVDb29yZHMgYXJlIHVzZWQgdG8gcXVpY2tseSBmaW5kIG9iamVjdCBkdXJpbmcgcG9pbnRlciBldmVudHMuXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy93aWtpL1doZW4tdG8tY2FsbC1zZXRDb29yZHN8V2hlbi10by1jYWxsLXNldENvb3Jkc31cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ29ybmVyc10gc2tpcCBjYWxjdWxhdGlvbiBvZiBvQ29vcmRzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29vcmRzOiBmdW5jdGlvbihza2lwQ29ybmVycykge1xuICAgICAgdGhpcy5hQ29vcmRzID0gdGhpcy5jYWxjQUNvb3JkcygpO1xuICAgICAgLy8gaW4gY2FzZSB3ZSBhcmUgaW4gYSBncm91cCwgZm9yIGhvdyB0aGUgaW5uZXIgZ3JvdXAgdGFyZ2V0IGNoZWNrIHdvcmtzLFxuICAgICAgLy8gbGluZUNvb3JkcyBhcmUgZXhhY3RseSBhQ29vcmRzLiBTaW5jZSB0aGUgdnB0IGdldHMgYWJzb3JiZWQgYnkgdGhlIG5vcm1hbGl6ZWQgcG9pbnRlci5cbiAgICAgIHRoaXMubGluZUNvb3JkcyA9IHRoaXMuZ3JvdXAgPyB0aGlzLmFDb29yZHMgOiB0aGlzLmNhbGNMaW5lQ29vcmRzKCk7XG4gICAgICBpZiAoc2tpcENvcm5lcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBzZXQgY29vcmRpbmF0ZXMgb2YgdGhlIGRyYWdnYWJsZSBib3hlcyBpbiB0aGUgY29ybmVycyB1c2VkIHRvIHNjYWxlL3JvdGF0ZSB0aGUgaW1hZ2VcbiAgICAgIHRoaXMub0Nvb3JkcyA9IHRoaXMuY2FsY09Db29yZHMoKTtcbiAgICAgIHRoaXMuX3NldENvcm5lckNvb3JkcyAmJiB0aGlzLl9zZXRDb3JuZXJDb29yZHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgcm90YXRpb24gbWF0cml4IG9mIGFuIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSByb3RhdGlvbiBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBfY2FsY1JvdGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdXRpbC5jYWxjUm90YXRlTWF0cml4KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCBmb3IgYW4gb2JqZWN0IHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge0FycmF5fSByb3RhdGlvbiBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBfY2FsY1RyYW5zbGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxLCBjZW50ZXIueCwgY2VudGVyLnldO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1NYXRyaXhLZXk6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgdmFyIHNlcCA9ICdfJywgcHJlZml4ID0gJyc7XG4gICAgICBpZiAoIXNraXBHcm91cCAmJiB0aGlzLmdyb3VwKSB7XG4gICAgICAgIHByZWZpeCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtTWF0cml4S2V5KHNraXBHcm91cCkgKyBzZXA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHByZWZpeCArIHRoaXMudG9wICsgc2VwICsgdGhpcy5sZWZ0ICsgc2VwICsgdGhpcy5zY2FsZVggKyBzZXAgKyB0aGlzLnNjYWxlWSArXG4gICAgICAgIHNlcCArIHRoaXMuc2tld1ggKyBzZXAgKyB0aGlzLnNrZXdZICsgc2VwICsgdGhpcy5hbmdsZSArIHNlcCArIHRoaXMub3JpZ2luWCArIHNlcCArIHRoaXMub3JpZ2luWSArXG4gICAgICAgIHNlcCArIHRoaXMud2lkdGggKyBzZXAgKyB0aGlzLmhlaWdodCArIHNlcCArIHRoaXMuc3Ryb2tlV2lkdGggKyB0aGlzLmZsaXBYICsgdGhpcy5mbGlwWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRyYW5zZm9ybSBtYXRyaXggdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9ucyBmcm9tIHRoZVxuICAgICAqIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEdyb3VwXSByZXR1cm4gdHJhbnNmb3JtIG1hdHJpeCBmb3Igb2JqZWN0IG5vdCBjb3VudGluZyBwYXJlbnQgdHJhbnNmb3JtYXRpb25zXG4gICAgICogVGhlcmUgYXJlIHNvbWUgc2l0dWF0aW9uIGluIHdoaWNoIHRoaXMgaXMgdXNlZnVsIHRvIGF2b2lkIHRoZSBmYWtlIHJvdGF0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0cmFuc2Zvcm0gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY1RyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24oc2tpcEdyb3VwKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgICBpZiAoc2tpcEdyb3VwIHx8ICF0aGlzLmdyb3VwKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkoc2tpcEdyb3VwKSwgY2FjaGUgPSB0aGlzLm1hdHJpeENhY2hlIHx8ICh0aGlzLm1hdHJpeENhY2hlID0ge30pO1xuICAgICAgaWYgKGNhY2hlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KGZhbHNlKSwgbWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIGNhY2hlLnZhbHVlID0gbWF0cml4O1xuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRyYW5zZm9ybSBtYXRyaXggdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9ucyBmcm9tIHRoZVxuICAgICAqIG9iamVjdCdzIHByb3BlcnRpZXMsIHRoaXMgbWF0cml4IGRvZXMgbm90IGluY2x1ZGUgdGhlIGdyb3VwIHRyYW5zZm9ybWF0aW9uXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRyYW5zZm9ybSBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjT3duTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLnRyYW5zZm9ybU1hdHJpeEtleSh0cnVlKSwgY2FjaGUgPSB0aGlzLm93bk1hdHJpeENhY2hlIHx8ICh0aGlzLm93bk1hdHJpeENhY2hlID0ge30pO1xuICAgICAgaWYgKGNhY2hlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciB0TWF0cml4ID0gdGhpcy5fY2FsY1RyYW5zbGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbmdsZTogdGhpcy5hbmdsZSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IHRNYXRyaXhbNF0sXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiB0TWF0cml4WzVdLFxuICAgICAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgICAgICBza2V3WDogdGhpcy5za2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiB0aGlzLnNrZXdZLFxuICAgICAgICAgICAgZmxpcFg6IHRoaXMuZmxpcFgsXG4gICAgICAgICAgICBmbGlwWTogdGhpcy5mbGlwWSxcbiAgICAgICAgICB9O1xuICAgICAgY2FjaGUua2V5ID0ga2V5O1xuICAgICAgY2FjaGUudmFsdWUgPSB1dGlsLmNvbXBvc2VNYXRyaXgob3B0aW9ucyk7XG4gICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIDMuNC4wLCBwbGVhc2UgdXNlIGZhYnJpYy51dGlsLl9jYWxjRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeFxuICAgICAqIG5vdCBpbmNsdWRpbmcgb3IgaW5jbHVkaW5nIGZsaXBYLCBmbGlwWSB0byBlbXVsYXRlIHRoZSBmbGlwcGluZyBib29sZWFuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSwgZmxpcHBpbmcpIHtcbiAgICAgIHJldHVybiB1dGlsLmNhbGNEaW1lbnNpb25zTWF0cml4KHtcbiAgICAgICAgc2tld1g6IHNrZXdYLFxuICAgICAgICBza2V3WTogc2tld1ksXG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVggKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWCA/IC0xIDogMSksXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVkgKiAoZmxpcHBpbmcgJiYgdGhpcy5mbGlwWSA/IC0xIDogMSlcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC54IHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodCArIHN0cm9rZVdpZHRoO1xuICAgICAgcmV0dXJuIHsgeDogdywgeTogaCB9O1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgYm91bmRpbmcgYm94IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllcyBzY2FsZSwgc2tldy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tld1gsIGEgdmFsdWUgdG8gb3ZlcnJpZGUgY3VycmVudCBza2V3WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WSwgYSB2YWx1ZSB0byBvdmVycmlkZSBjdXJyZW50IHNrZXdZXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC54IHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSkge1xuICAgICAgaWYgKHR5cGVvZiBza2V3WCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBza2V3WSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1kgPSB0aGlzLnNrZXdZO1xuICAgICAgfVxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSwgZGltWCwgZGltWSxcbiAgICAgICAgICBub1NrZXcgPSBza2V3WCA9PT0gMCAmJiBza2V3WSA9PT0gMDtcblxuICAgICAgaWYgKHRoaXMuc3Ryb2tlVW5pZm9ybSkge1xuICAgICAgICBkaW1YID0gdGhpcy53aWR0aDtcbiAgICAgICAgZGltWSA9IHRoaXMuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRpbVggPSBkaW1lbnNpb25zLng7XG4gICAgICAgIGRpbVkgPSBkaW1lbnNpb25zLnk7XG4gICAgICB9XG4gICAgICBpZiAobm9Ta2V3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZURpbWVuc2lvbnMoZGltWCAqIHRoaXMuc2NhbGVYLCBkaW1ZICogdGhpcy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgdmFyIGJib3ggPSB1dGlsLnNpemVBZnRlclRyYW5zZm9ybShkaW1YLCBkaW1ZLCB7XG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHNrZXdYOiBza2V3WCxcbiAgICAgICAgc2tld1k6IHNrZXdZLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVEaW1lbnNpb25zKGJib3gueCwgYmJveC55KTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXMgc2NhbGUsIHNrZXcuXG4gICAgICogQHBhcmFtIE51bWJlciB3aWR0aCB3aWR0aCBvZiB0aGUgYmJveFxuICAgICAqIEBwYXJhbSBOdW1iZXIgaGVpZ2h0IGhlaWdodCBvZiB0aGUgYmJveFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCBmaW5hbGl6ZWQgd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBmaW5hbGl6ZWQgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9maW5hbGl6ZURpbWVuc2lvbnM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cm9rZVVuaWZvcm0gP1xuICAgICAgICB7IHg6IHdpZHRoICsgdGhpcy5zdHJva2VXaWR0aCwgeTogaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aCB9XG4gICAgICAgIDpcbiAgICAgICAgeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBkaW1lbnNpb25zIGZvciBjb250cm9scyBib3gsIGluY2x1ZGluZyBwYWRkaW5nIGFuZCBjYW52YXMgem9vbS5cbiAgICAgKiBhbmQgYWN0aXZlIHNlbGVjdGlvblxuICAgICAqIHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkgIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksXG4gICAgICAgICAgcCA9IHRyYW5zZm9ybVBvaW50KGRpbSwgdnB0LCB0cnVlKTtcbiAgICAgIHJldHVybiBwLnNjYWxhckFkZCgyICogdGhpcy5wYWRkaW5nKTtcbiAgICB9LFxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNlbmRUb0JhY2suY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNlbmRUb0JhY2sodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmJyaW5nVG9Gcm9udC5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdUb0Zyb250KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kQmFja3dhcmRzLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNlbmRCYWNrd2FyZHModGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ0ZvcndhcmQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdGb3J3YXJkKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gc3BlY2lmaWVkIGxldmVsIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IE5ldyBwb3NpdGlvbiBvZiBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC50eXBlICE9PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUubW92ZVRvLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMubW92ZVRvKHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGdldFN2Z0NvbG9yU3RyaW5nKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiBub25lOyAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50b0xpdmUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogdXJsKCNTVkdJRF8nICsgdmFsdWUuaWQgKyAnKTsgJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSxcbiAgICAgICAgICBzdHIgPSBwcm9wICsgJzogJyArIGNvbG9yLnRvUmdiKCkgKyAnOyAnLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgLy9jaGFuZ2UgdGhlIGNvbG9yIGluIHJnYiArIG9wYWNpdHlcbiAgICAgICAgc3RyICs9IHByb3AgKyAnLW9wYWNpdHk6ICcgKyBvcGFjaXR5LnRvU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuXG4gICAgICB2YXIgZmlsbFJ1bGUgPSB0aGlzLmZpbGxSdWxlID8gdGhpcy5maWxsUnVsZSA6ICdub256ZXJvJyxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoIDogJzAnLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHRoaXMuc3Ryb2tlRGFzaEFycmF5ID8gdGhpcy5zdHJva2VEYXNoQXJyYXkuam9pbignICcpIDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQgPSB0aGlzLnN0cm9rZURhc2hPZmZzZXQgPyB0aGlzLnN0cm9rZURhc2hPZmZzZXQgOiAnMCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcCA/IHRoaXMuc3Ryb2tlTGluZUNhcCA6ICdidXR0JyxcbiAgICAgICAgICBzdHJva2VMaW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW4gPyB0aGlzLnN0cm9rZUxpbmVKb2luIDogJ21pdGVyJyxcbiAgICAgICAgICBzdHJva2VNaXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0ID8gdGhpcy5zdHJva2VNaXRlckxpbWl0IDogJzQnLFxuICAgICAgICAgIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/IHRoaXMub3BhY2l0eSA6ICcxJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuICAgICAgICAgIGZpbHRlciA9IHNraXBTaGFkb3cgPyAnJyA6IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgZmlsbCA9IGdldFN2Z0NvbG9yU3RyaW5nKCdmaWxsJywgdGhpcy5maWxsKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdmdDb2xvclN0cmluZygnc3Ryb2tlJywgdGhpcy5zdHJva2UpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgICdzdHJva2Utd2lkdGg6ICcsIHN0cm9rZVdpZHRoLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheTogJywgc3Ryb2tlRGFzaEFycmF5LCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXA6ICcsIHN0cm9rZUxpbmVDYXAsICc7ICcsXG4gICAgICAgICdzdHJva2UtZGFzaG9mZnNldDogJywgc3Ryb2tlRGFzaE9mZnNldCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbjogJywgc3Ryb2tlTGluZUpvaW4sICc7ICcsXG4gICAgICAgICdzdHJva2UtbWl0ZXJsaW1pdDogJywgc3Ryb2tlTWl0ZXJMaW1pdCwgJzsgJyxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgJ2ZpbGwtcnVsZTogJywgZmlsbFJ1bGUsICc7ICcsXG4gICAgICAgICdvcGFjaXR5OiAnLCBvcGFjaXR5LCAnOycsXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIHRoZSBvYmplY3QgZnJvbSB3aGljaCB0byByZXRyaWV2ZSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2VXaGl0ZVNwYWNlIGEgYm9vbGVhbiB0byBpbmNsdWRlIGFuIGFkZGl0aW9uYWwgYXR0cmlidXRlIGluIHRoZSBzdHlsZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3BhblN0eWxlczogZnVuY3Rpb24oc3R5bGUsIHVzZVdoaXRlU3BhY2UpIHtcbiAgICAgIHZhciB0ZXJtID0gJzsgJztcbiAgICAgIHZhciBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseSA/XG4gICAgICAgICdmb250LWZhbWlseTogJyArICgoKHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXFwnJykgPT09IC0xICYmIHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXCInKSA9PT0gLTEpID9cbiAgICAgICAgICAnXFwnJyArIHN0eWxlLmZvbnRGYW1pbHkgICsgJ1xcJycgOiBzdHlsZS5mb250RmFtaWx5KSkgKyB0ZXJtIDogJyc7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5zdHJva2VXaWR0aCA/ICdzdHJva2Utd2lkdGg6ICcgKyBzdHlsZS5zdHJva2VXaWR0aCArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250RmFtaWx5ID0gZm9udEZhbWlseSxcbiAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplID8gJ2ZvbnQtc2l6ZTogJyArIHN0eWxlLmZvbnRTaXplICsgJ3B4JyArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgPyAnZm9udC1zdHlsZTogJyArIHN0eWxlLmZvbnRTdHlsZSArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCA/ICdmb250LXdlaWdodDogJyArIHN0eWxlLmZvbnRXZWlnaHQgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZmlsbCA9IHN0eWxlLmZpbGwgPyBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHN0eWxlLmZpbGwpIDogJycsXG4gICAgICAgICAgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHN0eWxlLnN0cm9rZSkgOiAnJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24oc3R5bGUpLFxuICAgICAgICAgIGRlbHRhWSA9IHN0eWxlLmRlbHRhWSA/ICdiYXNlbGluZS1zaGlmdDogJyArICgtc3R5bGUuZGVsdGFZKSArICc7ICcgOiAnJztcbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9ICd0ZXh0LWRlY29yYXRpb246ICcgKyB0ZXh0RGVjb3JhdGlvbiArIHRlcm07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGUsXG4gICAgICAgIGZvbnRXZWlnaHQsXG4gICAgICAgIHRleHREZWNvcmF0aW9uLFxuICAgICAgICBmaWxsLFxuICAgICAgICBkZWx0YVksXG4gICAgICAgIHVzZVdoaXRlU3BhY2UgPyAnd2hpdGUtc3BhY2U6IHByZTsgJyA6ICcnXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRleHQtZGVjb3JhdGlvbiBwcm9wZXJ0eSBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHJldHVybiBbJ292ZXJsaW5lJywgJ3VuZGVybGluZScsICdsaW5lLXRocm91Z2gnXS5maWx0ZXIoZnVuY3Rpb24oZGVjb3JhdGlvbikge1xuICAgICAgICByZXR1cm4gc3R5bGVbZGVjb3JhdGlvbi5yZXBsYWNlKCctJywgJycpXTtcbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaWx0ZXIgZm9yIHN2ZyBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRvdyA/ICdmaWx0ZXI6IHVybCgjU1ZHSURfJyArIHRoaXMuc2hhZG93LmlkICsgJyk7JyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlkIGF0dHJpYnV0ZSBmb3Igc3ZnIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdDb21tb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuaWQgPyAnaWQ9XCInICsgdGhpcy5pZCArICdcIiAnIDogJycsXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPyAnY2xpcC1wYXRoPVwidXJsKCMnICsgdGhpcy5jbGlwUGF0aC5jbGlwUGF0aElkICsgJylcIiAnIDogJycsXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRyYW5zZm9ybS1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZSB0aGUgZnVsbCB0cmFuc2Zvcm0gb3IgdGhlIHNpbmdsZSBvYmplY3Qgb25lLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUcmFuc2Zvcm06IGZ1bmN0aW9uKGZ1bGwsIGFkZGl0aW9uYWxUcmFuc2Zvcm0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBmdWxsID8gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkgOiB0aGlzLmNhbGNPd25NYXRyaXgoKSxcbiAgICAgICAgICBzdmdUcmFuc2Zvcm0gPSAndHJhbnNmb3JtPVwiJyArIGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gc3ZnVHJhbnNmb3JtICtcbiAgICAgICAgKGFkZGl0aW9uYWxUcmFuc2Zvcm0gfHwgJycpICsgJ1wiICc7XG4gICAgfSxcblxuICAgIF9zZXRTVkdCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMpIHtcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgICAnXFx0XFx0PHJlY3QgJyxcbiAgICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyh0aGlzLmJhY2tncm91bmRDb2xvciksXG4gICAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLndpZHRoIC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIHk9XCInLFxuICAgICAgICAgIHRvRml4ZWQoLXRoaXMuaGVpZ2h0IC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIHdpZHRoPVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIj48L3JlY3Q+XFxuJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCh0aGlzLl90b1NWRyhyZXZpdmVyKSwgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAodGhpcy5fdG9TVkcocmV2aXZlciksIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwOiBmdW5jdGlvbihvYmplY3RNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHJldml2ZXIgPSBvcHRpb25zLnJldml2ZXIsXG4gICAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA9IG9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSB8fCAnJyxcbiAgICAgICAgICBjb21tb25QaWVjZXMgPSBbXG4gICAgICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybSh0cnVlLCBhZGRpdGlvbmFsVHJhbnNmb3JtKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0U3ZnQ29tbW9ucygpLFxuICAgICAgICAgIF0uam9pbignJyksXG4gICAgICAgICAgLy8gaW5zZXJ0IGNvbW1vbnMgaW4gdGhlIG1hcmt1cCwgc3R5bGUgYW5kIHN2Z0NvbW1vbnNcbiAgICAgICAgICBpbmRleCA9IG9iamVjdE1hcmt1cC5pbmRleE9mKCdDT01NT05fUEFSVFMnKTtcbiAgICAgIG9iamVjdE1hcmt1cFtpbmRleF0gPSBjb21tb25QaWVjZXM7XG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIob2JqZWN0TWFya3VwLmpvaW4oJycpKSA6IG9iamVjdE1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZVNWR01hcmt1cDogZnVuY3Rpb24ob2JqZWN0TWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBub1N0eWxlID0gb3B0aW9ucy5ub1N0eWxlLFxuICAgICAgICAgIHJldml2ZXIgPSBvcHRpb25zLnJldml2ZXIsXG4gICAgICAgICAgc3R5bGVJbmZvID0gbm9TdHlsZSA/ICcnIDogJ3N0eWxlPVwiJyArIHRoaXMuZ2V0U3ZnU3R5bGVzKCkgKyAnXCIgJyxcbiAgICAgICAgICBzaGFkb3dJbmZvID0gb3B0aW9ucy53aXRoU2hhZG93ID8gJ3N0eWxlPVwiJyArIHRoaXMuZ2V0U3ZnRmlsdGVyKCkgKyAnXCIgJyA6ICcnLFxuICAgICAgICAgIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aCxcbiAgICAgICAgICB2ZWN0b3JFZmZlY3QgPSB0aGlzLnN0cm9rZVVuaWZvcm0gPyAndmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiICcgOiAnJyxcbiAgICAgICAgICBhYnNvbHV0ZUNsaXBQYXRoID0gY2xpcFBhdGggJiYgY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkLFxuICAgICAgICAgIHN0cm9rZSA9IHRoaXMuc3Ryb2tlLCBmaWxsID0gdGhpcy5maWxsLCBzaGFkb3cgPSB0aGlzLnNoYWRvdyxcbiAgICAgICAgICBjb21tb25QaWVjZXMsIG1hcmt1cCA9IFtdLCBjbGlwUGF0aE1hcmt1cCxcbiAgICAgICAgICAvLyBpbnNlcnQgY29tbW9ucyBpbiB0aGUgbWFya3VwLCBzdHlsZSBhbmQgc3ZnQ29tbW9uc1xuICAgICAgICAgIGluZGV4ID0gb2JqZWN0TWFya3VwLmluZGV4T2YoJ0NPTU1PTl9QQVJUUycpLFxuICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm07XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGguY2xpcFBhdGhJZCA9ICdDTElQUEFUSF8nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBjbGlwUGF0aE1hcmt1cCA9ICc8Y2xpcFBhdGggaWQ9XCInICsgY2xpcFBhdGguY2xpcFBhdGhJZCArICdcIiA+XFxuJyArXG4gICAgICAgICAgY2xpcFBhdGgudG9DbGlwUGF0aFNWRyhyZXZpdmVyKSArXG4gICAgICAgICAgJzwvY2xpcFBhdGg+XFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChhYnNvbHV0ZUNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8ZyAnLCBzaGFkb3dJbmZvLCB0aGlzLmdldFN2Z0NvbW1vbnMoKSwgJyA+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZyAnLFxuICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybShmYWxzZSksXG4gICAgICAgICFhYnNvbHV0ZUNsaXBQYXRoID8gc2hhZG93SW5mbyArIHRoaXMuZ2V0U3ZnQ29tbW9ucygpIDogJycsXG4gICAgICAgICcgPlxcbidcbiAgICAgICk7XG4gICAgICBjb21tb25QaWVjZXMgPSBbXG4gICAgICAgIHN0eWxlSW5mbyxcbiAgICAgICAgdmVjdG9yRWZmZWN0LFxuICAgICAgICBub1N0eWxlID8gJycgOiB0aGlzLmFkZFBhaW50T3JkZXIoKSwgJyAnLFxuICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID8gJ3RyYW5zZm9ybT1cIicgKyBhZGRpdGlvbmFsVHJhbnNmb3JtICsgJ1wiICcgOiAnJyxcbiAgICAgIF0uam9pbignJyk7XG4gICAgICBvYmplY3RNYXJrdXBbaW5kZXhdID0gY29tbW9uUGllY2VzO1xuICAgICAgaWYgKGZpbGwgJiYgZmlsbC50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2goZmlsbC50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3Ryb2tlICYmIHN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2goc3Ryb2tlLnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgbWFya3VwLnB1c2goc2hhZG93LnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaChjbGlwUGF0aE1hcmt1cCk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChvYmplY3RNYXJrdXAuam9pbignJykpO1xuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIGFic29sdXRlQ2xpcFBhdGggJiYgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBhZGRQYWludE9yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJyA/ICcgcGFpbnQtb3JkZXI9XCInICsgdGhpcy5wYWludEZpcnN0ICsgJ1wiICcgOiAnJztcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG9yaWdpbmFsU2V0ID0gJ3N0YXRlUHJvcGVydGllcyc7XG5cbiAgLypcbiAgICBEZXBlbmRzIG9uIGBzdGF0ZVByb3BlcnRpZXNgXG4gICovXG4gIGZ1bmN0aW9uIHNhdmVQcm9wcyhvcmlnaW4sIGRlc3RpbmF0aW9uLCBwcm9wcykge1xuICAgIHZhciB0bXBPYmogPSB7IH0sIGRlZXAgPSB0cnVlO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdG1wT2JqW3Byb3BdID0gb3JpZ2luW3Byb3BdO1xuICAgIH0pO1xuXG4gICAgZXh0ZW5kKG9yaWdpbltkZXN0aW5hdGlvbl0sIHRtcE9iaiwgZGVlcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNFcXVhbChvcmlnVmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmlyc3RQYXNzKSB7XG4gICAgaWYgKG9yaWdWYWx1ZSA9PT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAvLyBpZiB0aGUgb2JqZWN0cyBhcmUgaWRlbnRpY2FsLCByZXR1cm5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9yaWdWYWx1ZSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpIHx8IG9yaWdWYWx1ZS5sZW5ndGggIT09IGN1cnJlbnRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9yaWdWYWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtpXSwgY3VycmVudFZhbHVlW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9yaWdWYWx1ZSAmJiB0eXBlb2Ygb3JpZ1ZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcmlnVmFsdWUpLCBrZXk7XG4gICAgICBpZiAoIWN1cnJlbnRWYWx1ZSB8fFxuICAgICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgKCFmaXJzdFBhc3MgJiYga2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGN1cnJlbnRWYWx1ZSkubGVuZ3RoKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vIHNpbmNlIGNsaXBQYXRoIGlzIGluIHRoZSBzdGF0ZWZ1bGwgY2FjaGUgbGlzdCBhbmQgdGhlIGNsaXBQYXRoIG9iamVjdHNcbiAgICAgICAgLy8gd291bGQgYmUgaXRlcmF0ZWQgYXMgYW4gb2JqZWN0LCB0aGlzIHdvdWxkIGxlYWQgdG8gcG9zc2libGUgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGNvbXBhcmUgdGhvc2UuXG4gICAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnIHx8IGtleSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2lzRXF1YWwob3JpZ1ZhbHVlW2tleV0sIGN1cnJlbnRWYWx1ZVtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3Qgc3RhdGUgKG9uZSBvZiBpdHMgc3RhdGUgcHJvcGVydGllcykgd2FzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5U2V0XSBvcHRpb25hbCBuYW1lIGZvciB0aGUgc2V0IG9mIHByb3BlcnR5IHdlIHdhbnQgdG8gc2F2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaW5zdGFuY2UnIHN0YXRlIGhhcyBjaGFuZ2VkIHNpbmNlIGB7QGxpbmsgZmFicmljLk9iamVjdCNzYXZlU3RhdGV9YCB3YXMgY2FsbGVkXG4gICAgICovXG4gICAgaGFzU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbihwcm9wZXJ0eVNldCkge1xuICAgICAgcHJvcGVydHlTZXQgPSBwcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldDtcbiAgICAgIHZhciBkYXNoZWRQcm9wZXJ0eVNldCA9ICdfJyArIHByb3BlcnR5U2V0O1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdKS5sZW5ndGggPCB0aGlzW3Byb3BlcnR5U2V0XS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gIV9pc0VxdWFsKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgc3RhdGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGBzdGF0ZVByb3BlcnRpZXNgIGFycmF5IHRvIGluY2x1ZGUgd2hlbiBzYXZpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2F2ZVN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQsXG4gICAgICAgICAgZGVzdGluYXRpb24gPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmICghdGhpc1tkZXN0aW5hdGlvbl0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBTdGF0ZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgdGhpc1twcm9wZXJ0eVNldF0pO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgc2F2ZVByb3BzKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnN0YXRlUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXBzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldHVwU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIHZhciBwcm9wZXJ0eVNldCA9IG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICBvcHRpb25zLnByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQ7XG4gICAgICB0aGlzWydfJyArIHByb3BlcnR5U2V0XSA9IHsgfTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoaWNoIGNvcm5lciBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBUaGUgcG9pbnRlciBpbmRpY2F0aW5nIHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufSBjb3JuZXIgY29kZSAodGwsIHRyLCBibCwgYnIsIGV0Yy4pLCBvciBmYWxzZSBpZiBub3RoaW5nIGlzIGZvdW5kXG4gICAgICovXG4gICAgX2ZpbmRUYXJnZXRDb3JuZXI6IGZ1bmN0aW9uKHBvaW50ZXIsIGZvclRvdWNoKSB7XG4gICAgICAvLyBvYmplY3RzIGluIGdyb3VwLCBhbnlraW5kLCBhcmUgbm90IHNlbGYgbW9kaWZpY2FibGUsXG4gICAgICAvLyBtdXN0IG5vdCByZXR1cm4gYW4gaG92ZXJlZCBjb3JuZXIuXG4gICAgICBpZiAoIXRoaXMuaGFzQ29udHJvbHMgfHwgdGhpcy5ncm91cCB8fCAoIXRoaXMuY2FudmFzIHx8IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ID0gcG9pbnRlci54LFxuICAgICAgICAgIGV5ID0gcG9pbnRlci55LFxuICAgICAgICAgIHhQb2ludHMsXG4gICAgICAgICAgbGluZXMsIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9Db29yZHMpLFxuICAgICAgICAgIGogPSBrZXlzLmxlbmd0aCAtIDEsIGk7XG4gICAgICB0aGlzLl9fY29ybmVyID0gMDtcblxuICAgICAgLy8gY3ljbGUgaW4gcmV2ZXJzZSBvcmRlciBzbyB3ZSBwaWNrIGZpcnN0IHRoZSBvbmUgb24gdG9wXG4gICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgaSA9IGtleXNbal07XG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRyb2xWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IHRoaXMuX2dldEltYWdlTGluZXMoZm9yVG91Y2ggPyB0aGlzLm9Db29yZHNbaV0udG91Y2hDb3JuZXIgOiB0aGlzLm9Db29yZHNbaV0uY29ybmVyKTtcbiAgICAgICAgLy8gLy8gZGVidWdnaW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5kLngsIGxpbmVzLmJvdHRvbWxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5vLngsIGxpbmVzLmxlZnRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5kLngsIGxpbmVzLnRvcGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLm8ueCwgbGluZXMudG9wbGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5kLngsIGxpbmVzLnJpZ2h0bGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMoeyB4OiBleCwgeTogZXkgfSwgbGluZXMpO1xuICAgICAgICBpZiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX19jb3JuZXIgPSBpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2ggY29udHJvbC4gVGhlIGZ1bmN0aW9uIGdldHMgY2FsbGVkLFxuICAgICAqIHdpdGggdGhlIGNvbnRyb2wsIHRoZSBvYmplY3QgdGhhdCBpcyBjYWxsaW5nIHRoZSBpdGVyYXRvciBhbmQgdGhlIGNvbnRyb2wncyBrZXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgdGhlIGNvbnRyb2xzIG92ZXJcbiAgICAgKi9cbiAgICBmb3JFYWNoQ29udHJvbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb250cm9scykge1xuICAgICAgICBmbih0aGlzLmNvbnRyb2xzW2ldLCBpLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgb2ZcbiAgICAgKiB0aGUgaW1hZ2UgdXNlZCB0byBzY2FsZS9yb3RhdGUgaXQuXG4gICAgICogbm90ZTogaWYgd2Ugd291bGQgc3dpdGNoIHRvIFJPVU5EIGNvcm5lciBhcmVhLCBhbGwgb2YgdGhpcyB3b3VsZCBkaXNhcHBlYXIuXG4gICAgICogZXZlcnl0aGluZyB3b3VsZCByZXNvbHZlIHRvIGEgc2luZ2xlIHBvaW50IGFuZCBhIHB5dGhhZ29yZWFuIHRoZW9yZW0gZm9yIHRoZSBkaXN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldENvcm5lckNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5vQ29vcmRzO1xuXG4gICAgICBmb3IgKHZhciBjb250cm9sIGluIGNvb3Jkcykge1xuICAgICAgICB2YXIgY29udHJvbE9iamVjdCA9IHRoaXMuY29udHJvbHNbY29udHJvbF07XG4gICAgICAgIGNvb3Jkc1tjb250cm9sXS5jb3JuZXIgPSBjb250cm9sT2JqZWN0LmNhbGNDb3JuZXJDb29yZHMoXG4gICAgICAgICAgdGhpcy5hbmdsZSwgdGhpcy5jb3JuZXJTaXplLCBjb29yZHNbY29udHJvbF0ueCwgY29vcmRzW2NvbnRyb2xdLnksIGZhbHNlKTtcbiAgICAgICAgY29vcmRzW2NvbnRyb2xdLnRvdWNoQ29ybmVyID0gY29udHJvbE9iamVjdC5jYWxjQ29ybmVyQ29vcmRzKFxuICAgICAgICAgIHRoaXMuYW5nbGUsIHRoaXMudG91Y2hDb3JuZXJTaXplLCBjb29yZHNbY29udHJvbF0ueCwgY29vcmRzW2NvbnRyb2xdLnksIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3QsIGluc2lkZSBpdHMgc2VsZWN0aW9uIGJvcmRlcnMuXG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvclxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgdHJhbnNmb3JtZWRcbiAgICAgKiBoYXMgY2hlY2tzIHRvIGJlIHNraXBwZWQgd2hlbiB0aGUgb2JqZWN0IGlzIG9uIGEgc3RhdGljQ2FudmFzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmICF0aGlzLmNhbnZhcy5pbnRlcmFjdGl2ZSkgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgY3R4LnNjYWxlKDEgLyB2cHRbMF0sIDEgLyB2cHRbM10pO1xuICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgtd2gueCAvIDIsIC13aC55IC8gMiwgd2gueCwgd2gueSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5ib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICB3aWR0aCA9IHdoLnggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB3aC55ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGFzQ29udHJvbHMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgICAgc2hvdWxkU3Ryb2tlID0gZmFsc2U7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuYm9yZGVyRGFzaEFycmF5IHx8IHRoaXMuYm9yZGVyRGFzaEFycmF5LCBudWxsKTtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgICAgLy8gaW4gdGhpcyBtb21lbnQsIHRoZSBjdHggaXMgY2VudGVyZWQgb24gdGhlIG9iamVjdC5cbiAgICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBhYm92ZSBmdW5jdGlvbiBhcmUgdGhlIHNpemUgb2YgdGhlIGJib3guXG4gICAgICAgICAgaWYgKGNvbnRyb2wud2l0aENvbm5lY3Rpb24gJiYgY29udHJvbC5nZXRWaXNpYmlsaXR5KGZhYnJpY09iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgbW92ZW1lbnQgZm9yIGVhY2ggY29udHJvbFxuICAgICAgICAgICAgc2hvdWxkU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29udHJvbC54ICogd2lkdGgsIGNvbnRyb2wueSAqIGhlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICBjb250cm9sLnggKiB3aWR0aCArIGNvbnRyb2wub2Zmc2V0WCxcbiAgICAgICAgICAgICAgY29udHJvbC55ICogaGVpZ2h0ICsgY29udHJvbC5vZmZzZXRZXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaG91bGRTdHJva2UpIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9yZGVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3ggd2hlbiBpdCBpcyBpbnNpZGUgYSBncm91cC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb2JqZWN0IHJlcHJlc2VudGluZyBjdXJyZW50IG9iamVjdCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdCb3JkZXJzSW5Hcm91cDogZnVuY3Rpb24oY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciBiYm94ID0gZmFicmljLnV0aWwuc2l6ZUFmdGVyVHJhbnNmb3JtKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBvcHRpb25zKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgc3Ryb2tlVW5pZm9ybSA9IHRoaXMuc3Ryb2tlVW5pZm9ybSxcbiAgICAgICAgICBib3JkZXJTY2FsZUZhY3RvciA9IHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPVxuICAgICAgICAgICAgYmJveC54ICsgc3Ryb2tlV2lkdGggKiAoc3Ryb2tlVW5pZm9ybSA/IHRoaXMuY2FudmFzLmdldFpvb20oKSA6IG9wdGlvbnMuc2NhbGVYKSArIGJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIGhlaWdodCA9XG4gICAgICAgICAgICBiYm94LnkgKyBzdHJva2VXaWR0aCAqIChzdHJva2VVbmlmb3JtID8gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpIDogb3B0aW9ucy5zY2FsZVkpICsgYm9yZGVyU2NhbGVGYWN0b3I7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmJvcmRlckRhc2hBcnJheSB8fCB0aGlzLmJvcmRlckRhc2hBcnJheSwgbnVsbCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgY29ybmVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogY29ybmVyU2l6ZSwgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKSwgMCwgMCwgdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpLCAwLCAwKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lckNvbG9yIHx8IHRoaXMuY29ybmVyQ29sb3I7XG4gICAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnRDb3JuZXJzKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgdGhpcy5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5jb3JuZXJEYXNoQXJyYXkgfHwgdGhpcy5jb3JuZXJEYXNoQXJyYXksIG51bGwpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuZm9yRWFjaENvbnRyb2woZnVuY3Rpb24oY29udHJvbCwga2V5LCBmYWJyaWNPYmplY3QpIHtcbiAgICAgICAgaWYgKGNvbnRyb2wuZ2V0VmlzaWJpbGl0eShmYWJyaWNPYmplY3QsIGtleSkpIHtcbiAgICAgICAgICBjb250cm9sLnJlbmRlcihjdHgsXG4gICAgICAgICAgICBmYWJyaWNPYmplY3Qub0Nvb3Jkc1trZXldLngsXG4gICAgICAgICAgICBmYWJyaWNPYmplY3Qub0Nvb3Jkc1trZXldLnksIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sS2V5IFRoZSBrZXkgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzQ29udHJvbFZpc2libGU6IGZ1bmN0aW9uKGNvbnRyb2xLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xLZXldICYmIHRoaXMuY29udHJvbHNbY29udHJvbEtleV0uZ2V0VmlzaWJpbGl0eSh0aGlzLCBjb250cm9sS2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xLZXkgVGhlIGtleSBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGFyZSAndGwnLCAndHInLCAnYnInLCAnYmwnLCAnbWwnLCAnbXQnLCAnbXInLCAnbWInLCAnbXRyJy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgdHJ1ZSB0byBzZXQgdGhlIHNwZWNpZmllZCBjb250cm9sIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29udHJvbFZpc2libGU6IGZ1bmN0aW9uKGNvbnRyb2xLZXksIHZpc2libGUpIHtcbiAgICAgIGlmICghdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5W2NvbnRyb2xLZXldID0gdmlzaWJsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIG9iamVjdCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibF0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJyXSB0cnVlIHRvIGVuYWJsZSB0aGUgYm90dG9tLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1iXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLWJvdHRvbSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tbF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1yXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10XSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXRvcCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50bF0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyXSB0cnVlIHRvIGVuYWJsZSB0aGUgdG9wLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10cl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3Atcm90YXRlIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xzVmlzaWJpbGl0eTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIGZvciAodmFyIHAgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldENvbnRyb2xWaXNpYmxlKHAsIG9wdGlvbnNbcF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIGRlc2VsZWN0IHRoaXMgb2JqZWN0LiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgcHJvY2VzcyBpcyBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgc2VudCBmcm9tIHRoZSB1cHBlciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbb3B0aW9ucy5lXSBldmVudCBpZiB0aGUgcHJvY2VzcyBpcyBnZW5lcmF0ZWQgYnkgYW4gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIHNlbGVjdCB0aGlzIG9iamVjdC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHByb2Nlc3MgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHNlbnQgZnJvbSB0aGUgdXBwZXIgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gW29wdGlvbnMuZV0gZXZlbnQgaWYgdGhlIHByb2Nlc3MgaXMgZ2VuZXJhdGVkIGJ5IGFuIGV2ZW50XG4gICAgICovXG4gICAgb25TZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQW5pbWF0aW9uIGR1cmF0aW9uIChpbiBtcykgZm9yIGZ4KiBtZXRob2RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRlhfRFVSQVRJT046IDUwMCxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IHdpdGggYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeENlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QubGVmdCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlcigpLmxlZnQsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdsZWZ0JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4Q2VudGVyT2JqZWN0VjogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC50b3AsXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXIoKS50b3AsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCd0b3AnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgZmFicmljLkNhbnZhcyNyZW1vdmVgIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFJlbW92ZTogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5vcGFjaXR5LFxuICAgICAgZW5kVmFsdWU6IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdvcGFjaXR5JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEFuaW1hdGVzIG9iamVjdCdzIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlIChpZiBzdHJpbmcpIG9yIHByb3BlcnRpZXMgdG8gYW5pbWF0ZSAoaWYgb2JqZWN0KVxuICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZhbHVlIFZhbHVlIHRvIGFuaW1hdGUgcHJvcGVydHkgdG8gKGlmIHN0cmluZyB3YXMgZ2l2ZW4gZmlyc3QpIG9yIG9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjYW5pbWF0aW9ufVxuICAgKiBAY2hhaW5hYmxlXG4gICAqXG4gICAqIEFzIG9iamVjdCDigJQgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSk7XG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9LCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqIEFzIHN0cmluZyDigJQgb25lIHByb3BlcnR5XG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgLi4uKTtcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcHJvcHNUb0FuaW1hdGUgPSBbXSwgcHJvcCwgc2tpcENhbGxiYWNrcztcbiAgICAgIGZvciAocHJvcCBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgcHJvcHNUb0FuaW1hdGUucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wc1RvQW5pbWF0ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wID0gcHJvcHNUb0FuaW1hdGVbaV07XG4gICAgICAgIHNraXBDYWxsYmFja3MgPSBpICE9PSBsZW4gLSAxO1xuICAgICAgICB0aGlzLl9hbmltYXRlKHByb3AsIGFyZ3VtZW50c1swXVtwcm9wXSwgYXJndW1lbnRzWzFdLCBza2lwQ2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9hbmltYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG8gVmFsdWUgdG8gYW5pbWF0ZSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDYWxsYmFja3NdIFdoZW4gdHJ1ZSwgY2FsbGJhY2tzIGxpa2Ugb25jaGFuZ2UgYW5kIG9uY29tcGxldGUgYXJlIG5vdCBpbnZva2VkXG4gICAqL1xuICBfYW5pbWF0ZTogZnVuY3Rpb24ocHJvcGVydHksIHRvLCBvcHRpb25zLCBza2lwQ2FsbGJhY2tzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgcHJvcFBhaXI7XG5cbiAgICB0byA9IHRvLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAofnByb3BlcnR5LmluZGV4T2YoJy4nKSkge1xuICAgICAgcHJvcFBhaXIgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIH1cblxuICAgIHZhciBwcm9wSXNDb2xvciA9XG4gICAgICBfdGhpcy5jb2xvclByb3BlcnRpZXMuaW5kZXhPZihwcm9wZXJ0eSkgPiAtMSB8fFxuICAgICAgKHByb3BQYWlyICYmIF90aGlzLmNvbG9yUHJvcGVydGllcy5pbmRleE9mKHByb3BQYWlyWzFdKSA+IC0xKTtcblxuICAgIHZhciBjdXJyZW50VmFsdWUgPSBwcm9wUGFpclxuICAgICAgPyB0aGlzLmdldChwcm9wUGFpclswXSlbcHJvcFBhaXJbMV1dXG4gICAgICA6IHRoaXMuZ2V0KHByb3BlcnR5KTtcblxuICAgIGlmICghKCdmcm9tJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mcm9tID0gY3VycmVudFZhbHVlO1xuICAgIH1cblxuICAgIGlmICghcHJvcElzQ29sb3IpIHtcbiAgICAgIGlmICh+dG8uaW5kZXhPZignPScpKSB7XG4gICAgICAgIHRvID0gY3VycmVudFZhbHVlICsgcGFyc2VGbG9hdCh0by5yZXBsYWNlKCc9JywgJycpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0byA9IHBhcnNlRmxvYXQodG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0VmFsdWU6IG9wdGlvbnMuZnJvbSxcbiAgICAgIGVuZFZhbHVlOiB0byxcbiAgICAgIGJ5VmFsdWU6IG9wdGlvbnMuYnksXG4gICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICBhYm9ydDogb3B0aW9ucy5hYm9ydCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmFib3J0LmNhbGwoX3RoaXMpO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcykge1xuICAgICAgICBpZiAocHJvcFBhaXIpIHtcbiAgICAgICAgICBfdGhpc1twcm9wUGFpclswXV1bcHJvcFBhaXJbMV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2V0KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5vbkNoYW5nZSAmJiBvcHRpb25zLm9uQ2hhbmdlKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChwcm9wSXNDb2xvcikge1xuICAgICAgZmFicmljLnV0aWwuYW5pbWF0ZUNvbG9yKF9vcHRpb25zLnN0YXJ0VmFsdWUsIF9vcHRpb25zLmVuZFZhbHVlLCBfb3B0aW9ucy5kdXJhdGlvbiwgX29wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoX29wdGlvbnMpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICBjb29yZFByb3BzID0geyB4MTogMSwgeDI6IDEsIHkxOiAxLCB5MjogMSB9LFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyk7XG5cbiAgaWYgKGZhYnJpYy5MaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5MaW5lIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuTGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5MaW5lI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuTGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnbGluZScsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeDE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIHNlY29uZCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgyOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB5MjogMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgneDEnLCAneDInLCAneTEnLCAneTInKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BvaW50c10gQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5MaW5lfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICBwb2ludHMgPSBbMCwgMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuc2V0KCd4MScsIHBvaW50c1swXSk7XG4gICAgICB0aGlzLnNldCgneTEnLCBwb2ludHNbMV0pO1xuICAgICAgdGhpcy5zZXQoJ3gyJywgcG9pbnRzWzJdKTtcbiAgICAgIHRoaXMuc2V0KCd5MicsIHBvaW50c1szXSk7XG5cbiAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMud2lkdGggPSBNYXRoLmFicyh0aGlzLngyIC0gdGhpcy54MSk7XG4gICAgICB0aGlzLmhlaWdodCA9IE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKTtcblxuICAgICAgdGhpcy5sZWZ0ID0gJ2xlZnQnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLmxlZnRcbiAgICAgICAgOiB0aGlzLl9nZXRMZWZ0VG9PcmlnaW5YKCk7XG5cbiAgICAgIHRoaXMudG9wID0gJ3RvcCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMudG9wXG4gICAgICAgIDogdGhpcy5fZ2V0VG9wVG9PcmlnaW5ZKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBjb29yZFByb3BzW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlZnRUb09yaWdpblggRGlzdGFuY2UgZnJvbSBsZWZ0IGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblggb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0TGVmdFRvT3JpZ2luWDogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWCcsXG4gICAgICAgIGF4aXMxOiAneDEnLFxuICAgICAgICBheGlzMjogJ3gyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnd2lkdGgnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICdsZWZ0JyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdyaWdodCdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRvcFRvT3JpZ2luWSBEaXN0YW5jZSBmcm9tIHRvcCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5ZIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldFRvcFRvT3JpZ2luWTogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWScsXG4gICAgICAgIGF4aXMxOiAneTEnLFxuICAgICAgICBheGlzMjogJ3kyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnaGVpZ2h0J1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAndG9wJyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdib3R0b20nXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlRGFzaEFycmF5IHx8IHRoaXMuc3Ryb2tlRGFzaEFycmF5ICYmIHN1cHBvcnRzTGluZURhc2gpIHtcbiAgICAgICAgLy8gbW92ZSBmcm9tIGNlbnRlciAob2YgdmlydHVhbCBib3gpIHRvIGl0cyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgICAgLy8gd2UgY2FuJ3QgYXNzdW1lIHgxLCB5MSBpcyB0b3AgbGVmdCBhbmQgeDIsIHkyIGlzIGJvdHRvbSByaWdodFxuICAgICAgICB2YXIgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwLngxLCBwLnkxKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwLngyLCBwLnkyKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG5cbiAgICAgIC8vIFRPRE86IHRlc3QgdGhpc1xuICAgICAgLy8gbWFrZSBzdXJlIHNldHRpbmcgXCJmaWxsXCIgY2hhbmdlcyBjb2xvciBvZiBhIGxpbmVcbiAgICAgIC8vIChieSBjb3B5aW5nIGZpbGxTdHlsZSB0byBzdHJva2VTdHlsZSwgc2luY2UgbGluZSBpcyBzdHJva2VkLCBub3QgZmlsbGVkKVxuICAgICAgdmFyIG9yaWdTdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlIHx8IGN0eC5maWxsU3R5bGU7XG4gICAgICB0aGlzLnN0cm9rZSAmJiB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9yaWdTdHJva2VTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBwLngxLCBwLnkxLCBwLngyLCBwLnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCBpbiB0aGUgc3ZnXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgcG9pbnQgZnJvbSBlbGVtZW50IGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAodGhpcy54MSArIHRoaXMueDIpIC8gMixcbiAgICAgICAgeTogKHRoaXMueTEgKyB0aGlzLnkyKSAvIDIsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwgdGhpcy5jYWxjTGluZVBvaW50cygpKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltID0gdGhpcy5jYWxsU3VwZXIoJ19nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMnKTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZUxpbmVDYXAgPT09ICdidXR0Jykge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCkge1xuICAgICAgICAgIGRpbS55IC09IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgZGltLnggLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIGxpbmUgcG9pbnRzIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNhbGNMaW5lUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4TXVsdCA9IHRoaXMueDEgPD0gdGhpcy54MiA/IC0xIDogMSxcbiAgICAgICAgICB5TXVsdCA9IHRoaXMueTEgPD0gdGhpcy55MiA/IC0xIDogMSxcbiAgICAgICAgICB4MSA9ICh4TXVsdCAqIHRoaXMud2lkdGggKiAwLjUpLFxuICAgICAgICAgIHkxID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAwLjUpLFxuICAgICAgICAgIHgyID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIC0wLjUpLFxuICAgICAgICAgIHkyID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAtMC41KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5jYWxjTGluZVBvaW50cygpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxsaW5lICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAneDE9XCInLCBwLngxLFxuICAgICAgICAnXCIgeTE9XCInLCBwLnkxLFxuICAgICAgICAnXCIgeDI9XCInLCBwLngyLFxuICAgICAgICAnXCIgeTI9XCInLCBwLnkyLFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNMaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkxpbmUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgneDEgeTEgeDIgeTInLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5MaW5lIGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKi9cbiAgZmFicmljLkxpbmUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkxpbmUuQVRUUklCVVRFX05BTUVTKSxcbiAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueDEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLnkxIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MiB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTIgfHwgMFxuICAgICAgICBdO1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuTGluZShwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5MaW5lIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLkxpbmUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBfY2FsbGJhY2soaW5zdGFuY2UpIHtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5wb2ludHM7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgfTtcbiAgICB2YXIgb3B0aW9ucyA9IGNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgb3B0aW9ucy5wb2ludHMgPSBbb2JqZWN0LngxLCBvYmplY3QueTEsIG9iamVjdC54Miwgb2JqZWN0LnkyXTtcbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdMaW5lJywgb3B0aW9ucywgX2NhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGVzIGRpc3RhbmNlIGZyb20gY2FudmFzIGVkZ2UgdG8gTGluZSBvcmlnaW4uXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKHByb3BlcnR5TmFtZXMsIG9yaWdpblZhbHVlcykge1xuICAgIHZhciBvcmlnaW4gPSBwcm9wZXJ0eU5hbWVzLm9yaWdpbixcbiAgICAgICAgYXhpczEgPSBwcm9wZXJ0eU5hbWVzLmF4aXMxLFxuICAgICAgICBheGlzMiA9IHByb3BlcnR5TmFtZXMuYXhpczIsXG4gICAgICAgIGRpbWVuc2lvbiA9IHByb3BlcnR5TmFtZXMuZGltZW5zaW9uLFxuICAgICAgICBuZWFyZXN0ID0gb3JpZ2luVmFsdWVzLm5lYXJlc3QsXG4gICAgICAgIGNlbnRlciA9IG9yaWdpblZhbHVlcy5jZW50ZXIsXG4gICAgICAgIGZhcnRoZXN0ID0gb3JpZ2luVmFsdWVzLmZhcnRoZXN0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgc3dpdGNoICh0aGlzLmdldChvcmlnaW4pKSB7XG4gICAgICAgIGNhc2UgbmVhcmVzdDpcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpO1xuICAgICAgICBjYXNlIGNlbnRlcjpcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpICsgKDAuNSAqIHRoaXMuZ2V0KGRpbWVuc2lvbikpO1xuICAgICAgICBjYXNlIGZhcnRoZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICB9XG4gICAgfTtcblxuICB9XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHBpID0gTWF0aC5QSTtcblxuICBpZiAoZmFicmljLkNpcmNsZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuQ2lyY2xlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ2lyY2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQ2lyY2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkNpcmNsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkNpcmNsZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkNpcmNsZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdjaXJjbGUnLFxuXG4gICAgLyoqXG4gICAgICogUmFkaXVzIG9mIHRoaXMgY2lyY2xlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByYWRpdXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBhbmdsZSBvZiB0aGUgY2lyY2xlLCBtb3ZpbmcgY2xvY2t3aXNlXG4gICAgICogZGVwcmVjYXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogRW5kIGFuZ2xlIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBkZXByZWNhdGVkIHR5cGUsIHRoaXMgc2hvdWxkIGJlIGluIGRlZ3JlZSwgdGhpcyB3YXMgYW4gb3ZlcnNpZ2h0LlxuICAgICAqIHByb2JhYmx5IHdpbGwgY2hhbmdlIHRvIGRlZ3JlZXMgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMlBpXG4gICAgICovXG4gICAgZW5kQW5nbGU6IHBpICogMixcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcblxuICAgICAgaWYgKGtleSA9PT0gJ3JhZGl1cycpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXModmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN2Z1N0cmluZywgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgIGFuZ2xlID0gKHRoaXMuZW5kQW5nbGUgLSB0aGlzLnN0YXJ0QW5nbGUpICUgKCAyICogcGkpO1xuXG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgc3ZnU3RyaW5nID0gW1xuICAgICAgICAgICc8Y2lyY2xlICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAgICdjeD1cIicgKyB4ICsgJ1wiIGN5PVwiJyArIHkgKyAnXCIgJyxcbiAgICAgICAgICAncj1cIicsIHRoaXMucmFkaXVzLFxuICAgICAgICAgICdcIiAvPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnRYID0gZmFicmljLnV0aWwuY29zKHRoaXMuc3RhcnRBbmdsZSkgKiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WSA9IGZhYnJpYy51dGlsLnNpbih0aGlzLnN0YXJ0QW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBlbmRYID0gZmFicmljLnV0aWwuY29zKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBlbmRZID0gZmFicmljLnV0aWwuc2luKHRoaXMuZW5kQW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBsYXJnZUZsYWcgPSBhbmdsZSA+IHBpID8gJzEnIDogJzAnO1xuICAgICAgICBzdmdTdHJpbmcgPSBbXG4gICAgICAgICAgJzxwYXRoIGQ9XCJNICcgKyBzdGFydFggKyAnICcgKyBzdGFydFksXG4gICAgICAgICAgJyBBICcgKyB0aGlzLnJhZGl1cyArICcgJyArIHRoaXMucmFkaXVzLFxuICAgICAgICAgICcgMCAnLCArbGFyZ2VGbGFnICsgJyAxJywgJyAnICsgZW5kWCArICcgJyArIGVuZFksXG4gICAgICAgICAgJ1wiICcsICdDT01NT05fUEFSVFMnLCAnIC8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlLFxuICAgICAgICB0aGlzLmVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFuZCB1cGRhdGVzIHdpZHRoIGFjY29yZGluZ2x5KVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMikuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0NpcmNsZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgaWYgKCFpc1ZhbGlkUmFkaXVzKHBhcnNlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIGNhbiBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yYWRpdXM7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkNpcmNsZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkUmFkaXVzKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKCgncmFkaXVzJyBpbiBhdHRyaWJ1dGVzKSAmJiAoYXR0cmlidXRlcy5yYWRpdXMgPj0gMCkpO1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgZmFicmljLkNpcmNsZVxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIC13aWR0aEJ5MiwgaGVpZ2h0QnkyLCAwLCAtaGVpZ2h0QnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIDAsIC1oZWlnaHRCeTIsIHdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgd2lkdGhCeTIsIGhlaWdodEJ5MiwgLXdpZHRoQnkyLCBoZWlnaHRCeTIsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2lkdGhCeTIgPSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBoZWlnaHRCeTIgPSB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAgLXdpZHRoQnkyICsgJyAnICsgaGVpZ2h0QnkyLFxuICAgICAgICAgICAgJzAgJyArIC1oZWlnaHRCeTIsXG4gICAgICAgICAgICB3aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MlxuICAgICAgICAgIF0uam9pbignLCcpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxwb2x5Z29uICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAncG9pbnRzPVwiJywgcG9pbnRzLFxuICAgICAgICAnXCIgLz4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuVHJpYW5nbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UcmlhbmdsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5UcmlhbmdsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdUcmlhbmdsZScsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBwaUJ5MiAgID0gTWF0aC5QSSAqIDI7XG5cbiAgaWYgKGZhYnJpYy5FbGxpcHNlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5FbGxpcHNlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogRWxsaXBzZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkVsbGlwc2VcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuRWxsaXBzZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5FbGxpcHNlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2VsbGlwc2UnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ4OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ5OiAgIDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldCgncngnLCBvcHRpb25zICYmIG9wdGlvbnMucnggfHwgMCk7XG4gICAgICB0aGlzLnNldCgncnknLCBvcHRpb25zICYmIG9wdGlvbnMucnkgfHwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuXG4gICAgICAgIGNhc2UgJ3J4JzpcbiAgICAgICAgICB0aGlzLnJ4ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyeSc6XG4gICAgICAgICAgdGhpcy5yeSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Ung6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeCcpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeScpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyeCcsICdyeSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxlbGxpcHNlICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAnY3g9XCIwXCIgY3k9XCIwXCIgJyxcbiAgICAgICAgJ3J4PVwiJywgdGhpcy5yeCxcbiAgICAgICAgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJ4LFxuICAgICAgICAwLFxuICAgICAgICBwaUJ5MixcbiAgICAgICAgZmFsc2UpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNFbGxpcHNlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcnggcnknLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuRWxsaXBzZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfVxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yeDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucnk7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5FbGxpcHNlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0VsbGlwc2UnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoZmFicmljLlJlY3QpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlJlY3QgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3RhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlJlY3RcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUmVjdH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUmVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlJlY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5SZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UnhSeSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyByeC9yeSBhdHRyaWJ1dGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJ4Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucnggJiYgIXRoaXMucnkpIHtcbiAgICAgICAgdGhpcy5yeSA9IHRoaXMucng7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJ5ICYmICF0aGlzLnJ4KSB7XG4gICAgICAgIHRoaXMucnggPSB0aGlzLnJ5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgLy8gMXgxIGNhc2UgKHVzZWQgaW4gc3ByYXkgYnJ1c2gpIG9wdGltaXphdGlvbiB3YXMgcmVtb3ZlZCBiZWNhdXNlXG4gICAgICAvLyB3aXRoIGNhY2hpbmcgYW5kIGhpZ2hlciB6b29tIGxldmVsIHRoaXMgbWFrZXMgbW9yZSBkYW1hZ2UgdGhhbiBoZWxwXG5cbiAgICAgIHZhciByeCA9IHRoaXMucnggPyBNYXRoLm1pbih0aGlzLnJ4LCB0aGlzLndpZHRoIC8gMikgOiAwLFxuICAgICAgICAgIHJ5ID0gdGhpcy5yeSA/IE1hdGgubWluKHRoaXMucnksIHRoaXMuaGVpZ2h0IC8gMikgOiAwLFxuICAgICAgICAgIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICB4ID0gLXRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHkgPSAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIGlzUm91bmRlZCA9IHJ4ICE9PSAwIHx8IHJ5ICE9PSAwLFxuICAgICAgICAgIC8qIFwibWFnaWMgbnVtYmVyXCIgZm9yIGJlemllciBhcHByb3hpbWF0aW9ucyBvZiBhcmNzIChodHRwOi8vaXRjLmt0dS5sdC9pdGMzNTQvUmlza3VzMzU0LnBkZikgKi9cbiAgICAgICAgICBrID0gMSAtIDAuNTUyMjg0NzQ5ODtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuXG4gICAgICBjdHgubGluZVRvKHggKyB3IC0gcngsIHkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3IC0gayAqIHJ4LCB5LCB4ICsgdywgeSArIGsgKiByeSwgeCArIHcsIHkgKyByeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcnkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3LCB5ICsgaCAtIGsgKiByeSwgeCArIHcgLSBrICogcngsIHkgKyBoLCB4ICsgdyAtIHJ4LCB5ICsgaCk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaCk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIGsgKiByeCwgeSArIGgsIHgsIHkgKyBoIC0gayAqIHJ5LCB4LCB5ICsgaCAtIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHkgKyBrICogcnksIHggKyBrICogcngsIHksIHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHksIHggKyB3LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5LCB4ICsgdywgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHkgKyBoLCB4LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5ICsgaCwgeCwgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyeCcsICdyeSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSAtdGhpcy53aWR0aCAvIDIsIHkgPSAtdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxyZWN0ICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAneD1cIicsIHgsICdcIiB5PVwiJywgeSxcbiAgICAgICAgJ1wiIHJ4PVwiJywgdGhpcy5yeCwgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlJlY3QuZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUmVjdEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3ggeSByeCByeSB3aWR0aCBoZWlnaHQnLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUmVjdH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlJlY3QuQVRUUklCVVRFX05BTUVTKTtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmhlaWdodCAgPSBwYXJzZWRBdHRyaWJ1dGVzLmhlaWdodCB8fCAwO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMud2lkdGggID0gcGFyc2VkQXR0cmlidXRlcy53aWR0aCB8fCAwO1xuICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KGV4dGVuZCgob3B0aW9ucyA/IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgICByZWN0LnZpc2libGUgPSByZWN0LnZpc2libGUgJiYgcmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwO1xuICAgIGNhbGxiYWNrKHJlY3QpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUmVjdH0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUmVjdCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUmVjdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdSZWN0Jywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlBvbHlsaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5bGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUG9seWxpbmUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5bGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUG9seWxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgLyoqXG4gICAgICogUG9pbnRzIGFycmF5XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBvaW50czogbnVsbCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncG9pbnRzJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgKHdoZXJlIGVhY2ggcG9pbnQgaXMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSB0aGlzQXJnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IG5ldyBmYWJyaWMuUG9seWxpbmUoW1xuICAgICAqICAgICB7IHg6IDEwLCB5OiAxMCB9LFxuICAgICAqICAgICB7IHg6IDUwLCB5OiAzMCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiA3MCB9LFxuICAgICAqICAgICB7IHg6IDYwLCB5OiA1MCB9LFxuICAgICAqICAgICB7IHg6IDEwMCwgeTogMTUwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDEwMCB9XG4gICAgICogICBdLCB7XG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBfc2V0UG9zaXRpb25EaW1lbnNpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FsY0RpbSA9IHRoaXMuX2NhbGNEaW1lbnNpb25zKG9wdGlvbnMpLCBjb3JyZWN0TGVmdFRvcDtcbiAgICAgIHRoaXMud2lkdGggPSBjYWxjRGltLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBjYWxjRGltLmhlaWdodDtcbiAgICAgIGlmICghb3B0aW9ucy5mcm9tU1ZHKSB7XG4gICAgICAgIGNvcnJlY3RMZWZ0VG9wID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKFxuICAgICAgICAgIHsgeDogY2FsY0RpbS5sZWZ0IC0gdGhpcy5zdHJva2VXaWR0aCAvIDIsIHk6IGNhbGNEaW0udG9wIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIgfSxcbiAgICAgICAgICAnbGVmdCcsXG4gICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgdGhpcy5vcmlnaW5YLFxuICAgICAgICAgIHRoaXMub3JpZ2luWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IG9wdGlvbnMuZnJvbVNWRyA/IGNhbGNEaW0ubGVmdCA6IGNvcnJlY3RMZWZ0VG9wLng7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IG9wdGlvbnMuZnJvbVNWRyA/IGNhbGNEaW0udG9wIDogY29ycmVjdExlZnRUb3AueTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aE9mZnNldCA9IHtcbiAgICAgICAgeDogY2FsY0RpbS5sZWZ0ICsgdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHk6IGNhbGNEaW0udG9wICsgdGhpcy5oZWlnaHQgLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvbHlnb24gbWluIGFuZCBtYXggcG9pbnQgZnJvbSBwb2ludHMgYXJyYXksXG4gICAgICogcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB0byBtZWFzdXJlIHRoZVxuICAgICAqIHBvbHlnb24gc2l6ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LmxlZnQgWCBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uIGxlZnRtb3N0IHBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QudG9wIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvbiB0b3Btb3N0IHBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGggZGlzdGFuY2UgYmV0d2VlbiBYIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uIGxlZnRtb3N0IGFuZCByaWdodG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC5oZWlnaHQgZGlzdGFuY2UgYmV0d2VlbiBZIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uIHRvcG1vc3QgYW5kIGJvdHRvbW1vc3QgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICBtaW5YID0gbWluKHBvaW50cywgJ3gnKSB8fCAwLFxuICAgICAgICAgIG1pblkgPSBtaW4ocG9pbnRzLCAneScpIHx8IDAsXG4gICAgICAgICAgbWF4WCA9IG1heChwb2ludHMsICd4JykgfHwgMCxcbiAgICAgICAgICBtYXhZID0gbWF4KHBvaW50cywgJ3knKSB8fCAwLFxuICAgICAgICAgIHdpZHRoID0gKG1heFggLSBtaW5YKSxcbiAgICAgICAgICBoZWlnaHQgPSAobWF4WSAtIG1pblkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgcG9pbnRzOiB0aGlzLnBvaW50cy5jb25jYXQoKVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IFtdLCBkaWZmWCA9IHRoaXMucGF0aE9mZnNldC54LCBkaWZmWSA9IHRoaXMucGF0aE9mZnNldC55LFxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludHMucHVzaChcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMucG9pbnRzW2ldLnggLSBkaWZmWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICcsJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMucG9pbnRzW2ldLnkgLSBkaWZmWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICcgJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzwnICsgdGhpcy50eXBlICsgJyAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cy5qb2luKCcnKSxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBjb21tb25SZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBvaW50LCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgeCA9IHRoaXMucGF0aE9mZnNldC54LFxuICAgICAgICAgIHkgPSB0aGlzLnBhdGhPZmZzZXQueTtcblxuICAgICAgaWYgKCFsZW4gfHwgaXNOYU4odGhpcy5wb2ludHNbbGVuIC0gMV0ueSkpIHtcbiAgICAgICAgLy8gZG8gbm90IGRyYXcgaWYgbm8gcG9pbnRzIG9yIG9kZCBwb2ludHNcbiAgICAgICAgLy8gTmFOIGNvbWVzIGZyb20gcGFyc2VGbG9hdCBvZiBhIGVtcHR5IHN0cmluZyBpbiBwYXJzZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLnBvaW50c1swXS54IC0geCwgdGhpcy5wb2ludHNbMF0ueSAtIHkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LnggLSB4LCBwb2ludC55IC0geSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAxLCBwMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHAxID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5wb2ludHNbaSArIDFdIHx8IHAxO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHAxLngsIHAxLnksIHAyLngsIHAyLnksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IgPSBmdW5jdGlvbihfY2xhc3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHBvaW50cyA9IGZhYnJpYy5wYXJzZVBvaW50c0F0dHJpYnV0ZShlbGVtZW50LmdldEF0dHJpYnV0ZSgncG9pbnRzJykpLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpY1tfY2xhc3NdLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgICBwYXJzZWRBdHRyaWJ1dGVzLmZyb21TVkcgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpY1tfY2xhc3NdKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gICAgfTtcbiAgfTtcblxuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnQgPSBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IoJ1BvbHlsaW5lJyk7XG5cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlsaW5lJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5Z29uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5Z29uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5Z29uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWdvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBvbHlnb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlBvbHlsaW5lLCAvKiogQGxlbmRzIGZhYnJpYy5Qb2x5Z29uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlnb24nLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJEYXNoZWRTdHJva2UnLCBjdHgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUG9seWdvbkVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlBvbHlnb259IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50ID0gZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yKCdQb2x5Z29uJyk7XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlnb24gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQb2x5Z29uJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgsXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGlmIChmYWJyaWMuUGF0aCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUGF0aCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUGF0aCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBhdGhcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNwYXRoX2FuZF9wYXRoZ3JvdXB9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXRoI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUGF0aCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBhdGgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncGF0aCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwYXRoIHBvaW50c1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoOiBudWxsLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdwYXRoJywgJ2ZpbGxSdWxlJyksXG5cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3BhdGgnKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHBhdGggUGF0aCBkYXRhIChzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyBhbmQgY29ycmVzcG9uZGluZyBcImNvbW1hbmRcIiB0b2tlbnMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIGlmICghcGF0aCkge1xuICAgICAgICBwYXRoID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tQXJyYXkgPSBfdG9TdHJpbmcuY2FsbChwYXRoKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblxuICAgICAgdGhpcy5wYXRoID0gZnJvbUFycmF5XG4gICAgICAgID8gZmFicmljLnV0aWwubWFrZVBhdGhTaW1wbGVyKHBhdGgpXG5cbiAgICAgICAgOiBmYWJyaWMudXRpbC5tYWtlUGF0aFNpbXBsZXIoXG4gICAgICAgICAgZmFicmljLnV0aWwucGFyc2VQYXRoKHBhdGgpXG4gICAgICAgICk7XG5cbiAgICAgIGlmICghdGhpcy5wYXRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5Qb2x5bGluZS5wcm90b3R5cGUuX3NldFBvc2l0aW9uRGltZW5zaW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgcGF0aCBvblxuICAgICAqL1xuICAgIF9yZW5kZXJQYXRoQ29tbWFuZHM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgbCA9IC10aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB0ID0gLXRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICAgICAgeSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgY3VycmVudFszXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0gKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIHBhdGggb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBhdGhDb21tYW5kcyhjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLlBhdGggKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IFwidG9wXCI6ICcgKyB0aGlzLnRvcCArICcsIFwibGVmdFwiOiAnICsgdGhpcy5sZWZ0ICsgJyB9Pic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgcGF0aDogdGhpcy5wYXRoLm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLnNsaWNlKCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KFsnc291cmNlUGF0aCddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgICBpZiAoby5zb3VyY2VQYXRoKSB7XG4gICAgICAgIGRlbGV0ZSBvLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aC5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5qb2luKCcgJyk7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHBhdGggJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICAnLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICBfZ2V0T2Zmc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaWdpdHMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICByZXR1cm4gJyB0cmFuc2xhdGUoJyArIHRvRml4ZWQoLXRoaXMucGF0aE9mZnNldC54LCBkaWdpdHMpICsgJywgJyArXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy5wYXRoT2Zmc2V0LnksIGRpZ2l0cykgKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsVHJhbnNmb3JtID0gdGhpcy5fZ2V0T2Zmc2V0VHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAoXG4gICAgICAgIHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSB9XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSB0aGlzLl9nZXRPZmZzZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSAgfSk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IDAsXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IDAsXG4gICAgICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgICAgICBib3VuZHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgYVgucHVzaChwb2ludC54KTtcbiAgICAgICAgICBhWS5wdXNoKHBvaW50LnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYVgucHVzaCh4KTtcbiAgICAgICAgYVkucHVzaCh5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pblggPSBtaW4oYVgpIHx8IDAsXG4gICAgICAgICAgbWluWSA9IG1pbihhWSkgfHwgMCxcbiAgICAgICAgICBtYXhYID0gbWF4KGFYKSB8fCAwLFxuICAgICAgICAgIG1heFkgPSBtYXgoYVkpIHx8IDAsXG4gICAgICAgICAgZGVsdGFYID0gbWF4WCAtIG1pblgsXG4gICAgICAgICAgZGVsdGFZID0gbWF4WSAtIG1pblk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IGRlbHRhWCxcbiAgICAgICAgaGVpZ2h0OiBkZWx0YVlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5zb3VyY2VQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhdGhVcmwgPSBvYmplY3Quc291cmNlUGF0aDtcbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChwYXRoVXJsLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBlbGVtZW50c1swXTtcbiAgICAgICAgcGF0aC5zZXRPcHRpb25zKG9iamVjdCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUGF0aCcsIG9iamVjdCwgY2FsbGJhY2ssICdwYXRoJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBhdGguZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFsnZCddKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIFNWRyA8cGF0aD4gZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTKTtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmZyb21TVkcgPSB0cnVlO1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuUGF0aChwYXJzZWRBdHRyaWJ1dGVzLmQsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXg7XG5cbiAgaWYgKGZhYnJpYy5Hcm91cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyb3VwXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQG1peGVzIGZhYnJpYy5Db2xsZWN0aW9uXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2dyb3Vwc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyb3VwI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JvdXAgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCBmYWJyaWMuQ29sbGVjdGlvbiwgLyoqIEBsZW5kcyBmYWJyaWMuR3JvdXAucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2Ygc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBjbGljaywgbW91c2VvdmVyLCBtb3VzZW91dCBldmVudHMgJiBob3ZlckN1cnNvciBzaG91bGQgYWxzbyBjaGVjayBmb3Igc3VidGFyZ2V0c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1YlRhcmdldENoZWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhcmUgY29udGFpbmVyLCBkbyBub3QgcmVuZGVyIGFueXRoaW5nIG9uIHRoZXlyIG93biwgZW5jZSBubyBjYWNoZSBwcm9wZXJ0aWVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogW10sXG5cbiAgICAvKipcbiAgICAgKiBzZXRPbkdyb3VwIGlzIGEgbWV0aG9kIHVzZWQgZm9yIFRleHRCb3ggdGhhdCBpcyBubyBtb3JlIHVzZWQgc2luY2UgMi4wLjAgVGhlIGJlaGF2aW9yIGlzIHN0aWxsXG4gICAgICogYXZhaWxhYmxlIHNldHRpbmcgdGhpcyBib29sZWFuIHRvIHRydWUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdXNlU2V0T25Hcm91cDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEdyb3VwIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNBbHJlYWR5R3JvdXBlZF0gaWYgdHJ1ZSwgb2JqZWN0cyBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMsIGlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgLy8gaWYgb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHksXG4gICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAgICAgIC8vIFRodXMgd2UgbmVlZCB0byBzZXQgb3B0aW9ucyB0byBncm91cCB3aXRob3V0IG9iamVjdHMsXG4gICAgICBpc0FscmVhZHlHcm91cGVkICYmIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICB2YXIgY2VudGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNlbnRlclBvaW50O1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHNldCBvcmlnaW5zIGJlZm9yZSBjYWxjdWxhdGluZyB0aGUgYm91bmRpbmcgYm94LlxuICAgICAgICAvLyBzbyB0aGF0IHRoZSB0b3BsZWZ0IGNhbiBiZSBzZXQgd2l0aCB0aGF0IGluIG1pbmQuXG4gICAgICAgIC8vIGlmIHNwZWNpZmljIHRvcCBhbmQgbGVmdCBhcmUgcGFzc2VkLCBhcmUgb3ZlcndyaXR0ZW4gbGF0ZXJcbiAgICAgICAgLy8gd2l0aCB0aGUgY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucylcbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9yaWdpblkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3JpZ2luWSA9IG9wdGlvbnMub3JpZ2luWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjb21pbmcgZnJvbSBzdmcgaSBkbyBub3Qgd2FudCB0byBjYWxjIGJvdW5kcy5cbiAgICAgICAgLy8gaSBhc3N1bWUgd2lkdGggYW5kIGhlaWdodCBhcmUgcGFzc2VkIGFsb25nIG9wdGlvbnNcbiAgICAgICAgY2VudGVyIHx8IHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcyhjZW50ZXIpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jZW50ZXJQb2ludDtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RzQUNvb3JkcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RzQUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2tpcENvbnRyb2xzID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldENvb3Jkcyhza2lwQ29udHJvbHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgdmFyIGNlbnRlciA9IGNlbnRlciB8fCB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0Q29vcmRzKHRoaXMuX29iamVjdHNbaV0sIGNlbnRlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIsIGN1cnJlbnQgY2VudGVyIG9mIGdyb3VwLlxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RDb29yZHM6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICB2YXIgb2JqZWN0TGVmdCA9IG9iamVjdC5sZWZ0LFxuICAgICAgICAgIG9iamVjdFRvcCA9IG9iamVjdC50b3AsXG4gICAgICAgICAgc2tpcENvbnRyb2xzID0gdHJ1ZTtcblxuICAgICAgb2JqZWN0LnNldCh7XG4gICAgICAgIGxlZnQ6IG9iamVjdExlZnQgLSBjZW50ZXIueCxcbiAgICAgICAgdG9wOiBvYmplY3RUb3AgLSBjZW50ZXIueVxuICAgICAgfSk7XG4gICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgb2JqZWN0LnNldENvb3Jkcyhza2lwQ29udHJvbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbmF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5Hcm91cDogKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gb2JqZWN0IHRvIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZFdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gb2JqZWN0IGZyb20gYSBncm91cDsgVGhlbiByZWNhbGN1bGF0ZXMgZ3JvdXAncyBkaW1lbnNpb24sIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVtb3ZlV2l0aFVwZGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgICBmYWJyaWMudXRpbC5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcblxuICAgICAgdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5fc2V0KCdjYW52YXMnLCB0aGlzLmNhbnZhcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnVzZVNldE9uR3JvdXApIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0T25Hcm91cChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3NldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgX2luY2x1ZGVEZWZhdWx0VmFsdWVzID0gdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgIHZhciBvYmpzVG9PYmplY3QgPSB0aGlzLl9vYmplY3RzLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IF9pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgdmFyIF9vYmogPSBvYmoudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgfSk7XG4gICAgICB2YXIgb2JqID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UsIGluIGRhdGFsZXNzIG1vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9ianNUb09iamVjdCwgc291cmNlUGF0aCA9IHRoaXMuc291cmNlUGF0aDtcbiAgICAgIGlmIChzb3VyY2VQYXRoKSB7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHRoaXMuX29iamVjdHMubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHZhciBvcmlnaW5hbERlZmF1bHRzID0gb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IF9pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICB2YXIgX29iaiA9IG9iai50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgICAgcmV0dXJuIF9vYmo7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvRGF0YWxlc3NPYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZSBvbiBhIGdpdmVuIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIGluc3RhbmNlIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIGlzIGFscmVhZHkgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG93bkNhY2hlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuc2hvdWxkQ2FjaGUuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChvd25DYWNoZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICAgIHRoaXMub3duQ2FjaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG93bkNhY2hlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHdpbGxEcmF3U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS53aWxsRHJhd1NoYWRvdy5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duQ2FjaGluZyB8fCAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmF3Q2xpcFBhdGgoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FjaGUgaXMgZGlydHlcbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxTdXBlcignaXNDYWNoZURpcnR5Jywgc2tpcENhbnZhcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0uaXNDYWNoZURpcnR5KHRydWUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGhhcyBub3QgYSBjYWNoZSBjYW52YXMgdGhlcmUgaXMgbm90aGluZyB0byBjbGVhblxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YLCB5ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC14IC8gMiwgLXkgLyAyLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgc3RhdGUgb2YgZWFjaCBvZiBncm91cCBvYmplY3RzIChvcmlnaW5hbCBzdGF0ZSBpcyB0aGF0IHdoaWNoIHdhcyBiZWZvcmUgZ3JvdXAgd2FzIGNyZWF0ZWQpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9yZXN0b3JlT2JqZWN0c1N0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29iamVjdHMuZm9yRWFjaCh0aGlzLl9yZXN0b3JlT2JqZWN0U3RhdGUsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWxpc2VzIHRoZSB0cmFuc2Zvcm0gZnJvbSB0aGlzIGdyb3VwIG9udG8gdGhlIHN1cHBsaWVkIG9iamVjdFxuICAgICAqIGkuZS4gaXQgdGVsbHMgeW91IHdoYXQgd291bGQgaGFwcGVuIGlmIHRoZSBzdXBwbGllZCBvYmplY3Qgd2FzIGluXG4gICAgICogdGhlIGdyb3VwLCBhbmQgdGhlbiB0aGUgZ3JvdXAgd2FzIGRlc3Ryb3llZC4gSXQgbXV0YXRlcyB0aGUgc3VwcGxpZWRcbiAgICAgKiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0cmFuc2Zvcm1lZE9iamVjdFxuICAgICAqL1xuICAgIHJlYWxpemVUcmFuc2Zvcm06IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIG1hdHJpeCA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKG1hdHJpeCksXG4gICAgICAgICAgY2VudGVyID0gbmV3IGZhYnJpYy5Qb2ludChvcHRpb25zLnRyYW5zbGF0ZVgsIG9wdGlvbnMudHJhbnNsYXRlWSk7XG4gICAgICBvYmplY3QuZmxpcFggPSBmYWxzZTtcbiAgICAgIG9iamVjdC5mbGlwWSA9IGZhbHNlO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgb2JqZWN0LnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgIG9iamVjdC5za2V3WSA9IG9wdGlvbnMuc2tld1k7XG4gICAgICBvYmplY3QuYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgb2JqZWN0LnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgc3RhdGUgb2YgYSBzcGVjaWZpZWQgb2JqZWN0IGluIGdyb3VwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9yZXN0b3JlT2JqZWN0U3RhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5yZWFsaXplVHJhbnNmb3JtKG9iamVjdCk7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JvdXAgKHJlc3RvcmluZyBzdGF0ZSBvZiBpdHMgb2JqZWN0cylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyB3aGVuIGdyb3VwIGlzIGRlc3Ryb3llZCBvYmplY3RzIG5lZWRzIHRvIGdldCBhIHJlcGFpbnQgdG8gYmUgZXZlbnR1YWxseVxuICAgICAgLy8gZGlzcGxheWVkIG9uIGNhbnZhcy5cbiAgICAgIHRoaXMuX29iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGdyb3VwIGFuIGFjdGl2ZSBzZWxlY3Rpb24sIHJlbW92ZSB0aGUgZ3JvdXAgZnJvbSBjYW52YXNcbiAgICAgKiB0aGUgZ3JvdXAgaGFzIHRvIGJlIG9uIGNhbnZhcyBmb3IgdGhpcyB0byB3b3JrLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdG9BY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKFtdKTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5zZXQob3B0aW9ucyk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24udHlwZSA9ICdhY3RpdmVTZWxlY3Rpb24nO1xuICAgICAgY2FudmFzLnJlbW92ZSh0aGlzKTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgICBvYmplY3QuZGlydHkgPSB0cnVlO1xuICAgICAgICBjYW52YXMuYWRkKG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5jYW52YXMgPSBjYW52YXM7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHMgPSBvYmplY3RzO1xuICAgICAgY2FudmFzLl9hY3RpdmVPYmplY3QgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uc2V0Q29vcmRzKCk7XG4gICAgICByZXR1cm4gYWN0aXZlU2VsZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIGdyb3VwIChyZXN0b3Jpbmcgc3RhdGUgb2YgaXRzIG9iamVjdHMpXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHVuZ3JvdXBPbkNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvb3JkaW5hdGVzIG9mIGFsbCBvYmplY3RzIGluc2lkZSBncm91cFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRPYmplY3RzQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBza2lwQ29udHJvbHMgPSB0cnVlO1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKHNraXBDb250cm9scyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjQm91bmRzOiBmdW5jdGlvbihvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgbywgcHJvcCxcbiAgICAgICAgICBwcm9wcyA9IFsndHInLCAnYnInLCAnYmwnLCAndGwnXSxcbiAgICAgICAgICBpID0gMCwgaUxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGosIGpMZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoIDsgaSA8IGlMZW47ICsraSkge1xuICAgICAgICBvID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgby5hQ29vcmRzID0gby5jYWxjQUNvb3JkcygpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICAgIGFYLnB1c2goby5hQ29vcmRzW3Byb3BdLngpO1xuICAgICAgICAgIGFZLnB1c2goby5hQ29vcmRzW3Byb3BdLnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dldEJvdW5kcyhhWCwgYVksIG9ubHlXaWR0aEhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24oYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBtaW5YWSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKGFYKSwgbWluKGFZKSksXG4gICAgICAgICAgbWF4WFkgPSBuZXcgZmFicmljLlBvaW50KG1heChhWCksIG1heChhWSkpLFxuICAgICAgICAgIHRvcCA9IG1pblhZLnkgfHwgMCwgbGVmdCA9IG1pblhZLnggfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYWS54IC0gbWluWFkueCkgfHwgMCxcbiAgICAgICAgICBoZWlnaHQgPSAobWF4WFkueSAtIG1pblhZLnkpIHx8IDA7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGlmICghb25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICAgIC8vIHRoZSBib3VuZGluZyBib3ggYWx3YXlzIGZpbmRzIHRoZSB0b3BsZWZ0IG1vc3QgY29ybmVyLlxuICAgICAgICAvLyB3aGF0ZXZlciBpcyB0aGUgZ3JvdXAgb3JpZ2luLCB3ZSBzZXQgdXAgaGVyZSB0aGUgbGVmdC90b3AgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbih7IHg6IGxlZnQsIHk6IHRvcCB9LCAnbGVmdCcsICd0b3AnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbJzxnICcsICdDT01NT05fUEFSVFMnLCAnID5cXG4nXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goJ1xcdFxcdCcsIHRoaXMuX29iamVjdHNbaV0udG9TVkcocmV2aXZlcikpO1xuICAgICAgfVxuICAgICAgc3ZnU3RyaW5nLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIHJldHVybiBzdmdTdHJpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydCwgc3BlY2lmaWMgdmVyc2lvbiBmb3IgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gdHlwZW9mIHRoaXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcGFjaXR5ICE9PSAxID9cbiAgICAgICAgICAgICdvcGFjaXR5OiAnICsgdGhpcy5vcGFjaXR5ICsgJzsnIDogJycsXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJsZSA/ICcnIDogJyB2aXNpYmlsaXR5OiBoaWRkZW47JztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goJ1xcdCcsIHRoaXMuX29iamVjdHNbaV0udG9DbGlwUGF0aFNWRyhyZXZpdmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAoc3ZnU3RyaW5nLCB7IHJldml2ZXI6IHJldml2ZXIgfSk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5Hcm91cH0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkdyb3VwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyb3VwIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBncm91cCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuR3JvdXAuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2JqZWN0cyA9IG9iamVjdC5vYmplY3RzLFxuICAgICAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgZGVsZXRlIG9wdGlvbnMub2JqZWN0cztcbiAgICBpZiAodHlwZW9mIG9iamVjdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBpdCBoYXMgdG8gYmUgYW4gdXJsIG9yIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgZmFicmljLmxvYWRTVkdGcm9tVVJMKG9iamVjdHMsIGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBmYWJyaWMudXRpbC5ncm91cFNWR0VsZW1lbnRzKGVsZW1lbnRzLCBvYmplY3QsIG9iamVjdHMpO1xuICAgICAgICBncm91cC5zZXQob3B0aW9ucyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGdyb3VwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbb2JqZWN0LmNsaXBQYXRoXSwgZnVuY3Rpb24oZW5saXZlZENsaXBQYXRoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgICAgIG9wdGlvbnMuY2xpcFBhdGggPSBlbmxpdmVkQ2xpcFBhdGhbMF07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuR3JvdXAoZW5saXZlbmVkT2JqZWN0cywgb3B0aW9ucywgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkFjdGl2ZVNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkFjdGl2ZVNlbGVjdGlvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuR3JvdXBcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkdyb3VwLCAvKiogQGxlbmRzIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnYWN0aXZlU2VsZWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMgQWN0aXZlU2VsZWN0aW9uIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSkge1xuICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGUgYWN0aXZlU2VsZWN0aW9uIHRvIGEgbm9ybWFsIGdyb3VwLFxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdGhhdCBhdXRvbWF0aWNhbGx5IGFkZHMgaXQgdG8gY2FudmFzIGFzXG4gICAgICogYWN0aXZlIG9iamVjdC4gbm8gZXZlbnRzIGZpcmVkLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICB0b0dyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cy5jb25jYXQoKTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBuZXdHcm91cCA9IG5ldyBmYWJyaWMuR3JvdXAoW10pO1xuICAgICAgZGVsZXRlIG9wdGlvbnMudHlwZTtcbiAgICAgIG5ld0dyb3VwLnNldChvcHRpb25zKTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmNhbnZhcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gbmV3R3JvdXA7XG4gICAgICB9KTtcbiAgICAgIG5ld0dyb3VwLl9vYmplY3RzID0gb2JqZWN0cztcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIG5ld0dyb3VwO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2FudmFzLmFkZChuZXdHcm91cCk7XG4gICAgICBjYW52YXMuX2FjdGl2ZU9iamVjdCA9IG5ld0dyb3VwO1xuICAgICAgbmV3R3JvdXAuc2V0Q29vcmRzKCk7XG4gICAgICByZXR1cm4gbmV3R3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHJldHVybnMgdHJ1ZSwgZGVzZWxlY3Rpb24gaXMgY2FuY2VsbGVkLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFtjYW5jZWxdXG4gICAgICovXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBncm91cFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkFjdGl2ZVNlbGVjdGlvbjogKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBncm91cCBvciBpdHMgcGFyZW50IGdyb3VwIGFyZSBjYWNoaW5nLCByZWN1cnNpdmVseSB1cFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPbkFDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NoaWxkcmVuT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIGNoaWxkcmVuIG92ZXJyaWRlc1xuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlLCBjaGlsZHJlbk92ZXJyaWRlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5pc01vdmluZyA/IHRoaXMuYm9yZGVyT3BhY2l0eVdoZW5Nb3ZpbmcgOiAxO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJDb250cm9scycsIGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICBjaGlsZHJlbk92ZXJyaWRlID0gY2hpbGRyZW5PdmVycmlkZSB8fCB7IH07XG4gICAgICBpZiAodHlwZW9mIGNoaWxkcmVuT3ZlcnJpZGUuaGFzQ29udHJvbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuaGFzQ29udHJvbHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuZm9yQWN0aXZlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3JlbmRlckNvbnRyb2xzKGN0eCwgY2hpbGRyZW5PdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQWN0aXZlU2VsZWN0aW9ufSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyb3VwIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBBY3RpdmVTZWxlY3Rpb24gaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkFjdGl2ZVNlbGVjdGlvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdC5vYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBkZWxldGUgb2JqZWN0Lm9iamVjdHM7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihlbmxpdmVuZWRPYmplY3RzLCBvYmplY3QsIHRydWUpKTtcbiAgICB9KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKCFnbG9iYWwuZmFicmljKSB7XG4gICAgZ2xvYmFsLmZhYnJpYyA9IHsgfTtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZmFicmljLkltYWdlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5JbWFnZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEltYWdlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2VcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNpbWFnZXN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkltYWdlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnaW1hZ2UnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBzdHJva2UuXG4gICAgICogRm9yIGltYWdlIHF1YWxpdHkgYSBzdHJva2UgbXVsdGlwbGUgb2YgMiBnaXZlcyBiZXR0ZXIgcmVzdWx0cy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBjYWxsaW5nIHtAbGluayBmYWJyaWMuSW1hZ2UuZ2V0U3JjfSwgcmV0dXJuIHZhbHVlIGZyb20gZWxlbWVudCBzcmMgd2l0aCBgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpYC5cbiAgICAgKiBUaGlzIGFsbG93cyBmb3IgcmVsYXRpdmUgdXJscyBhcyBpbWFnZSBzcmMuXG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3JjRnJvbUF0dHJpYnV0ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVggdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGVZIHRvIGRldGVjdFxuICAgICAqIGlmIHRoZSBJbWFnZSBnb3QgcmVzaXplZCBhZnRlciB0aGUgbGFzdCBSZW5kZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfbGFzdFNjYWxlWTogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxpbmcgYXBwbGllZCBieSB0aGUgYXBwbHkgZmlsdGVyIGNoYWluXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2ZpbHRlclNjYWxpbmdYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1k6IDEsXG5cbiAgICAvKipcbiAgICAgKiBtaW5pbXVtIHNjYWxlIGZhY3RvciB1bmRlciB3aGljaCBhbnkgcmVzaXplRmlsdGVyIGlzIHRyaWdnZXJlZCB0byByZXNpemUgdGhlIGltYWdlXG4gICAgICogMCB3aWxsIGRpc2FibGUgdGhlIGF1dG9tYXRpYyByZXNpemUuIDEgd2lsbCB0cmlnZ2VyIGF1dG9tYXRpY2FsbHkgYWx3YXlzLlxuICAgICAqIG51bWJlciBiaWdnZXIgdGhhbiAxIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIG1pbmltdW1TY2FsZVRyaWdnZXI6IDAuNSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICoga2V5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHRleHR1cmUgcmVwcmVzZW50aW5nIHRoaXMgaW1hZ2VcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlS2V5OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BYOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgY3JvcCBpbiBwaXhlbHMgZnJvbSBvcmlnaW5hbCBpbWFnZSBzaXplLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcgd2hlbiBwYWludGluZyB0aGlzIGltYWdlLlxuICAgICAqIEFsc28gaW5mbHVlbmNlIGlmIHRoZSBjYWNoZUNhbnZhcyBmb3IgdGhpcyBpbWFnZSB1c2VzIGltYWdlU21vb3RoaW5nXG4gICAgICogQHNpbmNlIDQuMC4wLWJldGEuMTFcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgU3RyaW5nfSBlbGVtZW50IEltYWdlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIGV2ZW50dWFsIGZpbHRlcnMgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgdGhpcy5jYWNoZUtleSA9ICd0ZXh0dXJlJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0RWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbWFnZSBlbGVtZW50IHdoaWNoIHRoaXMgaW5zdGFuY2UgaWYgYmFzZWQgb25cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudCB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbWFnZSBlbGVtZW50IGZvciB0aGlzIGluc3RhbmNlIHRvIGEgc3BlY2lmaWVkIG9uZS5cbiAgICAgKiBJZiBmaWx0ZXJzIGRlZmluZWQgdGhleSBhcmUgYXBwbGllZCB0byBuZXcgaW1hZ2UuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgY2FudmFzLnJlbmRlckFsbGAgYW5kIGBvYmplY3Quc2V0Q29vcmRzYCBhZnRlciByZXBsYWNpbmcsIHRvIHJlbmRlciBuZXcgaW1hZ2UgYW5kIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbml0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc2l6ZUZpbHRlcnMgd29yayBvbiB0aGUgYWxyZWFkeSBmaWx0ZXJlZCBjb3B5LlxuICAgICAgLy8gd2UgbmVlZCB0byBhcHBseSByZXNpemVGaWx0ZXJzIEFGVEVSIG5vcm1hbCBmaWx0ZXJzLlxuICAgICAgLy8gYXBwbHlSZXNpemVGaWx0ZXJzIGlzIHJ1biBtb3JlIG9mdGVuIHRoYW4gbm9ybWFsIGZpbHRlcnNcbiAgICAgIC8vIGFuZCBpcyB0cmlnZ2VyZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgcmF0aGVyIHRoYW4gZGV2IGNvZGVcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHNpbmdsZSB0ZXh0dXJlIGlmIGluIHdlYmdsIG1vZGVcbiAgICAgKi9cbiAgICByZW1vdmVUZXh0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBiYWNrZW5kID0gZmFicmljLmZpbHRlckJhY2tlbmQ7XG4gICAgICBpZiAoYmFja2VuZCAmJiBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KSB7XG4gICAgICAgIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRleHR1cmVzLCByZWZlcmVuY2UgdG8gZWxlbWVudHMgYW5kIGV2ZW50dWFsbHkgSlNET00gY2xlYW51cFxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICBbJ19vcmlnaW5hbEVsZW1lbnQnLCAnX2VsZW1lbnQnLCAnX2ZpbHRlcmVkRWwnLCAnX2NhY2hlQ2FudmFzJ10uZm9yRWFjaCgoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlKHRoaXNbZWxlbWVudF0pO1xuICAgICAgICB0aGlzW2VsZW1lbnRdID0gdW5kZWZpbmVkO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3Jvc3NPcmlnaW4gdmFsdWUgKG9mIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGVsZW1lbnQpXG4gICAgICovXG4gICAgZ2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsRWxlbWVudCAmJiAodGhpcy5fb3JpZ2luYWxFbGVtZW50LmNyb3NzT3JpZ2luIHx8IG51bGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9yaWdpbmFsIHNpemUgb2YgYW4gaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIiBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T3JpZ2luYWxTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZWxlbWVudC5uYXR1cmFsV2lkdGggfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCAvIDIsIGggPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKC13LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckRhc2hlZFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCB0aGlzKTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4ICsgdywgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSwgeCArIHcsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5ICsgaCwgeCwgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSArIGgsIHgsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAgIHRoaXMuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlck9iaikge1xuICAgICAgICBpZiAoZmlsdGVyT2JqKSB7XG4gICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlck9iai50b09iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb2JqZWN0ID0gZXh0ZW5kKFxuICAgICAgICB0aGlzLmNhbGxTdXBlcihcbiAgICAgICAgICAndG9PYmplY3QnLFxuICAgICAgICAgIFsnY3JvcFgnLCAnY3JvcFknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgKSwge1xuICAgICAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgICAgICBjcm9zc09yaWdpbjogdGhpcy5nZXRDcm9zc09yaWdpbigpLFxuICAgICAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucmVzaXplRmlsdGVyKSB7XG4gICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSB0aGlzLnJlc2l6ZUZpbHRlci50b09iamVjdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFuIGltYWdlIGhhcyBjcm9wIGFwcGxpZWQsIGluc3BlY3RpbmcgdmFsdWVzIG9mIGNyb3BYLGNyb3BZLHdpZHRoLGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0Nyb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JvcFggfHwgdGhpcy5jcm9wWSB8fCB0aGlzLndpZHRoIDwgdGhpcy5fZWxlbWVudC53aWR0aCB8fCB0aGlzLmhlaWdodCA8IHRoaXMuX2VsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbXSwgaW1hZ2VNYXJrdXAgPSBbXSwgc3Ryb2tlU3ZnLCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMiwgY2xpcFBhdGggPSAnJywgaW1hZ2VSZW5kZXJpbmcgPSAnJztcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNDcm9wKCkpIHtcbiAgICAgICAgdmFyIGNsaXBQYXRoSWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKFxuICAgICAgICAgICc8Y2xpcFBhdGggaWQ9XCJpbWFnZUNyb3BfJyArIGNsaXBQYXRoSWQgKyAnXCI+XFxuJyxcbiAgICAgICAgICAnXFx0PHJlY3QgeD1cIicgKyB4ICsgJ1wiIHk9XCInICsgeSArICdcIiB3aWR0aD1cIicgKyB0aGlzLndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyB0aGlzLmhlaWdodCArICdcIiAvPlxcbicsXG4gICAgICAgICAgJzwvY2xpcFBhdGg+XFxuJ1xuICAgICAgICApO1xuICAgICAgICBjbGlwUGF0aCA9ICcgY2xpcC1wYXRoPVwidXJsKCNpbWFnZUNyb3BfJyArIGNsaXBQYXRoSWQgKyAnKVwiICc7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW1hZ2VTbW9vdGhpbmcpIHtcbiAgICAgICAgaW1hZ2VSZW5kZXJpbmcgPSAnXCIgaW1hZ2UtcmVuZGVyaW5nPVwib3B0aW1pemVTcGVlZCc7XG4gICAgICB9XG4gICAgICBpbWFnZU1hcmt1cC5wdXNoKCdcXHQ8aW1hZ2UgJywgJ0NPTU1PTl9QQVJUUycsICd4bGluazpocmVmPVwiJywgdGhpcy5nZXRTdmdTcmModHJ1ZSksXG4gICAgICAgICdcIiB4PVwiJywgeCAtIHRoaXMuY3JvcFgsICdcIiB5PVwiJywgeSAtIHRoaXMuY3JvcFksXG4gICAgICAgIC8vIHdlJ3JlIGVzc2VudGlhbGx5IG1vdmluZyBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gZnJvbSB0b3AvbGVmdCBjb3JuZXIgdG8gdGhlIGNlbnRlciBvZiB0aGUgc2hhcGVcbiAgICAgICAgLy8gYnkgd3JhcHBpbmcgaXQgaW4gY29udGFpbmVyIDxnPiBlbGVtZW50IHdpdGggYWN0dWFsIHRyYW5zZm9ybWF0aW9uLCB0aGVuIG9mZnNldHRpbmcgb2JqZWN0IHRvIHRoZSB0b3AvbGVmdFxuICAgICAgICAvLyBzbyB0aGF0IG9iamVjdCdzIGNlbnRlciBhbGlnbnMgd2l0aCBjb250YWluZXIncyBsZWZ0L3RvcFxuICAgICAgICAnXCIgd2lkdGg9XCInLCBlbGVtZW50LndpZHRoIHx8IGVsZW1lbnQubmF0dXJhbFdpZHRoLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJywgZWxlbWVudC5oZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQsXG4gICAgICAgIGltYWdlUmVuZGVyaW5nLFxuICAgICAgICAnXCInLCBjbGlwUGF0aCxcbiAgICAgICAgJz48L2ltYWdlPlxcbicpO1xuXG4gICAgICBpZiAodGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VEYXNoQXJyYXkpIHtcbiAgICAgICAgdmFyIG9yaWdGaWxsID0gdGhpcy5maWxsO1xuICAgICAgICB0aGlzLmZpbGwgPSBudWxsO1xuICAgICAgICBzdHJva2VTdmcgPSBbXG4gICAgICAgICAgJ1xcdDxyZWN0ICcsXG4gICAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuZmlsbCA9IG9yaWdGaWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCAhPT0gJ2ZpbGwnKSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5jb25jYXQoc3Ryb2tlU3ZnLCBpbWFnZU1hcmt1cCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3ZnU3RyaW5nID0gc3ZnU3RyaW5nLmNvbmNhdChpbWFnZU1hcmt1cCwgc3Ryb2tlU3ZnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdmdTdHJpbmc7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmaWx0ZXJlZCBpbmRpY2F0ZXMgaWYgdGhlIHNyYyBpcyBuZWVkZWQgZm9yIHN2Z1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU291cmNlIG9mIGFuIGltYWdlXG4gICAgICovXG4gICAgZ2V0U3JjOiBmdW5jdGlvbihmaWx0ZXJlZCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBmaWx0ZXJlZCA/IHRoaXMuX2VsZW1lbnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC50b0RhdGFVUkwpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC50b0RhdGFVUkwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNyY0Zyb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LnNyYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNyYyB8fCAnJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFNvdXJjZSBzdHJpbmcgKFVSTClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBpbWFnZSBoYXMgYmVlbiBsb2FkZWQgKGFuZCBhbGwgZmlsdGVycyBoYXZlIGJlZW4gYXBwbGllZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiB2YWx1ZSAob25lIG9mIFwiXCIsIFwiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCIpXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNyYzogZnVuY3Rpb24oc3JjLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKHNyYywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChpbWcsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzLCBpc0Vycm9yKTtcbiAgICAgIH0sIHRoaXMsIG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuSW1hZ2U6IHsgc3JjOiBcIicgKyB0aGlzLmdldFNyYygpICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgYXBwbHlSZXNpemVGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLnJlc2l6ZUZpbHRlcixcbiAgICAgICAgICBtaW5pbXVtU2NhbGUgPSB0aGlzLm1pbmltdW1TY2FsZVRyaWdnZXIsXG4gICAgICAgICAgb2JqZWN0U2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIHNjYWxlWCA9IG9iamVjdFNjYWxlLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVkgPSBvYmplY3RTY2FsZS5zY2FsZVksXG4gICAgICAgICAgZWxlbWVudFRvRmlsdGVyID0gdGhpcy5fZmlsdGVyZWRFbCB8fCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlsdGVyIHx8IChzY2FsZVggPiBtaW5pbXVtU2NhbGUgJiYgc2NhbGVZID4gbWluaW11bVNjYWxlKSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFRvRmlsdGVyO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IDE7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gMTtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWJyaWMuZmlsdGVyQmFja2VuZCkge1xuICAgICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZCA9IGZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCgpO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIGNhY2hlS2V5ID0gdGhpcy5fZmlsdGVyZWRFbCA/ICh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpIDogdGhpcy5jYWNoZUtleSxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGVsZW1lbnRUb0ZpbHRlci53aWR0aCwgc291cmNlSGVpZ2h0ID0gZWxlbWVudFRvRmlsdGVyLmhlaWdodDtcbiAgICAgIGNhbnZhc0VsLndpZHRoID0gc291cmNlV2lkdGg7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gY2FudmFzRWw7XG4gICAgICB0aGlzLl9sYXN0U2NhbGVYID0gZmlsdGVyLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSBmaWx0ZXIuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBbZmlsdGVyXSwgZWxlbWVudFRvRmlsdGVyLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCBjYWNoZUtleSk7XG4gICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IGNhbnZhc0VsLndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSBjYW52YXNFbC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlcnMgYXNzaWduZWQgdG8gdGhpcyBpbWFnZSAoZnJvbSBcImZpbHRlcnNcIiBhcnJheSkgb3IgZnJvbSBmaWx0ZXIgcGFyYW1cbiAgICAgKiBAbWV0aG9kIGFwcGx5RmlsdGVyc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yUmVzaXppbmcgc3BlY2lmeSBpZiB0aGUgZmlsdGVyIG9wZXJhdGlvbiBpcyBhIHJlc2l6ZSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfSByZXR1cm4gdGhlIGZhYnJpYy5JbWFnZSBvYmplY3RcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XG5cbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHRoaXMuZmlsdGVycyB8fCBbXTtcbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcihmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlciAmJiAhZmlsdGVyLmlzTmV1dHJhbFN0YXRlKCk7IH0pO1xuICAgICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG5cbiAgICAgIC8vIG5lZWRzIHRvIGNsZWFyIG91dCBvciBXRUJHTCB3aWxsIG5vdCByZXNpemUgY29ycmVjdGx5XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKTtcblxuICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkRWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IDE7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWdFbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50LFxuICAgICAgICAgIHNvdXJjZVdpZHRoID0gaW1nRWxlbWVudC5uYXR1cmFsV2lkdGggfHwgaW1nRWxlbWVudC53aWR0aCxcbiAgICAgICAgICBzb3VyY2VIZWlnaHQgPSBpbWdFbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgaW1nRWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWUgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIGNhbnZhc0VsLndpZHRoID0gc291cmNlV2lkdGg7XG4gICAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGNhbnZhc0VsO1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gY2FudmFzRWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gY2xlYXIgdGhlIGV4aXN0aW5nIGVsZW1lbnQgdG8gZ2V0IG5ldyBmaWx0ZXIgZGF0YVxuICAgICAgICAvLyBhbHNvIGRlcmVmZXJlbmNlIHRoZSBldmVudHVhbCByZXNpemVkIF9lbGVtZW50XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9maWx0ZXJlZEVsO1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsLmdldENvbnRleHQoJzJkJykuY2xlYXJSZWN0KDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gcmVzaXplIGFnYWluIGF0IG5leHQgcmVuZGVyQWxsLCBzbyByZW1vdmUgc2F2ZWQgX2xhc3RTY2FsZVgvWVxuICAgICAgICB0aGlzLl9sYXN0U2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoIWZhYnJpYy5maWx0ZXJCYWNrZW5kKSB7XG4gICAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kID0gZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kKCk7XG4gICAgICB9XG4gICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZC5hcHBseUZpbHRlcnMoXG4gICAgICAgIGZpbHRlcnMsIHRoaXMuX29yaWdpbmFsRWxlbWVudCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGhpcy5fZWxlbWVudCwgdGhpcy5jYWNoZUtleSk7XG4gICAgICBpZiAodGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoICE9PSB0aGlzLl9lbGVtZW50LndpZHRoIHx8XG4gICAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQgIT09IHRoaXMuX2VsZW1lbnQuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gdGhpcy5fZWxlbWVudC53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSB0aGlzLl9lbGVtZW50LmhlaWdodCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmcpO1xuICAgICAgaWYgKHRoaXMuaXNNb3ZpbmcgIT09IHRydWUgJiYgdGhpcy5yZXNpemVGaWx0ZXIgJiYgdGhpcy5fbmVlZHNSZXNpemUoKSkge1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3Ryb2tlKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3Qgb24gdGhlIHRhcmdldCBjb250ZXh0LlxuICAgICAqIGl0IHdpbGwgc2V0IHRoZSBpbWFnZVNtb290aGluZyBmb3IgdGhlIGRyYXcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDYWNoZU9uQ2FudmFzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZhYnJpYy51dGlsLnNldEltYWdlU21vb3RoaW5nKGN0eCwgdGhpcy5pbWFnZVNtb290aGluZyk7XG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5kcmF3Q2FjaGVPbkNhbnZhcy5jYWxsKHRoaXMsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIFRoaXMgaXMgdGhlIHNwZWNpYWwgaW1hZ2UgdmVyc2lvbiB3aGVyZSB3ZSB3b3VsZCBsaWtlIHRvIGF2b2lkIGNhY2hpbmcgd2hlcmUgcG9zc2libGUuXG4gICAgICogRXNzZW50aWFsbHkgaW1hZ2VzIGRvIG5vdCBiZW5lZml0IGZyb20gY2FjaGluZy4gVGhleSBtYXkgcmVxdWlyZSBjYWNoaW5nLCBhbmQgaW4gdGhhdFxuICAgICAqIGNhc2Ugd2UgZG8gaXQuIEFsc28gY2FjaGluZyBhbiBpbWFnZSB1c3VhbGx5IGVuZHMgaW4gYSBsb3NzIG9mIGRldGFpbHMuXG4gICAgICogQSBmdWxsIHBlcmZvcm1hbmNlIGF1ZGl0IHNob3VsZCBiZSBkb25lLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmVlZHNJdHNPd25DYWNoZSgpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgZWxlbWVudFRvRHJhdyA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICBpZiAoIWVsZW1lbnRUb0RyYXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjYWxlWCA9IHRoaXMuX2ZpbHRlclNjYWxpbmdYLCBzY2FsZVkgPSB0aGlzLl9maWx0ZXJTY2FsaW5nWSxcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0LCBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgICAgLy8gY3JvcCB2YWx1ZXMgY2Fubm90IGJlIGxlc3NlciB0aGFuIDAuXG4gICAgICAgICAgY3JvcFggPSBtYXgodGhpcy5jcm9wWCwgMCksIGNyb3BZID0gbWF4KHRoaXMuY3JvcFksIDApLFxuICAgICAgICAgIGVsV2lkdGggPSBlbGVtZW50VG9EcmF3Lm5hdHVyYWxXaWR0aCB8fCBlbGVtZW50VG9EcmF3LndpZHRoLFxuICAgICAgICAgIGVsSGVpZ2h0ID0gZWxlbWVudFRvRHJhdy5uYXR1cmFsSGVpZ2h0IHx8IGVsZW1lbnRUb0RyYXcuaGVpZ2h0LFxuICAgICAgICAgIHNYID0gY3JvcFggKiBzY2FsZVgsXG4gICAgICAgICAgc1kgPSBjcm9wWSAqIHNjYWxlWSxcbiAgICAgICAgICAvLyB0aGUgd2lkdGggaGVpZ2h0IGNhbm5vdCBleGNlZWQgZWxlbWVudCB3aWR0aC9oZWlnaHQsIHN0YXJ0aW5nIGZyb20gdGhlIGNyb3Agb2Zmc2V0LlxuICAgICAgICAgIHNXID0gbWluKHcgKiBzY2FsZVgsIGVsV2lkdGggLSBzWCksXG4gICAgICAgICAgc0ggPSBtaW4oaCAqIHNjYWxlWSwgZWxIZWlnaHQgLSBzWSksXG4gICAgICAgICAgeCA9IC13IC8gMiwgeSA9IC1oIC8gMixcbiAgICAgICAgICBtYXhEZXN0VyA9IG1pbih3LCBlbFdpZHRoIC8gc2NhbGVYIC0gY3JvcFgpLFxuICAgICAgICAgIG1heERlc3RIID0gbWluKGgsIGVsSGVpZ2h0IC8gc2NhbGVYIC0gY3JvcFkpO1xuXG4gICAgICBlbGVtZW50VG9EcmF3ICYmIGN0eC5kcmF3SW1hZ2UoZWxlbWVudFRvRHJhdywgc1gsIHNZLCBzVywgc0gsIHgsIHksIG1heERlc3RXLCBtYXhEZXN0SCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG5lZWRlZCB0byBjaGVjayBpZiBpbWFnZSBuZWVkcyByZXNpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9uZWVkc1Jlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpO1xuICAgICAgcmV0dXJuIChzY2FsZS5zY2FsZVggIT09IHRoaXMuX2xhc3RTY2FsZVggfHwgc2NhbGUuc2NhbGVZICE9PSB0aGlzLl9sYXN0U2NhbGVZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRXaWR0aEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldCh0aGlzLmdldE9yaWdpbmFsU2l6ZSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIEltYWdlIGNsYXNzJ3MgaW5pdGlhbGl6YXRpb24gbWV0aG9kLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxTdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0RWxlbWVudChmYWJyaWMudXRpbC5nZXRCeUlkKGVsZW1lbnQpLCBvcHRpb25zKTtcbiAgICAgIGZhYnJpYy51dGlsLmFkZENsYXNzKHRoaXMuZ2V0RWxlbWVudCgpLCBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0Q29uZmlnOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgZmFicmljLkltYWdlLmZpbHRlcnMgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gICAgICovXG4gICAgX2luaXRGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoZmlsdGVycywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICB9LCAnZmFicmljLkltYWdlLmZpbHRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNldCB0aGUgd2lkdGggYW5kIHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlIG9iamVjdCwgdXNpbmcgdGhlIGVsZW1lbnQgb3IgdGhlXG4gICAgICogb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgX3NldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHZhciBlbCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgZWwubmF0dXJhbFdpZHRoIHx8IGVsLndpZHRoIHx8IDA7XG4gICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGVsLm5hdHVyYWxIZWlnaHQgfHwgZWwuaGVpZ2h0IHx8IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBvZmZzZXQgZm9yIGNlbnRlciBhbmQgc2NhbGUgZmFjdG9yIGZvciB0aGUgaW1hZ2UgaW4gb3JkZXIgdG8gcmVzcGVjdFxuICAgICAqIHRoZSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIGF0dHJpYnV0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcEFSID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbyB8fCAnJyksXG4gICAgICAgICAgcldpZHRoID0gdGhpcy5fZWxlbWVudC53aWR0aCwgckhlaWdodCA9IHRoaXMuX2VsZW1lbnQuaGVpZ2h0LFxuICAgICAgICAgIHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIG9mZnNldExlZnQgPSAwLCBvZmZzZXRUb3AgPSAwLCBjcm9wWCA9IDAsIGNyb3BZID0gMCxcbiAgICAgICAgICBvZmZzZXQsIHBXaWR0aCA9IHRoaXMud2lkdGgsIHBIZWlnaHQgPSB0aGlzLmhlaWdodCwgcGFyc2VkQXR0cmlidXRlcyA9IHsgd2lkdGg6IHBXaWR0aCwgaGVpZ2h0OiBwSGVpZ2h0IH07XG4gICAgICBpZiAocEFSICYmIChwQVIuYWxpZ25YICE9PSAnbm9uZScgfHwgcEFSLmFsaWduWSAhPT0gJ25vbmUnKSkge1xuICAgICAgICBpZiAocEFSLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBmYWJyaWMudXRpbC5maW5kU2NhbGVUb0ZpdCh0aGlzLl9lbGVtZW50LCBwYXJzZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICBvZmZzZXQgPSAocFdpZHRoIC0gcldpZHRoICogc2NhbGVYKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0ID0gLW9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblggPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSAocEhlaWdodCAtIHJIZWlnaHQgKiBzY2FsZVkpIC8gMjtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pbicpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25ZID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocEFSLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9Db3Zlcih0aGlzLl9lbGVtZW50LCBwYXJzZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICBvZmZzZXQgPSByV2lkdGggLSBwV2lkdGggLyBzY2FsZVg7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgICAgICBjcm9wWCA9IG9mZnNldCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldCA9IHJIZWlnaHQgLSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFkgPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByV2lkdGggPSBwV2lkdGggLyBzY2FsZVg7XG4gICAgICAgICAgckhlaWdodCA9IHBIZWlnaHQgLyBzY2FsZVk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzY2FsZVggPSBwV2lkdGggLyByV2lkdGg7XG4gICAgICAgIHNjYWxlWSA9IHBIZWlnaHQgLyBySGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBySGVpZ2h0LFxuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIG9mZnNldExlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgIG9mZnNldFRvcDogb2Zmc2V0VG9wLFxuICAgICAgICBjcm9wWDogY3JvcFgsXG4gICAgICAgIGNyb3BZOiBjcm9wWVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IENTUyBjbGFzcyBuYW1lIGZvciBjYW52YXNcbiAgICogQHN0YXRpY1xuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5DU1NfQ0FOVkFTID0gJ2NhbnZhcy1pbWcnO1xuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgZ2V0U3JjXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3ZnU3JjID0gZmFicmljLkltYWdlLnByb3RvdHlwZS5nZXRTcmM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLkltYWdlIGZyb20gaXRzIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGltYWdlIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24oX29iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2JqZWN0ID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKF9vYmplY3QpO1xuICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShvYmplY3Quc3JjLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLl9pbml0RmlsdGVycy5jYWxsKG9iamVjdCwgb2JqZWN0LmZpbHRlcnMsIGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICAgICAgb2JqZWN0LmZpbHRlcnMgPSBmaWx0ZXJzIHx8IFtdO1xuICAgICAgICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLl9pbml0RmlsdGVycy5jYWxsKG9iamVjdCwgW29iamVjdC5yZXNpemVGaWx0ZXJdLCBmdW5jdGlvbihyZXNpemVGaWx0ZXJzKSB7XG4gICAgICAgICAgb2JqZWN0LnJlc2l6ZUZpbHRlciA9IHJlc2l6ZUZpbHRlcnNbMF07XG4gICAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoW29iamVjdC5jbGlwUGF0aF0sIGZ1bmN0aW9uKGVubGl2ZWRQcm9wcykge1xuICAgICAgICAgICAgb2JqZWN0LmNsaXBQYXRoID0gZW5saXZlZFByb3BzWzBdO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IGZhYnJpYy5JbWFnZShpbWcsIG9iamVjdCk7XG4gICAgICAgICAgICBjYWxsYmFjayhpbWFnZSwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIG51bGwsIG9iamVjdC5jcm9zc09yaWdpbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLkltYWdlIGZyb20gYW4gVVJMIHN0cmluZ1xuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGNyZWF0ZSBhbiBpbWFnZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgY3JlYXRlZCAobmV3bHkgY3JlYXRlZCBpbWFnZSBpcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudCkuIFNlY29uZCBhcmd1bWVudCBpcyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciBub3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1nT3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgaW1nT3B0aW9ucykge1xuICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZSh1cmwsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShpbWcsIGltZ09wdGlvbnMpLCBpc0Vycm9yKTtcbiAgICB9LCBudWxsLCBpbWdPcHRpb25zICYmIGltZ09wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkltYWdlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjSW1hZ2VFbGVtZW50fVxuICAgKi9cbiAgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyA9XG4gICAgZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChcbiAgICAgICd4IHkgd2lkdGggaGVpZ2h0IHByZXNlcnZlQXNwZWN0UmF0aW8geGxpbms6aHJlZiBjcm9zc09yaWdpbiBpbWFnZS1yZW5kZXJpbmcnLnNwbGl0KCcgJylcbiAgICApO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuSW1hZ2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBmYWJyaWMuSW1hZ2Ugb2JqZWN0IGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIGZhYnJpYy5JbWFnZS5mcm9tVVJMKHBhcnNlZEF0dHJpYnV0ZXNbJ3hsaW5rOmhyZWYnXSwgY2FsbGJhY2ssXG4gICAgICBleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZSB2YWx1ZVxuICAgKi9cbiAgX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlICUgMzYwO1xuICAgIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbmdsZSAtIDEpIC8gOTApICogOTA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKGFuZ2xlIC8gOTApICogOTA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIGFuIG9iamVjdCAocm90YXRpbmcgaXQgZnJvbSBjdXJyZW50IGFuZ2xlIHRvIG9uZSBvZiAwLCA5MCwgMTgwLCAyNzAsIGV0Yy4gZGVwZW5kaW5nIG9uIHdoaWNoIGlzIGNsb3NlcilcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJvdGF0ZSh0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RyYWlnaHRlbn0gYnV0IHdpdGggYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3MgT2JqZWN0IHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeFN0cmFpZ2h0ZW46IGZ1bmN0aW9uKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiB0aGlzLmdldCgnYW5nbGUnKSxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgX3RoaXMucm90YXRlKHZhbHVlKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBvYmplY3QsIHRoZW4gcmVyZW5kZXJzIGNhbnZhc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBvYmplY3Quc3RyYWlnaHRlbigpO1xuICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5zdHJhaWdodGVuT2JqZWN0fSwgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhTdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LmZ4U3RyYWlnaHRlbih7XG4gICAgICBvbkNoYW5nZTogdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGVzdHMgaWYgd2ViZ2wgc3VwcG9ydHMgY2VydGFpbiBwcmVjaXNpb25cbiAgICogQHBhcmFtIHtXZWJHTH0gQ2FudmFzIFdlYkdMIGNvbnRleHQgdG8gdGVzdCBvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gUHJlY2lzaW9uIHRvIHRlc3QgY2FuIGJlIGFueSBvZiBmb2xsb3dpbmc6ICdsb3dwJywgJ21lZGl1bXAnLCAnaGlnaHAnXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBXZWJHTCBzdXBwb3J0cyBnaXZlbiBwcmVjaXNpb24uXG4gICAqL1xuICBmdW5jdGlvbiB0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb24pe1xuICAgIHZhciBmcmFnbWVudFNvdXJjZSA9ICdwcmVjaXNpb24gJyArIHByZWNpc2lvbiArICcgZmxvYXQ7XFxudm9pZCBtYWluKCl7fSc7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZmlsdGVyaW5nIGJhY2tlbmQgaXMgc3VwcG9ydGVkIGJ5IHRoZSB1c2VyJ3MgYnJvd3Nlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVTaXplIGNoZWNrIGlmIHRoZSB0aWxlU2l6ZSBpcyBzdXBwb3J0ZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIHN1cHBvcnRzIFdlYkdMLlxuICAgKi9cbiAgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQgPSBmdW5jdGlvbih0aWxlU2l6ZSkge1xuICAgIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRpbGVTaXplID0gdGlsZVNpemUgfHwgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUudGlsZVNpemU7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAoZ2wpIHtcbiAgICAgIGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICAgIGlzU3VwcG9ydGVkID0gZmFicmljLm1heFRleHR1cmVTaXplID49IHRpbGVTaXplO1xuICAgICAgdmFyIHByZWNpc2lvbnMgPSBbJ2hpZ2hwJywgJ21lZGl1bXAnLCAnbG93cCddO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspe1xuICAgICAgICBpZiAodGVzdFByZWNpc2lvbihnbCwgcHJlY2lzaW9uc1tpXSkpe1xuICAgICAgICAgIGZhYnJpYy53ZWJHbFByZWNpc2lvbiA9IHByZWNpc2lvbnNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH07XG5cbiAgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZCA9IFdlYmdsRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogV2ViR0wgZmlsdGVyIGJhY2tlbmQuXG4gICAqL1xuICBmdW5jdGlvbiBXZWJnbEZpbHRlckJhY2tlbmQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGlsZVNpemUpIHtcbiAgICAgIHRoaXMudGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplO1xuICAgIH1cbiAgICB0aGlzLnNldHVwR0xDb250ZXh0KHRoaXMudGlsZVNpemUsIHRoaXMudGlsZVNpemUpO1xuICAgIHRoaXMuY2FwdHVyZUdQVUluZm8oKTtcbiAgfTtcblxuICBXZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0aWxlU2l6ZTogMjA0OCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9iYWJseSBkbyBub3Qgd2FudCB0byBjcmVhdGUgaGVscCBsYXllcnMgZXZlcnkgZmlsdGVyIHN0ZXAuXG4gICAgICogaW4gdGhpcyBvYmplY3QgdGhlcmUgd2lsbCBiZSBhcHBlbmRlZCBzb21lIGNhbnZhc2VzLCBjcmVhdGVkIG9uY2UsIHJlc2l6ZWQgc29tZXRpbWVzXG4gICAgICogY2xlYXJlZCBuZXZlci4gQ2xlYXJpbmcgaXMgbGVmdCB0byB0aGUgZGV2ZWxvcGVyLlxuICAgICAqKi9cbiAgICByZXNvdXJjZXM6IHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhIFdlYkdMIGNvbnRleHQgc3VpdGFibGUgZm9yIGZpbHRlcmluZywgYW5kIGJpbmQgYW55IG5lZWRlZCBldmVudCBoYW5kbGVycy5cbiAgICAgKi9cbiAgICBzZXR1cEdMQ29udGV4dDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmNyZWF0ZVdlYkdMQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB0aGlzLmFQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKTtcbiAgICAgIHRoaXMuY2hvb3NlRmFzdGVzdENvcHlHTFRvMkRNZXRob2Qod2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgYSBtZXRob2QgdG8gY29weSBkYXRhIGZyb20gR0wgY29udGV4dCB0byAyZCBjYW52YXMuICBJbiBzb21lIGJyb3dzZXJzIHVzaW5nXG4gICAgICogcHV0SW1hZ2VEYXRhIGlzIGZhc3RlciB0aGFuIGRyYXdJbWFnZSBmb3IgdGhhdCBzcGVjaWZpYyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgY2hvb3NlRmFzdGVzdENvcHlHTFRvMkRNZXRob2Q6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW5NZWFzdXJlUGVyZiA9IHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnLCBjYW5Vc2VJbWFnZURhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgSW1hZ2VEYXRhKDEsIDEpO1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FuVXNlSW1hZ2VEYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VVaW50OENsYW1wZWQgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICBpZiAoIShjYW5NZWFzdXJlUGVyZiAmJiBjYW5Vc2VJbWFnZURhdGEgJiYgY2FuVXNlQXJyYXlCdWZmZXIgJiYgY2FuVXNlVWludDhDbGFtcGVkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBpbWFnZUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgaWYgKGZhYnJpYy5mb3JjZUdMUHV0SW1hZ2VEYXRhKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIgPSBpbWFnZUJ1ZmZlcjtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRFB1dEltYWdlRGF0YTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRlc3RDb250ZXh0ID0ge1xuICAgICAgICBpbWFnZUJ1ZmZlcjogaW1hZ2VCdWZmZXIsXG4gICAgICAgIGRlc3RpbmF0aW9uV2lkdGg6IHdpZHRoLFxuICAgICAgICBkZXN0aW5hdGlvbkhlaWdodDogaGVpZ2h0LFxuICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhc1xuICAgICAgfTtcbiAgICAgIHZhciBzdGFydFRpbWUsIGRyYXdJbWFnZVRpbWUsIHB1dEltYWdlRGF0YVRpbWU7XG4gICAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvcHlHTFRvMkREcmF3SW1hZ2UuY2FsbCh0ZXN0Q29udGV4dCwgdGhpcy5nbCwgdGVzdENvbnRleHQpO1xuICAgICAgZHJhd0ltYWdlVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRFB1dEltYWdlRGF0YS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBwdXRJbWFnZURhdGFUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBpZiAoZHJhd0ltYWdlVGltZSA+IHB1dEltYWdlRGF0YVRpbWUpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGltYWdlQnVmZmVyO1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkREcmF3SW1hZ2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNhbnZhcyBlbGVtZW50IGFuZCBhc3NvY2lhdGVkIFdlYkdMIGNvbnRleHQgYW5kIGF0dGFjaGVzIHRoZW0gYXNcbiAgICAgKiBjbGFzcyBwcm9wZXJ0aWVzIHRvIHRoZSBHTEZpbHRlckJhY2tlbmQgY2xhc3MuXG4gICAgICovXG4gICAgY3JlYXRlV2ViR0xDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgZ2xPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAvLyB0aGlzIGNhbnZhcyBjYW4gZmlyZSB3ZWJnbGNvbnRleHRsb3N0IGFuZCB3ZWJnbGNvbnRleHRyZXN0b3JlZFxuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGFwcGx5IHRoZSByZXF1ZXN0ZWQgZmlsdGVycyB0byB0aGUgc291cmNlIHByb3ZpZGVkLCBkcmF3aW5nIHRoZSBmaWx0ZXJlZCBvdXRwdXRcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgdGFyZ2V0IGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2UgVGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSBkZXN0aW5hdGlvbiBmb3IgZmlsdGVyZWQgb3V0cHV0IHRvIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfHVuZGVmaW5lZH0gY2FjaGVLZXkgQSBrZXkgdXNlZCB0byBjYWNoZSByZXNvdXJjZXMgcmVsYXRlZCB0byB0aGUgc291cmNlLiBJZlxuICAgICAqIG9taXR0ZWQsIGNhY2hpbmcgd2lsbCBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgc291cmNlLCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDYW52YXMsIGNhY2hlS2V5KSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgdmFyIGNhY2hlZFRleHR1cmU7XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkVGV4dHVyZSA9IHRoaXMuZ2V0Q2FjaGVkVGV4dHVyZShjYWNoZUtleSwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBvcmlnaW5hbFdpZHRoOiBzb3VyY2Uud2lkdGggfHwgc291cmNlLm9yaWdpbmFsV2lkdGgsXG4gICAgICAgIG9yaWdpbmFsSGVpZ2h0OiBzb3VyY2UuaGVpZ2h0IHx8IHNvdXJjZS5vcmlnaW5hbEhlaWdodCxcbiAgICAgICAgc291cmNlV2lkdGg6IHdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGNvbnRleHQ6IGdsLFxuICAgICAgICBzb3VyY2VUZXh0dXJlOiB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsICFjYWNoZWRUZXh0dXJlICYmIHNvdXJjZSksXG4gICAgICAgIHRhcmdldFRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgIG9yaWdpbmFsVGV4dHVyZTogY2FjaGVkVGV4dHVyZSB8fFxuICAgICAgICAgIHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgcGFzc2VzOiBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgd2ViZ2w6IHRydWUsXG4gICAgICAgIGFQb3NpdGlvbjogdGhpcy5hUG9zaXRpb24sXG4gICAgICAgIHByb2dyYW1DYWNoZTogdGhpcy5wcm9ncmFtQ2FjaGUsXG4gICAgICAgIHBhc3M6IDAsXG4gICAgICAgIGZpbHRlckJhY2tlbmQ6IHRoaXMsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHRlbXBGYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0ZW1wRmJvKTtcbiAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgZmlsdGVyICYmIGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIHJlc2l6ZUNhbnZhc0lmTmVlZGVkKHBpcGVsaW5lU3RhdGUpO1xuICAgICAgdGhpcy5jb3B5R0xUbzJEKGdsLCBwaXBlbGluZVN0YXRlKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnNvdXJjZVRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnRhcmdldFRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGVtcEZibyk7XG4gICAgICB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICByZXR1cm4gcGlwZWxpbmVTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIGV2ZW50IGxpc3RlbmVycywgcmVtb3ZlIHJlZmVyZW5jZXMsIGFuZCBjbGVhbiB1cCBjYWNoZXMuXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJXZWJHTENhY2hlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaXBlIG91dCBXZWJHTC1yZWxhdGVkIGNhY2hlcy5cbiAgICAgKi9cbiAgICBjbGVhcldlYkdMQ2FjaGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucHJvZ3JhbUNhY2hlID0ge307XG4gICAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBXZWJHTCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEFjY2VwdHMgc3BlY2lmaWMgZGltZW5zaW9ucyB0byBpbml0aWFsaXplIHRoZSB0ZXh0dXJlIHRvIG9yIGEgc291cmNlIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjb250ZXh0IHRvIHVzZSBmb3IgY3JlYXRpbmcgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byBpbml0aWFsaXplIHRoZSB0ZXh0dXJlIGF0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCB0byBpbml0aWFsaXplIHRoZSB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gdGV4dHVyZUltYWdlU291cmNlIEEgc291cmNlIGZvciB0aGUgdGV4dHVyZSBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtXZWJHTFRleHR1cmV9XG4gICAgICovXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBpZiAodGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZUltYWdlU291cmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbiBiZSBvcHRpb25hbGx5IHVzZWQgdG8gZ2V0IGEgdGV4dHVyZSBmcm9tIHRoZSBjYWNoZSBhcnJheVxuICAgICAqXG4gICAgICogSWYgYW4gZXhpc3RpbmcgdGV4dHVyZSBpcyBub3QgZm91bmQsIGEgbmV3IHRleHR1cmUgaXMgY3JlYXRlZCBhbmQgY2FjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVuaXF1ZUlkIEEgY2FjaGUga2V5IHRvIHVzZSB0byBmaW5kIGFuIGV4aXN0aW5nIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgdG8gdXNlIHRvIGNyZWF0ZSB0aGVcbiAgICAgKiB0ZXh0dXJlIGNhY2hlIGVudHJ5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqL1xuICAgIGdldENhY2hlZFRleHR1cmU6IGZ1bmN0aW9uKHVuaXF1ZUlkLCB0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShcbiAgICAgICAgICB0aGlzLmdsLCB0ZXh0dXJlSW1hZ2VTb3VyY2Uud2lkdGgsIHRleHR1cmVJbWFnZVNvdXJjZS5oZWlnaHQsIHRleHR1cmVJbWFnZVNvdXJjZSk7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXSA9IHRleHR1cmU7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBvdXQgY2FjaGVkIHJlc291cmNlcyByZWxhdGVkIHRvIGEgc291cmNlIGltYWdlIHRoYXQgaGFzIGJlZW5cbiAgICAgKiBmaWx0ZXJlZCBwcmV2aW91c2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhY2hlS2V5IFRoZSBjYWNoZSBrZXkgcHJvdmlkZWQgd2hlbiB0aGUgc291cmNlIGltYWdlIHdhcyBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBldmljdENhY2hlc0ZvcktleTogZnVuY3Rpb24oY2FjaGVLZXkpIHtcbiAgICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvcHlHTFRvMkQ6IGNvcHlHTFRvMkREcmF3SW1hZ2UsXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGV4dHJhY3QgR1BVIGluZm9ybWF0aW9uIHN0cmluZ3MgZnJvbSBhIFdlYkdMIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgaW5mb3JtYXRpb24gd2hlbiBkZWJ1Z2dpbmcgb3IgYmxhY2tsaXN0aW5nIHNwZWNpZmljIEdQVXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEdQVSBpbmZvIG9iamVjdCB3aXRoIHJlbmRlcmVyIGFuZCB2ZW5kb3Igc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjYXB0dXJlR1BVSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5ncHVJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdwdUluZm87XG4gICAgICB9XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsLCBncHVJbmZvID0geyByZW5kZXJlcjogJycsIHZlbmRvcjogJycgfTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgcmV0dXJuIGdwdUluZm87XG4gICAgICB9XG4gICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyk7XG4gICAgICBpZiAoZXh0KSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IGdsLmdldFBhcmFtZXRlcihleHQuVU5NQVNLRURfUkVOREVSRVJfV0VCR0wpO1xuICAgICAgICB2YXIgdmVuZG9yID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5VTk1BU0tFRF9WRU5ET1JfV0VCR0wpO1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICBncHVJbmZvLnJlbmRlcmVyID0gcmVuZGVyZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVuZG9yKSB7XG4gICAgICAgICAgZ3B1SW5mby52ZW5kb3IgPSB2ZW5kb3IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ncHVJbmZvID0gZ3B1SW5mbztcbiAgICAgIHJldHVybiBncHVJbmZvO1xuICAgIH0sXG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiByZXNpemVDYW52YXNJZk5lZWRlZChwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIHdpZHRoID0gdGFyZ2V0Q2FudmFzLndpZHRoLCBoZWlnaHQgPSB0YXJnZXRDYW52YXMuaGVpZ2h0LFxuICAgICAgZFdpZHRoID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbldpZHRoLFxuICAgICAgZEhlaWdodCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25IZWlnaHQ7XG5cbiAgaWYgKHdpZHRoICE9PSBkV2lkdGggfHwgaGVpZ2h0ICE9PSBkSGVpZ2h0KSB7XG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gZFdpZHRoO1xuICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBkSGVpZ2h0O1xuICB9XG59XG5cbi8qKlxuICogQ29weSBhbiBpbnB1dCBXZWJHTCBjYW52YXMgb24gdG8gYW4gb3V0cHV0IDJEIGNhbnZhcy5cbiAqXG4gKiBUaGUgV2ViR0wgY2FudmFzIGlzIGFzc3VtZWQgdG8gYmUgdXBzaWRlIGRvd24sIHdpdGggdGhlIHRvcC1sZWZ0IHBpeGVsIG9mIHRoZVxuICogZGVzaXJlZCBvdXRwdXQgaW1hZ2UgYXBwZWFyaW5nIGluIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIFdlYkdMIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gc291cmNlQ29udGV4dCBUaGUgV2ViR0wgY29udGV4dCB0byBjb3B5IGZyb20uXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwaXBlbGluZVN0YXRlIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKi9cbmZ1bmN0aW9uIGNvcHlHTFRvMkREcmF3SW1hZ2UoZ2wsIHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIGdsQ2FudmFzID0gZ2wuY2FudmFzLCB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHgudHJhbnNsYXRlKDAsIHRhcmdldENhbnZhcy5oZWlnaHQpOyAvLyBtb3ZlIGl0IGRvd24gYWdhaW5cbiAgY3R4LnNjYWxlKDEsIC0xKTsgLy8gdmVydGljYWwgZmxpcFxuICAvLyB3aGVyZSBpcyBteSBpbWFnZSBvbiB0aGUgYmlnIGdsY2FudmFzP1xuICB2YXIgc291cmNlWSA9IGdsQ2FudmFzLmhlaWdodCAtIHRhcmdldENhbnZhcy5oZWlnaHQ7XG4gIGN0eC5kcmF3SW1hZ2UoZ2xDYW52YXMsIDAsIHNvdXJjZVksIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCwgMCwgMCxcbiAgICB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQpO1xufVxuXG4vKipcbiAqIENvcHkgYW4gaW5wdXQgV2ViR0wgY2FudmFzIG9uIHRvIGFuIG91dHB1dCAyRCBjYW52YXMgdXNpbmcgMmQgY2FudmFzJyBwdXRJbWFnZURhdGFcbiAqIEFQSS4gTWVhc3VyYWJseSBmYXN0ZXIgdGhhbiB1c2luZyBjdHguZHJhd0ltYWdlIGluIEZpcmVmb3ggKHZlcnNpb24gNTQgb24gT1NYIFNpZXJyYSkuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHNvdXJjZUNvbnRleHQgVGhlIFdlYkdMIGNvbnRleHQgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gcGlwZWxpbmVTdGF0ZSBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICovXG5mdW5jdGlvbiBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhKGdsLCBwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcywgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICBkV2lkdGggPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uV2lkdGgsXG4gICAgICBkSGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbkhlaWdodCxcbiAgICAgIG51bUJ5dGVzID0gZFdpZHRoICogZEhlaWdodCAqIDQ7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuaW1hZ2VCdWZmZXIsIDAsIG51bUJ5dGVzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OENsYW1wZWQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy5pbWFnZUJ1ZmZlciwgMCwgbnVtQnl0ZXMpO1xuXG4gIGdsLnJlYWRQaXhlbHMoMCwgMCwgZFdpZHRoLCBkSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB1OCk7XG4gIHZhciBpbWdEYXRhID0gbmV3IEltYWdlRGF0YSh1OENsYW1wZWQsIGRXaWR0aCwgZEhlaWdodCk7XG4gIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCA9IENhbnZhczJkRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogQ2FudmFzIDJEIGZpbHRlciBiYWNrZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKCkge307XG5cbiAgQ2FudmFzMmRGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBub29wLFxuICAgIGRpc3Bvc2U6IG5vb3AsXG4gICAgY2xlYXJXZWJHTENhY2hlczogbm9vcCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9iYWJseSBkbyBub3Qgd2FudCB0byBjcmVhdGUgaGVscCBsYXllcnMgZXZlcnkgZmlsdGVyIHN0ZXAuXG4gICAgICogaW4gdGhpcyBvYmplY3QgdGhlcmUgd2lsbCBiZSBhcHBlbmRlZCBzb21lIGNhbnZhc2VzLCBjcmVhdGVkIG9uY2UsIHJlc2l6ZWQgc29tZXRpbWVzXG4gICAgICogY2xlYXJlZCBuZXZlci4gQ2xlYXJpbmcgaXMgbGVmdCB0byB0aGUgZGV2ZWxvcGVyLlxuICAgICAqKi9cbiAgICByZXNvdXJjZXM6IHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHNldCBvZiBmaWx0ZXJzIGFnYWluc3QgYSBzb3VyY2UgaW1hZ2UgYW5kIGRyYXcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCBkZXN0aW5hdGlvbiBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuaGFuY2VkRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXIgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2VFbGVtZW50IFRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VIZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgZGVzdGluYXRpb24gZm9yIGZpbHRlcmVkIG91dHB1dCB0byBiZSBkcmF3bi5cbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZUVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldENhbnZhcykge1xuICAgICAgdmFyIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzb3VyY2VFbGVtZW50LCAwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIG9yaWdpbmFsSW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBzb3VyY2VXaWR0aDogc291cmNlV2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogc291cmNlSGVpZ2h0LFxuICAgICAgICBpbWFnZURhdGE6IGltYWdlRGF0YSxcbiAgICAgICAgb3JpZ2luYWxFbDogc291cmNlRWxlbWVudCxcbiAgICAgICAgb3JpZ2luYWxJbWFnZURhdGE6IG9yaWdpbmFsSW1hZ2VEYXRhLFxuICAgICAgICBjYW52YXNFbDogdGFyZ2V0Q2FudmFzLFxuICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7IGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIGlmIChwaXBlbGluZVN0YXRlLmltYWdlRGF0YS53aWR0aCAhPT0gc291cmNlV2lkdGggfHwgcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEuaGVpZ2h0ICE9PSBzb3VyY2VIZWlnaHQpIHtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEud2lkdGg7XG4gICAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlXG4gKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNpbWFnZV9maWx0ZXJzfVxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICovXG5mYWJyaWMuSW1hZ2UgPSBmYWJyaWMuSW1hZ2UgfHwgeyB9O1xuZmFicmljLkltYWdlLmZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyB8fCB7IH07XG5cbi8qKlxuICogUm9vdCBmaWx0ZXIgY2xhc3MgZnJvbSB3aGljaCBhbGwgZmlsdGVyIGNsYXNzZXMgaW5oZXJpdCBmcm9tXG4gKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gKi9cbmZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogRmlsdGVyIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHR5cGU6ICdCYXNlRmlsdGVyJyxcblxuICAvKipcbiAgICogQXJyYXkgb2YgYXR0cmlidXRlcyB0byBzZW5kIHdpdGggYnVmZmVycy4gZG8gbm90IG1vZGlmeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2ZXJ0ZXhTb3VyY2U6ICdhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxuJyArXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICd2VGV4Q29vcmQgPSBhUG9zaXRpb247XFxuJyArXG4gICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiAqIDIuMCAtIDEuMCwgMC4wLCAxLjApO1xcbicgK1xuICAgICd9JyxcblxuICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICdnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgJ30nLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgZmlsdGVyJ3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyIHByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdG8gdXNlIGZvciBzaGFkZXIgY29tcGlsYXRpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnbWVudFNvdXJjZSBmcmFnbWVudFNoYWRlciBzb3VyY2UgZm9yIGNvbXBpbGF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0ZXhTb3VyY2UgdmVydGV4U2hhZGVyIHNvdXJjZSBmb3IgY29tcGlsYXRpb25cbiAgICovXG4gIGNyZWF0ZVByb2dyYW06IGZ1bmN0aW9uKGdsLCBmcmFnbWVudFNvdXJjZSwgdmVydGV4U291cmNlKSB7XG4gICAgZnJhZ21lbnRTb3VyY2UgPSBmcmFnbWVudFNvdXJjZSB8fCB0aGlzLmZyYWdtZW50U291cmNlO1xuICAgIHZlcnRleFNvdXJjZSA9IHZlcnRleFNvdXJjZSB8fCB0aGlzLnZlcnRleFNvdXJjZTtcbiAgICBpZiAoZmFicmljLndlYkdsUHJlY2lzaW9uICE9PSAnaGlnaHAnKXtcbiAgICAgIGZyYWdtZW50U291cmNlID0gZnJhZ21lbnRTb3VyY2UucmVwbGFjZShcbiAgICAgICAgL3ByZWNpc2lvbiBoaWdocCBmbG9hdC9nLFxuICAgICAgICAncHJlY2lzaW9uICcgKyBmYWJyaWMud2ViR2xQcmVjaXNpb24gKyAnIGZsb2F0J1xuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdWZXJ0ZXggc2hhZGVyIGNvbXBpbGUgZXJyb3IgZm9yICcgKyB0aGlzLnR5cGUgKyAnOiAnICtcbiAgICAgICAgZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnRnJhZ21lbnQgc2hhZGVyIGNvbXBpbGUgZXJyb3IgZm9yICcgKyB0aGlzLnR5cGUgKyAnOiAnICtcbiAgICAgICAgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ1NoYWRlciBsaW5rIGVycm9yIGZvciBcIiR7dGhpcy50eXBlfVwiICcgK1xuICAgICAgICBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb25zID0gdGhpcy5nZXRBdHRyaWJ1dGVMb2NhdGlvbnMoZ2wsIHByb2dyYW0pO1xuICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb25zKGdsLCBwcm9ncmFtKSB8fCB7IH07XG4gICAgdW5pZm9ybUxvY2F0aW9ucy51U3RlcFcgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwVycpO1xuICAgIHVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBIID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcEgnKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uczogYXR0cmlidXRlTG9jYXRpb25zLFxuICAgICAgdW5pZm9ybUxvY2F0aW9uczogdW5pZm9ybUxvY2F0aW9uc1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gV2ViR0xBdHRyaWJ1dGVMb2NhdGlvbiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoZSBzaGFkZXIgcHJvZ3JhbSBmcm9tIHdoaWNoIHRvIHRha2UgYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICogQHJldHVybnMge09iamVjdH0gQSBtYXAgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGF0dHJpYnV0ZSBsb2NhdGlvbnMuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVMb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFQb3NpdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb3NpdGlvbicpLFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG1hcCBvZiB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGUgc2hhZGVyIHByb2dyYW0gZnJvbSB3aGljaCB0byB0YWtlIHVuaWZvcm0gbG9jYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1hcCBvZiB1bmlmb3JtIG5hbWVzIHRvIHVuaWZvcm0gbG9jYXRpb25zLlxuICAgKi9cbiAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24gKC8qIGdsLCBwcm9ncmFtICovKSB7XG4gICAgLy8gaW4gY2FzZSBpIGRvIG5vdCBuZWVkIGFueSBzcGVjaWFsIHVuaWZvcm0gaSBuZWVkIHRvIHJldHVybiBhbiBlbXB0eSBvYmplY3RcbiAgICByZXR1cm4geyB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kIGF0dHJpYnV0ZSBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtIG9uIHRoZSBHUFUuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZUxvY2F0aW9ucyBBIG1hcCBvZiBzaGFkZXIgYXR0cmlidXRlIG5hbWVzIHRvIHRoZWlyIGxvY2F0aW9ucy5cbiAgICovXG4gIHNlbmRBdHRyaWJ1dGVEYXRhOiBmdW5jdGlvbihnbCwgYXR0cmlidXRlTG9jYXRpb25zLCBhUG9zaXRpb25EYXRhKSB7XG4gICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9uID0gYXR0cmlidXRlTG9jYXRpb25zLmFQb3NpdGlvbjtcbiAgICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmlidXRlTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFQb3NpdGlvbkRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcbiAgfSxcblxuICBfc2V0dXBGcmFtZUJ1ZmZlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dCwgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAob3B0aW9ucy5wYXNzZXMgPiAxKSB7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aDtcbiAgICAgIGhlaWdodCA9IG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQ7XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VXaWR0aCAhPT0gd2lkdGggfHwgb3B0aW9ucy5zb3VyY2VIZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKG9wdGlvbnMudGFyZ2V0VGV4dHVyZSk7XG4gICAgICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSA9IG9wdGlvbnMuZmlsdGVyQmFja2VuZC5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlLCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBkcmF3IGxhc3QgZmlsdGVyIG9uIGNhbnZhcyBhbmQgbm90IHRvIGZyYW1lYnVmZmVyLlxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIGdsLmZpbmlzaCgpO1xuICAgIH1cbiAgfSxcblxuICBfc3dhcFRleHR1cmVzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5wYXNzZXMtLTtcbiAgICBvcHRpb25zLnBhc3MrKztcbiAgICB2YXIgdGVtcCA9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZTtcbiAgICBvcHRpb25zLnRhcmdldFRleHR1cmUgPSBvcHRpb25zLnNvdXJjZVRleHR1cmU7XG4gICAgb3B0aW9ucy5zb3VyY2VUZXh0dXJlID0gdGVtcDtcbiAgfSxcblxuICAvKipcbiAgICogR2VuZXJpYyBpc05ldXRyYWwgaW1wbGVtZW50YXRpb24gZm9yIG9uZSBwYXJhbWV0ZXIgYmFzZWQgZmlsdGVycy5cbiAgICogVXNlZCBvbmx5IGluIGltYWdlIGFwcGx5RmlsdGVycyB0byBkaXNjYXJkIGZpbHRlcnMgdGhhdCB3aWxsIG5vdCBoYXZlIGFuIGVmZmVjdFxuICAgKiBvbiB0aGUgaW1hZ2VcbiAgICogT3RoZXIgZmlsdGVycyBtYXkgbmVlZCB0aGVpciBvd24gdmVyc2lvbiAoIENvbG9yTWF0cml4LCBIdWVSb3RhdGlvbiwgZ2FtbWEsIENvbXBvc2VkRmlsdGVyIClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICoqL1xuICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oLyogb3B0aW9ucyAqLykge1xuICAgIHZhciBtYWluID0gdGhpcy5tYWluUGFyYW1ldGVyLFxuICAgICAgICBfY2xhc3MgPSBmYWJyaWMuSW1hZ2UuZmlsdGVyc1t0aGlzLnR5cGVdLnByb3RvdHlwZTtcbiAgICBpZiAobWFpbikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX2NsYXNzW21haW5dKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gX2NsYXNzW21haW5dLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGlmICh0aGlzW21haW5dW2ldICE9PSBfY2xhc3NbbWFpbl1baV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9jbGFzc1ttYWluXSA9PT0gdGhpc1ttYWluXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBseSB0aGlzIGZpbHRlciB0byB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBwcm92aWRlZC5cbiAgICpcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KHRoaXMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgZmlsdGVyIHVzaW5nIHdlYmdsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSBUaGUgdGV4dHVyZSBvZiB0aGUgb3JpZ2luYWwgaW5wdXQgaW1hZ2UuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICBhcHBseVRvV2ViR0w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIHNoYWRlciA9IHRoaXMucmV0cmlldmVTaGFkZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMucGFzcyA9PT0gMCAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSkge1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9wdGlvbnMuc291cmNlVGV4dHVyZSk7XG4gICAgfVxuICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgIHRoaXMuc2VuZEF0dHJpYnV0ZURhdGEoZ2wsIHNoYWRlci5hdHRyaWJ1dGVMb2NhdGlvbnMsIG9wdGlvbnMuYVBvc2l0aW9uKTtcblxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybUxvY2F0aW9ucy51U3RlcFcsIDEgLyBvcHRpb25zLnNvdXJjZVdpZHRoKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBILCAxIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQpO1xuXG4gICAgdGhpcy5zZW5kVW5pZm9ybURhdGEoZ2wsIHNoYWRlci51bmlmb3JtTG9jYXRpb25zKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGgsIG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICB9LFxuXG4gIGJpbmRBZGRpdGlvbmFsVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gcmVzZXQgYWN0aXZlIHRleHR1cmUgdG8gMCBhcyB1c3VhbFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICB9LFxuXG4gIHVuYmluZEFkZGl0aW9uYWxUZXh0dXJlOiBmdW5jdGlvbihnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgfSxcblxuICBnZXRNYWluUGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdO1xuICB9LFxuXG4gIHNldE1haW5QYXJhbWV0ZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgdW5pZm9ybSBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtIG9uIHRoZSBHUFUuXG4gICAqXG4gICAqIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzaGFkZXIgdW5pZm9ybSBuYW1lcyB0byB0aGVpciBsb2NhdGlvbnMuXG4gICAqL1xuICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKC8qIGdsLCB1bmlmb3JtTG9jYXRpb25zICovKSB7XG4gICAgLy8gSW50ZW50aW9uYWxseSBsZWZ0IGJsYW5rLiAgT3ZlcnJpZGUgbWUgaW4gc3ViY2xhc3Nlcy5cbiAgfSxcblxuICAvKipcbiAgICogSWYgbmVlZGVkIGJ5IGEgMmQgZmlsdGVyLCB0aGlzIGZ1bmN0aW9ucyBjYW4gY3JlYXRlIGFuIGhlbHBlciBjYW52YXMgdG8gYmUgdXNlZFxuICAgKiByZW1lbWJlciB0aGF0IG9wdGlvbnMudGFyZ2V0Q2FudmFzIGlzIGF2YWlsYWJsZSBmb3IgdXNlIHRpbGwgZW5kIG9mIGNoYWluLlxuICAgKi9cbiAgY3JlYXRlSGVscExheWVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmhlbHBMYXllcikge1xuICAgICAgdmFyIGhlbHBMYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgaGVscExheWVyLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgIGhlbHBMYXllci5oZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgIG9wdGlvbnMuaGVscExheWVyID0gaGVscExheWVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICovXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0ID0geyB0eXBlOiB0aGlzLnR5cGUgfSwgbWFpblAgPSB0aGlzLm1haW5QYXJhbWV0ZXI7XG4gICAgaWYgKG1haW5QKSB7XG4gICAgICBvYmplY3RbbWFpblBdID0gdGhpc1ttYWluUF07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgKi9cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAvLyBkZWxlZ2F0ZSwgbm90IGFsaWFzXG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxufSk7XG5cbmZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tvYmplY3QudHlwZV0ob2JqZWN0KTtcbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZmlsdGVyKTtcbiAgcmV0dXJuIGZpbHRlcjtcbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgTWF0cml4IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vd3d3LndlYndhc3AuY28udWsvdHV0b3JpYWxzLzIxOS9Db2xvcl9NYXRyaXhfRmlsdGVyLnBocH1cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3Bob2Jvc2xhYi5vcmcvbG9nLzIwMTMvMTEvZmFzdC1pbWFnZS1maWx0ZXJzLXdpdGgtd2ViZ2x9XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPktvZGFjaHJvbWUgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4KHtcbiAgICogIG1hdHJpeDogW1xuICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LCAxLjA4MzUyNTE1NjYyOTEzMDQsIC0wLjA1NDk4ODA1MTE1NjMzMTMyLCAwLCAyNC43MzI0MDc4OTY3MDYyMDMsXG4gICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXG4gICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbG9yTWF0cml4ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29sb3JNYXRyaXgnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd1bmlmb3JtIG1hdDQgdUNvbG9yTWF0cml4O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvciAqPSB1Q29sb3JNYXRyaXg7XFxuJyArXG4gICAgICAgICdjb2xvciArPSB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvcm1hdHJpeCBmb3IgcGl4ZWxzLlxuICAgICAqIGFycmF5IG9mIDIwIGZsb2F0cy4gTnVtYmVycyBpbiBwb3NpdGlvbnMgNCwgOSwgMTQsIDE5IGxvb3NlIG1lYW5pbmdcbiAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgKiAwLjAwMzkyMTU2ODYgaXMgdGhlIHBhcnQgb2YgMSB0aGF0IGdldCB0cmFuc2xhdGVkIHRvIDEgaW4gMmRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggYXJyYXkgb2YgMjAgbnVtYmVycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1hdHJpeDogW1xuICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnbWF0cml4JyxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIGNvbG9ybWF0cml4IG9uIHRoZSBjb2xvciBwYXJ0LCBza2lwcGluZyBhbHBoYSwgbWFubHkgZm9yIG5vbiB3ZWJnbCBzY2VuYXJpb1xuICAgICAqIHRvIHNhdmUgc29tZSBjYWxjdWxhdGlvblxuICAgICAqL1xuICAgIGNvbG9yc09ubHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGFycmF5IGluc3RlYWQgbXV0YXRpbmcgdGhlIHByb3RvdHlwZSB3aXRoIHB1c2hcbiAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5tYXRyaXguc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBDb2xvck1hdHJpeCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBtID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgciwgZywgYiwgYSwgaSwgY29sb3JzT25seSA9IHRoaXMuY29sb3JzT25seTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGlmIChjb2xvcnNPbmx5KSB7XG4gICAgICAgICAgZGF0YVtpXSA9IHIgKiBtWzBdICsgZyAqIG1bMV0gKyBiICogbVsyXSArIG1bNF0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSByICogbVs1XSArIGcgKiBtWzZdICsgYiAqIG1bN10gKyBtWzldICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDJdID0gciAqIG1bMTBdICsgZyAqIG1bMTFdICsgYiAqIG1bMTJdICsgbVsxNF0gKiAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuICAgICAgICAgIGRhdGFbaV0gPSByICogbVswXSArIGcgKiBtWzFdICsgYiAqIG1bMl0gKyBhICogbVszXSArIG1bNF0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSByICogbVs1XSArIGcgKiBtWzZdICsgYiAqIG1bN10gKyBhICogbVs4XSArIG1bOV0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMl0gPSByICogbVsxMF0gKyBnICogbVsxMV0gKyBiICogbVsxMl0gKyBhICogbVsxM10gKyBtWzE0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAzXSA9IHIgKiBtWzE1XSArIGcgKiBtWzE2XSArIGIgKiBtWzE3XSArIGEgKiBtWzE4XSArIG1bMTldICogMjU1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29sb3JNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbG9yTWF0cml4JyksXG4gICAgICAgIHVDb25zdGFudHM6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbnN0YW50cycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICBtYXRyaXggPSBbXG4gICAgICAgICAgICBtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLFxuICAgICAgICAgICAgbVs1XSwgbVs2XSwgbVs3XSwgbVs4XSxcbiAgICAgICAgICAgIG1bMTBdLCBtWzExXSwgbVsxMl0sIG1bMTNdLFxuICAgICAgICAgICAgbVsxNV0sIG1bMTZdLCBtWzE3XSwgbVsxOF1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGNvbnN0YW50cyA9IFttWzRdLCBtWzldLCBtWzE0XSwgbVsxOV1dO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtTG9jYXRpb25zLnVDb2xvck1hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbnN0YW50cywgY29uc3RhbnRzKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXh9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEJyaWdodG5lc3MgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3MjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3Moe1xuICAgKiAgIGJyaWdodG5lc3M6IDAuMDVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5CcmlnaHRuZXNzID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3MucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdCcmlnaHRuZXNzJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUJyaWdodG5lc3M7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiICs9IHVCcmlnaHRuZXNzO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBCcmlnaHRuZXNzIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogdHJhbnNsYXRlZCB0byAtMjU1IHRvIDI1NSBmb3IgMmRcbiAgICAgKiAwLjAwMzkyMTU2ODYgaXMgdGhlIHBhcnQgb2YgMSB0aGF0IGdldCB0cmFuc2xhdGVkIHRvIDEgaW4gMmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzc1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYnJpZ2h0bmVzczogMCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdicmlnaHRuZXNzJyxcblxuICAgIC8qKlxuICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgKlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmJyaWdodG5lc3MgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYnJpZ2h0bmVzcyA9IE1hdGgucm91bmQodGhpcy5icmlnaHRuZXNzICogMjU1KTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gZGF0YVtpXSArIGJyaWdodG5lc3M7XG4gICAgICAgIGRhdGFbaSArIDFdID0gZGF0YVtpICsgMV0gKyBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICsgYnJpZ2h0bmVzcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVCcmlnaHRuZXNzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VCcmlnaHRuZXNzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51QnJpZ2h0bmVzcywgdGhpcy5icmlnaHRuZXNzKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3N9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3NcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3MuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9pbWFnZWZpbHRlcnMvXCI+aHRtbDVyb2NrcyBhcnRpY2xlPC9hPlxuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlNoYXJwZW4gZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDAsIC0xLCAgMCxcbiAgICogICAgICAgICAgICAtMSwgIDUsIC0xLFxuICAgKiAgICAgICAgICAgICAwLCAtMSwgIDAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Qmx1ciBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMS85LCAxLzksIDEvOSxcbiAgICogICAgICAgICAgICAgMS85LCAxLzksIDEvOSxcbiAgICogICAgICAgICAgICAgMS85LCAxLzksIDEvOSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDEsICAgMSwgIDEsXG4gICAqICAgICAgICAgICAgIDEsIDAuNywgLTEsXG4gICAqICAgICAgICAgICAgLTEsICAtMSwgLTEgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1ib3NzIGZpbHRlciB3aXRoIG9wYXF1ZW5lc3M8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBvcGFxdWU6IHRydWUsXG4gICAqICAgbWF0cml4OiBbIDEsICAgMSwgIDEsXG4gICAqICAgICAgICAgICAgIDEsIDAuNywgLTEsXG4gICAqICAgICAgICAgICAgLTEsICAtMSwgLTEgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29udm9sdXRlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbnZvbHV0ZScsXG5cbiAgICAvKlxuICAgICAqIE9wYXF1ZSB2YWx1ZSAodHJ1ZS9mYWxzZSlcbiAgICAgKi9cbiAgICBvcGFxdWU6IGZhbHNlLFxuXG4gICAgLypcbiAgICAgKiBtYXRyaXggZm9yIHRoZSBmaWx0ZXIsIG1heCA5eDlcbiAgICAgKi9cbiAgICBtYXRyaXg6IFswLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwXSxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBDb252b2x1dGVfM18xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbOV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDMuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgMy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDEpLCB1U3RlcEggKiAoaCAtIDEpKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiAzLjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfM18wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbOV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDMuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgMy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDEuMCksIHVTdGVwSCAqIChoIC0gMS4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiAzLjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfNV8xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbMjVdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA1LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDUuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAyLjApLCB1U3RlcEggKiAoaCAtIDIuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV81XzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFsyNV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDUuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiA1LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfN18xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbNDldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA3LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDcuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAzLjApLCB1U3RlcEggKiAoaCAtIDMuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV83XzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs0OV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDcuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiA3LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfOV8xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbODFdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA5LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDkuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSA0LjApLCB1U3RlcEggKiAoaCAtIDQuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV85XzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs4MV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDkuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiA5LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcGFxdWU9ZmFsc2VdIE9wYXF1ZSB2YWx1ZSAodHJ1ZS9mYWxzZSlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tYXRyaXhdIEZpbHRlciBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc2l6ZSA9IE1hdGguc3FydCh0aGlzLm1hdHJpeC5sZW5ndGgpO1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgc2l6ZSArICdfJyArICh0aGlzLm9wYXF1ZSA/IDEgOiAwKTtcbiAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW2NhY2hlS2V5XTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgd2VpZ2h0cyA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpLFxuICAgICAgICAgIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMiksXG4gICAgICAgICAgc3cgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgc2ggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShzdywgc2gpLFxuICAgICAgICAgIGRzdCA9IG91dHB1dC5kYXRhLFxuICAgICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIGRlc3RpbmF0aW9uIGltYWdlIHBpeGVsc1xuICAgICAgICAgIGFscGhhRmFjID0gdGhpcy5vcGFxdWUgPyAxIDogMCxcbiAgICAgICAgICByLCBnLCBiLCBhLCBkc3RPZmYsXG4gICAgICAgICAgc2N4LCBzY3ksIHNyY09mZiwgd3QsXG4gICAgICAgICAgeCwgeSwgY3gsIGN5O1xuXG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgc3c7IHgrKykge1xuICAgICAgICAgIGRzdE9mZiA9ICh5ICogc3cgKyB4KSAqIDQ7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB3ZWlnaGVkIHN1bSBvZiB0aGUgc291cmNlIGltYWdlIHBpeGVscyB0aGF0XG4gICAgICAgICAgLy8gZmFsbCB1bmRlciB0aGUgY29udm9sdXRpb24gbWF0cml4XG4gICAgICAgICAgciA9IDA7IGcgPSAwOyBiID0gMDsgYSA9IDA7XG5cbiAgICAgICAgICBmb3IgKGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICAgIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgICBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmIChzY3kgPCAwIHx8IHNjeSA+PSBzaCB8fCBzY3ggPCAwIHx8IHNjeCA+PSBzdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgICAgICAgIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgciArPSBkYXRhW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgZyArPSBkYXRhW3NyY09mZiArIDFdICogd3Q7XG4gICAgICAgICAgICAgIGIgKz0gZGF0YVtzcmNPZmYgKyAyXSAqIHd0O1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgICAgICBhICs9IGRhdGFbc3JjT2ZmICsgM10gKiB3dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDFdID0gZztcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gZGF0YVtkc3RPZmYgKyAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TWF0cml4JyksXG4gICAgICAgIHVPcGFxdWU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU9wYXF1ZScpLFxuICAgICAgICB1SGFsZlNpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUhhbGZTaXplJyksXG4gICAgICAgIHVTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTaXplJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudU1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBvcGFxdWU6IHRoaXMub3BhcXVlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR3JheXNjYWxlIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdyYXlzY2FsZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHcmF5c2NhbGUnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIGF2ZXJhZ2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmIgKyBjb2xvci5nKSAvIDMuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbGlnaHRuZXNzOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKG1heChtYXgoY29sLnIsIGNvbC5nKSxjb2wuYikgKyBtaW4obWluKGNvbC5yLCBjb2wuZyksY29sLmIpKSAvIDIuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGx1bWlub3NpdHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gaW50IHVNb2RlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAwLjIxICogY29sLnIgKyAwLjcyICogY29sLmcgKyAwLjA3ICogY29sLmI7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR3JheXNjYWxlIG1vZGUsIGJldHdlZW4gJ2F2ZXJhZ2UnLCAnbGlnaHRuZXNzJywgJ2x1bWlub3NpdHknXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vZGU6ICdhdmVyYWdlJyxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtb2RlJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHcmF5c2NhbGUgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCwgdmFsdWUsXG4gICAgICAgICAgbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2F2ZXJhZ2UnKSB7XG4gICAgICAgICAgdmFsdWUgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbGlnaHRuZXNzJykge1xuICAgICAgICAgIHZhbHVlID0gKE1hdGgubWluKGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkgK1xuICAgICAgICAgICAgTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdsdW1pbm9zaXR5Jykge1xuICAgICAgICAgIHZhbHVlID0gMC4yMSAqIGRhdGFbaV0gKyAwLjcyICogZGF0YVtpICsgMV0gKyAwLjA3ICogZGF0YVtpICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TW9kZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TW9kZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgLy8gZGVmYXVsdCBhdmVyYWdlIG1vZGUuXG4gICAgICB2YXIgbW9kZSA9IDE7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51TW9kZSwgbW9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYXlzY2FsZSBmaWx0ZXIgaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBUaGUgZmlsdGVyIGlzIG5ldmVyIG5ldXRyYWxcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSW52ZXJ0IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuSW52ZXJ0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0ludmVydCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGludCB1SW52ZXJ0O1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmICh1SW52ZXJ0ID09IDEpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAgLSBjb2xvci5yLDEuMCAtY29sb3IuZywxLjAgLWNvbG9yLmIsY29sb3IuYSk7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBpbnZlcnQuIGlmIGZhbHNlLCBkb2VzIG5vdGhpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGludmVydFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW52ZXJ0OiB0cnVlLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2ludmVydCcsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgSW52ZXJ0IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IDI1NSAtIGRhdGFbaV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gMjU1IC0gZGF0YVtpICsgMV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gZGF0YVtpICsgMl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCBmaWx0ZXIgaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmludmVydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVJbnZlcnQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUludmVydCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudUludmVydCwgdGhpcy5pbnZlcnQpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogTm9pc2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2Uoe1xuICAgKiAgIG5vaXNlOiA3MDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLk5vaXNlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnTm9pc2UnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgbm9pc2UgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdU5vaXNlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVNlZWQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICdmbG9hdCByYW5kKHZlYzIgY28sIGZsb2F0IHNlZWQsIGZsb2F0IHZTY2FsZSkge1xcbicgK1xuICAgICAgICAncmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHkgKiB2U2NhbGUgLHZlYzIoMTIuOTg5OCAsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMgKiAoc2VlZCArIDAuMDEpIC8gMi4wKTtcXG4nICtcbiAgICAgICd9XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiArPSAoMC41IC0gcmFuZCh2VGV4Q29vcmQsIHVTZWVkLCAwLjEgLyB1U3RlcEgpKSAqIHVOb2lzZTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ25vaXNlJyxcblxuICAgIC8qKlxuICAgICAqIE5vaXNlIHZhbHVlLCBmcm9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5vaXNlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub2lzZTogMCxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMubm9pc2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgbm9pc2UgPSB0aGlzLm5vaXNlLCByYW5kO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgcmFuZCA9ICgwLjUgLSBNYXRoLnJhbmRvbSgpKSAqIG5vaXNlO1xuXG4gICAgICAgIGRhdGFbaV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gcmFuZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVOb2lzZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Tm9pc2UnKSxcbiAgICAgICAgdVNlZWQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNlZWQnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVOb2lzZSwgdGhpcy5ub2lzZSAvIDI1NSk7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51U2VlZCwgTWF0aC5yYW5kb20oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIG5vaXNlOiB0aGlzLm5vaXNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUGl4ZWxhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUoe1xuICAgKiAgIGJsb2Nrc2l6ZTogOFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlBpeGVsYXRlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUGl4ZWxhdGUnLFxuXG4gICAgYmxvY2tzaXplOiA0LFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2Jsb2Nrc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBQaXhlbGF0ZSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QmxvY2tzaXplO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAnZmxvYXQgYmxvY2tXID0gdUJsb2Nrc2l6ZSAqIHVTdGVwVztcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGJsb2NrSCA9IHVCbG9ja3NpemUgKiB1U3RlcFc7XFxuJyArXG4gICAgICAgICdpbnQgcG9zWCA9IGludCh2VGV4Q29vcmQueCAvIGJsb2NrVyk7XFxuJyArXG4gICAgICAgICdpbnQgcG9zWSA9IGludCh2VGV4Q29vcmQueSAvIGJsb2NrSCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBmcG9zWCA9IGZsb2F0KHBvc1gpO1xcbicgK1xuICAgICAgICAnZmxvYXQgZnBvc1kgPSBmbG9hdChwb3NZKTtcXG4nICtcbiAgICAgICAgJ3ZlYzIgc3F1YXJlQ29vcmRzID0gdmVjMihmcG9zWCAqIGJsb2NrVywgZnBvc1kgKiBibG9ja0gpO1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgc3F1YXJlQ29vcmRzKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFBpeGVsYXRlIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBqTGVuID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGluZGV4LCBpLCBqLCByLCBnLCBiLCBhLFxuICAgICAgICAgIF9pLCBfaiwgX2lMZW4sIF9qTGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuXG4gICAgICAgICAgaW5kZXggPSAoaSAqIDQpICogakxlbiArIChqICogNCk7XG5cbiAgICAgICAgICByID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM107XG5cbiAgICAgICAgICBfaUxlbiA9IE1hdGgubWluKGkgKyB0aGlzLmJsb2Nrc2l6ZSwgaUxlbik7XG4gICAgICAgICAgX2pMZW4gPSBNYXRoLm1pbihqICsgdGhpcy5ibG9ja3NpemUsIGpMZW4pO1xuICAgICAgICAgIGZvciAoX2kgPSBpOyBfaSA8IF9pTGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmb3IgKF9qID0gajsgX2ogPCBfakxlbjsgX2orKykge1xuICAgICAgICAgICAgICBpbmRleCA9IChfaSAqIDQpICogakxlbiArIChfaiAqIDQpO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGc7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IGI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHdoZW4gdGhlIGZpbHRlciBpcyBub3QgZ29ubmEgYXBwbHkgY2hhbmdlcyB0byB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvY2tzaXplID09PSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJsb2Nrc2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QmxvY2tzaXplJyksXG4gICAgICAgIHVTdGVwVzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKSxcbiAgICAgICAgdVN0ZXBIOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJsb2Nrc2l6ZSwgdGhpcy5ibG9ja3NpemUpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aGl0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcih7XG4gICAqICAgdGhyZXNob2xkOiAwLjIsXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5SZW1vdmVDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1JlbW92ZUNvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIHJlbW92ZSwgaW4gYW55IGZvcm1hdCB1bmRlcnN0b29kIGJ5IGZhYnJpYy5Db2xvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICcjRkZGRkZGJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1TG93O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1SGlnaDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmKGFsbChncmVhdGVyVGhhbihnbF9GcmFnQ29sb3IucmdiLHVMb3cucmdiKSkgJiYgYWxsKGdyZWF0ZXJUaGFuKHVIaWdoLnJnYixnbF9GcmFnQ29sb3IucmdiKSkpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSAwLjA7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBkaXN0YW5jZSB0byBhY3R1YWwgY29sb3IsIGFzIHZhbHVlIHVwIG9yIGRvd24gZnJvbSBlYWNoIHIsZyxiXG4gICAgICogYmV0d2VlbiAwIGFuZCAxXG4gICAgICoqL1xuICAgIGRpc3RhbmNlOiAwLjAyLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbG9yIHRvIHJlbW92ZSBpbnNpZGUgZGlzdGFuY2UsIHVzZSBhbHBoYSBjaGFubmVsIGZvciBhIHNtb290aGVyIGRlbGV0aW9uXG4gICAgICogTk9UIElNUExFTUVOVEVEIFlFVFxuICAgICAqKi9cbiAgICB1c2VBbHBoYTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbG9yPSNSUkdHQkJdIFRocmVzaG9sZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZT0xMF0gRGlzdGFuY2UgdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UgKiAyNTUsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gKyBkaXN0YW5jZSxcbiAgICAgICAgICBdO1xuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBpZiAociA+IGxvd0NbMF0gJiZcbiAgICAgICAgICAgIGcgPiBsb3dDWzFdICYmXG4gICAgICAgICAgICBiID4gbG93Q1syXSAmJlxuICAgICAgICAgICAgciA8IGhpZ2hDWzBdICYmXG4gICAgICAgICAgICBnIDwgaGlnaENbMV0gJiZcbiAgICAgICAgICAgIGIgPCBoaWdoQ1syXSkge1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUxvdzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TG93JyksXG4gICAgICAgIHVIaWdoOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIaWdoJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHBhcnNlRmxvYXQodGhpcy5kaXN0YW5jZSksXG4gICAgICAgICAgbG93QyA9IFtcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMF0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMV0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMl0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdLFxuICAgICAgICAgIGhpZ2hDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF07XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUxvdywgbG93Qyk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUhpZ2gsIGhpZ2hDKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3J9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICB2YXIgbWF0cmljZXMgPSB7XG4gICAgQnJvd25pZTogW1xuICAgICAgMC41OTk3MCwwLjM0NTUzLC0wLjI3MDgyLDAsMC4xODYsXG4gICAgICAtMC4wMzc3MCwwLjg2MDk1LDAuMTUwNTksMCwtMC4xNDQ5LFxuICAgICAgMC4yNDExMywtMC4wNzQ0MSwwLjQ0OTcyLDAsLTAuMDI5NjUsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFZpbnRhZ2U6IFtcbiAgICAgIDAuNjI3OTMsMC4zMjAyMSwtMC4wMzk2NSwwLDAuMDM3ODQsXG4gICAgICAwLjAyNTc4LDAuNjQ0MTEsMC4wMzI1OSwwLDAuMDI5MjYsXG4gICAgICAwLjA0NjYwLC0wLjA4NTEyLDAuNTI0MTYsMCwwLjAyMDIzLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBLb2RhY2hyb21lOiBbXG4gICAgICAxLjEyODU1LC0wLjM5NjczLC0wLjAzOTkyLDAsMC4yNDk5MSxcbiAgICAgIC0wLjE2NDA0LDEuMDgzNTIsLTAuMDU0OTgsMCwwLjA5Njk4LFxuICAgICAgLTAuMTY3ODYsLTAuNTYwMzQsMS42MDE0OCwwLDAuMTM5NzIsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFRlY2huaWNvbG9yOiBbXG4gICAgICAxLjkxMjUyLC0wLjg1NDUzLC0wLjA5MTU1LDAsMC4wNDYyNCxcbiAgICAgIC0wLjMwODc4LDEuNzY1ODksLTAuMTA2MDEsMCwtMC4yNzU4OSxcbiAgICAgIC0wLjIzMTEwLC0wLjc1MDE4LDEuODQ3NTksMCwwLjEyMTM3LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBQb2xhcm9pZDogW1xuICAgICAgMS40MzgsLTAuMDYyLC0wLjA2MiwwLDAsXG4gICAgICAtMC4xMjIsMS4zNzgsLTAuMTIyLDAsMCxcbiAgICAgIC0wLjAxNiwtMC4wMTYsMS40ODMsMCwwLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBTZXBpYTogW1xuICAgICAgMC4zOTMsIDAuNzY5LCAwLjE4OSwgMCwgMCxcbiAgICAgIDAuMzQ5LCAwLjY4NiwgMC4xNjgsIDAsIDAsXG4gICAgICAwLjI3MiwgMC41MzQsIDAuMTMxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG4gICAgQmxhY2tXaGl0ZTogW1xuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMCwgMCwgMCwgMSwgMCxcbiAgICBdXG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIG1hdHJpY2VzKSB7XG4gICAgZmlsdGVyc1trZXldID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlciB0eXBlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgdHlwZToga2V5LFxuXG4gICAgICAvKipcbiAgICAgICAqIENvbG9ybWF0cml4IGZvciB0aGUgZWZmZWN0XG4gICAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgbWF0cml4OiBtYXRyaWNlc1trZXldLFxuXG4gICAgICAvKipcbiAgICAgICAqIExvY2sgdGhlIG1hdHJpeCBleHBvcnQgZm9yIHRoaXMga2luZCBvZiBzdGF0aWMsIHBhcmFtZXRlciBsZXNzIGZpbHRlcnMuXG4gICAgICAgKi9cbiAgICAgIG1haW5QYXJhbWV0ZXI6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGFcbiAgICAgICAqL1xuICAgICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIH0pO1xuICAgIGZhYnJpYy5JbWFnZS5maWx0ZXJzW2tleV0uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kQ29sb3JcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yKHtcbiAgICogIGNvbG9yOiAnIzAwMCcsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuXG4gIGZpbHRlcnMuQmxlbmRDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZC5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZENvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBjb2xvcjogJyNGOTVDNjMnLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlcjogb25lIG9mIG11bHRpcGx5LCBhZGQsIGRpZmYsIHNjcmVlbiwgc3VidHJhY3QsXG4gICAgICogZGFya2VuLCBsaWdodGVuLCBvdmVybGF5LCBleGNsdXNpb24sIHRpbnQuXG4gICAgICoqL1xuICAgIG1vZGU6ICdtdWx0aXBseScsXG5cbiAgICAvKipcbiAgICAgKiBhbHBoYSB2YWx1ZS4gcmVwcmVzZW50IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxlbmQgY29sb3Igb3BlcmF0aW9uLlxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdnbF9GcmFnQ29sb3IucmdiICo9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIHNjcmVlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSAxLjAgLSAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnJnYikgKiAoMS4wIC0gdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGFkZDogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgZGlmZjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBhYnMoZ2xfRnJhZ0NvbG9yLnJnYiAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBzdWJ0cmFjdDogJ2dsX0ZyYWdDb2xvci5yZ2IgLT0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgbGlnaHRlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtYXgoZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGRhcmtlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtaW4oZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGV4Y2x1c2lvbjogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYiAtIDIuMCAqICh1Q29sb3IucmdiICogZ2xfRnJhZ0NvbG9yLnJnYik7XFxuJyxcbiAgICAgIG92ZXJsYXk6ICdpZiAodUNvbG9yLnIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgKj0gMi4wICogdUNvbG9yLnI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuciA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IucikgKiAoMS4wIC0gdUNvbG9yLnIpO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnaWYgKHVDb2xvci5nIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nICo9IDIuMCAqIHVDb2xvci5nO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmcgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmcpICogKDEuMCAtIHVDb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuYiA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiAqPSAyLjAgKiB1Q29sb3IuYjtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5iID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5iKSAqICgxLjAgLSB1Q29sb3IuYik7XFxuJyArXG4gICAgICAgICd9XFxuJyxcbiAgICAgIHRpbnQ6ICdnbF9GcmFnQ29sb3IucmdiICo9ICgxLjAgLSB1Q29sb3IuYSk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYnVpbGQgdGhlIGZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGZpbHRlcnMsIGpvaW5pbmcgdGhlIGNvbW1vbiBwYXJ0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWMgb25lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIHRoZSBtb2RlIG9mIHRoZSBmaWx0ZXIsIGEga2V5IG9mIHRoaXMuZnJhZ21lbnRTb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkU291cmNlOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICByZXR1cm4gJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdpZiAoY29sb3IuYSA+IDAuMCkge1xcbicgK1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNvdXJjZVttb2RlXSArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ30nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlLCBzaGFkZXJTb3VyY2U7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBzaGFkZXJTb3VyY2UgPSB0aGlzLmJ1aWxkU291cmNlKHRoaXMubW9kZSk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgdHIsIHRnLCB0YixcbiAgICAgICAgICByLCBnLCBiLFxuICAgICAgICAgIHNvdXJjZSwgYWxwaGExID0gMSAtIHRoaXMuYWxwaGE7XG5cbiAgICAgIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCk7XG4gICAgICB0ciA9IHNvdXJjZVswXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0ZyA9IHNvdXJjZVsxXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0YiA9IHNvdXJjZVsyXSAqIHRoaXMuYWxwaGE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY3JlZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IDI1NSAtICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtICgyNTUgLSBiKSAqICgyNTUgLSB0YikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKyB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyArIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICsgdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICBjYXNlICdkaWZmZXJlbmNlJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLmFicyhyIC0gdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLmFicyhnIC0gdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLmFicyhiIC0gdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3VidHJhY3QnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgLSB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAtIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiIC0gdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXJrZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWluKHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1pbihiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1heChyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3ZlcmxheSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgPCAxMjggPyAoMiAqIHIgKiB0ciAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyA8IDEyOCA/ICgyICogZyAqIHRnIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGcpICogKDI1NSAtIHRnKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiIDwgMTI4ID8gKDIgKiBiICogdGIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2V4Y2x1c2lvbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgKyByIC0gKCgyICogdHIgKiByKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAtICgoMiAqIHRnICogZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgLSAoKDIgKiB0YiAqIGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RpbnQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgKyBnICogYWxwaGExO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgKiBhbHBoYTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3InKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzBdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVswXSAvIDI1NTtcbiAgICAgIHNvdXJjZVsxXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMV0gLyAyNTU7XG4gICAgICBzb3VyY2VbMl0gPSB0aGlzLmFscGhhICogc291cmNlWzJdIC8gMjU1O1xuICAgICAgc291cmNlWzNdID0gdGhpcy5hbHBoYTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3IsIHNvdXJjZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEltYWdlIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZEltYWdlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kSW1hZ2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZEltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBpbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXI6IG9uZSBvZiBtdWx0aXBseSwgYWRkLCBkaWZmLCBzY3JlZW4sIHN1YnRyYWN0LFxuICAgICAqIGRhcmtlbiwgbGlnaHRlbiwgb3ZlcmxheSwgZXhjbHVzaW9uLCB0aW50LlxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGltYWdlIG9wZXJhdGlvbi5cbiAgICAgKiBub3QgaW1wbGVtZW50ZWQuXG4gICAgICoqL1xuICAgIGFscGhhOiAxLFxuXG4gICAgdmVydGV4U291cmNlOiAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAndW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm1NYXRyaXg7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndlRleENvb3JkID0gYVBvc2l0aW9uO1xcbicgK1xuICAgICAgICAndlRleENvb3JkMiA9ICh1VHJhbnNmb3JtTWF0cml4ICogdmVjMyhhUG9zaXRpb24sIDEuMCkpLnh5O1xcbicgK1xuICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiAqIDIuMCAtIDEuMCwgMC4wLCAxLjApO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgTXVsdGlwbHkgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBtdWx0aXBseTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcXG4nICtcbiAgICAgICAgICAnY29sb3IucmdiYSAqPSBjb2xvcjIucmdiYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIG1hc2s6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yLmEgPSBjb2xvcjIuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZTtcbiAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW3RoaXMubW9kZV07XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1dlYkdMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBsb2FkIHRleHR1cmUgdG8gYmxlbmQuXG4gICAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShvcHRpb25zLmZpbHRlckJhY2tlbmQsIHRoaXMuaW1hZ2UpO1xuICAgICAgdGhpcy5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIHRleHR1cmUsIGdsLlRFWFRVUkUxKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdhcHBseVRvV2ViR0wnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMudW5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIGdsLlRFWFRVUkUxKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24oYmFja2VuZCwgaW1hZ2UpIHtcbiAgICAgIHJldHVybiBiYWNrZW5kLmdldENhY2hlZFRleHR1cmUoaW1hZ2UuY2FjaGVLZXksIGltYWdlLl9lbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtTWF0cml4IHRvIGFkYXB0IHRoZSBpbWFnZSB0byBibGVuZCBvdmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgICAgICB3aWR0aCA9IGltYWdlLl9lbGVtZW50LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlLl9lbGVtZW50LmhlaWdodDtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDEgLyBpbWFnZS5zY2FsZVgsIDAsIDAsXG4gICAgICAgIDAsIDEgLyBpbWFnZS5zY2FsZVksIDAsXG4gICAgICAgIC1pbWFnZS5sZWZ0IC8gd2lkdGgsIC1pbWFnZS50b3AgLyBoZWlnaHQsIDFcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCbGVuZCBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgdHIsIHRnLCB0YiwgdGEsXG4gICAgICAgICAgciwgZywgYiwgYSxcbiAgICAgICAgICBjYW52YXMxLCBjb250ZXh0LCBpbWFnZSA9IHRoaXMuaW1hZ2UsIGJsZW5kRGF0YTtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmxlbmRJbWFnZSkge1xuICAgICAgICByZXNvdXJjZXMuYmxlbmRJbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmxlbmRJbWFnZTtcbiAgICAgIGNvbnRleHQgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oaW1hZ2Uuc2NhbGVYLCAwLCAwLCBpbWFnZS5zY2FsZVksIGltYWdlLmxlZnQsIGltYWdlLnRvcCk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZS5fZWxlbWVudCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBibGVuZERhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcblxuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgICB0ciA9IGJsZW5kRGF0YVtpXTtcbiAgICAgICAgdGcgPSBibGVuZERhdGFbaSArIDFdO1xuICAgICAgICB0YiA9IGJsZW5kRGF0YVtpICsgMl07XG4gICAgICAgIHRhID0gYmxlbmREYXRhW2kgKyAzXTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgM10gPSBhICogdGEgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXNrJzpcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VHJhbnNmb3JtTWF0cml4JyksXG4gICAgICAgIHVJbWFnZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW1hZ2UnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudUltYWdlLCAxKTsgLy8gdGV4dHVyZSB1bml0IDEuXG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVuaWZvcm1Mb2NhdGlvbnMudVRyYW5zZm9ybU1hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGltYWdlOiB0aGlzLmltYWdlICYmIHRoaXMuaW1hZ2UudG9PYmplY3QoKSxcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdChvYmplY3QuaW1hZ2UsIGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvYmplY3QpO1xuICAgICAgb3B0aW9ucy5pbWFnZSA9IGltYWdlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uob3B0aW9ucykpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLCBwb3cgPSBNYXRoLnBvdywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgc3FydCA9IE1hdGguc3FydCwgYWJzID0gTWF0aC5hYnMsIHJvdW5kID0gTWF0aC5yb3VuZCwgc2luID0gTWF0aC5zaW4sXG4gICAgICBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVzaXplIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuUmVzaXplID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1Jlc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdHlwZVxuICAgICAqIGZvciB3ZWJnbCByZXNpemVUeXBlIGlzIGp1c3QgbGFuY3pvcywgZm9yIGNhbnZhczJkIGNhbiBiZTpcbiAgICAgKiBiaWxpbmVhciwgaGVybWl0ZSwgc2xpY2VIYWNrLCBsYW5jem9zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXNpemVUeXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXNpemVUeXBlOiAnaGVybWl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6IDEsXG5cbiAgICAvKipcbiAgICAgKiBMYW5jem9zTG9iZXMgcGFyYW1ldGVyIGZvciBsYW5jem9zIGZpbHRlciwgdmFsaWQgZm9yIHJlc2l6ZVR5cGUgbGFuY3pvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsYW5jem9zTG9iZXNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxhbmN6b3NMb2JlczogMyxcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVEZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgICAgdVRhcHM6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRhcHMnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0yZnYodW5pZm9ybUxvY2F0aW9ucy51RGVsdGEsIHRoaXMuaG9yaXpvbnRhbCA/IFsxIC8gdGhpcy53aWR0aCwgMF0gOiBbMCwgMSAvIHRoaXMuaGVpZ2h0XSk7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudVRhcHMsIHRoaXMudGFwcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBmaWx0ZXJXaW5kb3c7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdlbmVyYXRlU2hhZGVyKGZpbHRlcldpbmRvdyk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIGdldEZpbHRlcldpbmRvdzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnRlbXBTY2FsZTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5sYW5jem9zTG9iZXMgLyBzY2FsZSk7XG4gICAgfSxcblxuICAgIGdldFRhcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvYmVGdW5jdGlvbiA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksIHNjYWxlID0gdGhpcy50ZW1wU2NhbGUsXG4gICAgICAgICAgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgdGFwcyA9IG5ldyBBcnJheShmaWx0ZXJXaW5kb3cpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZmlsdGVyV2luZG93OyBpKyspIHtcbiAgICAgICAgdGFwc1tpIC0gMV0gPSBsb2JlRnVuY3Rpb24oaSAqIHNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB2ZXJ0ZXggYW5kIHNoYWRlciBzb3VyY2VzIGZyb20gdGhlIG5lY2Vzc2FyeSBzdGVwcyBudW1iZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbHRlcldpbmRvd1xuICAgICAqL1xuICAgIGdlbmVyYXRlU2hhZGVyOiBmdW5jdGlvbihmaWx0ZXJXaW5kb3cpIHtcbiAgICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGZpbHRlcldpbmRvdyksXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U291cmNlVE9QLCBmaWx0ZXJXaW5kb3c7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZpbHRlcldpbmRvdzsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaSAtIDFdID0gaSArICcuMCAqIHVEZWx0YSc7XG4gICAgICB9XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd1bmlmb3JtIGZsb2F0IHVUYXBzWycgKyBmaWx0ZXJXaW5kb3cgKyAnXTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ3ZvaWQgbWFpbigpIHtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgZmxvYXQgc3VtID0gMS4wO1xcbic7XG5cbiAgICAgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbihvZmZzZXQsIGkpIHtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyAnICsgb2Zmc2V0ICsgJykgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkIC0gJyArIG9mZnNldCArICcpICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBzdW0gKz0gMi4wICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgfSk7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHN1bTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ30nO1xuICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgIH0sXG5cbiAgICBmcmFnbWVudFNvdXJjZVRPUDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSByZXNpemUgZmlsdGVyIHRvIHRoZSBpbWFnZVxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kVyA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHRoaXMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5kSCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLnRlbXBTY2FsZSA9IHRoaXMuZFcgLyB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoID0gdGhpcy5kVztcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VXaWR0aCA9IG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aDtcblxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kSCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiB0aGlzLnNjYWxlWSk7XG4gICAgICAgIHRoaXMudGVtcFNjYWxlID0gdGhpcy5kSCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodCA9IHRoaXMuZEg7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc291cmNlSGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYID09PSAxICYmIHRoaXMuc2NhbGVZID09PSAxO1xuICAgIH0sXG5cbiAgICBsYW5jem9zQ3JlYXRlOiBmdW5jdGlvbihsb2Jlcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPj0gbG9iZXMgfHwgeCA8PSAtbG9iZXMpIHtcbiAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgMS4xOTIwOTI5MEUtMDcgJiYgeCA+IC0xLjE5MjA5MjkwRS0wNykge1xuICAgICAgICAgIHJldHVybiAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgeCAqPSBNYXRoLlBJO1xuICAgICAgICB2YXIgeHggPSB4IC8gbG9iZXM7XG4gICAgICAgIHJldHVybiAoc2luKHgpIC8geCkgKiBzaW4oeHgpIC8geHg7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVk7XG5cbiAgICAgIHRoaXMucmNwU2NhbGVYID0gMSAvIHNjYWxlWDtcbiAgICAgIHRoaXMucmNwU2NhbGVZID0gMSAvIHNjYWxlWTtcblxuICAgICAgdmFyIG9XID0gaW1hZ2VEYXRhLndpZHRoLCBvSCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgZFcgPSByb3VuZChvVyAqIHNjYWxlWCksIGRIID0gcm91bmQob0ggKiBzY2FsZVkpLFxuICAgICAgICAgIG5ld0RhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdzbGljZUhhY2snKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLnNsaWNlQnlUd28ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnaGVybWl0ZScpIHtcbiAgICAgICAgbmV3RGF0YSA9IHRoaXMuaGVybWl0ZUZhc3RSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnYmlsaW5lYXInKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmJpbGluZWFyRmlsdGVyaW5nKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2xhbmN6b3MnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmxhbmN6b3NSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSBuZXdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgc2xpY2VCeVR3b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgc2xpY2VCeVR3bzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBtdWx0ID0gMC41LCBkb25lVyA9IGZhbHNlLCBkb25lSCA9IGZhbHNlLCBzdGVwVyA9IG9XICogbXVsdCxcbiAgICAgICAgICBzdGVwSCA9IG9IICogbXVsdCwgcmVzb3VyY2VzID0gZmFicmljLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIHRtcENhbnZhcywgY3R4LCBzWCA9IDAsIHNZID0gMCwgZFggPSBvVywgZFkgPSAwO1xuICAgICAgaWYgKCFyZXNvdXJjZXMuc2xpY2VCeVR3bykge1xuICAgICAgICByZXNvdXJjZXMuc2xpY2VCeVR3byA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgfVxuICAgICAgdG1wQ2FudmFzID0gcmVzb3VyY2VzLnNsaWNlQnlUd287XG4gICAgICBpZiAodG1wQ2FudmFzLndpZHRoIDwgb1cgKiAxLjUgfHwgdG1wQ2FudmFzLmhlaWdodCA8IG9IKSB7XG4gICAgICAgIHRtcENhbnZhcy53aWR0aCA9IG9XICogMS41O1xuICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gb0g7XG4gICAgICB9XG4gICAgICBjdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgb1cgKiAxLjUsIG9IKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgZFcgPSBmbG9vcihkVyk7XG4gICAgICBkSCA9IGZsb29yKGRIKTtcblxuICAgICAgd2hpbGUgKCFkb25lVyB8fCAhZG9uZUgpIHtcbiAgICAgICAgb1cgPSBzdGVwVztcbiAgICAgICAgb0ggPSBzdGVwSDtcbiAgICAgICAgaWYgKGRXIDwgZmxvb3Ioc3RlcFcgKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBXID0gZmxvb3Ioc3RlcFcgKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwVyA9IGRXO1xuICAgICAgICAgIGRvbmVXID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZEggPCBmbG9vcihzdGVwSCAqIG11bHQpKSB7XG4gICAgICAgICAgc3RlcEggPSBmbG9vcihzdGVwSCAqIG11bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0ZXBIID0gZEg7XG4gICAgICAgICAgZG9uZUggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCBzWCwgc1ksIG9XLCBvSCwgZFgsIGRZLCBzdGVwVywgc3RlcEgpO1xuICAgICAgICBzWCA9IGRYO1xuICAgICAgICBzWSA9IGRZO1xuICAgICAgICBkWSArPSBzdGVwSDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKHNYLCBzWSwgZFcsIGRIKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGxhbmN6b3NSZXNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGxhbmN6b3NSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3ModSkge1xuICAgICAgICB2YXIgdiwgaSwgd2VpZ2h0LCBpZHgsIGEsIHJlZCwgZ3JlZW4sXG4gICAgICAgICAgICBibHVlLCBhbHBoYSwgZlgsIGZZO1xuICAgICAgICBjZW50ZXIueCA9ICh1ICsgMC41KSAqIHJhdGlvWDtcbiAgICAgICAgaWNlbnRlci54ID0gZmxvb3IoY2VudGVyLngpO1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgZEg7IHYrKykge1xuICAgICAgICAgIGNlbnRlci55ID0gKHYgKyAwLjUpICogcmF0aW9ZO1xuICAgICAgICAgIGljZW50ZXIueSA9IGZsb29yKGNlbnRlci55KTtcbiAgICAgICAgICBhID0gMDsgcmVkID0gMDsgZ3JlZW4gPSAwOyBibHVlID0gMDsgYWxwaGEgPSAwO1xuICAgICAgICAgIGZvciAoaSA9IGljZW50ZXIueCAtIHJhbmdlMlg7IGkgPD0gaWNlbnRlci54ICsgcmFuZ2UyWDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBvVykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZYID0gZmxvb3IoMTAwMCAqIGFicyhpIC0gY2VudGVyLngpKTtcbiAgICAgICAgICAgIGlmICghY2FjaGVMYW5jW2ZYXSkge1xuICAgICAgICAgICAgICBjYWNoZUxhbmNbZlhdID0geyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGljZW50ZXIueSAtIHJhbmdlMlk7IGogPD0gaWNlbnRlci55ICsgcmFuZ2UyWTsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IG9IKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZlkgPSBmbG9vcigxMDAwICogYWJzKGogLSBjZW50ZXIueSkpO1xuICAgICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF1bZlldKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXVtmWV0gPSBsYW5jem9zKHNxcnQocG93KGZYICogcmNwUmF0aW9YLCAyKSArIHBvdyhmWSAqIHJjcFJhdGlvWSwgMikpIC8gMTAwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2VpZ2h0ID0gY2FjaGVMYW5jW2ZYXVtmWV07XG4gICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGogKiBvVyArIGkpICogNDtcbiAgICAgICAgICAgICAgICBhICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICByZWQgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHhdO1xuICAgICAgICAgICAgICAgIGdyZWVuICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgYmx1ZSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDJdO1xuICAgICAgICAgICAgICAgIGFscGhhICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWR4ID0gKHYgKiBkVyArIHUpICogNDtcbiAgICAgICAgICBkZXN0RGF0YVtpZHhdID0gcmVkIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAxXSA9IGdyZWVuIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAyXSA9IGJsdWUgLyBhO1xuICAgICAgICAgIGRlc3REYXRhW2lkeCArIDNdID0gYWxwaGEgLyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrdSA8IGRXKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3ModSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3RJbWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNyY0RhdGEgPSBvcHRpb25zLmltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGRlc3RJbWcgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0RGF0YSA9IGRlc3RJbWcuZGF0YSxcbiAgICAgICAgICBsYW5jem9zID0gdGhpcy5sYW5jem9zQ3JlYXRlKHRoaXMubGFuY3pvc0xvYmVzKSxcbiAgICAgICAgICByYXRpb1ggPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmNwUmF0aW9YID0gMiAvIHRoaXMucmNwU2NhbGVYLCByY3BSYXRpb1kgPSAyIC8gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmFuZ2UyWCA9IGNlaWwocmF0aW9YICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICByYW5nZTJZID0gY2VpbChyYXRpb1kgKiB0aGlzLmxhbmN6b3NMb2JlcyAvIDIpLFxuICAgICAgICAgIGNhY2hlTGFuYyA9IHsgfSwgY2VudGVyID0geyB9LCBpY2VudGVyID0geyB9O1xuXG4gICAgICByZXR1cm4gcHJvY2VzcygwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmlsaW5lYXJGaWx0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGJpbGluZWFyRmlsdGVyaW5nOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIGEsIGIsIGMsIGQsIHgsIHksIGksIGosIHhEaWZmLCB5RGlmZiwgY2hubCxcbiAgICAgICAgICBjb2xvciwgb2Zmc2V0ID0gMCwgb3JpZ1BpeCwgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsXG4gICAgICAgICAgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgdzQgPSA0ICogKG9XIC0gMSksIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHBpeGVscyA9IGltZy5kYXRhLCBkZXN0SW1hZ2UgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0UGl4ZWxzID0gZGVzdEltYWdlLmRhdGE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZEg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZFc7IGorKykge1xuICAgICAgICAgIHggPSBmbG9vcihyYXRpb1ggKiBqKTtcbiAgICAgICAgICB5ID0gZmxvb3IocmF0aW9ZICogaSk7XG4gICAgICAgICAgeERpZmYgPSByYXRpb1ggKiBqIC0geDtcbiAgICAgICAgICB5RGlmZiA9IHJhdGlvWSAqIGkgLSB5O1xuICAgICAgICAgIG9yaWdQaXggPSA0ICogKHkgKiBvVyArIHgpO1xuXG4gICAgICAgICAgZm9yIChjaG5sID0gMDsgY2hubCA8IDQ7IGNobmwrKykge1xuICAgICAgICAgICAgYSA9IHBpeGVsc1tvcmlnUGl4ICsgY2hubF07XG4gICAgICAgICAgICBiID0gcGl4ZWxzW29yaWdQaXggKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjID0gcGl4ZWxzW29yaWdQaXggKyB3NCArIGNobmxdO1xuICAgICAgICAgICAgZCA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjb2xvciA9IGEgKiAoMSAtIHhEaWZmKSAqICgxIC0geURpZmYpICsgYiAqIHhEaWZmICogKDEgLSB5RGlmZikgK1xuICAgICAgICAgICAgICAgICAgICBjICogeURpZmYgKiAoMSAtIHhEaWZmKSArIGQgKiB4RGlmZiAqIHlEaWZmO1xuICAgICAgICAgICAgZGVzdFBpeGVsc1tvZmZzZXQrK10gPSBjb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXN0SW1hZ2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhlcm1pdGVGYXN0UmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBoZXJtaXRlRmFzdFJlc2l6ZTogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciByYXRpb1cgPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9IID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmF0aW9XSGFsZiA9IGNlaWwocmF0aW9XIC8gMiksXG4gICAgICAgICAgcmF0aW9ISGFsZiA9IGNlaWwocmF0aW9IIC8gMiksXG4gICAgICAgICAgaW1nID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWcuZGF0YSxcbiAgICAgICAgICBpbWcyID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksIGRhdGEyID0gaW1nMi5kYXRhO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkSDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZFc7IGkrKykge1xuICAgICAgICAgIHZhciB4MiA9IChpICsgaiAqIGRXKSAqIDQsIHdlaWdodCA9IDAsIHdlaWdodHMgPSAwLCB3ZWlnaHRzQWxwaGEgPSAwLFxuICAgICAgICAgICAgICBneFIgPSAwLCBneEcgPSAwLCBneEIgPSAwLCBneEEgPSAwLCBjZW50ZXJZID0gKGogKyAwLjUpICogcmF0aW9IO1xuICAgICAgICAgIGZvciAodmFyIHl5ID0gZmxvb3IoaiAqIHJhdGlvSCk7IHl5IDwgKGogKyAxKSAqIHJhdGlvSDsgeXkrKykge1xuICAgICAgICAgICAgdmFyIGR5ID0gYWJzKGNlbnRlclkgLSAoeXkgKyAwLjUpKSAvIHJhdGlvSEhhbGYsXG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IChpICsgMC41KSAqIHJhdGlvVywgdzAgPSBkeSAqIGR5O1xuICAgICAgICAgICAgZm9yICh2YXIgeHggPSBmbG9vcihpICogcmF0aW9XKTsgeHggPCAoaSArIDEpICogcmF0aW9XOyB4eCsrKSB7XG4gICAgICAgICAgICAgIHZhciBkeCA9IGFicyhjZW50ZXJYIC0gKHh4ICsgMC41KSkgLyByYXRpb1dIYWxmLFxuICAgICAgICAgICAgICAgICAgdyA9IHNxcnQodzAgKyBkeCAqIGR4KTtcbiAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICAgIGlmICh3ID4gMSAmJiB3IDwgLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL2hlcm1pdGUgZmlsdGVyXG4gICAgICAgICAgICAgIHdlaWdodCA9IDIgKiB3ICogdyAqIHcgLSAzICogdyAqIHcgKyAxO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGR4ID0gNCAqICh4eCArIHl5ICogb1cpO1xuICAgICAgICAgICAgICAgIC8vYWxwaGFcbiAgICAgICAgICAgICAgICBneEEgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDNdO1xuICAgICAgICAgICAgICAgIHdlaWdodHNBbHBoYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy9jb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtkeCArIDNdIDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQgKiBkYXRhW2R4ICsgM10gLyAyNTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGd4UiArPSB3ZWlnaHQgKiBkYXRhW2R4XTtcbiAgICAgICAgICAgICAgICBneEcgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDFdO1xuICAgICAgICAgICAgICAgIGd4QiArPSB3ZWlnaHQgKiBkYXRhW2R4ICsgMl07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cyArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YTJbeDJdID0gZ3hSIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDFdID0gZ3hHIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDJdID0gZ3hCIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDNdID0gZ3hBIC8gd2VpZ2h0c0FscGhhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgcmVzaXplVHlwZTogdGhpcy5yZXNpemVUeXBlLFxuICAgICAgICBsYW5jem9zTG9iZXM6IHRoaXMubGFuY3pvc0xvYmVzXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb250cmFzdCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCh7XG4gICAqICAgY29udHJhc3Q6IDAuMjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5Db250cmFzdCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbnRyYXN0JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUNvbnRyYXN0O1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGNvbnRyYXN0RiA9IDEuMDE1ICogKHVDb250cmFzdCArIDEuMCkgLyAoMS4wICogKDEuMDE1IC0gdUNvbnRyYXN0KSk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgPSBjb250cmFzdEYgKiAoY29sb3IucmdiIC0gMC41KSArIDAuNTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogY29udHJhc3QgdmFsdWUsIHJhbmdlIGZyb20gLTEgdG8gMS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgY29udHJhc3Q6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnY29udHJhc3QnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb250cmFzdD0wXSBWYWx1ZSB0byBjb250cmFzdCB0aGUgaW1hZ2UgdXAgKC0xLi4uMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAgKiBBcHBseSB0aGUgQ29udHJhc3Qgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRyYXN0ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSwgaSwgbGVuLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgY29udHJhc3QgPSBNYXRoLmZsb29yKHRoaXMuY29udHJhc3QgKiAyNTUpLFxuICAgICAgICAgIGNvbnRyYXN0RiA9IDI1OSAqIChjb250cmFzdCArIDI1NSkgLyAoMjU1ICogKDI1OSAtIGNvbnRyYXN0KSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gY29udHJhc3RGICogKGRhdGFbaV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAxXSAtIDEyOCkgKyAxMjg7XG4gICAgICAgIGRhdGFbaSArIDJdID0gY29udHJhc3RGICogKGRhdGFbaSArIDJdIC0gMTI4KSArIDEyODtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb250cmFzdDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29udHJhc3QnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVDb250cmFzdCwgdGhpcy5jb250cmFzdCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBTYXR1cmF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbih7XG4gICAqICAgc2F0dXJhdGlvbjogMTAwXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuU2F0dXJhdGlvbiA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnU2F0dXJhdGlvbicsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTYXR1cmF0aW9uO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHJnTWF4ID0gbWF4KGNvbG9yLnIsIGNvbG9yLmcpO1xcbicgK1xuICAgICAgICAnZmxvYXQgcmdiTWF4ID0gbWF4KHJnTWF4LCBjb2xvci5iKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnIgKz0gcmdiTWF4ICE9IGNvbG9yLnIgPyAocmdiTWF4IC0gY29sb3IucikgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5nICs9IHJnYk1heCAhPSBjb2xvci5nID8gKHJnYk1heCAtIGNvbG9yLmcpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuYiArPSByZ2JNYXggIT0gY29sb3IuYiA/IChyZ2JNYXggLSBjb2xvci5iKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgc2F0dXJhdGlvbjogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdzYXR1cmF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2F0dXJhdGU9MF0gVmFsdWUgdG8gc2F0dXJhdGUgdGhlIGltYWdlICgtMS4uLjEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgU2F0dXJhdGlvbiBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLnNhdHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYWRqdXN0ID0gLXRoaXMuc2F0dXJhdGlvbiwgaSwgbWF4O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKTtcbiAgICAgICAgZGF0YVtpXSArPSBtYXggIT09IGRhdGFbaV0gPyAobWF4IC0gZGF0YVtpXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBtYXggIT09IGRhdGFbaSArIDFdID8gKG1heCAtIGRhdGFbaSArIDFdKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IG1heCAhPT0gZGF0YVtpICsgMl0gPyAobWF4IC0gZGF0YVtpICsgMl0pICogYWRqdXN0IDogMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVTYXR1cmF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYXR1cmF0aW9uJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51U2F0dXJhdGlvbiwgLXRoaXMuc2F0dXJhdGlvbik7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9ufSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbi5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQmx1ciBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXJcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1ciNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1cih7XG4gICAqICAgYmx1cjogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5CbHVyID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdCbHVyJyxcblxuICAgIC8qXG4nZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNyAqIHVEZWx0YSkqMC4wMDQ0Mjk5MTIxMDU1MTEzMjY1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNiAqIHVEZWx0YSkqMC4wMDg5NTc4MTIxMTc5NDsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTUgKiB1RGVsdGEpKjAuMDIxNTk2Mzg2NjA1MzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTQgKiB1RGVsdGEpKjAuMDQ0MzY4MzMzODcxODsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTMgKiB1RGVsdGEpKjAuMDc3Njc0NDIxOTkzMzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTIgKiB1RGVsdGEpKjAuMTE1ODc2NjIxMTA1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMSAqIHVEZWx0YSkqMC4xNDczMDgwNTYxMjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCAgICAgICAgICAgICAgKSowLjE1OTU3NjkxMjE2MTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMSAqIHVEZWx0YSkqMC4xNDczMDgwNTYxMjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDIgKiB1RGVsdGEpKjAuMTE1ODc2NjIxMTA1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAzICogdURlbHRhKSowLjA3NzY3NDQyMTk5MzM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDQgKiB1RGVsdGEpKjAuMDQ0MzY4MzMzODcxODsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNSAqIHVEZWx0YSkqMC4wMjE1OTYzODY2MDUzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA2ICogdURlbHRhKSowLjAwODk1NzgxMjExNzk0OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA3ICogdURlbHRhKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7JyxcbiovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMyIHVEZWx0YTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ2NvbnN0IGZsb2F0IG5TYW1wbGVzID0gMTUuMDtcXG4nICtcbiAgICAgICd2ZWMzIHYzb2Zmc2V0ID0gdmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKTtcXG4nICtcbiAgICAgICdmbG9hdCByYW5kb20odmVjMyBzY2FsZSkge1xcbicgK1xuICAgICAgICAvKiB1c2UgdGhlIGZyYWdtZW50IHBvc2l0aW9uIGZvciBhIGRpZmZlcmVudCBzZWVkIHBlci1waXhlbCAqL1xuICAgICAgICAncmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiwgc2NhbGUpKSAqIDQzNzU4LjU0NTMpO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcbicgK1xuICAgICAgICAnZmxvYXQgdG90YWwgPSAwLjA7XFxuJyArXG4gICAgICAgICdmbG9hdCBvZmZzZXQgPSByYW5kb20odjNvZmZzZXQpO1xcbicgK1xuICAgICAgICAnZm9yIChmbG9hdCB0ID0gLW5TYW1wbGVzOyB0IDw9IG5TYW1wbGVzOyB0KyspIHtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIG5TYW1wbGVzO1xcbicgK1xuICAgICAgICAgICdmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgdURlbHRhICogcGVyY2VudCkgKiB3ZWlnaHQ7XFxuJyArXG4gICAgICAgICAgJ3RvdGFsICs9IHdlaWdodDtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yIC8gdG90YWw7XFxuJyArXG4gICAgICAnfScsXG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbiAgICAvKipcbiAgICAgKiBibHVyIHZhbHVlLCBpbiBwZXJjZW50YWdlIG9mIGltYWdlIGRpbWVuc2lvbnMuXG4gICAgICogc3BlY2lmaWMgdG8ga2VlcCB0aGUgaW1hZ2UgYmx1ciBjb25zdGFudCBhdCBkaWZmZXJlbnQgcmVzb2x1dGlvbnNcbiAgICAgKiByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG4gICAgYmx1cjogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdibHVyJyxcblxuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICAgIC8vIHRoaXMgYXNwZWN0UmF0aW8gaXMgdXNlZCB0byBnaXZlIHRoZSBzYW1lIGJsdXIgdG8gdmVydGljYWwgYW5kIGhvcml6b250YWxcbiAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IG9wdGlvbnMuc291cmNlV2lkdGggLyBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgb3B0aW9ucy5wYXNzZXMrKztcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgLy8gcGFpbnQgY2FudmFzRWwgd2l0aCBjdXJyZW50IGltYWdlIGRhdGEuXG4gICAgICAvL29wdGlvbnMuY3R4LnB1dEltYWdlRGF0YShvcHRpb25zLmltYWdlRGF0YSwgMCwgMCk7XG4gICAgICBvcHRpb25zLmltYWdlRGF0YSA9IHRoaXMuc2ltcGxlQmx1cihvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgc2ltcGxlQmx1cjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHJlc291cmNlcyA9IG9wdGlvbnMuZmlsdGVyQmFja2VuZC5yZXNvdXJjZXMsIGNhbnZhczEsIGNhbnZhczIsXG4gICAgICAgICAgd2lkdGggPSBvcHRpb25zLmltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmltYWdlRGF0YS5oZWlnaHQ7XG5cbiAgICAgIGlmICghcmVzb3VyY2VzLmJsdXJMYXllcjEpIHtcbiAgICAgICAgcmVzb3VyY2VzLmJsdXJMYXllcjEgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIHJlc291cmNlcy5ibHVyTGF5ZXIyID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuICAgICAgY2FudmFzMSA9IHJlc291cmNlcy5ibHVyTGF5ZXIxO1xuICAgICAgY2FudmFzMiA9IHJlc291cmNlcy5ibHVyTGF5ZXIyO1xuICAgICAgaWYgKGNhbnZhczEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhczEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzMi53aWR0aCA9IGNhbnZhczEud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzMi5oZWlnaHQgPSBjYW52YXMxLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIHZhciBjdHgxID0gY2FudmFzMS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGN0eDIgPSBjYW52YXMyLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgblNhbXBsZXMgPSAxNSxcbiAgICAgICAgICByYW5kb20sIHBlcmNlbnQsIGosIGksXG4gICAgICAgICAgYmx1ciA9IHRoaXMuYmx1ciAqIDAuMDYgKiAwLjU7XG5cbiAgICAgIC8vIGxvYWQgZmlyc3QgY2FudmFzXG4gICAgICBjdHgxLnB1dEltYWdlRGF0YShvcHRpb25zLmltYWdlRGF0YSwgMCwgMCk7XG4gICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgZm9yIChpID0gLW5TYW1wbGVzOyBpIDw9IG5TYW1wbGVzOyBpKyspIHtcbiAgICAgICAgcmFuZG9tID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNDtcbiAgICAgICAgcGVyY2VudCA9IGkgLyBuU2FtcGxlcztcbiAgICAgICAgaiA9IGJsdXIgKiBwZXJjZW50ICogd2lkdGggKyByYW5kb207XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxIC0gTWF0aC5hYnMocGVyY2VudCk7XG4gICAgICAgIGN0eDIuZHJhd0ltYWdlKGNhbnZhczEsIGosIHJhbmRvbSk7XG4gICAgICAgIGN0eDEuZHJhd0ltYWdlKGNhbnZhczIsIDAsIDApO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgY2FudmFzMi53aWR0aCwgY2FudmFzMi5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gLW5TYW1wbGVzOyBpIDw9IG5TYW1wbGVzOyBpKyspIHtcbiAgICAgICAgcmFuZG9tID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNDtcbiAgICAgICAgcGVyY2VudCA9IGkgLyBuU2FtcGxlcztcbiAgICAgICAgaiA9IGJsdXIgKiBwZXJjZW50ICogaGVpZ2h0ICsgcmFuZG9tO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMSAtIE1hdGguYWJzKHBlcmNlbnQpO1xuICAgICAgICBjdHgyLmRyYXdJbWFnZShjYW52YXMxLCByYW5kb20sIGopO1xuICAgICAgICBjdHgxLmRyYXdJbWFnZShjYW52YXMyLCAwLCAwKTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczIud2lkdGgsIGNhbnZhczIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuY3R4LmRyYXdJbWFnZShjYW52YXMxLCAwLCAwKTtcbiAgICAgIHZhciBuZXdJbWFnZURhdGEgPSBvcHRpb25zLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzMS53aWR0aCwgY2FudmFzMS5oZWlnaHQpO1xuICAgICAgY3R4MS5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHgxLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICByZXR1cm4gbmV3SW1hZ2VEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVsdGE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndURlbHRhJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgZGVsdGEgPSB0aGlzLmNob29zZVJpZ2h0RGVsdGEoKTtcbiAgICAgIGdsLnVuaWZvcm0yZnYodW5pZm9ybUxvY2F0aW9ucy5kZWx0YSwgZGVsdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjaG9vc2UgcmlnaHQgdmFsdWUgb2YgaW1hZ2UgcGVyY2VudGFnZSB0byBibHVyIHdpdGhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGEgbnVtZXJpYyBhcnJheSB3aXRoIGRlbHRhIHZhbHVlc1xuICAgICAqL1xuICAgIGNob29zZVJpZ2h0RGVsdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsdXJTY2FsZSA9IDEsIGRlbHRhID0gWzAsIDBdLCBibHVyO1xuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAodGhpcy5hc3BlY3RSYXRpbyA+IDEpIHtcbiAgICAgICAgICAvLyBpbWFnZSBpcyB3aWRlLCBpIHdhbnQgdG8gc2hyaW5rIHJhZGl1cyBob3Jpem9udGFsXG4gICAgICAgICAgYmx1clNjYWxlID0gMSAvIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hc3BlY3RSYXRpbyA8IDEpIHtcbiAgICAgICAgICAvLyBpbWFnZSBpcyB0YWxsLCBpIHdhbnQgdG8gc2hyaW5rIHJhZGl1cyB2ZXJ0aWNhbFxuICAgICAgICAgIGJsdXJTY2FsZSA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJsdXIgPSBibHVyU2NhbGUgKiB0aGlzLmJsdXIgKiAwLjEyO1xuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICBkZWx0YVswXSA9IGJsdXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsdGFbMV0gPSBibHVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gZGVmaW5pdGlvbiBvZiBhIEJsdXJGaWx0ZXIgaW50byBhIGNvbmNyZXRlIGluc3RhbmNlLlxuICAgKi9cbiAgZmlsdGVycy5CbHVyLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBHYW1tYSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYSh7XG4gICAqICAgZ2FtbWE6IFsxLCAwLjUsIDIuMV1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5HYW1tYSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dhbW1hJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMyB1R2FtbWE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAndmVjMyBjb3JyZWN0aW9uID0gKDEuMCAvIHVHYW1tYSk7XFxuJyArXG4gICAgICAgICdjb2xvci5yID0gcG93KGNvbG9yLnIsIGNvcnJlY3Rpb24ucik7XFxuJyArXG4gICAgICAgICdjb2xvci5nID0gcG93KGNvbG9yLmcsIGNvcnJlY3Rpb24uZyk7XFxuJyArXG4gICAgICAgICdjb2xvci5iID0gcG93KGNvbG9yLmIsIGNvcnJlY3Rpb24uYik7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3IuYTtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEdhbW1hIGFycmF5IHZhbHVlLCBmcm9tIDAuMDEgdG8gMi4yLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdhbW1hXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBnYW1tYTogWzEsIDEsIDFdLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2dhbW1hJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZ2FtbWEgPSBbMSwgMSwgMV07XG4gICAgICBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEdhbW1hIG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSwgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGdhbW1hID0gdGhpcy5nYW1tYSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgckludiA9IDEgLyBnYW1tYVswXSwgZ0ludiA9IDEgLyBnYW1tYVsxXSxcbiAgICAgICAgICBiSW52ID0gMSAvIGdhbW1hWzJdLCBpO1xuXG4gICAgICBpZiAoIXRoaXMuclZhbHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuclZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5nVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLmJWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gLSBwcmUtY29tcHV0ZSBhIGxvb2stdXAgdGFibGUgZm9yIGVhY2ggY29sb3IgY2hhbm5lbFxuICAgICAgLy8gaW5zdGVhZCBvZiBwZXJmb3JtaW5nIHRoZXNlIHBvdyBjYWxscyBmb3IgZWFjaCBwaXhlbCBpbiB0aGUgaW1hZ2UuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSAyNTY7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnJWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgckludikgKiAyNTU7XG4gICAgICAgIHRoaXMuZ1ZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBnSW52KSAqIDI1NTtcbiAgICAgICAgdGhpcy5iVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIGJJbnYpICogMjU1O1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gdGhpcy5yVmFsc1tkYXRhW2ldXTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSB0aGlzLmdWYWxzW2RhdGFbaSArIDFdXTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSB0aGlzLmJWYWxzW2RhdGFbaSArIDJdXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVHYW1tYTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1R2FtbWEnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0zZnYodW5pZm9ybUxvY2F0aW9ucy51R2FtbWEsIHRoaXMuZ2FtbWEpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWF9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQSBjb250YWluZXIgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gYXBwbHkgYSBzZXF1ZW5jZSBvZiBmaWx0ZXJzIHRvIGFuIGlucHV0IGltYWdlLlxuICAgKi9cbiAgZmlsdGVycy5Db21wb3NlZCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db21wb3NlZC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ0NvbXBvc2VkJyxcblxuICAgIC8qKlxuICAgICAqIEEgbm9uIHNwYXJzZSBhcnJheSBvZiBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICovXG4gICAgc3ViRmlsdGVyczogW10sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGFycmF5IGluc3RlYWQgbXV0YXRpbmcgdGhlIHByb3RvdHlwZSB3aXRoIHB1c2hcbiAgICAgIHRoaXMuc3ViRmlsdGVycyA9IHRoaXMuc3ViRmlsdGVycy5zbGljZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhpcyBjb250YWluZXIncyBmaWx0ZXJzIHRvIHRoZSBpbnB1dCBpbWFnZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgYXBwbGllZC5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zLnBhc3NlcyArPSB0aGlzLnN1YkZpbHRlcnMubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuc3ViRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICBmaWx0ZXIuYXBwbHlUbyhvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhpcyBmaWx0ZXIgaW50byBKU09OLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gQSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmlsdGVyLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIHN1YkZpbHRlcnM6IHRoaXMuc3ViRmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIudG9PYmplY3QoKTsgfSksXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnN1YkZpbHRlcnMuc29tZShmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuICFmaWx0ZXIuaXNOZXV0cmFsU3RhdGUoKTsgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIGRlZmluaXRpb24gb2YgYSBDb21wb3NlZEZpbHRlciBpbnRvIGEgY29uY3JldGUgaW5zdGFuY2UuXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db21wb3NlZC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWx0ZXJzID0gb2JqZWN0LnN1YkZpbHRlcnMgfHwgW10sXG4gICAgICAgIHN1YkZpbHRlcnMgPSBmaWx0ZXJzLm1hcChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzW2ZpbHRlci50eXBlXShmaWx0ZXIpO1xuICAgICAgICB9KSxcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQoeyBzdWJGaWx0ZXJzOiBzdWJGaWx0ZXJzIH0pO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSHVlUm90YXRpb24gZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24oe1xuICAgKiAgIHJvdGF0aW9uOiAtMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuSHVlUm90YXRpb24gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkNvbG9yTWF0cml4LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnSHVlUm90YXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogSHVlUm90YXRpb24gdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiB0aGUgdW5pdCBpcyByYWRpYW5zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG15UGFyYW1ldGVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdyb3RhdGlvbicsXG5cbiAgICBjYWxjdWxhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhZCA9IHRoaXMucm90YXRpb24gKiBNYXRoLlBJLCBjb3MgPSBmYWJyaWMudXRpbC5jb3MocmFkKSwgc2luID0gZmFicmljLnV0aWwuc2luKHJhZCksXG4gICAgICAgICAgYVRoaXJkID0gMSAvIDMsIGFUaGlyZFNxdFNpbiA9IE1hdGguc3FydChhVGhpcmQpICogc2luLCBPbmVNaW51c0NvcyA9IDEgLSBjb3M7XG4gICAgICB0aGlzLm1hdHJpeCA9IFtcbiAgICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXTtcbiAgICAgIHRoaXMubWF0cml4WzBdID0gY29zICsgT25lTWludXNDb3MgLyAzO1xuICAgICAgdGhpcy5tYXRyaXhbMV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyAtIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzJdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFs1XSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbNl0gPSBjb3MgKyBhVGhpcmQgKiBPbmVNaW51c0NvcztcbiAgICAgIHRoaXMubWF0cml4WzddID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMF0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyAtIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzExXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTJdID0gY29zICsgYVRoaXJkICogT25lTWludXNDb3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEh1ZVJvdGF0aW9uIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVXNlZCBvbmx5IGluIGltYWdlIGFwcGx5RmlsdGVycyB0byBkaXNjYXJkIGZpbHRlcnMgdGhhdCB3aWxsIG5vdCBoYXZlIGFuIGVmZmVjdFxuICAgICAqIG9uIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgcmV0dXJuIGZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuaXNOZXV0cmFsU3RhdGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdG8gdGhlIGlucHV0IGltYWdlIGRhdGEgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIGZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuYXBwbHlUby5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIGlmIChmYWJyaWMuVGV4dCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuVGV4dCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYWRkaXRpb25hbFByb3BzID1cbiAgICAoJ2ZvbnRGYW1pbHkgZm9udFdlaWdodCBmb250U2l6ZSB0ZXh0IHVuZGVybGluZSBvdmVybGluZSBsaW5ldGhyb3VnaCcgK1xuICAgICcgdGV4dEFsaWduIGZvbnRTdHlsZSBsaW5lSGVpZ2h0IHRleHRCYWNrZ3JvdW5kQ29sb3IgY2hhclNwYWNpbmcgc3R5bGVzIHBhdGgnKS5zcGxpdCgnICcpO1xuXG4gIC8qKlxuICAgKiBUZXh0IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI3RleHR9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczogW1xuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgJ3N0eWxlcycsXG4gICAgICAncGF0aCdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVOZXdsaW5lOiAvXFxyP1xcbi8sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGZvciB3aGl0ZXNwYWNlcyB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlc0FuZFRhYnM6IC9bIFxcdFxccl0vZyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgZm9yIHdoaXRlc3BhY2UgdGhhdCBpcyBub3QgYSBuZXcgbGluZS5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZUFuZFRhYjogL1sgXFx0XFxyXS8sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGNvbnNlY3V0aXZlIGdyb3VwcyBvZiBub24gc3BhY2VzLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVdvcmRzOiAvXFxTKy9nLFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICAgICAgICAgICAgICAgICAndGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHNpemUgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTaXplOiAgICAgICAgICAgICA0MCxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgd2VpZ2h0IChlLmcuIGJvbGQsIG5vcm1hbCwgNDAwLCA2MDAsIDgwMClcbiAgICAgKiBAdHlwZSB7KE51bWJlcnxTdHJpbmcpfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFdlaWdodDogICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBmYW1pbHlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRGYW1pbHk6ICAgICAgICAgICAnVGltZXMgTmV3IFJvbWFuJyxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiB1bmRlcmxpbmUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdW5kZXJsaW5lOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiBvdmVybGluZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gbGluZXRocm91Z2guXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGluZXRocm91Z2g6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiwgXCJqdXN0aWZ5XCIsXG4gICAgICogXCJqdXN0aWZ5LWxlZnRcIiwgXCJqdXN0aWZ5LWNlbnRlclwiIG9yIFwianVzdGlmeS1yaWdodFwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGV4dEFsaWduOiAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgLiBQb3NzaWJsZSB2YWx1ZXM6IFwiXCIsIFwibm9ybWFsXCIsIFwiaXRhbGljXCIgb3IgXCJvYmxpcXVlXCIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250U3R5bGU6ICAgICAgICAgICAgJ25vcm1hbCcsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGluZUhlaWdodDogICAgICAgICAgIDEuMTYsXG5cbiAgICAvKipcbiAgICAgKiBTdXBlcnNjcmlwdCBzY2hlbWEgb2JqZWN0IChtaW5pbXVtIG92ZXJsYXApXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1cGVyc2NyaXB0OiB7XG4gICAgICBzaXplOiAgICAgIDAuNjAsIC8vIGZvbnRTaXplIGZhY3RvclxuICAgICAgYmFzZWxpbmU6IC0wLjM1ICAvLyBiYXNlbGluZS1zaGlmdCBmYWN0b3IgKHVwd2FyZHMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmlwdCBzY2hlbWEgb2JqZWN0IChtaW5pbXVtIG92ZXJsYXApXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1YnNjcmlwdDoge1xuICAgICAgc2l6ZTogICAgICAwLjYwLCAvLyBmb250U2l6ZSBmYWN0b3JcbiAgICAgIGJhc2VsaW5lOiAgMC4xMSAgLy8gYmFzZWxpbmUtc2hpZnQgZmFjdG9yIChkb3dud2FyZHMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgdGV4dCBsaW5lc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGV4dEJhY2tncm91bmRDb2xvcjogICcnLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWZcbiAgICAgKiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoYWRkaXRpb25hbFByb3BzKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIGNhY2hlIG5lZWRzIHJlZnJlc2hcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdChhZGRpdGlvbmFsUHJvcHMpLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIG5hbWVkIFwic3Ryb2tlU3R5bGVcIiB1bnRpbCB2MS4xLjZcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZTogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGUuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJ0ZXh0U2hhZG93XCIgKFN0cmluZykgdW50aWwgdjEuMi4xMVxuICAgICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNoYWRvdzogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9udFNpemVGcmFjdGlvbjogMC4yMjIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9mZnNldHM6IHtcbiAgICAgIHVuZGVybGluZTogMC4xMCxcbiAgICAgIGxpbmV0aHJvdWdoOiAtMC4zMTUsXG4gICAgICBvdmVybGluZTogLTAuODhcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBMaW5lIHByb3BvcnRpb24gdG8gZm9udCBTaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfZm9udFNpemVNdWx0OiAgICAgICAgICAgICAxLjEzLFxuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlcnNcbiAgICAgKiBleHByZXNzZWQgaW4gdGhvdXNhbmRzIG9mIGVtIHVuaXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNoYXJTcGFjaW5nOiAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGNvbnRhaW5pbmcgY2hhcmFjdGVyIHN0eWxlcyAtIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIC0+IGxpbmUgbnVtYmVycyxcbiAgICAgKiAybmQtbGV2ZWwgcHJvcGVydGllcyAtIGNoYXJhY3RlciBudW1iZXJzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHlsZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gYSBjb250ZXh0IHRvIG1lYXN1cmUgdGV4dCBjaGFyIG9yIGNvdXBsZSBvZiBjaGFyc1xuICAgICAqIHRoZSBjYWNoZUNvbnRleHQgb2YgdGhlIGNhbnZhcyB3aWxsIGJlIHVzZWQgb3IgYSBmcmVzaGx5IGNyZWF0ZWQgb25lIGlmIHRoZSBvYmplY3QgaXMgbm90IG9uIGNhbnZhc1xuICAgICAqIG9uY2UgY3JlYXRlZCBpdCB3aWxsIGJlIHJlZmVyZW5jZWQgb24gZmFicmljLl9tZWFzdXJpbmdDb250ZXh0IHRvIGF2b2lkIGNyZWF0aW5nIGEgY2FudmFzIGZvciBldmVyeVxuICAgICAqIHRleHQgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9tZWFzdXJpbmdDb250ZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQmFzZWxpbmUgc2hpZnQsIHN0eWxlcyBvbmx5LCBrZWVwIGF0IDAgZm9yIHRoZSBtYWluIHRleHQgb2JqZWN0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlbHRhWTogMCxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgYSBzdHlsZSB1bml0IChvZiAnc3R5bGVzJykuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX3N0eWxlUHJvcGVydGllczogW1xuICAgICAgJ3N0cm9rZScsXG4gICAgICAnc3Ryb2tlV2lkdGgnLFxuICAgICAgJ2ZpbGwnLFxuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ3VuZGVybGluZScsXG4gICAgICAnb3ZlcmxpbmUnLFxuICAgICAgJ2xpbmV0aHJvdWdoJyxcbiAgICAgICdkZWx0YVknLFxuICAgICAgJ3RleHRCYWNrZ3JvdW5kQ29sb3InLFxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBjb250YWlucyBjaGFyYWN0ZXJzIGJvdW5kaW5nIGJveGVzXG4gICAgICovXG4gICAgX19jaGFyQm91bmRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIHVzZSB0aGlzIHNpemUgd2hlbiBtZWFzdXJpbmcgdGV4dC4gVG8gYXZvaWQgSUUxMSByb3VuZGluZyBlcnJvcnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDQUNIRV9GT05UX1NJWkU6IDQwMCxcblxuICAgIC8qKlxuICAgICAqIGNvbnRhaW5zIHRoZSBtaW4gdGV4dCB3aWR0aCB0byBhdm9pZCBnZXR0aW5nIDBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgTUlOX1RFWFRfV0lEVEg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5zdHlsZXMgPSBvcHRpb25zID8gKG9wdGlvbnMuc3R5bGVzIHx8IHsgfSkgOiB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRQYXRoSW5mbygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnNldHVwU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRleHQgaGFzIGEgcGF0aCwgaXQgd2lsbCBhZGQgdGhlIGV4dHJhIGluZm9ybWF0aW9uIG5lZWRlZFxuICAgICAqIGZvciBwYXRoIGFuZCB0ZXh0IGNhbGN1bGF0aW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0UGF0aEluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBwYXRoLnNlZ21lbnRzSW5mbyA9IGZhYnJpYy51dGlsLmdldFBhdGhTZWdtZW50c0luZm8ocGF0aC5wYXRoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29udGV4dCBmb3IgbWVhc3VyZW1lbnQgb2YgdGV4dCBzdHJpbmcuXG4gICAgICogaWYgY3JlYXRlZCBpdCBnZXRzIHN0b3JlZCBmb3IgcmV1c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGdldE1lYXN1cmluZ0NvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgd2UgZGlkIG5vdCByZXR1cm4gd2UgaGF2ZSB0byBtZWFzdXJlIHNvbWV0aGluZy5cbiAgICAgIGlmICghZmFicmljLl9tZWFzdXJpbmdDb250ZXh0KSB7XG4gICAgICAgIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRDYWNoZSB8fFxuICAgICAgICAgIGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXZpZGVzIHRleHQgaW50byBsaW5lcyBvZiB0ZXh0IGFuZCBsaW5lcyBvZiBncmFwaGVtZXMuXG4gICAgICovXG4gICAgX3NwbGl0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3TGluZXMgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy50ZXh0KTtcbiAgICAgIHRoaXMudGV4dExpbmVzID0gbmV3TGluZXMubGluZXM7XG4gICAgICB0aGlzLl90ZXh0TGluZXMgPSBuZXdMaW5lcy5ncmFwaGVtZUxpbmVzO1xuICAgICAgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzID0gbmV3TGluZXMuX3Vud3JhcHBlZExpbmVzO1xuICAgICAgdGhpcy5fdGV4dCA9IG5ld0xpbmVzLmdyYXBoZW1lVGV4dDtcbiAgICAgIHJldHVybiBuZXdMaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvciB1cGRhdGUgdGV4dCBkaW1lbnNpb25zLlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3BsaXRUZXh0KCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnBhdGgud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5wYXRoLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5jYWxjVGV4dFdpZHRoKCkgfHwgdGhpcy5jdXJzb3JXaWR0aCB8fCB0aGlzLk1JTl9URVhUX1dJRFRIO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xKSB7XG4gICAgICAgIC8vIG9uY2UgdGV4dCBpcyBtZWFzdXJlZCB3ZSBuZWVkIHRvIG1ha2Ugc3BhY2UgZmF0dGVyIHRvIG1ha2UganVzdGlmaWVkIHRleHQuXG4gICAgICAgIHRoaXMuZW5sYXJnZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVubGFyZ2Ugc3BhY2UgYm94ZXMgYW5kIHNoaWZ0IHRoZSBvdGhlcnNcbiAgICAgKi9cbiAgICBlbmxhcmdlU3BhY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaWZmU3BhY2UsIGN1cnJlbnRMaW5lV2lkdGgsIG51bWJlck9mU3BhY2VzLCBhY2N1bXVsYXRlZFNwYWNlLCBsaW5lLCBjaGFyQm91bmQsIHNwYWNlcztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dEFsaWduICE9PSAnanVzdGlmeScgJiYgKGkgPT09IGxlbiAtIDEgfHwgdGhpcy5pc0VuZE9mV3JhcHBpbmcoaSkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSA9IDA7XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPCB0aGlzLndpZHRoICYmIChzcGFjZXMgPSB0aGlzLnRleHRMaW5lc1tpXS5tYXRjaCh0aGlzLl9yZVNwYWNlc0FuZFRhYnMpKSkge1xuICAgICAgICAgIG51bWJlck9mU3BhY2VzID0gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgICBkaWZmU3BhY2UgPSAodGhpcy53aWR0aCAtIGN1cnJlbnRMaW5lV2lkdGgpIC8gbnVtYmVyT2ZTcGFjZXM7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8PSBqbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNoYXJCb3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2pdKSkge1xuICAgICAgICAgICAgICBjaGFyQm91bmQud2lkdGggKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgICBjaGFyQm91bmQua2VybmVkV2lkdGggKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgICBjaGFyQm91bmQubGVmdCArPSBhY2N1bXVsYXRlZFNwYWNlO1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlZFNwYWNlICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjaGFyQm91bmQubGVmdCArPSBhY2N1bXVsYXRlZFNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIHRleHQgbGluZSBpcyBlbmRlZCB3aXRoIGFuIGhhcmQgYnJlYWtcbiAgICAgKiB0ZXh0IGFuZCBpdGV4dCBkbyBub3QgaGF2ZSB3cmFwcGluZywgcmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VuZE9mV3JhcHBpbmc6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgcmV0dXJuIGxpbmVJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBhIGxpbmUgaGFzIGEgbGluZWJyZWFrIGFuZCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGl0IHdoZW4gbW92aW5nXG4gICAgICogYW5kIGNvdW50aW5nIHN0eWxlLlxuICAgICAqIEl0IHJldHVybiBhbHdheXMgZm9yIHRleHQgYW5kIEl0ZXh0LlxuICAgICAqIEByZXR1cm4gTnVtYmVyXG4gICAgICovXG4gICAgbWlzc2luZ05ld2xpbmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLlRleHQgKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IFwidGV4dFwiOiBcIicgKyB0aGlzLnRleHQgKyAnXCIsIFwiZm9udEZhbWlseVwiOiBcIicgKyB0aGlzLmZvbnRGYW1pbHkgKyAnXCIgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpbWVuc2lvbiBhbmQgdGhlIHpvb20gbGV2ZWwgbmVlZGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGNhbnZhc1xuICAgICAqIGJpZyBlbm91Z2ggdG8gaG9zdCB0aGUgb2JqZWN0IHRvIGJlIGNhY2hlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueCB3aWR0aCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbS55IGhlaWdodCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW1zID0gdGhpcy5jYWxsU3VwZXIoJ19nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMnKTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemU7XG4gICAgICBkaW1zLndpZHRoICs9IGZvbnRTaXplICogZGltcy56b29tWDtcbiAgICAgIGRpbXMuaGVpZ2h0ICs9IGZvbnRTaXplICogZGltcy56b29tWTtcbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ3VuZGVybGluZScpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24oY3R4LCAnb3ZlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ2xpbmV0aHJvdWdoJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgPT09ICdzdHJva2UnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0RmlsbChjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZm9udCBwYXJhbWV0ZXIgb2YgdGhlIGNvbnRleHQgd2l0aCB0aGUgb2JqZWN0IHByb3BlcnRpZXMgb3Igd2l0aCBjaGFyU3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NoYXJTdHlsZV0gb2JqZWN0IHdpdGggZm9udCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udEZhbWlseV0gRm9udCBGYW1pbHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NoYXJTdHlsZS5mb250U2l6ZV0gRm9udCBzaXplIGluIHBpeGVscy4gKCB3aXRob3V0IHB4IHN1ZmZpeCApXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFdlaWdodF0gRm9udCB3ZWlnaHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJTdHlsZS5mb250U3R5bGVdIEZvbnQgc3R5bGUgKGl0YWxpY3xub3JtYWwpXG4gICAgICovXG4gICAgX3NldFRleHRTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgY2hhclN0eWxlLCBmb3JNZWFzdXJpbmcpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihjaGFyU3R5bGUsIGZvck1lYXN1cmluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSB0ZXh0IFdpZHRoIG1lYXN1cmluZyBlYWNoIGxpbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBNYXhpbXVtIHdpZHRoIG9mIGZhYnJpYy5UZXh0IG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIG1heFdpZHRoID0gY3VycmVudExpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgVGV4dCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmUgaW4gYSB0ZXh0XG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHRleHQgYmFja2dyb3VuZCBmb3IgbGluZXMsIHRha2luZyBjYXJlIG9mIHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGVpZ2h0T2ZMaW5lLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBvcmlnaW5hbEZpbGwgPSBjdHguZmlsbFN0eWxlLFxuICAgICAgICAgIGxpbmUsIGxhc3RDb2xvcixcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBib3hTdGFydCA9IDAsIGJveFdpZHRoID0gMCwgY2hhckJveCwgY3VycmVudENvbG9yLCBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvciAmJiAhdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgICBjdXJyZW50Q29sb3IgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAtY2hhckJveC53aWR0aCAvIDIsXG4gICAgICAgICAgICAgIC1oZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pLFxuICAgICAgICAgICAgICBjaGFyQm94LndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RDb2xvcjtcbiAgICAgICAgICAgIGxhc3RDb2xvciAmJiBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgICBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgICBsYXN0Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvciAmJiAhcGF0aCkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9yaWdpbmFsRmlsbDtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjbCBzdHlsZSBkZWNsYXJhdGlvbiBmb3IgY2FjaGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250RmFtaWx5IGZvbnRGYW1pbHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250U3R5bGUgZm9udFN0eWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udFdlaWdodCBmb250V2VpZ2h0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZWZlcmVuY2UgdG8gY2FjaGVcbiAgICAgKi9cbiAgICBnZXRGb250Q2FjaGU6IGZ1bmN0aW9uKGRlY2wpIHtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZGVjbC5mb250RmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZSA9IGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0sXG4gICAgICAgICAgY2FjaGVQcm9wID0gZGVjbC5mb250U3R5bGUudG9Mb3dlckNhc2UoKSArICdfJyArIChkZWNsLmZvbnRXZWlnaHQgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghY2FjaGVbY2FjaGVQcm9wXSkge1xuICAgICAgICBjYWNoZVtjYWNoZVByb3BdID0geyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlUHJvcF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgYW5kIHJldHVybiB0aGUgd2lkdGggb2YgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICAgICAqIHBvc3NpYmx5IG92ZXJyaWRkZW4gdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IG1lYXN1cmUgbG9naWMgb3JcbiAgICAgKiB0byBob29rIHNvbWUgZXh0ZXJuYWwgbGliIGZvciBjaGFyYWN0ZXIgbWVhc3VyZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhciwgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFyU3R5bGUgc3R5bGUgb2YgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldmlvdXNDaGFyXSBwcmV2aW91cyBjaGFyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcmV2Q2hhclN0eWxlXSBzdHlsZSBvZiBwcmV2aW91cyBjaGFyXG4gICAgICovXG4gICAgX21lYXN1cmVDaGFyOiBmdW5jdGlvbihfY2hhciwgY2hhclN0eWxlLCBwcmV2aW91c0NoYXIsIHByZXZDaGFyU3R5bGUpIHtcbiAgICAgIC8vIGZpcnN0IGkgdHJ5IHRvIHJldHVybiBmcm9tIGNhY2hlXG4gICAgICB2YXIgZm9udENhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY2hhclN0eWxlKSwgZm9udERlY2xhcmF0aW9uID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGNoYXJTdHlsZSksXG4gICAgICAgICAgcHJldmlvdXNGb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24ocHJldkNoYXJTdHlsZSksIGNvdXBsZSA9IHByZXZpb3VzQ2hhciArIF9jaGFyLFxuICAgICAgICAgIHN0eWxlc0FyZUVxdWFsID0gZm9udERlY2xhcmF0aW9uID09PSBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiwgd2lkdGgsIGNvdXBsZVdpZHRoLCBwcmV2aW91c1dpZHRoLFxuICAgICAgICAgIGZvbnRNdWx0aXBsaWVyID0gY2hhclN0eWxlLmZvbnRTaXplIC8gdGhpcy5DQUNIRV9GT05UX1NJWkUsIGtlcm5lZFdpZHRoO1xuXG4gICAgICBpZiAocHJldmlvdXNDaGFyICYmIGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRDYWNoZVtfY2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gZm9udENhY2hlW19jaGFyXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXNBcmVFcXVhbCAmJiBmb250Q2FjaGVbY291cGxlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvdXBsZVdpZHRoID0gZm9udENhY2hlW2NvdXBsZV07XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgcHJldmlvdXNXaWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0TWVhc3VyaW5nQ29udGV4dCgpO1xuICAgICAgICAvLyBzZW5kIGEgVFJVRSB0byBzcGVjaWZ5IG1lYXN1cmluZyBmb250IHNpemUgQ0FDSEVfRk9OVF9TSVpFXG4gICAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4LCBjaGFyU3R5bGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVkV2lkdGggPSB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChfY2hhcikud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtfY2hhcl0gPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgJiYgc3R5bGVzQXJlRXF1YWwgJiYgcHJldmlvdXNDaGFyKSB7XG4gICAgICAgIHByZXZpb3VzV2lkdGggPSBjdHgubWVhc3VyZVRleHQocHJldmlvdXNDaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gPSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gd2UgY2FuIG1lYXN1cmUgdGhlIGtlcm5pbmcgY291cGxlIGFuZCBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHByZXZpb3VzIGNoYXJhY3RlclxuICAgICAgICBjb3VwbGVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjb3VwbGUpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbY291cGxlXSA9IGNvdXBsZVdpZHRoO1xuICAgICAgICBrZXJuZWRXaWR0aCA9IGNvdXBsZVdpZHRoIC0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCAqIGZvbnRNdWx0aXBsaWVyLCBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGggKiBmb250TXVsdGlwbGllciB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoZWlnaHQgb2YgY2hhcmFjdGVyIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmUgdGhlIGxpbmUgaW5kZXggbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IF9jaGFyIHRoZSBjaGFyYWN0ZXIgaW5kZXggbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBmb250U2l6ZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0T2ZDaGFyOiBmdW5jdGlvbihsaW5lLCBfY2hhcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZSwgX2NoYXIsICdmb250U2l6ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGEgdGV4dCBsaW5lIG1lYXN1cmluZyBhbGwgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVJbmZvID0gdGhpcy5fbWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVJbmZvLndpZHRoIDwgMCkge1xuICAgICAgICBsaW5lSW5mby53aWR0aCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZUluZm87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgZXZlcnkgZ3JhcGhlbWUgb2YgYSBsaW5lLCBwb3B1bGF0aW5nIF9fY2hhckJvdW5kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCB0b3RhbCB3aWR0aCBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGhPZlNwYWNlcyBsZW5ndGggb2YgY2hhcnMgdGhhdCBtYXRjaCB0aGlzLl9yZVNwYWNlc0FuZFRhYnNcbiAgICAgKi9cbiAgICBfbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIHdpZHRoID0gMCwgaSwgZ3JhcGhlbWUsIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSwgcHJldkdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lSW5mbywgbnVtT2ZTcGFjZXMgPSAwLCBsaW5lQm91bmRzID0gbmV3IEFycmF5KGxpbmUubGVuZ3RoKSxcbiAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9IDAsIHN0YXJ0aW5nUG9pbnQsIHRvdGFsUGF0aExlbmd0aCwgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XSA9IGxpbmVCb3VuZHM7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBzdGFydGluZ1BvaW50ID0gZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGgocGF0aC5wYXRoLCAwLCBwYXRoLnNlZ21lbnRzSW5mbyk7XG4gICAgICAgIHRvdGFsUGF0aExlbmd0aCA9IHBhdGguc2VnbWVudHNJbmZvW3BhdGguc2VnbWVudHNJbmZvLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgICAgc3RhcnRpbmdQb2ludC54ICs9IHBhdGgucGF0aE9mZnNldC54O1xuICAgICAgICBzdGFydGluZ1BvaW50LnkgKz0gcGF0aC5wYXRoT2Zmc2V0Lnk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZSA9IGxpbmVbaV07XG4gICAgICAgIGdyYXBoZW1lSW5mbyA9IHRoaXMuX2dldEdyYXBoZW1lQm94KGdyYXBoZW1lLCBsaW5lSW5kZXgsIGksIHByZXZHcmFwaGVtZSk7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgaWYgKHBvc2l0aW9uSW5QYXRoID4gdG90YWxQYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCAlPSB0b3RhbFBhdGhMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGl0IHdvdWxkIHByb2JhYmx5IG11Y2ggZmF0ZXIgdG8gc2VuZCBhbGwgdGhlIGdyYXBoZW1lIHBvc2l0aW9uIGZvciBhIGxpbmVcbiAgICAgICAgICAvLyBhbmQgY2FsY3VsYXRlIHBhdGggcG9zaXRpb24vYW5nbGUgYXQgb25jZS5cbiAgICAgICAgICB0aGlzLl9zZXRHcmFwaGVtZU9uUGF0aChwb3NpdGlvbkluUGF0aCwgZ3JhcGhlbWVJbmZvLCBzdGFydGluZ1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lQm91bmRzW2ldID0gZ3JhcGhlbWVJbmZvO1xuICAgICAgICB3aWR0aCArPSBncmFwaGVtZUluZm8ua2VybmVkV2lkdGg7XG4gICAgICAgIHBvc2l0aW9uSW5QYXRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gZ3JhcGhlbWU7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxhdGVzdCBib3VuZCBib3ggcmVwcmVzZW50IHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgbGluZVxuICAgICAgLy8gdG8gc2ltcGxpZnkgY3Vyc29yIGhhbmRsaW5nIGluIGludGVyYWN0aXZlIG1vZGUuXG4gICAgICBsaW5lQm91bmRzW2ldID0ge1xuICAgICAgICBsZWZ0OiBncmFwaGVtZUluZm8gPyBncmFwaGVtZUluZm8ubGVmdCArIGdyYXBoZW1lSW5mby53aWR0aCA6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBrZXJuZWRXaWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmZvbnRTaXplXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBudW1PZlNwYWNlczogbnVtT2ZTcGFjZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBhbmdsZSAgYW5kIHRoZSBsZWZ0LHRvcCBwb3NpdGlvbiBvZiB0aGUgY2hhciB0aGF0IGZvbGxvdyBhIHBhdGguXG4gICAgICogSXQgYXBwZW5kcyBpdCB0byBncmFwaGVtZUluZm8gdG8gYmUgcmV1c2VkIGxhdGVyIGF0IHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uSW5QYXRoIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoZW1lSW5mbyBjdXJyZW50IGdyYXBoZW1lIGJveCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFydGluZ1BvaW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9zZXRHcmFwaGVtZU9uUGF0aDogZnVuY3Rpb24ocG9zaXRpb25JblBhdGgsIGdyYXBoZW1lSW5mbywgc3RhcnRpbmdQb2ludCkge1xuICAgICAgdmFyIGNlbnRlclBvc2l0aW9uID0gcG9zaXRpb25JblBhdGggKyBncmFwaGVtZUluZm8ua2VybmVkV2lkdGggLyAyLFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIC8vIHdlIGFyZSBhdCBjdXJyZW50UG9zaXRpb25PblBhdGguIHdlIHdhbnQgdG8ga25vdyB3aGF0IHBvaW50IG9uIHRoZSBwYXRoIGlzLlxuICAgICAgdmFyIGluZm8gPSBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aChwYXRoLnBhdGgsIGNlbnRlclBvc2l0aW9uLCBwYXRoLnNlZ21lbnRzSW5mbyk7XG4gICAgICBncmFwaGVtZUluZm8ucmVuZGVyTGVmdCA9IGluZm8ueCAtIHN0YXJ0aW5nUG9pbnQueDtcbiAgICAgIGdyYXBoZW1lSW5mby5yZW5kZXJUb3AgPSBpbmZvLnkgLSBzdGFydGluZ1BvaW50Lnk7XG4gICAgICBncmFwaGVtZUluZm8uYW5nbGUgPSBpbmZvLmFuZ2xlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIGFuZCByZXR1cm4gdGhlIGluZm8gb2YgYSBzaW5nbGUgZ3JhcGhlbWUuXG4gICAgICogbmVlZHMgdGhlIHRoZSBpbmZvIG9mIHByZXZpb3VzIGdyYXBoZW1lcyBhbHJlYWR5IGZpbGxlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyYXBoZW1lIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gaW4gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZXZHcmFwaGVtZV0gY2hhcmFjdGVyIHByZWNlZGluZyB0aGUgb25lIHRvIGJlIG1lYXN1cmVkXG4gICAgICovXG4gICAgX2dldEdyYXBoZW1lQm94OiBmdW5jdGlvbihncmFwaGVtZSwgbGluZUluZGV4LCBjaGFySW5kZXgsIHByZXZHcmFwaGVtZSwgc2tpcExlZnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBwcmV2U3R5bGUgPSBwcmV2R3JhcGhlbWUgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCAtIDEpIDogeyB9LFxuICAgICAgICAgIGluZm8gPSB0aGlzLl9tZWFzdXJlQ2hhcihncmFwaGVtZSwgc3R5bGUsIHByZXZHcmFwaGVtZSwgcHJldlN0eWxlKSxcbiAgICAgICAgICBrZXJuZWRXaWR0aCA9IGluZm8ua2VybmVkV2lkdGgsXG4gICAgICAgICAgd2lkdGggPSBpbmZvLndpZHRoLCBjaGFyU3BhY2luZztcblxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgd2lkdGggKz0gY2hhclNwYWNpbmc7XG4gICAgICAgIGtlcm5lZFdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm94ID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGhlaWdodDogc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGtlcm5lZFdpZHRoOiBrZXJuZWRXaWR0aCxcbiAgICAgICAgZGVsdGFZOiBzdHlsZS5kZWx0YVksXG4gICAgICB9O1xuICAgICAgaWYgKGNoYXJJbmRleCA+IDAgJiYgIXNraXBMZWZ0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c0JveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICAgIGJveC5sZWZ0ID0gcHJldmlvdXNCb3gubGVmdCArIHByZXZpb3VzQm94LndpZHRoICsgaW5mby5rZXJuZWRXaWR0aCAtIGluZm8ud2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgaGVpZ2h0IG9mIGxpbmUgYXQgJ2xpbmVJbmRleCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IG9mIGxpbmUgdG8gY2FsY3VsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlaWdodE9mTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIC8vIGNoYXIgMCBpcyBtZWFzdXJlZCBiZWZvcmUgdGhlIGxpbmUgY3ljbGUgYmVjYXVzZSBpdCBubmVkcyB0byBjaGFyXG4gICAgICAgICAgLy8gZW1wdHlsaW5lc1xuICAgICAgICAgIG1heEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGxpbmVJbmRleCwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gbGluZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heCh0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIGkpLCBtYXhIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0gPSBtYXhIZWlnaHQgKiB0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0ZXh0IGJveCBoZWlnaHRcbiAgICAgKi9cbiAgICBjYWxjVGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUhlaWdodCwgaGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBoZWlnaHQgKz0gKGkgPT09IGxlbiAtIDEgPyBsaW5lSGVpZ2h0IC8gdGhpcy5saW5lSGVpZ2h0IDogbGluZUhlaWdodCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGVmdE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXRoaXMud2lkdGggLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVG9wIG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRUb3BPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLmhlaWdodCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dENvbW1vbjogZnVuY3Rpb24oY3R4LCBtZXRob2QpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgbGluZUhlaWdodHMgPSAwLCBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLCB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpLFxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZShcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBsZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICB0b3AgKyBsaW5lSGVpZ2h0cyArIG1heEhlaWdodCxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVIZWlnaHRzICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0RmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCAmJiAhdGhpcy5zdHlsZUhhcygnZmlsbCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyVGV4dENvbW1vbihjdHgsICdmaWxsVGV4dCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSAmJiB0aGlzLmlzRW1wdHlTdHlsZXMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ3N0cm9rZVRleHQnKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBmaWxsVGV4dCBvciBzdHJva2VUZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lIENvbnRlbnQgb2YgdGhlIGxpbmUsIHNwbGl0dGVkIGluIGFuIGFycmF5IGJ5IGdyYXBoZW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyczogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCksXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBhY3R1YWxTdHlsZSxcbiAgICAgICAgICBuZXh0U3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnLFxuICAgICAgICAgIGNoYXJCb3gsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIHRpbWVUb1JlbmRlcixcbiAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIHNob3J0Q3V0ID0gIWlzSnVzdGlmeSAmJiB0aGlzLmNoYXJTcGFjaW5nID09PSAwICYmIHRoaXMuaXNFbXB0eVN0eWxlcyhsaW5lSW5kZXgpICYmICFwYXRoO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdG9wIC09IGxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZUZyYWN0aW9uIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgaWYgKHNob3J0Q3V0KSB7XG4gICAgICAgIC8vIHJlbmRlciBhbGwgdGhlIGxpbmUgaW4gb25lIHBhc3Mgd2l0aG91dCBjaGVja2luZ1xuICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIDAsIGxpbmUuam9pbignJyksIGxlZnQsIHRvcCwgbGluZUhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lLmxlbmd0aCAtIDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdGltZVRvUmVuZGVyID0gaSA9PT0gbGVuIHx8IHRoaXMuY2hhclNwYWNpbmcgfHwgcGF0aDtcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgbGVmdCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRoaXMuX2hhc1N0eWxlQ2hhbmdlZChhY3R1YWxTdHlsZSwgbmV4dFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgaSwgY2hhcnNUb1JlbmRlciwgLWJveFdpZHRoIC8gMiwgMCwgbGluZUhlaWdodCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgaSwgY2hhcnNUb1JlbmRlciwgbGVmdCwgdG9wLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIGFjdHVhbFN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgICAgIGxlZnQgKz0gYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyeSB0byBwYXRjaCB0aGUgbWlzc2luZyBncmFkaWVudFRyYW5zZm9ybSBvbiBjYW52YXMgZ3JhZGllbnRzLlxuICAgICAqIHRyYW5zZm9ybWluZyBhIGNvbnRleHQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCwgaXMgZ29pbmcgdG8gdHJhbnNmb3JtIHRoZSBzdHJva2UgdG9vLlxuICAgICAqIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCBidXQgbm90IHRoZSBzdHJva2Ugb3BlcmF0aW9uLCBzbyB3ZSBjcmVhdGVcbiAgICAgKiBhIHRyYW5zZm9ybWVkIGdyYWRpZW50IG9uIGEgcGF0dGVybiBhbmQgdGhlbiB3ZSB1c2UgdGhlIHBhdHRlcm4gaW5zdGVhZCBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGRyYXdiYWNrczogaXMgc2xvdywgaXMgaW4gbG93IHJlc29sdXRpb24sIG5lZWRzIGEgcGF0Y2ggZm9yIHdoZW4gdGhlIHNpemVcbiAgICAgKiBpcyBsaW1pdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuR3JhZGllbnR9IGZpbGxlciBhIGZhYnJpYyBncmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59IGEgcGF0dGVybiB0byB1c2UgYXMgZmlsbC9zdHJva2Ugc3R5bGVcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0OiBmdW5jdGlvbihmaWxsZXIpIHtcbiAgICAgIHZhciBwQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLCBwQ3R4LFxuICAgICAgICAgIC8vIFRPRE86IHZlcmlmeSBjb21wYXRpYmlsaXR5IHdpdGggc3Ryb2tlVW5pZm9ybVxuICAgICAgICAgIHdpZHRoID0gdGhpcy53aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgIHBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LmZpbGxTdHlsZSA9IGZpbGxlci50b0xpdmUocEN0eCk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShwQ3R4LCBmaWxsZXIpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICByZXR1cm4gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlRmlsbGVyOiBmdW5jdGlvbihjdHgsIHByb3BlcnR5LCBmaWxsZXIpIHtcbiAgICAgIHZhciBvZmZzZXRYLCBvZmZzZXRZO1xuICAgICAgaWYgKGZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgaWYgKGZpbGxlci5ncmFkaWVudFVuaXRzID09PSAncGVyY2VudGFnZScgfHwgZmlsbGVyLmdyYWRpZW50VHJhc25mb3JtIHx8IGZpbGxlci5wYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgICAgLy8gbmVlZCB0byB0cmFuc2Zvcm0gZ3JhZGllbnQgaW4gYSBwYXR0ZXJuLlxuICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG93IHByb2Nlc3MuIElmIHlvdSBhcmUgaGl0dGluZyB0aGlzIGNvZGVwYXRoLCBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgIC8vIGlzIG5vdCB1c2luZyBjYWNoaW5nLCB5b3Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyBpdCBvbi5cbiAgICAgICAgICAvLyB3ZSBuZWVkIGEgY2FudmFzIGFzIGJpZyBhcyB0aGUgY3VycmVudCBvYmplY3QgY2FjaGluZyBjYW52YXMuXG4gICAgICAgICAgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybVRleHQoZmlsbGVyKTtcbiAgICAgICAgICByZXR1cm4geyBvZmZzZXRYOiBvZmZzZXRYLCBvZmZzZXRZOiBvZmZzZXRZIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaXMgYSBzaW1wbGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSBmaWxsZXIudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgZmlsbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGlzIGEgY29sb3JcbiAgICAgICAgY3R4W3Byb3BlcnR5XSA9IGZpbGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gZGVjbC5zdHJva2VXaWR0aDtcbiAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbjtcbiAgICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRmlsbGVyKGN0eCwgJ3N0cm9rZVN0eWxlJywgZGVjbC5zdHJva2UpO1xuICAgIH0sXG5cbiAgICBfc2V0RmlsbFN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVGaWxsZXIoY3R4LCAnZmlsbFN0eWxlJywgZGVjbC5maWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IEhlaWdodCBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIF9jaGFyLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgZnVsbERlY2wgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgc2hvdWxkRmlsbCA9IG1ldGhvZCA9PT0gJ2ZpbGxUZXh0JyAmJiBmdWxsRGVjbC5maWxsLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnICYmIGZ1bGxEZWNsLnN0cm9rZSAmJiBmdWxsRGVjbC5zdHJva2VXaWR0aCxcbiAgICAgICAgICBmaWxsT2Zmc2V0cywgc3Ryb2tlT2Zmc2V0cztcblxuICAgICAgaWYgKCFzaG91bGRTdHJva2UgJiYgIXNob3VsZEZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgc2hvdWxkRmlsbCAmJiAoZmlsbE9mZnNldHMgPSB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgZnVsbERlY2wpKTtcbiAgICAgIHNob3VsZFN0cm9rZSAmJiAoc3Ryb2tlT2Zmc2V0cyA9IHRoaXMuX3NldFN0cm9rZVN0eWxlcyhjdHgsIGZ1bGxEZWNsKSk7XG5cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGZ1bGxEZWNsKTtcblxuXG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLmRlbHRhWSkge1xuICAgICAgICB0b3AgKz0gZGVjbC5kZWx0YVk7XG4gICAgICB9XG4gICAgICBzaG91bGRGaWxsICYmIGN0eC5maWxsVGV4dChfY2hhciwgbGVmdCAtIGZpbGxPZmZzZXRzLm9mZnNldFgsIHRvcCAtIGZpbGxPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgc2hvdWxkU3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KF9jaGFyLCBsZWZ0IC0gc3Ryb2tlT2Zmc2V0cy5vZmZzZXRYLCB0b3AgLSBzdHJva2VPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGEgJ3N1cGVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1cGVyc2NyaXB0JylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFN1cGVyc2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3VwZXJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJucyB0aGUgY2hhcmFjdGVyIGludG8gYW4gJ2luZmVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1YnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdWJzY3JpcHQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRTY3JpcHQoc3RhcnQsIGVuZCwgdGhpcy5zdWJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzICdzY2hlbWEnIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjaGVtYVxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfc2V0U2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBzY2hlbWEpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2RlbHRhWScpLFxuICAgICAgICAgIHN0eWxlID0geyBmb250U2l6ZTogZm9udFNpemUgKiBzY2hlbWEuc2l6ZSwgZGVsdGFZOiBkeSArIGZvbnRTaXplICogc2NoZW1hLmJhc2VsaW5lIH07XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0eWxlcyhzdHlsZSwgc3RhcnQsIGVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNTdHlsZVxuICAgICAqL1xuICAgIF9oYXNTdHlsZUNoYW5nZWQ6IGZ1bmN0aW9uKHByZXZTdHlsZSwgdGhpc1N0eWxlKSB7XG4gICAgICByZXR1cm4gcHJldlN0eWxlLmZpbGwgIT09IHRoaXNTdHlsZS5maWxsIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2UgIT09IHRoaXNTdHlsZS5zdHJva2UgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZVdpZHRoICE9PSB0aGlzU3R5bGUuc3Ryb2tlV2lkdGggfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTaXplICE9PSB0aGlzU3R5bGUuZm9udFNpemUgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRGYW1pbHkgIT09IHRoaXNTdHlsZS5mb250RmFtaWx5IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250V2VpZ2h0ICE9PSB0aGlzU3R5bGUuZm9udFdlaWdodCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFN0eWxlICE9PSB0aGlzU3R5bGUuZm9udFN0eWxlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5kZWx0YVkgIT09IHRoaXNTdHlsZS5kZWx0YVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGVcbiAgICAgKi9cbiAgICBfaGFzU3R5bGVDaGFuZ2VkRm9yU3ZnOiBmdW5jdGlvbihwcmV2U3R5bGUsIHRoaXNTdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1N0eWxlQ2hhbmdlZChwcmV2U3R5bGUsIHRoaXNTdHlsZSkgfHxcbiAgICAgICAgcHJldlN0eWxlLm92ZXJsaW5lICE9PSB0aGlzU3R5bGUub3ZlcmxpbmUgfHxcbiAgICAgICAgcHJldlN0eWxlLnVuZGVybGluZSAhPT0gdGhpc1N0eWxlLnVuZGVybGluZSB8fFxuICAgICAgICBwcmV2U3R5bGUubGluZXRocm91Z2ggIT09IHRoaXNTdHlsZS5saW5ldGhyb3VnaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IHRleHQgbGluZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSBsZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMaW5lTGVmdE9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgobGluZUluZGV4KTtcbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWNlbnRlcicgJiYgdGhpcy5pc0VuZE9mV3JhcHBpbmcobGluZUluZGV4KSkge1xuICAgICAgICByZXR1cm4gKHRoaXMud2lkdGggLSBsaW5lV2lkdGgpIC8gMjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbiA9PT0gJ2p1c3RpZnktcmlnaHQnICYmIHRoaXMuaXNFbmRPZldyYXBwaW5nKGxpbmVJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fbGluZVdpZHRocyA9IFtdO1xuICAgICAgdGhpcy5fX2xpbmVIZWlnaHRzID0gW107XG4gICAgICB0aGlzLl9fY2hhckJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZTtcbiAgICAgIHNob3VsZENsZWFyIHx8IChzaG91bGRDbGVhciA9IHRoaXMuaGFzU3RhdGVDaGFuZ2VkKCdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnKSk7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZENsZWFyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIGEgc2luZ2xlIGxpbmUgZ2l2ZW4gaXRzIGluZGV4LiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbFxuICAgICAqIHRleHQgYm91bmRpbmcgYm94LiBUaGUgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGFuZCBzdG9yZWQgaW4gX19saW5lV2lkdGhzIGNhY2hlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBsaW5lIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSB3aWR0aFxuICAgICAqL1xuICAgIGdldExpbmVXaWR0aDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoLCBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sIGxpbmVJbmZvO1xuXG4gICAgICBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgd2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxpbmVJbmZvID0gdGhpcy5tZWFzdXJlTGluZShsaW5lSW5kZXgpO1xuICAgICAgICB3aWR0aCA9IGxpbmVJbmZvLndpZHRoO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSA9IHdpZHRoO1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICBfZ2V0V2lkdGhPZkNoYXJTcGFjaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRTaXplICogdGhpcy5jaGFyU3BhY2luZyAvIDEwMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBhdCBnaXZlbiBjaGFyYWN0ZXIgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRoZSBsaW5lIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggdGhlIGNoYXJhY3RlciBudW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgJ3Byb3BlcnR5J1xuICAgICAqL1xuICAgIGdldFZhbHVlT2ZQcm9wZXJ0eUF0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBjaGFyU3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICAgIGlmIChjaGFyU3R5bGUgJiYgdHlwZW9mIGNoYXJTdHlsZVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjaGFyU3R5bGVbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKGN0eCwgdHlwZSkge1xuICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsIHNpemUsIF9zaXplLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBkeSwgX2R5LFxuICAgICAgICAgIGxpbmUsIGxhc3REZWNvcmF0aW9uLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksIHRvcCxcbiAgICAgICAgICBib3hTdGFydCwgYm94V2lkdGgsIGNoYXJCb3gsIGN1cnJlbnREZWNvcmF0aW9uLFxuICAgICAgICAgIG1heEhlaWdodCwgY3VycmVudEZpbGwsIGxhc3RGaWxsLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICAgIGlmICghdGhpc1t0eXBlXSAmJiAhdGhpcy5zdHlsZUhhcyh0eXBlLCBpKSkge1xuICAgICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgbGFzdERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsIHR5cGUpO1xuICAgICAgICBsYXN0RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2ZpbGwnKTtcbiAgICAgICAgdG9wID0gdG9wT2Zmc2V0ICsgbWF4SGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIDApO1xuICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2RlbHRhWScpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgIGN1cnJlbnREZWNvcmF0aW9uID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCB0eXBlKTtcbiAgICAgICAgICBjdXJyZW50RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2ZpbGwnKTtcbiAgICAgICAgICBfc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIGopO1xuICAgICAgICAgIF9keSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2RlbHRhWScpO1xuICAgICAgICAgIGlmIChwYXRoICYmIGN1cnJlbnREZWNvcmF0aW9uICYmIGN1cnJlbnRGaWxsKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RGaWxsO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIC1jaGFyQm94Lmtlcm5lZFdpZHRoIC8gMixcbiAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW3R5cGVdICogX3NpemUgKyBfZHksXG4gICAgICAgICAgICAgIGNoYXJCb3gua2VybmVkV2lkdGgsXG4gICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgKGN1cnJlbnREZWNvcmF0aW9uICE9PSBsYXN0RGVjb3JhdGlvbiB8fCBjdXJyZW50RmlsbCAhPT0gbGFzdEZpbGwgfHwgX3NpemUgIT09IHNpemUgfHwgX2R5ICE9PSBkeSlcbiAgICAgICAgICAgICYmIGJveFdpZHRoID4gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbGFzdERlY29yYXRpb24gJiYgbGFzdEZpbGwgJiZcbiAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvcCArIHRoaXMub2Zmc2V0c1t0eXBlXSAqIHNpemUgKyBkeSxcbiAgICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgICAgbGFzdERlY29yYXRpb24gPSBjdXJyZW50RGVjb3JhdGlvbjtcbiAgICAgICAgICAgIGxhc3RGaWxsID0gY3VycmVudEZpbGw7XG4gICAgICAgICAgICBzaXplID0gX3NpemU7XG4gICAgICAgICAgICBkeSA9IF9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudEZpbGw7XG4gICAgICAgIGN1cnJlbnREZWNvcmF0aW9uICYmIGN1cnJlbnRGaWxsICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICB0b3AgKyB0aGlzLm9mZnNldHNbdHlwZV0gKiBzaXplICsgZHksXG4gICAgICAgICAgYm94V2lkdGggLSBjaGFyU3BhY2luZyxcbiAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgKTtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGZvbnQgZGVjbGFyYXRpb24gc3RyaW5nIGZvciBjYW52YXMgY29udGV4dFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPYmplY3RdIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGZvbnQgZGVjbGFyYXRpb24gZm9ybWF0dGVkIGZvciBjYW52YXMgY29udGV4dC5cbiAgICAgKi9cbiAgICBfZ2V0Rm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbihzdHlsZU9iamVjdCwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZU9iamVjdCB8fCB0aGlzLCBmYW1pbHkgPSB0aGlzLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udElzR2VuZXJpYyA9IGZhYnJpYy5UZXh0LmdlbmVyaWNGb250cy5pbmRleE9mKGZhbWlseS50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmYW1pbHkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1xcJycpID4gLTEgfHwgZmFtaWx5LmluZGV4T2YoJywnKSA+IC0xIHx8XG4gICAgICBmYW1pbHkuaW5kZXhPZignXCInKSA+IC0xIHx8IGZvbnRJc0dlbmVyaWNcbiAgICAgICAgPyBzdHlsZS5mb250RmFtaWx5IDogJ1wiJyArIHN0eWxlLmZvbnRGYW1pbHkgKyAnXCInO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbm9kZS1jYW52YXMgbmVlZHMgXCJ3ZWlnaHQgc3R5bGVcIiwgd2hpbGUgYnJvd3NlcnMgbmVlZCBcInN0eWxlIHdlaWdodFwiXG4gICAgICAgIC8vIHZlcmlmeSBpZiB0aGlzIGNhbiBiZSBmaXhlZCBpbiBKU0RPTVxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/IHN0eWxlLmZvbnRXZWlnaHQgOiBzdHlsZS5mb250U3R5bGUpLFxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/IHN0eWxlLmZvbnRTdHlsZSA6IHN0eWxlLmZvbnRXZWlnaHQpLFxuICAgICAgICBmb3JNZWFzdXJpbmcgPyB0aGlzLkNBQ0hFX0ZPTlRfU0laRSArICdweCcgOiBzdHlsZS5mb250U2l6ZSArICdweCcsXG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIF0uam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRleHQgaW5zdGFuY2Ugb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiBvYmplY3QgaXMgbm90IHZpc2libGVcbiAgICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5za2lwT2Zmc2NyZWVuICYmICF0aGlzLmdyb3VwICYmICF0aGlzLmlzT25TY3JlZW4oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGFzIGFuIGFycmF5IG9mIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IExpbmVzIGluIHRoZSB0ZXh0XG4gICAgICovXG4gICAgX3NwbGl0VGV4dEludG9MaW5lczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCh0aGlzLl9yZU5ld2xpbmUpLFxuICAgICAgICAgIG5ld0xpbmVzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCksXG4gICAgICAgICAgbmV3TGluZSA9IFsnXFxuJ10sXG4gICAgICAgICAgbmV3VGV4dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdMaW5lc1tpXSA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KGxpbmVzW2ldKTtcbiAgICAgICAgbmV3VGV4dCA9IG5ld1RleHQuY29uY2F0KG5ld0xpbmVzW2ldLCBuZXdMaW5lKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQucG9wKCk7XG4gICAgICByZXR1cm4geyBfdW53cmFwcGVkTGluZXM6IG5ld0xpbmVzLCBsaW5lczogbGluZXMsIGdyYXBoZW1lVGV4dDogbmV3VGV4dCwgZ3JhcGhlbWVMaW5lczogbmV3TGluZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gW1xuICAgICAgICAndGV4dCcsXG4gICAgICAgICdmb250U2l6ZScsXG4gICAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgICAnZm9udFN0eWxlJyxcbiAgICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgICAndW5kZXJsaW5lJyxcbiAgICAgICAgJ292ZXJsaW5lJyxcbiAgICAgICAgJ2xpbmV0aHJvdWdoJyxcbiAgICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgIF0uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgdmFyIG9iaiA9IHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICAgIG9iai5zdHlsZXMgPSBjbG9uZSh0aGlzLnN0eWxlcywgdHJ1ZSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHByb3BlcnR5IHRvIGEgZ2l2ZW4gdmFsdWUuIFdoZW4gY2hhbmdpbmcgcG9zaXRpb24vZGltZW5zaW9uIC1yZWxhdGVkIHByb3BlcnRpZXMgKGxlZnQsIHRvcCwgc2NhbGUsIGFuZ2xlLCBldGMuKSBgc2V0YCBkb2VzIG5vdCB1cGRhdGUgcG9zaXRpb24gb2Ygb2JqZWN0J3MgYm9yZGVycy9jb250cm9scy4gSWYgeW91IG5lZWQgdG8gdXBkYXRlIHRob3NlLCBjYWxsIGBzZXRDb29yZHMoKWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBrZXkgUHJvcGVydHkgbmFtZSBvciBvYmplY3QgKGlmIG9iamVjdCwgaXRlcmF0ZSBvdmVyIHRoZSBvYmplY3QgcHJvcGVydGllcylcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdzZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIHZhciBuZWVkc0RpbXMgPSBmYWxzZTtcbiAgICAgIHZhciBpc0FkZGluZ1BhdGggPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBfa2V5IGluIGtleSkge1xuICAgICAgICAgIGlmIChfa2V5ID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVlZHNEaW1zID0gbmVlZHNEaW1zIHx8IHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmluZGV4T2YoX2tleSkgIT09IC0xO1xuICAgICAgICAgIGlzQWRkaW5nUGF0aCA9IGlzQWRkaW5nUGF0aCB8fCBfa2V5ID09PSAncGF0aCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZWVkc0RpbXMgPSB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKGtleSkgIT09IC0xO1xuICAgICAgICBpc0FkZGluZ1BhdGggPSBrZXkgPT09ICdwYXRoJztcbiAgICAgIH1cbiAgICAgIGlmIChpc0FkZGluZ1BhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRQYXRoSW5mbygpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzRGltcykge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlRleHQuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvdGV4dC5odG1sI1RleHRFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICd4IHkgZHggZHkgZm9udC1mYW1pbHkgZm9udC1zdHlsZSBmb250LXdlaWdodCBmb250LXNpemUgbGV0dGVyLXNwYWNpbmcgdGV4dC1kZWNvcmF0aW9uIHRleHQtYW5jaG9yJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBTVkcgZm9udCBzaXplXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkUgPSAxNjtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50ICg8Yj5ub3QgeWV0IGltcGxlbWVudGVkPC9iPilcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTKSxcbiAgICAgICAgcGFyc2VkQW5jaG9yID0gcGFyc2VkQXR0cmlidXRlcy50ZXh0QW5jaG9yIHx8ICdsZWZ0JztcbiAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCgob3B0aW9ucyA/IGNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcyk7XG5cbiAgICBvcHRpb25zLnRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XG4gICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5sZWZ0IHx8IDA7XG4gICAgaWYgKHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb24pIHtcbiAgICAgIHZhciB0ZXh0RGVjb3JhdGlvbiA9IHBhcnNlZEF0dHJpYnV0ZXMudGV4dERlY29yYXRpb247XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLm92ZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy5saW5ldGhyb3VnaCA9IHRydWU7XG4gICAgICB9XG4gICAgICBkZWxldGUgb3B0aW9ucy50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gICAgaWYgKCdkeCcgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5sZWZ0ICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHg7XG4gICAgfVxuICAgIGlmICgnZHknIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMudG9wICs9IHBhcnNlZEF0dHJpYnV0ZXMuZHk7XG4gICAgfVxuICAgIGlmICghKCdmb250U2l6ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgfVxuXG4gICAgdmFyIHRleHRDb250ZW50ID0gJyc7XG5cbiAgICAvLyBUaGUgWE1MIGlzIG5vdCBwcm9wZXJseSBwYXJzZWQgaW4gSUU5IHNvIGEgd29ya2Fyb3VuZCB0byBnZXRcbiAgICAvLyB0ZXh0Q29udGVudCBpcyB0aHJvdWdoIGZpcnN0Q2hpbGQuZGF0YS4gQW5vdGhlciB3b3JrYXJvdW5kIHdvdWxkIGJlXG4gICAgLy8gdG8gY29udmVydCBYTUwgbG9hZGVkIGZyb20gYSBmaWxlIHRvIGJlIGNvbnZlcnRlZCB1c2luZyBET01QYXJzZXIgKHNhbWUgd2F5IGxvYWRTVkdGcm9tU3RyaW5nKCkgZG9lcylcbiAgICBpZiAoISgndGV4dENvbnRlbnQnIGluIGVsZW1lbnQpKSB7XG4gICAgICBpZiAoJ2ZpcnN0Q2hpbGQnIGluIGVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgnZGF0YScgaW4gZWxlbWVudC5maXJzdENoaWxkICYmIGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICB9XG5cbiAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskfFxcbisvZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB2YXIgb3JpZ2luYWxTdHJva2VXaWR0aCA9IG9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgb3B0aW9ucy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICB2YXIgdGV4dCA9IG5ldyBmYWJyaWMuVGV4dCh0ZXh0Q29udGVudCwgb3B0aW9ucyksXG4gICAgICAgIHRleHRIZWlnaHRTY2FsZUZhY3RvciA9IHRleHQuZ2V0U2NhbGVkSGVpZ2h0KCkgLyB0ZXh0LmhlaWdodCxcbiAgICAgICAgbGluZUhlaWdodERpZmYgPSAodGV4dC5oZWlnaHQgKyB0ZXh0LnN0cm9rZVdpZHRoKSAqIHRleHQubGluZUhlaWdodCAtIHRleHQuaGVpZ2h0LFxuICAgICAgICBzY2FsZWREaWZmID0gbGluZUhlaWdodERpZmYgKiB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IsXG4gICAgICAgIHRleHRIZWlnaHQgPSB0ZXh0LmdldFNjYWxlZEhlaWdodCgpICsgc2NhbGVkRGlmZixcbiAgICAgICAgb2ZmWCA9IDA7XG4gICAgLypcbiAgICAgIEFkanVzdCBwb3NpdGlvbmluZzpcbiAgICAgICAgeC95IGF0dHJpYnV0ZXMgaW4gU1ZHIGNvcnJlc3BvbmQgdG8gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0ZXh0IGJvdW5kaW5nIGJveFxuICAgICAgICBmYWJyaWMgb3V0cHV0IGJ5IGRlZmF1bHQgYXQgdG9wLCBsZWZ0LlxuICAgICovXG4gICAgaWYgKHBhcnNlZEFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIG9mZlggPSB0ZXh0LmdldFNjYWxlZFdpZHRoKCkgLyAyO1xuICAgIH1cbiAgICBpZiAocGFyc2VkQW5jaG9yID09PSAncmlnaHQnKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRTY2FsZWRXaWR0aCgpO1xuICAgIH1cbiAgICB0ZXh0LnNldCh7XG4gICAgICBsZWZ0OiB0ZXh0LmxlZnQgLSBvZmZYLFxuICAgICAgdG9wOiB0ZXh0LnRvcCAtICh0ZXh0SGVpZ2h0IC0gdGV4dC5mb250U2l6ZSAqICgwLjA3ICsgdGV4dC5fZm9udFNpemVGcmFjdGlvbikpIC8gdGV4dC5saW5lSGVpZ2h0LFxuICAgICAgc3Ryb2tlV2lkdGg6IHR5cGVvZiBvcmlnaW5hbFN0cm9rZVdpZHRoICE9PSAndW5kZWZpbmVkJyA/IG9yaWdpbmFsU3Ryb2tlV2lkdGggOiAxLFxuICAgIH0pO1xuICAgIGNhbGxiYWNrKHRleHQpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHQgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG5cbiAgZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzID0gWydzYW5zLXNlcmlmJywgJ3NlcmlmJywgJ2N1cnNpdmUnLCAnZmFudGFzeScsICdtb25vc3BhY2UnXTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5UZXh0KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGEgdGV4dCB3aWxsIHVzZSBhIHBhcnRpY3VsYXIgcHJvcGVydHkgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSB0byBjaGVjayBmb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRvIGNoZWNrIHRoZSBzdHlsZSBvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3R5bGVIYXM6IGZ1bmN0aW9uKHByb3BlcnR5LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxpbmVJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IDA6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmpbcDFdW3AyXVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2hhcmFjdGVycyBpbiBhIHRleHQgaGF2ZSBhIHZhbHVlIGZvciBhIHByb3BlcnR5XG4gICAgICogd2hvc2UgdmFsdWUgbWF0Y2hlcyB0aGUgdGV4dGJveCdzIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5LiAgSWYgc28sXG4gICAgICogdGhlIGNoYXJhY3Rlci1sZXZlbCBwcm9wZXJ0eSBpcyBkZWxldGVkLiAgSWYgdGhlIGNoYXJhY3RlclxuICAgICAqIGhhcyBubyBvdGhlciBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFsc28gZGVsZXRlZC4gIEZpbmFsbHksXG4gICAgICogaWYgdGhlIGxpbmUgY29udGFpbmluZyB0aGF0IGNoYXJhY3RlciBoYXMgbm8gb3RoZXIgY2hhcmFjdGVyc1xuICAgICAqIHRoZW4gaXQgYWxzbyBpcyBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjb21wYXJlIGJldHdlZW4gY2hhcmFjdGVycyBhbmQgdGV4dC5cbiAgICAgKi9cbiAgICBjbGVhblN0eWxlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0aGlzLnN0eWxlcywgc3R5bGVzQ291bnQgPSAwLCBsZXR0ZXJDb3VudCwgc3R5bGVQcm9wZXJ0eVZhbHVlLFxuICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gdHJ1ZSwgZ3JhcGhlbWVDb3VudCA9IDAsIHN0eWxlT2JqZWN0O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgbGV0dGVyQ291bnQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIHZhciBzdHlsZU9iamVjdCA9IG9ialtwMV1bcDJdLFxuICAgICAgICAgICAgICBzdHlsZVByb3BlcnR5SGFzQmVlblNldCA9IHN0eWxlT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgICAgIHN0eWxlc0NvdW50Kys7XG5cbiAgICAgICAgICBpZiAoc3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgIHN0eWxlUHJvcGVydHlWYWx1ZSA9IHN0eWxlT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlT2JqZWN0W3Byb3BlcnR5XSAhPT0gc3R5bGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZU9iamVjdFtwcm9wZXJ0eV0gPT09IHRoaXNbcHJvcGVydHldKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3R5bGVPYmplY3QpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgbGV0dGVyQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW3AxXVtwMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldHRlckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtwMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGV2ZXJ5IGdyYXBoZW1lIGhhcyB0aGUgc2FtZSBzdHlsZSBzZXQgdGhlblxuICAgICAgLy8gZGVsZXRlIHRob3NlIHN0eWxlcyBhbmQgc2V0IGl0IG9uIHRoZSBwYXJlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoZW1lQ291bnQgKz0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCAmJiBzdHlsZXNDb3VudCA9PT0gZ3JhcGhlbWVDb3VudCkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHN0eWxlUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZShwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHN0eWxlIHByb3BlcnR5IG9yIHByb3BlcnRpZXMgZnJvbSBhbGwgaW5kaXZpZHVhbCBjaGFyYWN0ZXIgc3R5bGVzXG4gICAgICogaW4gYSB0ZXh0IG9iamVjdC4gIERlbGV0ZXMgdGhlIGNoYXJhY3RlciBzdHlsZSBvYmplY3QgaWYgaXQgY29udGFpbnMgbm8gb3RoZXIgc3R5bGVcbiAgICAgKiBwcm9wcy4gIERlbGV0ZXMgYSBsaW5lIHN0eWxlIG9iamVjdCBpZiBpdCBjb250YWlucyBubyBvdGhlciBjaGFyYWN0ZXIgc3R5bGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BzIFRoZSBwcm9wZXJ0eSB0byByZW1vdmUgZnJvbSBjaGFyYWN0ZXIgc3R5bGVzLlxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0aGlzLnN0eWxlcywgbGluZSwgbGluZU51bSwgY2hhck51bTtcbiAgICAgIGZvciAobGluZU51bSBpbiBvYmopIHtcbiAgICAgICAgbGluZSA9IG9ialtsaW5lTnVtXTtcbiAgICAgICAgZm9yIChjaGFyTnVtIGluIGxpbmUpIHtcbiAgICAgICAgICBkZWxldGUgbGluZVtjaGFyTnVtXVtwcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpbmVbY2hhck51bV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpbmVbY2hhck51bV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsaW5lKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW2xpbmVOdW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4dGVuZFN0eWxlczogZnVuY3Rpb24oaW5kZXgsIHN0eWxlcykge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihpbmRleCk7XG5cbiAgICAgIGlmICghdGhpcy5fZ2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldExpbmVTdHlsZShsb2MubGluZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCksIHN0eWxlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgMmQgcmVwcmVzZW50YXRpb24gKGxpbmVJbmRleCBhbmQgY2hhckluZGV4KSBvZiBjdXJzb3IgKG9yIHNlbGVjdGlvbiBzdGFydClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlbGVjdGlvblN0YXJ0XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwV3JhcHBpbmddIGNvbnNpZGVyIHRoZSBsb2NhdGlvbiBmb3IgdW53cmFwcGVkIGxpbmVzLiB1c2VmdWwgdG8gbWFuYWdlIHN0eWxlcy5cbiAgICAgKi9cbiAgICBnZXQyREN1cnNvckxvY2F0aW9uOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgc2tpcFdyYXBwaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdGlvblN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICB2YXIgbGluZXMgPSBza2lwV3JhcHBpbmcgPyB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgOiB0aGlzLl90ZXh0TGluZXMsXG4gICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPD0gbGluZXNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVJbmRleDogaSxcbiAgICAgICAgICAgIGNoYXJJbmRleDogc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0IC09IGxpbmVzW2ldLmxlbmd0aCArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lSW5kZXg6IGkgLSAxLFxuICAgICAgICBjaGFySW5kZXg6IGxpbmVzW2kgLSAxXS5sZW5ndGggPCBzZWxlY3Rpb25TdGFydCA/IGxpbmVzW2kgLSAxXS5sZW5ndGggOiBzZWxlY3Rpb25TdGFydFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uL2N1cnNvciAoYXQgdGhlIHN0YXJ0IHBvc2l0aW9uKVxuICAgICAqIGlmIHN0YXJ0SW5kZXggb3IgZW5kSW5kZXggYXJlIG5vdCBwcm92aWRlZCwgc2VsZWN0aW9uU3RhcnQgb3Igc2VsZWN0aW9uRW5kIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZ2V0IGZ1bGwgc3R5bGUgb3Igbm90XG4gICAgICogQHJldHVybiB7QXJyYXl9IHN0eWxlcyBhbiBhcnJheSB3aXRoIG9uZSwgemVybyBvciBtb3JlIFN0eWxlIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25TdHlsZXM6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBjb21wbGV0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHN0eWxlcy5wdXNoKHRoaXMuZ2V0U3R5bGVBdFBvc2l0aW9uKGksIGNvbXBsZXRlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24vY3Vyc29yIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uICB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcGxldGVdIGZ1bGwgc3R5bGUgaWYgdHJ1ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgU3R5bGUgb2JqZWN0IGF0IGEgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTdHlsZUF0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbiksXG4gICAgICAgICAgc3R5bGUgPSBjb21wbGV0ZSA/IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpIDpcbiAgICAgICAgICAgIHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCk7XG4gICAgICByZXR1cm4gc3R5bGUgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbiwgaWYgbm8gc2VsZWN0aW9uIGV4aXN0LCBkbyBub3Qgc2V0IGFueXRoaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSBTdHlsZXMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4XSBTdGFydCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleF0gRW5kIGluZGV4IHRvIGdldCBzdHlsZXMgYXQsIGlmIG5vdCBzcGVjaWZpZWQgc2VsZWN0aW9uRW5kIG9yIHN0YXJ0SW5kZXggKyAxXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3R5bGVzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2V4dGVuZFN0eWxlcyhpLCBzdHlsZXMpO1xuICAgICAgfVxuICAgICAgLyogbm90IGluY2x1ZGVkIGluIF9leHRlbmRTdHlsZXMgdG8gYXZvaWQgY2xlYXJpbmcgY2FjaGUgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSByZWZlcmVuY2UsIG5vdCBhIGNsb25lLCBvZiB0aGUgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBsaW5lU3R5bGUgPSB0aGlzLnN0eWxlcyAmJiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgICAgaWYgKCFsaW5lU3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZVN0eWxlW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgdGhlIHN0eWxlIHByb3BlcnR5IGZvciBhIGNoYXJhY3RlclxuICAgICAqIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgbmV3bHkgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXJhY3RlciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gb2YgdGhlIGNoYXJhY3RlciBvbiB0aGUgbGluZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkgfHwgeyB9LFxuICAgICAgICAgIHN0eWxlT2JqZWN0ID0geyB9LCBwcm9wO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdHlsZVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IHRoaXMuX3N0eWxlUHJvcGVydGllc1tpXTtcbiAgICAgICAgc3R5bGVPYmplY3RbcHJvcF0gPSB0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnID8gdGhpc1twcm9wXSA6IHN0eWxlW3Byb3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoZSBsaW5lIGV4aXN0cyBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsaW5lIHN0eWxlIHRvIGFuIGVtcHR5IG9iamVjdCBzbyB0aGF0IGlzIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIHBhcnNlRGVjb3JhdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LnRleHREZWNvcmF0aW9uKSB7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgPiAtMSAmJiAob2JqZWN0LnVuZGVybGluZSA9IHRydWUpO1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ2xpbmUtdGhyb3VnaCcpID4gLTEgJiYgKG9iamVjdC5saW5ldGhyb3VnaCA9IHRydWUpO1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ292ZXJsaW5lJykgPiAtMSAmJiAob2JqZWN0Lm92ZXJsaW5lID0gdHJ1ZSk7XG4gICAgICBkZWxldGUgb2JqZWN0LnRleHREZWNvcmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJVGV4dCBjbGFzcyAoaW50cm9kdWNlZCBpbiA8Yj52MS40PC9iPikgRXZlbnRzIGFyZSBhbHNvIGZpcmVkIHdpdGggXCJ0ZXh0OlwiXG4gICAqIHByZWZpeCB3aGVuIG9ic2VydmluZyBjYW52YXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuSVRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLlRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqXG4gICAqIEBmaXJlcyBjaGFuZ2VkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y2hhbmdlZFxuICAgKiBAZmlyZXMgZWRpdGluZzplbnRlcmVkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmV4aXRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLklUZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBrZXkgY29tYmluYXRpb25zOjwvcD5cbiAgICogPHByZT5cbiAgICogICBNb3ZlIGN1cnNvcjogICAgICAgICAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCB1cCwgZG93blxuICAgKiAgIFNlbGVjdCBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgc2hpZnQgKyBsZWZ0LCBzaGlmdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHRleHQgdmVydGljYWxseTogICAgICAgICBzaGlmdCArIHVwLCBzaGlmdCArIGRvd25cbiAgICogICBNb3ZlIGN1cnNvciBieSB3b3JkOiAgICAgICAgICAgIGFsdCArIGxlZnQsIGFsdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHdvcmRzOiAgICAgICAgICAgICAgICAgICBzaGlmdCArIGFsdCArIGxlZnQsIHNoaWZ0ICsgYWx0ICsgcmlnaHRcbiAgICogICBNb3ZlIGN1cnNvciB0byBsaW5lIHN0YXJ0L2VuZDogIGNtZCArIGxlZnQsIGNtZCArIHJpZ2h0IG9yIGhvbWUsIGVuZFxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiBsaW5lOiAgY21kICsgc2hpZnQgKyBsZWZ0LCBjbWQgKyBzaGlmdCArIHJpZ2h0IG9yIHNoaWZ0ICsgaG9tZSwgc2hpZnQgKyBlbmRcbiAgICogICBKdW1wIHRvIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgICAgIGNtZCArIHVwLCBjbWQgKyBkb3duXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIHRleHQ6ICBjbWQgKyBzaGlmdCArIHVwLCBjbWQgKyBzaGlmdCArIGRvd24gb3Igc2hpZnQgKyBwZ1VwLCBzaGlmdCArIHBnRG93blxuICAgKiAgIERlbGV0ZSBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIHdvcmQ6ICAgICAgICAgICAgICAgICAgICBhbHQgKyBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgbGluZTogICAgICAgICAgICAgICAgICAgIGNtZCArIGJhY2tzcGFjZVxuICAgKiAgIEZvcndhcmQgZGVsZXRlOiAgICAgICAgICAgICAgICAgZGVsZXRlXG4gICAqICAgQ29weSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIGNcbiAgICogICBQYXN0ZSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgdlxuICAgKiAgIEN1dCB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB4XG4gICAqICAgU2VsZWN0IGVudGlyZSB0ZXh0OiAgICAgICAgICAgICBjdHJsL2NtZCArIGFcbiAgICogICBRdWl0IGVkaXRpbmcgICAgICAgICAgICAgICAgICAgIHRhYiBvciBlc2NcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBtb3VzZS90b3VjaCBjb21iaW5hdGlvbjwvcD5cbiAgICogPHByZT5cbiAgICogICBQb3NpdGlvbiBjdXJzb3I6ICAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljay90b3VjaCAmIGRyYWdcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrICYgc2hpZnQgKyBjbGlja1xuICAgKiAgIFNlbGVjdCB3b3JkOiAgICAgICAgICAgICAgICAgICAgZG91YmxlIGNsaWNrXG4gICAqICAgU2VsZWN0IGxpbmU6ICAgICAgICAgICAgICAgICAgICB0cmlwbGUgY2xpY2tcbiAgICogPC9wcmU+XG4gICAqL1xuICBmYWJyaWMuSVRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuVGV4dCwgZmFicmljLk9ic2VydmFibGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ktdGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBzdGFydHMgKG9yIHdoZXJlIGN1cnNvciBpcyB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbilcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvblN0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gZW5kc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRW5kOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGV4dCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNywxMTksMjU1LDAuMyknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGV4dCBpcyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYSB0ZXh0IGNhbiBiZSBlZGl0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0YWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEJvcmRlciBjb2xvciBvZiB0ZXh0IG9iamVjdCB3aGlsZSBpdCdzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGluZ0JvcmRlckNvbG9yOiAncmdiYSgxMDIsMTUzLDI1NSwwLjI1KScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBjdXJzb3IgKGluIHB4KVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0ZXh0IGN1cnNvciBjb2xvciBpbiBlZGl0aW5nIG1vZGUuXG4gICAgICogaWYgbm90IHNldCAoZGVmYXVsdCkgd2lsbCB0YWtlIGNvbG9yIGZyb20gdGhlIHRleHQuXG4gICAgICogaWYgc2V0IHRvIGEgY29sb3IgdmFsdWUgdGhhdCBmYWJyaWMgY2FuIHVuZGVyc3RhbmQsIGl0IHdpbGxcbiAgICAgKiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGNvbG9yIG9mIHRoZSB0ZXh0IGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yQ29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogRGVsYXkgYmV0d2VlbiBjdXJzb3IgYmxpbmsgKGluIG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yRGVsYXk6IDEwMDAsXG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiBjdXJzb3IgZmFkZWluIChpbiBtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckR1cmF0aW9uOiA2MDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBpbnRlcm5hbCB0ZXh0IGNoYXIgd2lkdGhzIGNhbiBiZSBjYWNoZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjYWNoaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZTogL1xcc3xcXG4vLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3VycmVudEN1cnNvck9wYWNpdHk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWxlY3Rpb25EaXJlY3Rpb246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hYm9ydEN1cnNvckFuaW1hdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fd2lkdGhPZlNwYWNlOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBzIGRldGVybWluaW5nIHdoZW4gdGhlIHRleHQgaXMgaW4gY29tcG9zaXRpb24sIHNvIHRoYXQgdGhlIGN1cnNvclxuICAgICAqIHJlbmRlcmluZyBpcyBhbHRlcmVkLlxuICAgICAqL1xuICAgIGluQ29tcG9zaXRpb25Nb2RlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCB0ZXh0LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdEJlaGF2aW9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0aW9uIHN0YXJ0IChsZWZ0IGJvdW5kYXJ5IG9mIGEgc2VsZWN0aW9uKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCB0byBzZXQgc2VsZWN0aW9uIHN0YXJ0IHRvXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvblN0YXJ0JywgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBlbmQgKHJpZ2h0IGJvdW5kYXJ5IG9mIGEgc2VsZWN0aW9uKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCB0byBzZXQgc2VsZWN0aW9uIGVuZCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvbkVuZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRoaXMudGV4dC5sZW5ndGgpO1xuICAgICAgdGhpcy5fdXBkYXRlQW5kRmlyZSgnc2VsZWN0aW9uRW5kJywgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAnc2VsZWN0aW9uU3RhcnQnIG9yICdzZWxlY3Rpb25FbmQnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IG5ldyBwb3NpdGlvbiBvZiBwcm9wZXJ0eVxuICAgICAqL1xuICAgIF91cGRhdGVBbmRGaXJlOiBmdW5jdGlvbihwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzW3Byb3BlcnR5XSAhPT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHRoZSBldmVuIG9mIHNlbGVjdGlvbiBjaGFuZ2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZVNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2hhbmdlZCcpO1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpzZWxlY3Rpb246Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRleHQgZGltZW5zaW9ucy4gUmVuZGVyIGFsbCB0ZXh0IG9uIGdpdmVuIGNvbnRleHRcbiAgICAgKiBvciBvbiBhIG9mZnNjcmVlbiBjYW52YXMgdG8gZ2V0IHRoZSB0ZXh0IHdpZHRoIHdpdGggbWVhc3VyZVRleHQuXG4gICAgICogVXBkYXRlcyB0aGlzLndpZHRoIGFuZCB0aGlzLmhlaWdodCB3aXRoIHRoZSBwcm9wZXIgdmFsdWVzLlxuICAgICAqIERvZXMgbm90IHJldHVybiBkaW1lbnNpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0RGltZW5zaW9ucycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvck9mZnNldENhY2hlLCBzbyB3ZSBlbnN1cmUgdG8gY2FsY3VsYXRlIG9uY2UgcGVyIHJlbmRlckN1cnNvclxuICAgICAgLy8gdGhlIGNvcnJlY3QgcG9zaXRpb24gYnV0IG5vdCBhdCBldmVyeSBjdXJzb3IgYW5pbWF0aW9uLlxuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlcicsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgYW5kIGNsZWFuIHRoZSBjb250ZXh0VG9wXG4gICAgICovXG4gICAgY2xlYXJDb250ZXh0VG9wOiBmdW5jdGlvbihza2lwUmVzdG9yZSkge1xuICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5jYW52YXMgfHwgIXRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuX2NsZWFyVGV4dEFyZWEoY3R4KTtcbiAgICAgIHNraXBSZXN0b3JlIHx8IGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGN1cnNvciBvciBzZWxlY3Rpb24gKGRlcGVuZGluZyBvbiB3aGF0IGV4aXN0cylcbiAgICAgKiBpdCBkb2VzIG9uIHRoZSBjb250ZXh0VG9wLiBJZiBjb250ZXh0VG9wIGlzIG5vdCBhdmFpbGFibGUsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5jYW52YXMgfHwgIXRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKCksXG4gICAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKHRydWUpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb24oYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIF9jbGVhclRleHRBcmVhOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIHdlIGFkZCA0IHBpeGVsLCB0byBiZSBzdXJlIHRvIGRvIG5vdCBsZWF2ZSBhbnkgcGl4ZWwgb3V0XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoICsgNCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyA0O1xuICAgICAgY3R4LmNsZWFyUmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3Vyc29yIGJvdW5kYXJpZXMgKGxlZnQsIHRvcCwgbGVmdE9mZnNldCwgdG9wT2Zmc2V0KVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2hhcnMgQXJyYXkgb2YgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlT2ZCb3VuZGFyaWVzXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cbiAgICAgIC8vIGxlZnQvdG9wIGFyZSBsZWZ0L3RvcCBvZiBlbnRpcmUgdGV4dCBib3hcbiAgICAgIC8vIGxlZnRPZmZzZXQvdG9wT2Zmc2V0IGFyZSBvZmZzZXQgZnJvbSB0aGF0IGxlZnQvdG9wIHBvaW50IG9mIGEgdGV4dCBib3hcblxuICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBvZmZzZXRzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHMocG9zaXRpb24pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdE9mZnNldDogb2Zmc2V0cy5sZWZ0LFxuICAgICAgICB0b3BPZmZzZXQ6IG9mZnNldHMudG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0czogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgIGlmICh0aGlzLmN1cnNvck9mZnNldENhY2hlICYmICd0b3AnIGluIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICB2YXIgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgICAgbGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCxcbiAgICAgICAgICB0b3BPZmZzZXQgPSAwLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSAwLFxuICAgICAgICAgIGJvdW5kYXJpZXMsXG4gICAgICAgICAgY3Vyc29yUG9zaXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24ocG9zaXRpb24pO1xuICAgICAgY2hhckluZGV4ID0gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4O1xuICAgICAgbGluZUluZGV4ID0gY3Vyc29yUG9zaXRpb24ubGluZUluZGV4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lSW5kZXg7IGkrKykge1xuICAgICAgICB0b3BPZmZzZXQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICB9XG4gICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCk7XG4gICAgICB2YXIgYm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgICBib3VuZCAmJiAobGVmdE9mZnNldCA9IGJvdW5kLmxlZnQpO1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDAgJiYgY2hhckluZGV4ID09PSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5sZW5ndGgpIHtcbiAgICAgICAgbGVmdE9mZnNldCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgIH1cbiAgICAgIGJvdW5kYXJpZXMgPSB7XG4gICAgICAgIHRvcDogdG9wT2Zmc2V0LFxuICAgICAgICBsZWZ0OiBsaW5lTGVmdE9mZnNldCArIChsZWZ0T2Zmc2V0ID4gMCA/IGxlZnRPZmZzZXQgOiAwKSxcbiAgICAgIH07XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0gYm91bmRhcmllcztcbiAgICAgIHJldHVybiB0aGlzLmN1cnNvck9mZnNldENhY2hlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGN1cnNvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJDdXJzb3I6IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuICAgICAgdmFyIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKCksXG4gICAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCA+IDAgPyBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXggLSAxIDogMCxcbiAgICAgICAgICBjaGFySGVpZ2h0ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2ZvbnRTaXplJyksXG4gICAgICAgICAgbXVsdGlwbGllciA9IHRoaXMuc2NhbGVYICogdGhpcy5jYW52YXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgIGN1cnNvcldpZHRoID0gdGhpcy5jdXJzb3JXaWR0aCAvIG11bHRpcGxpZXIsXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gYm91bmRhcmllcy50b3BPZmZzZXQsXG4gICAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZGVsdGFZJyk7XG5cbiAgICAgIHRvcE9mZnNldCArPSAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAtIGNoYXJIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuXG4gICAgICBpZiAodGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jdXJzb3JDb2xvciB8fCB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZmlsbCcpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fX2lzTW91c2Vkb3duID8gMSA6IHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5O1xuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBib3VuZGFyaWVzLmxlZnRPZmZzZXQgLSBjdXJzb3JXaWR0aCAvIDIsXG4gICAgICAgIHRvcE9mZnNldCArIGJvdW5kYXJpZXMudG9wICsgZHksXG4gICAgICAgIGN1cnNvcldpZHRoLFxuICAgICAgICBjaGFySGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzIE9iamVjdCB3aXRoIGxlZnQvdG9wL2xlZnRPZmZzZXQvdG9wT2Zmc2V0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuXG4gICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kIDogdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgZW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZUluZGV4LFxuICAgICAgICAgIHN0YXJ0Q2hhciA9IHN0YXJ0LmNoYXJJbmRleCA8IDAgPyAwIDogc3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGVuZENoYXIgPSBlbmQuY2hhckluZGV4IDwgMCA/IDAgOiBlbmQuY2hhckluZGV4O1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpIHx8IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICByZWFsTGluZUhlaWdodCA9IDAsIGJveFN0YXJ0ID0gMCwgYm94RW5kID0gMDtcblxuICAgICAgICBpZiAoaSA9PT0gc3RhcnRMaW5lKSB7XG4gICAgICAgICAgYm94U3RhcnQgPSB0aGlzLl9fY2hhckJvdW5kc1tzdGFydExpbmVdW3N0YXJ0Q2hhcl0ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBzdGFydExpbmUgJiYgaSA8IGVuZExpbmUpIHtcbiAgICAgICAgICBib3hFbmQgPSBpc0p1c3RpZnkgJiYgIXRoaXMuaXNFbmRPZldyYXBwaW5nKGkpID8gdGhpcy53aWR0aCA6IHRoaXMuZ2V0TGluZVdpZHRoKGkpIHx8IDU7IC8vIFdURiBpcyB0aGlzIDU/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gZW5kTGluZSkge1xuICAgICAgICAgIGlmIChlbmRDaGFyID09PSAwKSB7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyXS5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLmxlZnRcbiAgICAgICAgICAgICAgKyB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ud2lkdGggLSBjaGFyU3BhY2luZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVhbExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0IDwgMSB8fCAoaSA9PT0gZW5kTGluZSAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSkge1xuICAgICAgICAgIGxpbmVIZWlnaHQgLz0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29tcG9zaXRpb25Db2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGJvdW5kYXJpZXMubGVmdCArIGxpbmVPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgYm94RW5kIC0gYm94U3RhcnQsXG4gICAgICAgICAgICAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94RW5kIC0gYm94U3RhcnQsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgYm91bmRhcmllcy50b3BPZmZzZXQgKz0gcmVhbExpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJzb3IuXG4gICAgICogdGhlIGN1cnJlbnRDaGFyIGlzIHRoZSBvbmUgdGhhdCBwcmVjZWRlcyB0aGUgY3Vyc29yXG4gICAgICogUmV0dXJucyBmb250U2l6ZSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIFVudXNlZCBmcm9tIHRoZSBsaWJyYXJ5LCBpcyBmb3IgdGhlIGVuZCB1c2VyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDaGFyYWN0ZXIgZm9udCBzaXplXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJGb250U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3AgPSB0aGlzLl9nZXRDdXJyZW50Q2hhckluZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChjcC5sLCBjcC5jLCAnZm9udFNpemUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0byBrbm93IHRoZSBjb2xvciBvZiB0aGUgY3Vyc29yLlxuICAgICAqIHRoZSBjdXJyZW50Q2hhciBpcyB0aGUgb25lIHRoYXQgcHJlY2VkZXMgdGhlIGN1cnNvclxuICAgICAqIFJldHVybnMgY29sb3IgKGZpbGwpIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogVW51c2VkIGZyb20gdGhlIGxpYnJhcnksIGlzIGZvciB0aGUgZW5kIHVzZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IENoYXJhY3RlciBjb2xvciAoZmlsbClcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2hhckNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjcCA9IHRoaXMuX2dldEN1cnJlbnRDaGFySW5kZXgoKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGNwLmwsIGNwLmMsICdmaWxsJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnNvciBwb3NpdGlvbiBmb3IgdGhlIGdldEN1cnJlbnQuLiBmdW5jdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDdXJyZW50Q2hhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4IC0gMSA6IDA7XG4gICAgICByZXR1cm4geyBsOiBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXgsIGM6IGNoYXJJbmRleCB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLklUZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5JVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHBhcnNlRGVjb3JhdGlvbihvYmplY3QpO1xuICAgIGlmIChvYmplY3Quc3R5bGVzKSB7XG4gICAgICBmb3IgKHZhciBpIGluIG9iamVjdC5zdHlsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBvYmplY3Quc3R5bGVzW2ldKSB7XG4gICAgICAgICAgcGFyc2VEZWNvcmF0aW9uKG9iamVjdC5zdHlsZXNbaV1bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0lUZXh0Jywgb2JqZWN0LCBjYWxsYmFjaywgJ3RleHQnKTtcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbGwgdGhlIGludGVyYWN0aXZlIGJlaGF2aW9yIG9mIElUZXh0XG4gICAgICovXG4gICAgaW5pdEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5pdEFkZGVkSGFuZGxlcigpO1xuICAgICAgdGhpcy5pbml0UmVtb3ZlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzKCk7XG4gICAgICB0aGlzLmluaXREb3VibGVDbGlja1NpbXVsYXRpb24oKTtcbiAgICAgIHRoaXMubW91c2VNb3ZlSGFuZGxlciA9IHRoaXMubW91c2VNb3ZlSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgIH0sXG5cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuZXhpdEVkaXRpbmcoKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJhZGRlZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0QWRkZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdhZGRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgaWYgKCFjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5faW5pdENhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMucHVzaChfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0UmVtb3ZlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ3JlbW92ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMgPSBjYW52YXMuX2lUZXh0SW5zdGFuY2VzIHx8IFtdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheShjYW52YXMuX2lUZXh0SW5zdGFuY2VzLCBfdGhpcyk7XG4gICAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlZ2lzdGVyIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0Q2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgb2JqLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNhbnZhcy5vbignbW91c2U6dXAnLCBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgY2FudmFzIGV2ZW50IHRvIG1hbmFnZSBleGl0aW5nIG9uIG90aGVyIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUNhbnZhc0hhbmRsZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5vZmYoJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGljazogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlID0gdGhpcy5fYW5pbWF0ZUN1cnNvcih0aGlzLCAxLCB0aGlzLmN1cnNvckR1cmF0aW9uLCAnX29uVGlja0NvbXBsZXRlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVDdXJzb3I6IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0T3BhY2l0eSwgZHVyYXRpb24sIGNvbXBsZXRlTWV0aG9kKSB7XG5cbiAgICAgIHZhciB0aWNrU3RhdGU7XG5cbiAgICAgIHRpY2tTdGF0ZSA9IHtcbiAgICAgICAgaXNBYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIG9iai5hbmltYXRlKCdfY3VycmVudEN1cnNvck9wYWNpdHknLCB0YXJnZXRPcGFjaXR5LCB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCF0aWNrU3RhdGUuaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICBvYmpbY29tcGxldGVNZXRob2RdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gYW5pbWF0ZSBhIHNlbGVjdGlvbiwgb25seSBjdXJzb3JcbiAgICAgICAgICBpZiAob2JqLmNhbnZhcyAmJiBvYmouc2VsZWN0aW9uU3RhcnQgPT09IG9iai5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgIG9iai5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aWNrU3RhdGUuaXNBYm9ydGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aWNrU3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uVGlja0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2N1cnNvclRpbWVvdXQxKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgPSBfdGhpcy5fYW5pbWF0ZUN1cnNvcihfdGhpcywgMCwgdGhpcy5jdXJzb3JEdXJhdGlvbiAvIDIsICdfdGljaycpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZGVsYXllZCBjdXJzb3JcbiAgICAgKi9cbiAgICBpbml0RGVsYXllZEN1cnNvcjogZnVuY3Rpb24ocmVzdGFydCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBkZWxheSA9IHJlc3RhcnQgPyAwIDogdGhpcy5jdXJzb3JEZWxheTtcblxuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fdGljaygpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgY3Vyc29yIGFuaW1hdGlvbiBhbmQgY2xlYXJzIGFsbCB0aW1lb3V0c1xuICAgICAqL1xuICAgIGFib3J0Q3Vyc29yQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLFxuICAgICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmFib3J0KCk7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmFib3J0KCk7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0MSk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDIpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICAvLyB0byBjbGVhciBqdXN0IGl0ZXh0IGFyZWEgd2UgbmVlZCB0byB0cmFuc2Zvcm0gdGhlIGNvbnRleHRcbiAgICAgIC8vIGl0IG1heSBub3QgYmUgd29ydGggaXRcbiAgICAgIGlmIChzaG91bGRDbGVhciAmJiBjYW52YXMpIHtcbiAgICAgICAgY2FudmFzLmNsZWFyQ29udGV4dChjYW52YXMuY29udGV4dFRvcCB8fCBjYW52YXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBlbnRpcmUgdGV4dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuX3RleHQubGVuZ3RoO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzZWxlY3RlZCB0ZXh0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dC5zbGljZSh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCkuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgc3RhcnQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5TGVmdDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb20gLSAxO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYmVmb3JlIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCB3b3JkIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kV29yZEJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICAvLyByZW1vdmUgc3BhY2UgYWZ0ZXIgY3Vyc29yIGZpcnN0XG4gICAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgvXFxTLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA8IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgbGluZSBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZExpbmVCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgd2hpbGUgKCEvXFxuLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgaW5kZXggY29ycmVzcG9uZGluZyB0byBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gMSBvciAtMVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICovXG4gICAgc2VhcmNoV29yZEJvdW5kYXJ5OiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuX3RleHQsXG4gICAgICAgICAgaW5kZXggICAgID0gdGhpcy5fcmVTcGFjZS50ZXN0KHRleHRbc2VsZWN0aW9uU3RhcnRdKSA/IHNlbGVjdGlvblN0YXJ0IC0gMSA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIF9jaGFyICAgICA9IHRleHRbaW5kZXhdLFxuICAgICAgICAgIC8vIHdyb25nXG4gICAgICAgICAgcmVOb25Xb3JkID0gZmFicmljLnJlTm9uV29yZDtcblxuICAgICAgd2hpbGUgKCFyZU5vbldvcmQudGVzdChfY2hhcikgJiYgaW5kZXggPiAwICYmIGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uO1xuICAgICAgICBfY2hhciA9IHRleHRbaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKHJlTm9uV29yZC50ZXN0KF9jaGFyKSkge1xuICAgICAgICBpbmRleCArPSBkaXJlY3Rpb24gPT09IDEgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIHdvcmQgYmFzZWQgb24gdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICovXG4gICAgc2VsZWN0V29yZDogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VhcmNoV29yZEJvdW5kYXJ5KHNlbGVjdGlvblN0YXJ0LCAtMSksIC8qIHNlYXJjaCBiYWNrd2FyZHMgKi9cbiAgICAgICAgICBuZXdTZWxlY3Rpb25FbmQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgMSk7IC8qIHNlYXJjaCBmb3J3YXJkICovXG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uRW5kO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBsaW5lIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZWxlY3RMaW5lOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5TGVmdChzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5maW5kTGluZUJvdW5kYXJ5UmlnaHQoc2VsZWN0aW9uU3RhcnQpO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVudGVycyBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGVudGVyRWRpdGluZzogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuaXNFZGl0aW5nIHx8ICF0aGlzLmVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmNhbGNPZmZzZXQoKTtcbiAgICAgICAgdGhpcy5leGl0RWRpdGluZ09uT3RoZXJzKHRoaXMuY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuXG4gICAgICB0aGlzLmluaXRIaWRkZW5UZXh0YXJlYShlKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5fc2F2ZUVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fc2V0RWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl90ZXh0QmVmb3JlRWRpdCA9IHRoaXMudGV4dDtcblxuICAgICAgdGhpcy5fdGljaygpO1xuICAgICAgdGhpcy5maXJlKCdlZGl0aW5nOmVudGVyZWQnKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmVudGVyZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuaW5pdE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBleGl0RWRpdGluZ09uT3RoZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzKSB7XG4gICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICBvYmouc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAob2JqLmlzRWRpdGluZykge1xuICAgICAgICAgICAgb2JqLmV4aXRFZGl0aW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZW1vdmVcIiBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgaW5pdE1vdXNlTW92ZUhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jYW52YXMub24oJ21vdXNlOm1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1vdXNlTW92ZUhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5fX2lzTW91c2Vkb3duIHx8ICF0aGlzLmlzRWRpdGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpLFxuICAgICAgICAgIGN1cnJlbnRTdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgY3VycmVudEVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgICAgaWYgKFxuICAgICAgICAobmV3U2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duIHx8IGN1cnJlbnRTdGFydCA9PT0gY3VycmVudEVuZClcbiAgICAgICAgJiZcbiAgICAgICAgKGN1cnJlbnRTdGFydCA9PT0gbmV3U2VsZWN0aW9uU3RhcnQgfHwgY3VycmVudEVuZCA9PT0gbmV3U2VsZWN0aW9uU3RhcnQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24pIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSBjdXJyZW50U3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25FbmQgIT09IGN1cnJlbnRFbmQpIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0Q3Vyc29ySWZOZWVkZWQoKTtcbiAgICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9ICd0ZXh0JztcblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IgPSB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gJ3RleHQnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy5lZGl0aW5nQm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5zZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gdGV4dGFyZWEgdG8gZ3JhcGhlbWUgaW5kZXhlc1xuICAgICAqL1xuICAgIGZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCB0ZXh0KSB7XG4gICAgICB2YXIgc21hbGxlclRleHRTdGFydCA9IHRleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChzbWFsbGVyVGV4dFN0YXJ0KS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0IH07XG4gICAgICB9XG4gICAgICB2YXIgc21hbGxlclRleHRFbmQgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRFbmQpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgKyBncmFwaGVtZUVuZCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGZyb20gZmFicmljIHRvIHRleHRhcmVhIHZhbHVlc1xuICAgICAqL1xuICAgIGZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uOiBmdW5jdGlvbihzdGFydCwgZW5kLCBfdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSBfdGV4dC5zbGljZSgwLCBzdGFydCksXG4gICAgICAgICAgZ3JhcGhlbWVTdGFydCA9IHNtYWxsZXJUZXh0U3RhcnQuam9pbignJykubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gX3RleHQuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgZ3JhcGhlbWVFbmQgPSBzbWFsbGVyVGV4dEVuZC5qb2luKCcnKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlVGV4dGFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRoaXMuX3RleHQpO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVGcm9tVGV4dEFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCwgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQsIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmICghdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlVGV4dGFyZWFQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fY2FsY1RleHRhcmVhUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5sZWZ0ID0gc3R5bGUubGVmdDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS50b3AgPSBzdHlsZS50b3A7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBjb250YWlucyBzdHlsZSBmb3IgaGlkZGVuVGV4dGFyZWFcbiAgICAgKi9cbiAgICBfY2FsY1RleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4geyB4OiAxLCB5OiAxIH07XG4gICAgICB9XG4gICAgICB2YXIgZGVzaXJlZFBvc2l0aW9uID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuY29tcG9zaXRpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoZGVzaXJlZFBvc2l0aW9uKSxcbiAgICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihkZXNpcmVkUG9zaXRpb24pLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpICogdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSBib3VuZGFyaWVzLmxlZnRPZmZzZXQsXG4gICAgICAgICAgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIHAgPSB7XG4gICAgICAgICAgICB4OiBib3VuZGFyaWVzLmxlZnQgKyBsZWZ0T2Zmc2V0LFxuICAgICAgICAgICAgeTogYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCArIGNoYXJIZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJldGluYVNjYWxpbmcgPSB0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksXG4gICAgICAgICAgdXBwZXJDYW52YXMgPSB0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIHVwcGVyQ2FudmFzV2lkdGggPSB1cHBlckNhbnZhcy53aWR0aCAvIHJldGluYVNjYWxpbmcsXG4gICAgICAgICAgdXBwZXJDYW52YXNIZWlnaHQgPSB1cHBlckNhbnZhcy5oZWlnaHQgLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIG1heFdpZHRoID0gdXBwZXJDYW52YXNXaWR0aCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdXBwZXJDYW52YXNIZWlnaHQgLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIHNjYWxlWCA9IHVwcGVyQ2FudmFzLmNsaWVudFdpZHRoIC8gdXBwZXJDYW52YXNXaWR0aCxcbiAgICAgICAgICBzY2FsZVkgPSB1cHBlckNhbnZhcy5jbGllbnRIZWlnaHQgLyB1cHBlckNhbnZhc0hlaWdodDtcblxuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG0pO1xuICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHAueCAqPSBzY2FsZVg7XG4gICAgICBwLnkgKj0gc2NhbGVZO1xuICAgICAgaWYgKHAueCA8IDApIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnggPiBtYXhXaWR0aCkge1xuICAgICAgICBwLnggPSBtYXhXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPCAwKSB7XG4gICAgICAgIHAueSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC55ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgIHAueSA9IG1heEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNhbnZhcyBvZmZzZXQgb24gZG9jdW1lbnRcbiAgICAgIHAueCArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwLnkgKz0gdGhpcy5jYW52YXMuX29mZnNldC50b3A7XG5cbiAgICAgIHJldHVybiB7IGxlZnQ6IHAueCArICdweCcsIHRvcDogcC55ICsgJ3B4JywgZm9udFNpemU6IGNoYXJIZWlnaHQgKyAncHgnLCBjaGFySGVpZ2h0OiBjaGFySGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NhdmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc2F2ZWRQcm9wcyA9IHtcbiAgICAgICAgaGFzQ29udHJvbHM6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLmJvcmRlckNvbG9yLFxuICAgICAgICBsb2NrTW92ZW1lbnRYOiB0aGlzLmxvY2tNb3ZlbWVudFgsXG4gICAgICAgIGxvY2tNb3ZlbWVudFk6IHRoaXMubG9ja01vdmVtZW50WSxcbiAgICAgICAgaG92ZXJDdXJzb3I6IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgIHNlbGVjdGFibGU6IHRoaXMuc2VsZWN0YWJsZSxcbiAgICAgICAgZGVmYXVsdEN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvcixcbiAgICAgICAgbW92ZUN1cnNvcjogdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMubW92ZUN1cnNvclxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3NhdmVkUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5ob3ZlckN1cnNvcjtcbiAgICAgIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLl9zYXZlZFByb3BzLmhhc0NvbnRyb2xzO1xuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuX3NhdmVkUHJvcHMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLnNlbGVjdGFibGUgPSB0aGlzLl9zYXZlZFByb3BzLnNlbGVjdGFibGU7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFggPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFg7XG4gICAgICB0aGlzLmxvY2tNb3ZlbWVudFkgPSB0aGlzLl9zYXZlZFByb3BzLmxvY2tNb3ZlbWVudFk7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5kZWZhdWx0Q3Vyc29yO1xuICAgICAgICB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yID0gdGhpcy5fc2F2ZWRQcm9wcy5tb3ZlQ3Vyc29yO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGl0cyBmcm9tIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZXhpdEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzVGV4dENoYW5nZWQgPSAodGhpcy5fdGV4dEJlZm9yZUVkaXQgIT09IHRoaXMudGV4dCk7XG4gICAgICB2YXIgaGlkZGVuVGV4dGFyZWEgPSB0aGlzLmhpZGRlblRleHRhcmVhO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgICBpZiAoaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgaGlkZGVuVGV4dGFyZWEuYmx1ciAmJiBoaWRkZW5UZXh0YXJlYS5ibHVyKCk7XG4gICAgICAgIGhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUgJiYgaGlkZGVuVGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoaWRkZW5UZXh0YXJlYSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gbnVsbDtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX3Jlc3RvcmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdlZGl0aW5nOmV4aXRlZCcpO1xuICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmZpcmUoJ21vZGlmaWVkJyk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMub2ZmKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDplZGl0aW5nOmV4aXRlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICBpc1RleHRDaGFuZ2VkICYmIHRoaXMuY2FudmFzLmZpcmUoJ29iamVjdDptb2RpZmllZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHRMaW5lc1twcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYW5kIHJlZmxvdyBhIHN0eWxlIGJsb2NrIGZyb20gc3RhcnQgdG8gZW5kLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBsaW5lYXIgc3RhcnQgcG9zaXRpb24gZm9yIHJlbW92YWwgKGluY2x1ZGVkIGluIHJlbW92YWwpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBsaW5lYXIgZW5kIHBvc2l0aW9uIGZvciByZW1vdmFsICggZXhjbHVkZWQgZnJvbSByZW1vdmFsIClcbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZUZyb21UbzogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGN1cnNvclN0YXJ0ID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjdXJzb3JFbmQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZW5kLCB0cnVlKSxcbiAgICAgICAgICBsaW5lU3RhcnQgPSBjdXJzb3JTdGFydC5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhclN0YXJ0ID0gY3Vyc29yU3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGxpbmVFbmQgPSBjdXJzb3JFbmQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJFbmQgPSBjdXJzb3JFbmQuY2hhckluZGV4LFxuICAgICAgICAgIGksIHN0eWxlT2JqO1xuICAgICAgaWYgKGxpbmVTdGFydCAhPT0gbGluZUVuZCkge1xuICAgICAgICAvLyBzdGVwMSByZW1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVTdGFydFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lc1tsaW5lU3RhcnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcDIgbW92ZSB0aGUgdHJhaWxpbmcgb2YgbGluZUVuZCB0byBsaW5lU3RhcnQgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lRW5kXSkge1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJFbmQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZUVuZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0eWxlT2JqID0gdGhpcy5zdHlsZXNbbGluZUVuZF1baV07XG4gICAgICAgICAgICBpZiAoc3R5bGVPYmopIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSB8fCAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSA9IHsgfSk7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1bY2hhclN0YXJ0ICsgaSAtIGNoYXJFbmRdID0gc3R5bGVPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAzIGRldGVjdHMgbGluZXMgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgIGZvciAoaSA9IGxpbmVTdGFydCArIDE7IGkgPD0gbGluZUVuZDsgaSsrKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXA0IHNoaWZ0IHJlbWFpbmluZyBsaW5lcy5cbiAgICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUVuZCwgbGluZVN0YXJ0IC0gbGluZUVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFuZCBzaGlmdCBsZWZ0IG9uIHRoZSBzYW1lIGxpbmVcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVTdGFydF07XG4gICAgICAgICAgdmFyIGRpZmYgPSBjaGFyRW5kIC0gY2hhclN0YXJ0LCBudW1lcmljQ2hhciwgX2NoYXI7XG4gICAgICAgICAgZm9yIChpID0gY2hhclN0YXJ0OyBpIDwgY2hhckVuZDsgaSsrKSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVPYmpbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoX2NoYXIgaW4gdGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgICAgbnVtZXJpY0NoYXIgPSBwYXJzZUludChfY2hhciwgMTApO1xuICAgICAgICAgICAgaWYgKG51bWVyaWNDaGFyID49IGNoYXJFbmQpIHtcbiAgICAgICAgICAgICAgc3R5bGVPYmpbbnVtZXJpY0NoYXIgLSBkaWZmXSA9IHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW19jaGFyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIGxpbmUgc3R5bGVzIHVwIG9yIGRvd25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgQ2FuIGFueSBudW1iZXI/XG4gICAgICovXG4gICAgc2hpZnRMaW5lU3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgsIG9mZnNldCkge1xuICAgICAgLy8gc2hpZnQgYWxsIGxpbmUgc3R5bGVzIGJ5IG9mZnNldCB1cHdhcmQgb3IgZG93bndhcmRcbiAgICAgIC8vIGRvIG5vdCBjbG9uZSBkZWVwLiB3ZSBuZWVkIG5ldyBhcnJheSwgbm90IG5ldyBzdHlsZSBvYmplY3RzXG4gICAgICB2YXIgY2xvbmVkU3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMpO1xuICAgICAgZm9yICh2YXIgbGluZSBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICB2YXIgbnVtZXJpY0xpbmUgPSBwYXJzZUludChsaW5lLCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljTGluZSA+IGxpbmVJbmRleCkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lICsgb2Zmc2V0XSA9IGNsb25lZFN0eWxlc1tudW1lcmljTGluZV07XG4gICAgICAgICAgaWYgKCFjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmUgLSBvZmZzZXRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXN0YXJ0Q3Vyc29ySWZOZWVkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuaXNBYm9ydGVkXG4gICAgICAgIHx8ICF0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlLmlzQWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluc2VydGlvbiBvZiBtb3JlIGNvbnNlY3V0aXZlIHN0eWxlIGxpbmVzIGZvciB3aGVuIG9uZSBvciBtb3JlXG4gICAgICogbmV3bGluZXMgZ2V0cyBhZGRlZCB0byB0aGUgdGV4dC4gU2luY2UgY3VycmVudCBzdHlsZSBuZWVkcyB0byBiZSBzaGlmdGVkXG4gICAgICogZmlyc3Qgd2Ugc2hpZnQgdGhlIGN1cnJlbnQgc3R5bGUgb2YgdGhlIG51bWJlciBsaW5lcyBuZWVkZWQsIHRoZW4gd2UgYWRkXG4gICAgICogbmV3IGxpbmVzIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXR5IG51bWJlciBvZiBsaW5lcyB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBBcnJheSBvZiBvYmplY3RzIHN0eWxlc1xuICAgICAqL1xuICAgIGluc2VydE5ld2xpbmVTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF0eSwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJyZW50Q2hhclN0eWxlLFxuICAgICAgICAgIG5ld0xpbmVTdHlsZXMgPSB7fSxcbiAgICAgICAgICBzb21ldGhpbmdBZGRlZCA9IGZhbHNlLFxuICAgICAgICAgIGlzRW5kT2ZMaW5lID0gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoID09PSBjaGFySW5kZXg7XG5cbiAgICAgIHF0eSB8fCAocXR5ID0gMSk7XG4gICAgICB0aGlzLnNoaWZ0TGluZVN0eWxlcyhsaW5lSW5kZXgsIHF0eSk7XG4gICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICBjdXJyZW50Q2hhclN0eWxlID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggPT09IDAgPyBjaGFySW5kZXggOiBjaGFySW5kZXggLSAxXTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIGNsb25lIHN0eWxlcyBvZiBhbGwgY2hhcnNcbiAgICAgIC8vIGFmdGVyIGN1cnNvciBvbnRvIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgIGZvciAodmFyIGluZGV4IGluIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgdmFyIG51bUluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bUluZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIHNvbWV0aGluZ0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzW251bUluZGV4IC0gY2hhckluZGV4XSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIC8vIHJlbW92ZSBsaW5lcyBmcm9tIHRoZSBwcmV2aW91cyBsaW5lIHNpbmNlIHRoZXkncmUgb24gYSBuZXcgbGluZSBub3dcbiAgICAgICAgICBpZiAoIShpc0VuZE9mTGluZSAmJiBjaGFySW5kZXggPT09IDApKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVDYXJyaWVkT3ZlciA9IGZhbHNlO1xuICAgICAgaWYgKHNvbWV0aGluZ0FkZGVkICYmICFpc0VuZE9mTGluZSkge1xuICAgICAgICAvLyBpZiBpcyBlbmQgb2YgbGluZSwgdGhlIGV4dHJhIHN0eWxlIHdlIGNvcGllZFxuICAgICAgICAvLyBpcyBwcm9iYWJseSBub3Qgc29tZXRoaW5nIHdlIHdhbnRcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IG5ld0xpbmVTdHlsZXM7XG4gICAgICAgIHN0eWxlQ2FycmllZE92ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlQ2FycmllZE92ZXIpIHtcbiAgICAgICAgLy8gc2tpcCB0aGUgbGFzdCBsaW5lIG9mIHNpbmNlIHdlIGFscmVhZHkgcHJlcGFyZWQgaXQuXG4gICAgICAgIHF0eS0tO1xuICAgICAgfVxuICAgICAgLy8gZm9yIHRoZSBhbGwgdGhlIGxpbmVzIG9yIGFsbCB0aGUgb3RoZXIgbGluZXNcbiAgICAgIC8vIHdlIGNsb25lIGN1cnJlbnQgY2hhciBzdHlsZSBvbnRvIHRoZSBuZXh0IChvdGhlcndpc2UgZW1wdHkpIGxpbmVcbiAgICAgIHdoaWxlIChxdHkgPiAwKSB7XG4gICAgICAgIGlmIChjb3BpZWRTdHlsZSAmJiBjb3BpZWRTdHlsZVtxdHkgLSAxXSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGNvcGllZFN0eWxlW3F0eSAtIDFdKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDaGFyU3R5bGUpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0geyAwOiBjbG9uZShjdXJyZW50Q2hhclN0eWxlKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldO1xuICAgICAgICB9XG4gICAgICAgIHF0eS0tO1xuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gbGluZS9jaGFyIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFudGl0eSBudW1iZXIgU3R5bGUgb2JqZWN0IHRvIGluc2VydCwgaWYgZ2l2ZW5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb3BpZWRTdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3RzXG4gICAgICovXG4gICAgaW5zZXJ0Q2hhclN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcXVhbnRpdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudExpbmVTdHlsZXMgICAgICAgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkID0gY3VycmVudExpbmVTdHlsZXMgPyBjbG9uZShjdXJyZW50TGluZVN0eWxlcykgOiB7fTtcblxuICAgICAgcXVhbnRpdHkgfHwgKHF1YW50aXR5ID0gMSk7XG4gICAgICAvLyBzaGlmdCBhbGwgY2hhciBzdHlsZXMgYnkgcXVhbnRpdHkgZm9yd2FyZFxuICAgICAgLy8gMCwxLDIsMyAtPiAoY2hhckluZGV4PTIpIC0+IDAsMSwzLDQgLT4gKGluc2VydCAyKSAtPiAwLDEsMiwzLDRcbiAgICAgIGZvciAodmFyIGluZGV4IGluIGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkKSB7XG4gICAgICAgIHZhciBudW1lcmljSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0luZGV4ID49IGNoYXJJbmRleCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleCArIHF1YW50aXR5XSA9IGN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleF07XG4gICAgICAgICAgLy8gb25seSBkZWxldGUgdGhlIHN0eWxlIGlmIHRoZXJlIHdhcyBub3RoaW5nIG1vdmVkIHRoZXJlXG4gICAgICAgICAgaWYgKCFjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXggLSBxdWFudGl0eV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICB3aGlsZSAocXVhbnRpdHktLSkge1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoY29waWVkU3R5bGVbcXVhbnRpdHldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShjb3BpZWRTdHlsZVtxdWFudGl0eV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1N0eWxlID0gY3VycmVudExpbmVTdHlsZXNbY2hhckluZGV4ID8gY2hhckluZGV4IC0gMSA6IDFdO1xuICAgICAgd2hpbGUgKG5ld1N0eWxlICYmIHF1YW50aXR5LS0pIHtcbiAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXggKyBxdWFudGl0eV0gPSBjbG9uZShuZXdTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0KHMpXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5zZXJ0ZWRUZXh0IENoYXJhY3RlcnMgYXQgdGhlIGxvY2F0aW9uIHdoZXJlIHN0eWxlIGlzIGluc2VydGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGN1cnNvciBpbmRleCBmb3IgaW5zZXJ0aW5nIHN0eWxlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvcGllZFN0eWxlXSBhcnJheSBvZiBzdHlsZSBvYmplY3RzIHRvIGluc2VydC5cbiAgICAgKi9cbiAgICBpbnNlcnROZXdTdHlsZUJsb2NrOiBmdW5jdGlvbihpbnNlcnRlZFRleHQsIHN0YXJ0LCBjb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIGN1cnNvckxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgYWRkZWRMaW5lcyA9IFswXSwgbGluZXNMZW5ndGggPSAwO1xuICAgICAgLy8gZ2V0IGFuIGFycmF5IG9mIGhvdyBtYW55IGNoYXIgcGVyIGxpbmVzIGFyZSBiZWluZyBhZGRlZC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0ZWRUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnNlcnRlZFRleHRbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgbGluZXNMZW5ndGgrKztcbiAgICAgICAgICBhZGRlZExpbmVzW2xpbmVzTGVuZ3RoXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWRkZWRMaW5lc1tsaW5lc0xlbmd0aF0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZm9yIHRoZSBmaXJzdCBsaW5lIGNvcHkgdGhlIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgY2hhciBwb3NpdGlvbi5cbiAgICAgIGlmIChhZGRlZExpbmVzWzBdID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4LCBhZGRlZExpbmVzWzBdLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1swXSArIDEpO1xuICAgICAgfVxuICAgICAgbGluZXNMZW5ndGggJiYgdGhpcy5pbnNlcnROZXdsaW5lU3R5bGVPYmplY3QoXG4gICAgICAgIGN1cnNvckxvYy5saW5lSW5kZXgsIGN1cnNvckxvYy5jaGFySW5kZXggKyBhZGRlZExpbmVzWzBdLCBsaW5lc0xlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCArIGksIDAsIGFkZGVkTGluZXNbaV0sIGNvcGllZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3BpZWRTdHlsZSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXVswXSA9IGNvcGllZFN0eWxlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvcGllZFN0eWxlID0gY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGUuc2xpY2UoYWRkZWRMaW5lc1tpXSArIDEpO1xuICAgICAgfVxuICAgICAgLy8gd2UgdXNlIGkgb3V0c2lkZSB0aGUgbG9vcCB0byBnZXQgaXQgbGlrZSBsaW5lc0xlbmd0aFxuICAgICAgaWYgKGFkZGVkTGluZXNbaV0gPiAwKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBhY2NvcmRpbmcgdG8gdGhlIG5ldyBwb3NpdGlvbiBvZiBjdXJzb3JcbiAgICAgKiBtaW1pYyB0aGUga2V5IC0gbW91c2UgbmF2aWdhdGlvbiB3aGVuIHNoaWZ0IGlzIHByZXNzZWQuXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbikge1xuICAgICAgaWYgKG5ld1NlbGVjdGlvbiA8PSBzdGFydCkge1xuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobmV3U2VsZWN0aW9uID4gc3RhcnQgJiYgbmV3U2VsZWN0aW9uIDwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gbmV3U2VsZWN0aW9uIGlzID4gc2VsZWN0aW9uIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb25JbkJvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA8IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA8IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwiZGJjbGlja1wiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXREb3VibGVDbGlja1NpbXVsYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gZm9yIGRvdWJsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAvLyBmb3IgdHJpcGxlIGNsaWNrXG4gICAgdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSB7IH07XG5cbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIHRvIHNpbXVsYXRlIHRyaXBsZSBjbGlja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19uZXdDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbmV3UG9pbnRlciA9IG9wdGlvbnMucG9pbnRlcjtcbiAgICBpZiAodGhpcy5pc1RyaXBsZUNsaWNrKG5ld1BvaW50ZXIpKSB7XG4gICAgICB0aGlzLmZpcmUoJ3RyaXBsZWNsaWNrJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zdG9wRXZlbnQob3B0aW9ucy5lKTtcbiAgICB9XG4gICAgdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lID0gdGhpcy5fX2xhc3RDbGlja1RpbWU7XG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSB0aGlzLl9fbmV3Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IG5ld1BvaW50ZXI7XG4gICAgdGhpcy5fX2xhc3RJc0VkaXRpbmcgPSB0aGlzLmlzRWRpdGluZztcbiAgICB0aGlzLl9fbGFzdFNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcbiAgfSxcblxuICBpc1RyaXBsZUNsaWNrOiBmdW5jdGlvbihuZXdQb2ludGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX19uZXdDbGlja1RpbWUgLSB0aGlzLl9fbGFzdENsaWNrVGltZSA8IDUwMCAmJlxuICAgICAgICB0aGlzLl9fbGFzdENsaWNrVGltZSAtIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA8IDUwMCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueCA9PT0gbmV3UG9pbnRlci54ICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci55ID09PSBuZXdQb2ludGVyLnk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RvcEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24gJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZXZlbnQgaGFuZGxlcnMgcmVsYXRlZCB0byBjdXJzb3Igb3Igc2VsZWN0aW9uXG4gICAqL1xuICBpbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5pdE1vdXNlZG93bkhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRNb3VzZXVwSGFuZGxlcigpO1xuICAgIHRoaXMuaW5pdENsaWNrcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhhbmRsZXIgZm9yIGRvdWJsZSBjbGljaywgc2VsZWN0IGEgd29yZFxuICAgKi9cbiAgZG91YmxlQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdFdvcmQodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhhbmRsZXIgZm9yIHRyaXBsZSBjbGljaywgc2VsZWN0IGEgbGluZVxuICAgKi9cbiAgdHJpcGxlQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdExpbmUodGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBkb3VibGUgYW5kIHRyaXBsZSBjbGljayBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgaW5pdENsaWNrczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2VkYmxjbGljaycsIHRoaXMuZG91YmxlQ2xpY2tIYW5kbGVyKTtcbiAgICB0aGlzLm9uKCd0cmlwbGVjbGljaycsIHRoaXMudHJpcGxlQ2xpY2tIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIGZvciB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzIG5lZWRlZCBvbiBfbW91c2VEb3duXG4gICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gICAqIFNjb3BlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXM6IGZpbmQgdGhlIGNsaWNrIHBvc2l0aW9uLCBzZXQgc2VsZWN0aW9uU3RhcnRcbiAgICogZmluZCBzZWxlY3Rpb25FbmQsIGluaXRpYWxpemUgdGhlIGRyYXdpbmcgb2YgZWl0aGVyIGN1cnNvciBvciBzZWxlY3Rpb24gYXJlYVxuICAgKiBpbml0aWFsaXppbmcgYSBtb3VzZWREb3duIG9uIGEgdGV4dCBhcmVhIHdpbGwgY2FuY2VsIGZhYnJpY2pzIGtub3dsZWRnZSBvZlxuICAgKiBjdXJyZW50IGNvbXBvc2l0aW9uTW9kZS4gSXQgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG4gICAqL1xuICBfbW91c2VEb3duSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMgfHwgIXRoaXMuZWRpdGFibGUgfHwgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0Q3Vyc29yQnlDbGljayhvcHRpb25zLmUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRWRpdGluZykge1xuICAgICAgdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gbW91c2Vkb3duOmJlZm9yZVxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiB2ZXJpZnkgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHNlbGVjdGVkIHdoZW4gbW91c2luZyBkb3duXG4gICAqL1xuICBfbW91c2VEb3duSGFuZGxlckJlZm9yZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMgfHwgIXRoaXMuZWRpdGFibGUgfHwgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gd2Ugd2FudCB0byBhdm9pZCB0aGF0IGFuIG9iamVjdCB0aGF0IHdhcyBzZWxlY3RlZCBhbmQgdGhlbiBiZWNvbWVzIHVuc2VsZWN0YWJsZSxcbiAgICAvLyBtYXkgdHJpZ2dlciBlZGl0aW5nIG1vZGUgaW4gc29tZSB3YXkuXG4gICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMgPT09IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2Vkb3duXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNlZG93bkhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bkhhbmRsZXIpO1xuICAgIHRoaXMub24oJ21vdXNlZG93bjpiZWZvcmUnLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyQmVmb3JlKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZXVwXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdE1vdXNldXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwSGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHN0YW5kYXJkIGhhbmRsZXIgZm9yIG1vdXNlIHVwLCBvdmVycmlkYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZWRpdGFibGUgfHwgdGhpcy5ncm91cCB8fFxuICAgICAgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9wdGlvbnMudHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCkgfHxcbiAgICAgIChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB2YXIgY3VycmVudEFjdGl2ZSA9IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAoY3VycmVudEFjdGl2ZSAmJiBjdXJyZW50QWN0aXZlICE9PSB0aGlzKSB7XG4gICAgICAgIC8vIGF2b2lkIHJ1bm5pbmcgdGhpcyBsb2dpYyB3aGVuIHRoZXJlIGlzIGFuIGFjdGl2ZSBvYmplY3RcbiAgICAgICAgLy8gdGhpcyBiZWNhdXNlIGlzIHBvc3NpYmxlIHdpdGggc2hpZnQgY2xpY2sgYW5kIGZhc3QgY2xpY2tzLFxuICAgICAgICAvLyB0byByYXBpZGx5IGRlc2VsZWN0IGFuZCByZXNlbGVjdCB0aGlzIG9iamVjdCBhbmQgdHJpZ2dlciBhbiBlbnRlckVkaXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9fbGFzdFNlbGVjdGVkICYmICF0aGlzLl9fY29ybmVyKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fbGFzdFNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVudGVyRWRpdGluZyhvcHRpb25zLmUpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IodHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJzb3IgbG9jYXRpb24gaW4gYSB0ZXh0IGRlcGVuZGluZyBvbiBwYXNzZWQgcG9pbnRlciAoeC95KSBvYmplY3RcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHNldEN1cnNvckJ5Q2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKGUpLFxuICAgICAgICBzdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIGVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHN0YXJ0LCBlbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpbmRleCBvZiBhIGNoYXJhY3RlciBjb3JyZXNwb25kaW5nIHRvIHdoZXJlIGFuIG9iamVjdCB3YXMgY2xpY2tlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAqL1xuICBnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG1vdXNlT2Zmc2V0ID0gdGhpcy5nZXRMb2NhbFBvaW50ZXIoZSksXG4gICAgICAgIHByZXZXaWR0aCA9IDAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgY2hhckluZGV4ID0gMCxcbiAgICAgICAgbGluZUluZGV4ID0gMCxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGxpbmU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaGVpZ2h0IDw9IG1vdXNlT2Zmc2V0LnkpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxpbmVJbmRleCA9IGk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGNoYXJJbmRleCArPSB0aGlzLl90ZXh0TGluZXNbaSAtIDFdLmxlbmd0aCArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQoaSAtIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KTtcbiAgICB3aWR0aCA9IGxpbmVMZWZ0T2Zmc2V0ICogdGhpcy5zY2FsZVg7XG4gICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdO1xuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIHByZXZXaWR0aCA9IHdpZHRoO1xuICAgICAgLy8gaSByZW1vdmVkIHNvbWV0aGluZyBhYm91dCBmbGlwWCBoZXJlLCBjaGVjay5cbiAgICAgIHdpZHRoICs9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bal0ua2VybmVkV2lkdGggKiB0aGlzLnNjYWxlWDtcbiAgICAgIGlmICh3aWR0aCA8PSBtb3VzZU9mZnNldC54KSB7XG4gICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0KG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBjaGFySW5kZXgsIGpsZW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldDogZnVuY3Rpb24obW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGluZGV4LCBqbGVuKSB7XG4gICAgLy8gd2UgbmVlZCBNYXRoLmFicyBiZWNhdXNlIHdoZW4gd2lkdGggaXMgYWZ0ZXIgdGhlIGxhc3QgY2hhciwgdGhlIG9mZnNldCBpcyBnaXZlbiBhcyAxLCB3aGlsZSBpcyAwXG4gICAgdmFyIGRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IgPSBtb3VzZU9mZnNldC54IC0gcHJldldpZHRoLFxuICAgICAgICBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yID0gd2lkdGggLSBtb3VzZU9mZnNldC54LFxuICAgICAgICBvZmZzZXQgPSBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yID4gZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciB8fFxuICAgICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPCAwID8gMCA6IDEsXG4gICAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gaW5kZXggKyBvZmZzZXQ7XG4gICAgLy8gaWYgb2JqZWN0IGlzIGhvcml6b250YWxseSBmbGlwcGVkLCBtaXJyb3IgY3Vyc29yIGxvY2F0aW9uIGZyb20gdGhlIGVuZFxuICAgIGlmICh0aGlzLmZsaXBYKSB7XG4gICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IGpsZW4gLSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICB9XG5cbiAgICBpZiAobmV3U2VsZWN0aW9uU3RhcnQgPiB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gIH1cbn0pO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgaGlkZGVuIHRleHRhcmVhIChuZWVkZWQgdG8gYnJpbmcgdXAga2V5Ym9hcmQgaW4gaU9TKVxuICAgKi9cbiAgaW5pdEhpZGRlblRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmFicmljLWhpZGRlbnRleHRhcmVhJywgJycpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCd3cmFwJywgJ29mZicpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgLy8gbGluZS1oZWlnaHQ6IDFweDsgd2FzIHJlbW92ZWQgZnJvbSB0aGUgc3R5bGUgdG8gZml4IHRoaXM6XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODcwOTY2XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAnICsgc3R5bGUudG9wICtcbiAgICAnOyBsZWZ0OiAnICsgc3R5bGUubGVmdCArICc7IHotaW5kZXg6IC05OTk7IG9wYWNpdHk6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMXB4OyBmb250LXNpemU6IDFweDsnICtcbiAgICAnIHBhZGRpbmfvvbB0b3A6ICcgKyBzdHlsZS5mb250U2l6ZSArICc7JztcbiAgICBmYWJyaWMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcblxuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleXVwJywgdGhpcy5vbktleVVwLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdpbnB1dCcsIHRoaXMub25JbnB1dC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29weScsIHRoaXMuY29weS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY3V0JywgdGhpcy5jb3B5LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdwYXN0ZScsIHRoaXMucGFzdGUuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9uc3RhcnQnLCB0aGlzLm9uQ29tcG9zaXRpb25TdGFydC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb251cGRhdGUnLCB0aGlzLm9uQ29tcG9zaXRpb25VcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9uZW5kJywgdGhpcy5vbkNvbXBvc2l0aW9uRW5kLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCF0aGlzLl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5jYW52YXMudXBwZXJDYW52YXNFbCwgJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlEb3duXG4gICAqIE1hcCBhIHNwZWNpYWwga2V5IHRvIGEgZnVuY3Rpb24gb2YgdGhlIGluc3RhbmNlL3Byb3RvdHlwZVxuICAgKiBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgYmVoYXZpb3VyIGZvciBFU0Mgb3IgVEFCIG9yIGFycm93cywgeW91IGhhdmUgdG8gY2hhbmdlXG4gICAqIHRoaXMgbWFwIHNldHRpbmcgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiB0aGF0IHlvdSBidWlsZCBvbiB0aGUgZmFicmljLkl0ZXh0IG9yXG4gICAqIHlvdXIgcHJvdG90eXBlLlxuICAgKiB0aGUgbWFwIGNoYW5nZSB3aWxsIGFmZmVjdCBhbGwgSW5zdGFuY2VzIHVubGVzcyB5b3UgbmVlZCBmb3Igb25seSBzb21lIHRleHQgSW5zdGFuY2VzXG4gICAqIGluIHRoYXQgY2FzZSB5b3UgaGF2ZSB0byBjbG9uZSB0aGlzIG9iamVjdCBhbmQgYXNzaWduIHlvdXIgSW5zdGFuY2UuXG4gICAqIHRoaXMua2V5c01hcCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSh0aGlzLmtleXNNYXApO1xuICAgKiBUaGUgZnVuY3Rpb24gbXVzdCBiZSBpbiBmYWJyaWMuSXRleHQucHJvdG90eXBlLm15RnVuY3Rpb24gQW5kIHdpbGwgcmVjZWl2ZSBldmVudCBhcyBhcmdzWzBdXG4gICAqL1xuICBrZXlzTWFwOiB7XG4gICAgOTogICdleGl0RWRpdGluZycsXG4gICAgMjc6ICdleGl0RWRpdGluZycsXG4gICAgMzM6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM0OiAnbW92ZUN1cnNvckRvd24nLFxuICAgIDM1OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICAzNjogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzNzogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzODogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzk6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDQwOiAnbW92ZUN1cnNvckRvd24nLFxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleVVwICsgY3RybCB8fCBjbWRcbiAgICovXG4gIGN0cmxLZXlzTWFwVXA6IHtcbiAgICA2NzogJ2NvcHknLFxuICAgIDg4OiAnY3V0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleURvd24gKyBjdHJsIHx8IGNtZFxuICAgKi9cbiAgY3RybEtleXNNYXBEb3duOiB7XG4gICAgNjU6ICdzZWxlY3RBbGwnXG4gIH0sXG5cbiAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgLy8gTm8gbmVlZCB0byB0cmlnZ2VyIGNsaWNrIGV2ZW50IGhlcmUsIGZvY3VzIGlzIGVub3VnaCB0byBoYXZlIHRoZSBrZXlib2FyZCBhcHBlYXIgb24gQW5kcm9pZFxuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRcbiAgICogb25seSB1c2VkIGZvciBhcnJvd3MgYW5kIGNvbWJpbmF0aW9uIG9mIG1vZGlmaWVyIGtleXMuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbktleURvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLmtleUNvZGUgaW4gdGhpcy5rZXlzTWFwKSB7XG4gICAgICB0aGlzW3RoaXMua2V5c01hcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGUua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwRG93bikgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBEb3duW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGUua2V5Q29kZSA+PSAzMyAmJiBlLmtleUNvZGUgPD0gNDApIHtcbiAgICAgIC8vIGlmIGkgcHJlc3MgYW4gYXJyb3cga2V5IGp1c3QgdXBkYXRlIHNlbGVjdGlvblxuICAgICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50XG4gICAqIFdlIGhhbmRsZSBLZXlVcCBiZWNhdXNlIGllMTEgYW5kIGVkZ2UgaGF2ZSBkaWZmaWN1bHRpZXMgY29weS9wYXN0aW5nXG4gICAqIGlmIGEgY29weS9jdXQgZXZlbnQgZmlyZWQsIGtleXVwIGlzIGRpc21pc3NlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5fY29weURvbmUgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgdGhpcy5fY29weURvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcFVwKSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHRoaXNbdGhpcy5jdHJsS2V5c01hcFVwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG9uSW5wdXQgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uSW5wdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZnJvbVBhc3RlID0gdGhpcy5mcm9tUGFzdGU7XG4gICAgdGhpcy5mcm9tUGFzdGUgPSBmYWxzZTtcbiAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZWNpc2lvbnMgYWJvdXQgc3R5bGUgY2hhbmdlcy5cbiAgICB2YXIgbmV4dFRleHQgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSkuZ3JhcGhlbWVUZXh0LFxuICAgICAgICBjaGFyQ291bnQgPSB0aGlzLl90ZXh0Lmxlbmd0aCxcbiAgICAgICAgbmV4dENoYXJDb3VudCA9IG5leHRUZXh0Lmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlZFRleHQsIGluc2VydGVkVGV4dCxcbiAgICAgICAgY2hhckRpZmYgPSBuZXh0Q2hhckNvdW50IC0gY2hhckNvdW50LFxuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kLFxuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kLFxuICAgICAgICBjb3BpZWRTdHlsZSwgcmVtb3ZlRnJvbSwgcmVtb3ZlVG87XG4gICAgaWYgKHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLnN0eWxlcyA9IHsgfTtcbiAgICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgICB0aGlzLmZpcmUoJ2NoYW5nZWQnKTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0YXJlYVNlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQsXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlXG4gICAgKTtcbiAgICB2YXIgYmFja0RlbGV0ZSA9IHNlbGVjdGlvblN0YXJ0ID4gdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uU3RhcnQ7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICBjaGFyRGlmZiArPSBzZWxlY3Rpb25FbmQgLSBzZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dENoYXJDb3VudCA8IGNoYXJDb3VudCkge1xuICAgICAgaWYgKGJhY2tEZWxldGUpIHtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHNlbGVjdGlvbkVuZCArIGNoYXJEaWZmLCBzZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uU3RhcnQgLSBjaGFyRGlmZik7XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydGVkVGV4dCA9IG5leHRUZXh0LnNsaWNlKHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvbkVuZCAtIGNoYXJEaWZmLCB0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQpO1xuICAgIGlmIChyZW1vdmVkVGV4dCAmJiByZW1vdmVkVGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmIChpbnNlcnRlZFRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIGxldCdzIGNvcHkgc29tZSBzdHlsZSBiZWZvcmUgZGVsZXRpbmcuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gY29weSB0aGUgc3R5bGUgYmVmb3JlIHRoZSBjdXJzb3IgT1IgdGhlIHN0eWxlIGF0IHRoZSBjdXJzb3IgaWYgc2VsZWN0aW9uXG4gICAgICAgIC8vIGlzIGJpZ2dlciB0aGFuIDAuXG4gICAgICAgIGNvcGllZFN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZXMoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvblN0YXJ0ICsgMSwgZmFsc2UpO1xuICAgICAgICAvLyBub3cgZHVwbGljYXRlIHRoZSBzdHlsZSBvbmUgZm9yIGVhY2ggaW5zZXJ0ZWQgdGV4dC5cbiAgICAgICAgY29waWVkU3R5bGUgPSBpbnNlcnRlZFRleHQubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHRoaXMgcmV0dXJuIGFuIGFycmF5IG9mIHJlZmVyZW5jZXMsIGJ1dCB0aGF0IGlzIGZpbmUgc2luY2Ugd2UgYXJlXG4gICAgICAgICAgLy8gY29weWluZyB0aGUgc3R5bGUgbGF0ZXIuXG4gICAgICAgICAgcmV0dXJuIGNvcGllZFN0eWxlWzBdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVtb3ZlRnJvbSA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2tEZWxldGUpIHtcbiAgICAgICAgLy8gZGV0ZWN0IGRpZmZlcmVuY2VzIGJldHdlZW4gZm9yd2FyZERlbGV0ZSBhbmQgYmFja0RlbGV0ZVxuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uRW5kIC0gcmVtb3ZlZFRleHQubGVuZ3RoO1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZCArIHJlbW92ZWRUZXh0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8ocmVtb3ZlRnJvbSwgcmVtb3ZlVG8pO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKGZyb21QYXN0ZSAmJiBpbnNlcnRlZFRleHQuam9pbignJykgPT09IGZhYnJpYy5jb3BpZWRUZXh0ICYmICFmYWJyaWMuZGlzYWJsZVN0eWxlQ29weVBhc3RlKSB7XG4gICAgICAgIGNvcGllZFN0eWxlID0gZmFicmljLmNvcGllZFRleHRTdHlsZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0TmV3U3R5bGVCbG9jayhpbnNlcnRlZFRleHQsIHNlbGVjdGlvblN0YXJ0LCBjb3BpZWRTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBzdGFydFxuICAgKi9cbiAgb25Db21wb3NpdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcG9zaXRpb24gZW5kXG4gICAqL1xuICBvbkNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gIH0sXG5cbiAgLy8gLyoqXG4gIC8vICAqIENvbXBvc2l0aW9uIHVwZGF0ZVxuICAvLyAgKi9cbiAgb25Db21wb3NpdGlvblVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuY29tcG9zaXRpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0O1xuICAgIHRoaXMuY29tcG9zaXRpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQ7XG4gICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcGllcyBzZWxlY3RlZCB0ZXh0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIC8vZG8gbm90IGN1dC1jb3B5IGlmIG5vIHNlbGVjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5jb3BpZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICBpZiAoIWZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUpIHtcbiAgICAgIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLmNvcGllZFRleHRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2NvcHlEb25lID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzdGVzIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHBhc3RlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZyb21QYXN0ZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gQ2xpcGJvYXJkIGRhdGEgb2JqZWN0XG4gICAqL1xuICBfZ2V0Q2xpcGJvYXJkRGF0YTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLmNsaXBib2FyZERhdGEpIHx8IGZhYnJpYy53aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIHdpZHRoIGluIHBpeGVscyBiZWZvcmUgdGhlIGN1cnNvciBvbiB0aGUgc2FtZSBsaW5lXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoQmVmb3JlQ3Vyc29yIHdpZHRoIGJlZm9yZSBjdXJzb3JcbiAgICovXG4gIF9nZXRXaWR0aEJlZm9yZUN1cnNvcjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLCBib3VuZDtcblxuICAgIGlmIChjaGFySW5kZXggPiAwKSB7XG4gICAgICBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICB3aWR0aEJlZm9yZUN1cnNvciArPSBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aEJlZm9yZUN1cnNvcjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBzdGFydCBvZmZzZXQgb2YgYSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldERvd25DdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICAvLyBpZiBvbiBsYXN0IGxpbmUsIGRvd24gY3Vyc29yIGdvZXMgdG8gZW5kIG9mIGxpbmVcbiAgICBpZiAobGluZUluZGV4ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMSB8fCBlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNCkge1xuICAgICAgLy8gbW92ZSB0byB0aGUgZW5kIG9mIGEgdGV4dFxuICAgICAgcmV0dXJuIHRoaXMuX3RleHQubGVuZ3RoIC0gc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggKyAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRBZnRlckN1cnNvciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLnNsaWNlKGNoYXJJbmRleCk7XG4gICAgcmV0dXJuIHRleHRBZnRlckN1cnNvci5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lICsgMSArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQobGluZUluZGV4KTtcbiAgfSxcblxuICAvKipcbiAgICogcHJpdmF0ZVxuICAgKiBIZWxwcyBmaW5kaW5nIGlmIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGNvdW50ZWQgZnJvbSBTdGFydCBvciBFbmRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiBpc1JpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VXBDdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICBpZiAobGluZUluZGV4ID09PSAwIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDMzKSB7XG4gICAgICAvLyBpZiBvbiBmaXJzdCBsaW5lLCB1cCBjdXJzb3IgZ29lcyB0byBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gLXNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4IC0gMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoMCwgY2hhckluZGV4KSxcbiAgICAgICAgbWlzc2luZ05ld2xpbmVPZmZzZXQgPSB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGxpbmVJbmRleCAtIDEpO1xuICAgIC8vIHJldHVybiBhIG5lZ2F0aXZlIG9mZnNldFxuICAgIHJldHVybiAtdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleCAtIDFdLmxlbmd0aFxuICAgICArIGluZGV4T25PdGhlckxpbmUgLSB0ZXh0QmVmb3JlQ3Vyc29yLmxlbmd0aCArICgxIC0gbWlzc2luZ05ld2xpbmVPZmZzZXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmb3IgYSBnaXZlbiB3aWR0aCBpdCBmb3VuZHMgdGhlIG1hdGNoaW5nIGNoYXJhY3Rlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRJbmRleE9uTGluZTogZnVuY3Rpb24obGluZUluZGV4LCB3aWR0aCkge1xuXG4gICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLFxuICAgICAgICB3aWR0aE9mQ2hhcnNPbkxpbmUgPSBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgaW5kZXhPbkxpbmUgPSAwLCBjaGFyV2lkdGgsIGZvdW5kTWF0Y2g7XG5cbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBjaGFyV2lkdGggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2pdLndpZHRoO1xuICAgICAgd2lkdGhPZkNoYXJzT25MaW5lICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmICh3aWR0aE9mQ2hhcnNPbkxpbmUgPiB3aWR0aCkge1xuICAgICAgICBmb3VuZE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxlZnRFZGdlID0gd2lkdGhPZkNoYXJzT25MaW5lIC0gY2hhcldpZHRoLFxuICAgICAgICAgICAgcmlnaHRFZGdlID0gd2lkdGhPZkNoYXJzT25MaW5lLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbUxlZnRFZGdlID0gTWF0aC5hYnMobGVmdEVkZ2UgLSB3aWR0aCksXG4gICAgICAgICAgICBvZmZzZXRGcm9tUmlnaHRFZGdlID0gTWF0aC5hYnMocmlnaHRFZGdlIC0gd2lkdGgpO1xuXG4gICAgICAgIGluZGV4T25MaW5lID0gb2Zmc2V0RnJvbVJpZ2h0RWRnZSA8IG9mZnNldEZyb21MZWZ0RWRnZSA/IGogOiAoaiAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFjaGVkIGVuZFxuICAgIGlmICghZm91bmRNYXRjaCkge1xuICAgICAgaW5kZXhPbkxpbmUgPSBsaW5lLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4T25MaW5lO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBkb3duXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yRG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMuX3RleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JVcE9yRG93bignRG93bicsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXBcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JVcE9yRG93bignVXAnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwIG9yIGRvd24sIGZpcmVzIHRoZSBldmVudHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnVXAnIG9yICdEb3duJ1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX21vdmVDdXJzb3JVcE9yRG93bjogZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgLy8gZ2V0VXBDdXJzb3JPZmZzZXRcbiAgICAvLyBnZXREb3duQ3Vyc29yT2Zmc2V0XG4gICAgdmFyIGFjdGlvbiA9ICdnZXQnICsgZGlyZWN0aW9uICsgJ0N1cnNvck9mZnNldCcsXG4gICAgICAgIG9mZnNldCA9IHRoaXNbYWN0aW9uXShlLCB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLm1vdmVDdXJzb3JXaXRoU2hpZnQob2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm1vdmVDdXJzb3JXaXRob3V0U2hpZnQob2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25JbkJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcbiAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHdpdGggc2hpZnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgbW92ZUN1cnNvcldpdGhTaGlmdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnXG4gICAgICA/IHRoaXMuc2VsZWN0aW9uU3RhcnQgKyBvZmZzZXRcbiAgICAgIDogdGhpcy5zZWxlY3Rpb25FbmQgKyBvZmZzZXQ7XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgd2l0aG91dCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ0xlZnQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgX21vdmU6IGZ1bmN0aW9uKGUsIHByb3AsIGRpcmVjdGlvbikge1xuICAgIHZhciBuZXdWYWx1ZTtcbiAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZFdvcmRCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNSB8fCAgZS5rZXlDb2RlID09PSAzNiApIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZExpbmVCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcF0gKz0gZGlyZWN0aW9uID09PSAnTGVmdCcgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbcHJvcF0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZUxlZnQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnTGVmdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVSaWdodDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdSaWdodCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZSA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuXG4gICAgLy8gb25seSBtb3ZlIGN1cnNvciB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbixcbiAgICAvLyBvdGhlcndpc2Ugd2UgZGlzY2FyZCBpdCwgYW5kIGxlYXZlIGN1cnNvciBvbiBzYW1lIHBsYWNlXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID09PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApIHtcbiAgICAgIGNoYW5nZSA9IHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuXG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IDApe1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ1JpZ2h0JywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCBvciBMZWZ0LCBmaXJlcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICdMZWZ0JywgJ1JpZ2h0J1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX21vdmVDdXJzb3JMZWZ0T3JSaWdodDogZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgdmFyIGFjdGlvbk5hbWUgPSAnbW92ZUN1cnNvcicgKyBkaXJlY3Rpb24gKyAnV2l0aCc7XG4gICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIGFjdGlvbk5hbWUgKz0gJ1NoaWZ0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdvdXRTaGlmdCc7XG4gICAgfVxuICAgIGlmICh0aGlzW2FjdGlvbk5hbWVdKGUpKSB7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCB3aGlsZSBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHRXaXRoU2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRW5kICE9PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICBjaGFuZ2VkID0gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY2hhcmFjdGVycyBmcm9tIHN0YXJ0L2VuZFxuICAgKiBzdGFydC9lbmQgYXIgcGVyIGdyYXBoZW1lIHBvc2l0aW9uIGluIF90ZXh0IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBkZWZhdWx0IHRvIHN0YXJ0ICsgMVxuICAgKi9cbiAgcmVtb3ZlQ2hhcnM6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0ICsgMTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhzdGFydCwgZW5kKTtcbiAgICB0aGlzLl90ZXh0LnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHQuam9pbignJyk7XG4gICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBpbnNlcnQgY2hhcmFjdGVycyBhdCBzdGFydCBwb3NpdGlvbiwgYmVmb3JlIHN0YXJ0IHBvc2l0aW9uLlxuICAgKiBzdGFydCAgZXF1YWwgMSBpdCBtZWFucyB0aGUgdGV4dCBnZXQgaW5zZXJ0ZWQgYmV0d2VlbiBhY3R1YWwgZ3JhcGhlbWUgMCBhbmQgMVxuICAgKiBpZiBzdHlsZSBhcnJheSBpcyBwcm92aWRlZCwgaXQgbXVzdCBiZSBhcyB0aGUgc2FtZSBsZW5ndGggb2YgdGV4dCBpbiBncmFwaGVtZXNcbiAgICogaWYgZW5kIGlzIHByb3ZpZGVkIGFuZCBpcyBiaWdnZXIgdGhhbiBzdGFydCwgb2xkIHRleHQgaXMgcmVwbGFjZWQuXG4gICAqIHN0YXJ0L2VuZCBhciBwZXIgZ3JhcGhlbWUgcG9zaXRpb24gaW4gX3RleHQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlIGFycmF5IG9mIHN0eWxlIG9iamVjdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgZGVmYXVsdCB0byBzdGFydCArIDFcbiAgICovXG4gIGluc2VydENoYXJzOiBmdW5jdGlvbih0ZXh0LCBzdHlsZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgdmFyIGdyYXBoZW1lcyA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHRleHQpO1xuICAgIHRoaXMuaW5zZXJ0TmV3U3R5bGVCbG9jayhncmFwaGVtZXMsIHN0YXJ0LCBzdHlsZSk7XG4gICAgdGhpcy5fdGV4dCA9IFtdLmNvbmNhdCh0aGlzLl90ZXh0LnNsaWNlKDAsIHN0YXJ0KSwgZ3JhcGhlbWVzLCB0aGlzLl90ZXh0LnNsaWNlKGVuZCkpO1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHQuam9pbignJyk7XG4gICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlRXh0cmFuZW91c1N0eWxlcygpO1xuICB9LFxuXG59KTtcblxuXG4vKiBfVE9fU1ZHX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBtdWx0aXBsZVNwYWNlc1JlZ2V4ID0gLyAgKy9nO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cygpLFxuICAgICAgICAgIHRleHRBbmRCZyA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhvZmZzZXRzLnRleHRUb3AsIG9mZnNldHMudGV4dExlZnQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTVkdUZXh0QW5kQmcodGV4dEFuZEJnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKFxuICAgICAgICB0aGlzLl90b1NWRygpLFxuICAgICAgICB7IHJldml2ZXI6IHJldml2ZXIsIG5vU3R5bGU6IHRydWUsIHdpdGhTaGFkb3c6IHRydWUgfVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U1ZHTGVmdFRvcE9mZnNldHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dExlZnQ6IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgdGV4dFRvcDogLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgbGluZVRvcDogdGhpcy5nZXRIZWlnaHRPZkxpbmUoMClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dyYXBTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRBbmRCZykge1xuICAgICAgdmFyIG5vU2hhZG93ID0gdHJ1ZSxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24odGhpcyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0ZXh0QW5kQmcudGV4dEJnUmVjdHMuam9pbignJyksXG4gICAgICAgICdcXHRcXHQ8dGV4dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiICcsXG4gICAgICAgICh0aGlzLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgdGhpcy5mb250RmFtaWx5LnJlcGxhY2UoL1wiL2csICdcXCcnKSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgdGhpcy5mb250U2l6ZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyB0aGlzLmZvbnRTdHlsZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHRoaXMuZm9udFdlaWdodCArICdcIiAnIDogJycpLFxuICAgICAgICAodGV4dERlY29yYXRpb24gPyAndGV4dC1kZWNvcmF0aW9uPVwiJyArIHRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKG5vU2hhZG93KSwgJ1wiJywgdGhpcy5hZGRQYWludE9yZGVyKCksICcgPicsXG4gICAgICAgIHRleHRBbmRCZy50ZXh0U3BhbnMuam9pbignJyksXG4gICAgICAgICc8L3RleHQ+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dFRvcE9mZnNldCBUZXh0IHRvcCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dExlZnRPZmZzZXQgVGV4dCBsZWZ0IG9mZnNldFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0U1ZHVGV4dEFuZEJnOiBmdW5jdGlvbih0ZXh0VG9wT2Zmc2V0LCB0ZXh0TGVmdE9mZnNldCkge1xuICAgICAgdmFyIHRleHRTcGFucyA9IFtdLFxuICAgICAgICAgIHRleHRCZ1JlY3RzID0gW10sXG4gICAgICAgICAgaGVpZ2h0ID0gdGV4dFRvcE9mZnNldCwgbGluZU9mZnNldDtcbiAgICAgIC8vIGJvdW5kaW5nLWJveCBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLl9zZXRTVkdCZyh0ZXh0QmdSZWN0cyk7XG5cbiAgICAgIC8vIHRleHQgYW5kIHRleHQtYmFja2dyb3VuZFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGlmICh0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVCZyh0ZXh0QmdSZWN0cywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFNWR1RleHRMaW5lVGV4dCh0ZXh0U3BhbnMsIGksIHRleHRMZWZ0T2Zmc2V0ICsgbGluZU9mZnNldCwgaGVpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0U3BhbnM6IHRleHRTcGFucyxcbiAgICAgICAgdGV4dEJnUmVjdHM6IHRleHRCZ1JlY3RzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVUZXh0Q2hhclNwYW46IGZ1bmN0aW9uKF9jaGFyLCBzdHlsZURlY2wsIGxlZnQsIHRvcCkge1xuICAgICAgdmFyIHNob3VsZFVzZVdoaXRlc3BhY2UgPSBfY2hhciAhPT0gX2NoYXIudHJpbSgpIHx8IF9jaGFyLm1hdGNoKG11bHRpcGxlU3BhY2VzUmVnZXgpLFxuICAgICAgICAgIHN0eWxlUHJvcHMgPSB0aGlzLmdldFN2Z1NwYW5TdHlsZXMoc3R5bGVEZWNsLCBzaG91bGRVc2VXaGl0ZXNwYWNlKSxcbiAgICAgICAgICBmaWxsU3R5bGVzID0gc3R5bGVQcm9wcyA/ICdzdHlsZT1cIicgKyBzdHlsZVByb3BzICsgJ1wiJyA6ICcnLFxuICAgICAgICAgIGR5ID0gc3R5bGVEZWNsLmRlbHRhWSwgZHlTcGFuID0gJycsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIGlmIChkeSkge1xuICAgICAgICBkeVNwYW4gPSAnIGR5PVwiJyArIHRvRml4ZWQoZHksIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHRzcGFuIHg9XCInLCB0b0ZpeGVkKGxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgeT1cIicsXG4gICAgICAgIHRvRml4ZWQodG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiICcsIGR5U3BhbixcbiAgICAgICAgZmlsbFN0eWxlcywgJz4nLFxuICAgICAgICBmYWJyaWMudXRpbC5zdHJpbmcuZXNjYXBlWG1sKF9jaGFyKSxcbiAgICAgICAgJzwvdHNwYW4+J1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lVGV4dDogZnVuY3Rpb24odGV4dFNwYW5zLCBsaW5lSW5kZXgsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCksXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBhY3R1YWxTdHlsZSxcbiAgICAgICAgICBuZXh0U3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnLFxuICAgICAgICAgIGNoYXJCb3gsIHN0eWxlLFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgdGltZVRvUmVuZGVyO1xuXG4gICAgICB0ZXh0VG9wT2Zmc2V0ICs9IGxpbmVIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmUubGVuZ3RoIC0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB0aW1lVG9SZW5kZXIgPSBpID09PSBsZW4gfHwgdGhpcy5jaGFyU3BhY2luZztcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gY2hhckJveC5rZXJuZWRXaWR0aCAtIGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0p1c3RpZnkgJiYgIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtpXSkpIHtcbiAgICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBjaGFyU3BhY2luZywgd2UgcmVuZGVyIGNoYXIgYnkgY2hhclxuICAgICAgICAgIGFjdHVhbFN0eWxlID0gYWN0dWFsU3R5bGUgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKTtcbiAgICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkgKyAxKTtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0aGlzLl9oYXNTdHlsZUNoYW5nZWRGb3JTdmcoYWN0dWFsU3R5bGUsIG5leHRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpIHx8IHsgfTtcbiAgICAgICAgICB0ZXh0U3BhbnMucHVzaCh0aGlzLl9jcmVhdGVUZXh0Q2hhclNwYW4oY2hhcnNUb1JlbmRlciwgc3R5bGUsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSk7XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIGFjdHVhbFN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHVzaFRleHRCZ1JlY3Q6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBjb2xvciwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyhjb2xvciksXG4gICAgICAgICcgeD1cIicsXG4gICAgICAgIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICB0b0ZpeGVkKHdpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgIHRvRml4ZWQoaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBpLCBsZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgYm94U3RhcnQgPSAwLFxuICAgICAgICAgIGNoYXJCb3gsIGN1cnJlbnRDb2xvcixcbiAgICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICBpZiAoY3VycmVudENvbG9yICE9PSBsYXN0Q29sb3IpIHtcbiAgICAgICAgICBsYXN0Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGxhc3RDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgdGV4dFRvcE9mZnNldCwgYm94V2lkdGgsIGhlaWdodE9mTGluZSk7XG4gICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgIGxhc3RDb2xvciA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGN1cnJlbnRDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRvYmUgSWxsdXN0cmF0b3IgKGF0IGxlYXN0IENTNSkgaXMgdW5hYmxlIHRvIHJlbmRlciByZ2JhKCktYmFzZWQgZmlsbCB2YWx1ZXNcbiAgICAgKiB3ZSB3b3JrIGFyb3VuZCBpdCBieSBcIm1vdmluZ1wiIGFscGhhIGNoYW5uZWwgaW50byBvcGFjaXR5IGF0dHJpYnV0ZSBhbmQgc2V0dGluZyBmaWxsJ3MgYWxwaGEgdG8gMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9nZXRGaWxsQXR0cmlidXRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgPyBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSA6ICcnO1xuICAgICAgaWYgKCFmaWxsQ29sb3IgfHwgIWZpbGxDb2xvci5nZXRTb3VyY2UoKSB8fCBmaWxsQ29sb3IuZ2V0QWxwaGEoKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2ZpbGw9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdvcGFjaXR5PVwiJyArIGZpbGxDb2xvci5nZXRBbHBoYSgpICsgJ1wiIGZpbGw9XCInICsgZmlsbENvbG9yLnNldEFscGhhKDEpLnRvUmdiKCkgKyAnXCInO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMaW5lVG9wT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lVG9wT2Zmc2V0ID0gMCwgbGFzdEhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVJbmRleDsgaisrKSB7XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICB9XG4gICAgICBsYXN0SGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lVG9wOiBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICBvZmZzZXQ6ICh0aGlzLl9mb250U2l6ZU11bHQgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIGxhc3RIZWlnaHQgLyAodGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0KVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuICAgICAgdmFyIHN2Z1N0eWxlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuZ2V0U3ZnU3R5bGVzLmNhbGwodGhpcywgc2tpcFNoYWRvdyk7XG4gICAgICByZXR1cm4gc3ZnU3R5bGUgKyAnIHdoaXRlLXNwYWNlOiBwcmU7JztcbiAgICB9LFxuICB9KTtcbn0pKCk7XG4vKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0ge30pO1xuXG4gIC8qKlxuICAgKiBUZXh0Ym94IGNsYXNzLCBiYXNlZCBvbiBJVGV4dCwgYWxsb3dzIHRoZSB1c2VyIHRvIHJlc2l6ZSB0aGUgdGV4dCByZWN0YW5nbGVcbiAgICogYW5kIHdyYXBzIGxpbmVzIGF1dG9tYXRpY2FsbHkuIFRleHRib3hlcyBoYXZlIHRoZWlyIFkgc2NhbGluZyBsb2NrZWQsIHRoZVxuICAgKiB1c2VyIGNhbiBvbmx5IGNoYW5nZSB3aWR0aC4gSGVpZ2h0IGlzIGFkanVzdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlXG4gICAqIHdyYXBwaW5nIG9mIGxpbmVzLlxuICAgKiBAY2xhc3MgZmFicmljLlRleHRib3hcbiAgICogQGV4dGVuZHMgZmFicmljLklUZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dGJveH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dGJveCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHRib3ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuSVRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3RleHRib3gnLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSB3aWR0aCBvZiB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5XaWR0aDogMjAsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGNhbGN1bGF0ZWQgd2lkdGggb2YgYSB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogZml4ZWQgdG8gMiBzbyB0aGF0IGFuIGVtcHR5IHRleHRib3ggY2Fubm90IGdvIHRvIDBcbiAgICAgKiBhbmQgaXMgc3RpbGwgc2VsZWN0YWJsZSB3aXRob3V0IHRleHQuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkeW5hbWljTWluV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgYXJyYXkgb2YgdGV4dCB3cmFwcGluZy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIF9fY2FjaGVkTGluZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc3RhbmRhcmQgT2JqZWN0IGNsYXNzIHZhbHVlc1xuICAgICAqIFRleHRib3ggbmVlZHMgdGhpcyBvbiBmYWxzZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzOiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmNvbmNhdCgnd2lkdGgnKSxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCBzdHJpbmdzIGluIGJyZWFrYWJsZSBsaW5lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dvcmRKb2luZXJzOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGJvb2xlYW4gcHJvcGVydHkgaW4gb3JkZXIgdG8gc3BsaXQgc3RyaW5ncyB0aGF0IGhhdmUgbm8gd2hpdGUgc3BhY2UgY29uY2VwdC5cbiAgICAgKiB0aGlzIGlzIGEgY2hlYXAgd2F5IHRvIGhlbHAgd2l0aCBjaGluZXNlL2phcGFuZXNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjYuMFxuICAgICAqL1xuICAgIHNwbGl0QnlHcmFwaGVtZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBVbmxpa2Ugc3VwZXJjbGFzcydzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiwgVGV4dGJveCBkb2VzIG5vdCB1cGRhdGVcbiAgICAgKiBpdHMgd2lkdGguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIC8vIGNsZWFyIGR5bmFtaWNNaW5XaWR0aCBhcyBpdCB3aWxsIGJlIGRpZmZlcmVudCBhZnRlciB3ZSByZS13cmFwIGxpbmVcbiAgICAgIHRoaXMuZHluYW1pY01pbldpZHRoID0gMDtcbiAgICAgIC8vIHdyYXAgbGluZXNcbiAgICAgIHRoaXMuX3N0eWxlTWFwID0gdGhpcy5fZ2VuZXJhdGVTdHlsZU1hcCh0aGlzLl9zcGxpdFRleHQoKSk7XG4gICAgICAvLyBpZiBhZnRlciB3cmFwcGluZywgdGhlIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBkeW5hbWljTWluV2lkdGgsIGNoYW5nZSB0aGUgd2lkdGggYW5kIHJlLXdyYXBcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNNaW5XaWR0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgdGhpcy5fc2V0KCd3aWR0aCcsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xKSB7XG4gICAgICAgIC8vIG9uY2UgdGV4dCBpcyBtZWFzdXJlZCB3ZSBuZWVkIHRvIG1ha2Ugc3BhY2UgZmF0dGVyIHRvIG1ha2UganVzdGlmaWVkIHRleHQuXG4gICAgICAgIHRoaXMuZW5sYXJnZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgLy8gY2xlYXIgY2FjaGUgYW5kIHJlLWNhbGN1bGF0ZSBoZWlnaHRcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYWxjVGV4dEhlaWdodCgpO1xuICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIG9iamVjdCB0aGF0IHRyYW5zbGF0ZXMgdGhlIHN0eWxlIG9iamVjdCBzbyB0aGF0IGl0IGlzXG4gICAgICogYnJva2VuIHVwIGJ5IHZpc3VhbCBsaW5lcyAobmV3IGxpbmVzIGFuZCBhdXRvbWF0aWMgd3JhcHBpbmcpLlxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHN0eWxlcyBvYmplY3QgaXMgYnJva2VuIHVwIGJ5IGFjdHVhbCBsaW5lcyAobmV3IGxpbmVzIG9ubHkpLFxuICAgICAqIHdoaWNoIGlzIG9ubHkgc3VmZmljaWVudCBmb3IgVGV4dCAvIElUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVTdHlsZU1hcDogZnVuY3Rpb24odGV4dEluZm8pIHtcbiAgICAgIHZhciByZWFsTGluZUNvdW50ICAgICA9IDAsXG4gICAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgPSAwLFxuICAgICAgICAgIGNoYXJDb3VudCAgICAgICAgID0gMCxcbiAgICAgICAgICBtYXAgICAgICAgICAgICAgICA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRJbmZvLmdyYXBoZW1lTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRleHRJbmZvLmdyYXBoZW1lVGV4dFtjaGFyQ291bnRdID09PSAnXFxuJyAmJiBpID4gMCkge1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMDtcbiAgICAgICAgICBjaGFyQ291bnQrKztcbiAgICAgICAgICByZWFsTGluZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3BsaXRCeUdyYXBoZW1lICYmIHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdCh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBvbiBhIHNwZWNpZmllZCBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3R5bGVIYXM6IGZ1bmN0aW9uKHByb3BlcnR5LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuc3R5bGVIYXMuY2FsbCh0aGlzLCBwcm9wZXJ0eSwgbGluZUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgbm8gc3R5bGluZyBvciBubyBzdHlsaW5nIGluIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggLCBsaW5lSW5kZXggaXMgb24gd3JhcHBlZCBsaW5lcy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHlTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSAwLCBuZXh0TGluZUluZGV4ID0gbGluZUluZGV4ICsgMSwgbmV4dE9mZnNldCwgb2JqLCBzaG91bGRMaW1pdCA9IGZhbHNlLFxuICAgICAgICAgIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0sIG1hcE5leHRMaW5lID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV07XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBvZmZzZXQgPSBtYXAub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG1hcE5leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lSW5kZXggPSBtYXBOZXh0TGluZS5saW5lO1xuICAgICAgICBzaG91bGRMaW1pdCA9IG5leHRMaW5lSW5kZXggPT09IGxpbmVJbmRleDtcbiAgICAgICAgbmV4dE9mZnNldCA9IG1hcE5leHRMaW5lLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHAyID49IG9mZnNldCAmJiAoIXNob3VsZExpbWl0IHx8IHAyIDwgbmV4dE9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcm9iYWJseSBicm9rZW4gbmVlZCBhIGZpeFxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgc3R5bGUgbGluZSB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHdyYXBwZWQgbGluZUluZGV4IGxpbmVcbiAgICAgKiBVc2VkIGp1c3QgdG8gdmVyaWZ5IGlmIHRoZSBsaW5lIGRvZXMgZXhpc3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaWYgdGhlIGxpbmUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHJldHVybiAhIXRoaXMuc3R5bGVzW21hcC5saW5lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsaW5lIHN0eWxlIHRvIGFuIGVtcHR5IG9iamVjdCBzbyB0aGF0IGlzIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHRoaXMuc3R5bGVzW21hcC5saW5lXSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzIFRoZSBzdHJpbmcgYXJyYXkgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdG9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihsaW5lcywgZGVzaXJlZFdpZHRoKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IFtdLCBpO1xuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5jb25jYXQodGhpcy5fd3JhcExpbmUobGluZXNbaV0sIGksIGRlc2lyZWRXaWR0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgYSBzdHJpbmcgb2YgdGV4dCwgZ2l2ZW4gaXRzIGxpbmVJbmRleCBhbmQgY2hhckluZGV4IG9mZnNldFxuICAgICAqIGl0IGdldHMgY2FsbGVkIHdoZW4gY2hhckJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tZWFzdXJlV29yZDogZnVuY3Rpb24od29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0ID0gdHJ1ZTtcbiAgICAgIGNoYXJPZmZzZXQgPSBjaGFyT2Zmc2V0IHx8IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3god29yZFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCk7XG4gICAgICAgIHdpZHRoICs9IGJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gd29yZFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBsaW5lIG9mIHRleHQgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGFuZCBhIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgZ3JhcGhlbWUgYXJyYXkgdGhhdCByZXByZXNlbnQgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRoZSBsaW5lIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc2VydmVkU3BhY2Ugc3BhY2UgdG8gcmVtb3ZlIGZyb20gd3JhcHBpbmcgZm9yIGN1c3RvbSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmUocykgaW50byB3aGljaCB0aGUgZ2l2ZW4gdGV4dCBpcyB3cmFwcGVkXG4gICAgICogdG8uXG4gICAgICovXG4gICAgX3dyYXBMaW5lOiBmdW5jdGlvbihfbGluZSwgbGluZUluZGV4LCBkZXNpcmVkV2lkdGgsIHJlc2VydmVkU3BhY2UpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSAwLFxuICAgICAgICAgIHNwbGl0QnlHcmFwaGVtZSA9IHRoaXMuc3BsaXRCeUdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lTGluZXMgPSBbXSxcbiAgICAgICAgICBsaW5lID0gW10sXG4gICAgICAgICAgLy8gc3BhY2VzIGluIGRpZmZlcmVudCBsYW5ndWFnZXM/XG4gICAgICAgICAgd29yZHMgPSBzcGxpdEJ5R3JhcGhlbWUgPyBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChfbGluZSkgOiBfbGluZS5zcGxpdCh0aGlzLl93b3JkSm9pbmVycyksXG4gICAgICAgICAgd29yZCA9ICcnLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgaW5maXggPSBzcGxpdEJ5R3JhcGhlbWUgPyAnJyA6ICcgJyxcbiAgICAgICAgICB3b3JkV2lkdGggPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWRTcGFjZSA9IHJlc2VydmVkU3BhY2UgfHwgMDtcbiAgICAgIC8vIGZpeCBhIGRpZmZlcmVuY2UgYmV0d2VlbiBzcGxpdCBhbmQgZ3JhcGhlbWVTcGxpdFxuICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB3b3Jkcy5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICAgIGRlc2lyZWRXaWR0aCAtPSByZXNlcnZlZFNwYWNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBpZiB1c2luZyBzcGxpdEJ5R3JhcGhlbWUgd29yZHMgYXJlIGFscmVhZHkgaW4gZ3JhcGhlbWVzLlxuICAgICAgICB3b3JkID0gc3BsaXRCeUdyYXBoZW1lID8gd29yZHNbaV0gOiBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh3b3Jkc1tpXSk7XG4gICAgICAgIHdvcmRXaWR0aCA9IHRoaXMuX21lYXN1cmVXb3JkKHdvcmQsIGxpbmVJbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHdvcmQubGVuZ3RoO1xuXG4gICAgICAgIGxpbmVXaWR0aCArPSBpbmZpeFdpZHRoICsgd29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICBpZiAobGluZVdpZHRoID4gZGVzaXJlZFdpZHRoICYmICFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBncmFwaGVtZUxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgIGxpbmVXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxpbmVXaWR0aCArPSBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxpbmVKdXN0U3RhcnRlZCAmJiAhc3BsaXRCeUdyYXBoZW1lKSB7XG4gICAgICAgICAgbGluZS5wdXNoKGluZml4KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gbGluZS5jb25jYXQod29yZCk7XG5cbiAgICAgICAgaW5maXhXaWR0aCA9IHNwbGl0QnlHcmFwaGVtZSA/IDAgOiB0aGlzLl9tZWFzdXJlV29yZChbaW5maXhdLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBsYXJnZXN0IHdvcmRcbiAgICAgICAgaWYgKHdvcmRXaWR0aCA+IGxhcmdlc3RXb3JkV2lkdGgpIHtcbiAgICAgICAgICBsYXJnZXN0V29yZFdpZHRoID0gd29yZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkgJiYgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgICBpZiAobGFyZ2VzdFdvcmRXaWR0aCArIHJlc2VydmVkU3BhY2UgPiB0aGlzLmR5bmFtaWNNaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IGxhcmdlc3RXb3JkV2lkdGggLSBhZGRpdGlvbmFsU3BhY2UgKyByZXNlcnZlZFNwYWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoZW1lTGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdKSB7XG4gICAgICAgIC8vIGlzIGxhc3QgbGluZSwgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdLmxpbmUgIT09IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0ubGluZSkge1xuICAgICAgICAvLyB0aGlzIGlzIGxhc3QgbGluZSBiZWZvcmUgYSBsaW5lIGJyZWFrLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBhIGxpbmUgaGFzIGEgbGluZWJyZWFrIGFuZCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGl0IHdoZW4gbW92aW5nXG4gICAgICogYW5kIGNvdW50aW5nIHN0eWxlLlxuICAgICAqIEByZXR1cm4gTnVtYmVyXG4gICAgICovXG4gICAgbWlzc2luZ05ld2xpbmVPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuc3BsaXRCeUdyYXBoZW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpID8gMSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBHZXRzIGxpbmVzIG9mIHRleHQgdG8gcmVuZGVyIGluIHRoZSBUZXh0Ym94LiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXNcbiAgICAqIHRleHQgd3JhcHBpbmcgb24gdGhlIGZseSBldmVyeSB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gc3BsaXRcbiAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbGluZXMgaW4gdGhlIFRleHRib3guXG4gICAgKiBAb3ZlcnJpZGVcbiAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBuZXdUZXh0ID0gZmFicmljLlRleHQucHJvdG90eXBlLl9zcGxpdFRleHRJbnRvTGluZXMuY2FsbCh0aGlzLCB0ZXh0KSxcbiAgICAgICAgICBncmFwaGVtZUxpbmVzID0gdGhpcy5fd3JhcFRleHQobmV3VGV4dC5saW5lcywgdGhpcy53aWR0aCksXG4gICAgICAgICAgbGluZXMgPSBuZXcgQXJyYXkoZ3JhcGhlbWVMaW5lcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gZ3JhcGhlbWVMaW5lc1tpXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQubGluZXMgPSBsaW5lcztcbiAgICAgIG5ld1RleHQuZ3JhcGhlbWVMaW5lcyA9IGdyYXBoZW1lTGluZXM7XG4gICAgICByZXR1cm4gbmV3VGV4dDtcbiAgICB9LFxuXG4gICAgZ2V0TWluV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWluV2lkdGgsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVzVG9LZWVwID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3N0eWxlTWFwKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBsaW5lc1RvS2VlcFt0aGlzLl9zdHlsZU1hcFtwcm9wXS5saW5lXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCFsaW5lc1RvS2VlcFtwcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsnbWluV2lkdGgnLCAnc3BsaXRCeUdyYXBoZW1lJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0Ym94XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlRleHRib3ggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlRleHRib3guZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dGJveCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjb250cm9sc1V0aWxzID0gZmFicmljLmNvbnRyb2xzVXRpbHMsXG4gICAgICBzY2FsZVNrZXdTdHlsZUhhbmRsZXIgPSBjb250cm9sc1V0aWxzLnNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcixcbiAgICAgIHNjYWxlU3R5bGVIYW5kbGVyID0gY29udHJvbHNVdGlscy5zY2FsZUN1cnNvclN0eWxlSGFuZGxlcixcbiAgICAgIHNjYWxpbmdFcXVhbGx5ID0gY29udHJvbHNVdGlscy5zY2FsaW5nRXF1YWxseSxcbiAgICAgIHNjYWxpbmdZT3JTa2V3aW5nWCA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ1lPclNrZXdpbmdYLFxuICAgICAgc2NhbGluZ1hPclNrZXdpbmdZID0gY29udHJvbHNVdGlscy5zY2FsaW5nWE9yU2tld2luZ1ksXG4gICAgICBzY2FsZU9yU2tld0FjdGlvbk5hbWUgPSBjb250cm9sc1V0aWxzLnNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgICAgIG9iamVjdENvbnRyb2xzID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuY29udHJvbHM7XG5cbiAgb2JqZWN0Q29udHJvbHMubWwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IC0wLjUsXG4gICAgeTogMCxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWE9yU2tld2luZ1ksXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IDAsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubWIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAsXG4gICAgeTogMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm10ID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1lPclNrZXdpbmdYLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMudGwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IC0wLjUsXG4gICAgeTogLTAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLnRyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLjUsXG4gICAgeTogLTAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLmJsID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLmJyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLjUsXG4gICAgeTogMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ0VxdWFsbHlcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubXRyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IC0wLjUsXG4gICAgYWN0aW9uSGFuZGxlcjogY29udHJvbHNVdGlscy5yb3RhdGlvbldpdGhTbmFwcGluZyxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IGNvbnRyb2xzVXRpbHMucm90YXRpb25TdHlsZUhhbmRsZXIsXG4gICAgb2Zmc2V0WTogLTQwLFxuICAgIHdpdGhDb25uZWN0aW9uOiB0cnVlLFxuICAgIGFjdGlvbk5hbWU6ICdyb3RhdGUnLFxuICB9KTtcblxuICBpZiAoZmFicmljLlRleHRib3gpIHtcbiAgICAvLyB0aGlzIGlzIGJyZWFraW5nIHRoZSBwcm90b3R5cGUgaW5oZXJpdGFuY2UsIG5vIHRpbWUgLyBpZGVhcyB0byBmaXggaXQuXG4gICAgLy8gaXMgaW1wb3J0YW50IHRvIGRvY3VtZW50IHRoYXQgaWYgeW91IHdhbnQgdG8gaGF2ZSBhbGwgb2JqZWN0cyB0byBoYXZlIGFcbiAgICAvLyBzcGVjaWZpYyBjdXN0b20gY29udHJvbCwgeW91IGhhdmUgdG8gYWRkIGl0IHRvIE9iamVjdCBwcm90b3R5cGUgYW5kIHRvIFRleHRib3hcbiAgICAvLyBwcm90b3R5cGUuIFRoZSBjb250cm9scyBhcmUgc2hhcmVkIGFzIHJlZmVyZW5jZXMuIFNvIGNoYW5nZXMgdG8gY29udHJvbCBgdHJgXG4gICAgLy8gY2FuIHN0aWxsIGFwcGx5IHRvIGFsbCBvYmplY3RzIGlmIG5lZWRlZC5cbiAgICB2YXIgdGV4dEJveENvbnRyb2xzID0gZmFicmljLlRleHRib3gucHJvdG90eXBlLmNvbnRyb2xzID0geyB9O1xuXG4gICAgdGV4dEJveENvbnRyb2xzLm10ciA9IG9iamVjdENvbnRyb2xzLm10cjtcbiAgICB0ZXh0Qm94Q29udHJvbHMudHIgPSBvYmplY3RDb250cm9scy50cjtcbiAgICB0ZXh0Qm94Q29udHJvbHMuYnIgPSBvYmplY3RDb250cm9scy5icjtcbiAgICB0ZXh0Qm94Q29udHJvbHMudGwgPSBvYmplY3RDb250cm9scy50bDtcbiAgICB0ZXh0Qm94Q29udHJvbHMuYmwgPSBvYmplY3RDb250cm9scy5ibDtcbiAgICB0ZXh0Qm94Q29udHJvbHMubXQgPSBvYmplY3RDb250cm9scy5tdDtcbiAgICB0ZXh0Qm94Q29udHJvbHMubWIgPSBvYmplY3RDb250cm9scy5tYjtcblxuICAgIHRleHRCb3hDb250cm9scy5tciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgICB4OiAwLjUsXG4gICAgICB5OiAwLFxuICAgICAgYWN0aW9uSGFuZGxlcjogY29udHJvbHNVdGlscy5jaGFuZ2VXaWR0aCxcbiAgICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgICAgYWN0aW9uTmFtZTogJ3Jlc2l6aW5nJyxcbiAgICB9KTtcblxuICAgIHRleHRCb3hDb250cm9scy5tbCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgICB4OiAtMC41LFxuICAgICAgeTogMCxcbiAgICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMuY2hhbmdlV2lkdGgsXG4gICAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICAgIGFjdGlvbk5hbWU6ICdyZXNpemluZycsXG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8qISBub3Vpc2xpZGVyIC0gMTQuNi4zIC0gMTEvMTkvMjAyMCAqL1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gTm9kZS9Db21tb25KU1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgd2luZG93Lm5vVWlTbGlkZXIgPSBmYWN0b3J5KCk7XG4gICAgfVxufSkoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgVkVSU0lPTiA9IFwiMTQuNi4zXCI7XG5cbiAgICAvL3JlZ2lvbiBIZWxwZXIgTWV0aG9kc1xuXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZvcm1hdHRlcihlbnRyeSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBlbnRyeS50byA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBlbnRyeS5mcm9tID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbCkge1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBCaW5kYWJsZSB2ZXJzaW9uXG4gICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gYW4gYXJyYXkuXG4gICAgZnVuY3Rpb24gdW5pcXVlKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzW2FdID8gKHRoaXNbYV0gPSB0cnVlKSA6IGZhbHNlO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuXG4gICAgLy8gUm91bmQgYSB2YWx1ZSB0byB0aGUgY2xvc2VzdCAndG8nLlxuICAgIGZ1bmN0aW9uIGNsb3Nlc3QodmFsdWUsIHRvKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cbiAgICBmdW5jdGlvbiBvZmZzZXQoZWxlbSwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gZ2V0UGFnZU9mZnNldChkb2MpO1xuXG4gICAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBjb250YWlucyBsZWZ0IHNjcm9sbCBpbiBDaHJvbWUgb24gQW5kcm9pZC5cbiAgICAgICAgLy8gSSBoYXZlbid0IGZvdW5kIGEgZmVhdHVyZSBkZXRlY3Rpb24gdGhhdCBwcm92ZXMgdGhpcy4gV29yc3QgY2FzZVxuICAgICAgICAvLyBzY2VuYXJpbyBvbiBtaXMtbWF0Y2g6IHRoZSAndGFwJyBmZWF0dXJlIG9uIGhvcml6b250YWwgc2xpZGVycyBicmVha3MuXG4gICAgICAgIGlmICgvd2Via2l0LipDaHJvbWUuKk1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIHBhZ2VPZmZzZXQueCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3JpZW50YXRpb25cbiAgICAgICAgICAgID8gcmVjdC50b3AgKyBwYWdlT2Zmc2V0LnkgLSBkb2NFbGVtLmNsaWVudFRvcFxuICAgICAgICAgICAgOiByZWN0LmxlZnQgKyBwYWdlT2Zmc2V0LnggLSBkb2NFbGVtLmNsaWVudExlZnQ7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBudW1lcmljYWwuXG4gICAgZnVuY3Rpb24gaXNOdW1lcmljKGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmICFpc05hTihhKSAmJiBpc0Zpbml0ZShhKTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIGEgY2xhc3MgYW5kIHJlbW92ZXMgaXQgYWZ0ZXIgW2R1cmF0aW9uXSBtcy5cbiAgICBmdW5jdGlvbiBhZGRDbGFzc0ZvcihlbGVtZW50LCBjbGFzc05hbWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMaW1pdHMgYSB2YWx1ZSB0byAwIC0gMTAwXG4gICAgZnVuY3Rpb24gbGltaXQoYSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XG4gICAgfVxuXG4gICAgLy8gV3JhcHMgYSB2YXJpYWJsZSBhcyBhbiBhcnJheSwgaWYgaXQgaXNuJ3Qgb25lIHlldC5cbiAgICAvLyBOb3RlIHRoYXQgYW4gaW5wdXQgYXJyYXkgaXMgcmV0dXJuZWQgYnkgcmVmZXJlbmNlIVxuICAgIGZ1bmN0aW9uIGFzQXJyYXkoYSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgfVxuXG4gICAgLy8gQ291bnRzIGRlY2ltYWxzXG4gICAgZnVuY3Rpb24gY291bnREZWNpbWFscyhudW1TdHIpIHtcbiAgICAgICAgbnVtU3RyID0gU3RyaW5nKG51bVN0cik7XG4gICAgICAgIHZhciBwaWVjZXMgPSBudW1TdHIuc3BsaXQoXCIuXCIpO1xuICAgICAgICByZXR1cm4gcGllY2VzLmxlbmd0aCA+IDEgPyBwaWVjZXNbMV0ubGVuZ3RoIDogMDtcbiAgICB9XG5cbiAgICAvLyBodHRwOi8veW91bWlnaHRub3RuZWVkanF1ZXJ5LmNvbS8jYWRkX2NsYXNzXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0ICYmICEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNyZW1vdmVfY2xhc3NcbiAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QgJiYgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcIihefFxcXFxiKVwiICsgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKSArIFwiKFxcXFxifCQpXCIsIFwiZ2lcIiksXG4gICAgICAgICAgICAgICAgXCIgXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL3BsYWluanMuY29tL2phdmFzY3JpcHQvYXR0cmlidXRlcy9hZGRpbmctcmVtb3ZpbmctYW5kLXRlc3RpbmctZm9yLWNsYXNzZXMtOS9cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3RcbiAgICAgICAgICAgID8gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgICAgIDogbmV3IFJlZ0V4cChcIlxcXFxiXCIgKyBjbGFzc05hbWUgKyBcIlxcXFxiXCIpLnRlc3QoZWwuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Njcm9sbFkjTm90ZXNcbiAgICBmdW5jdGlvbiBnZXRQYWdlT2Zmc2V0KGRvYykge1xuICAgICAgICB2YXIgc3VwcG9ydFBhZ2VPZmZzZXQgPSB3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGlzQ1NTMUNvbXBhdCA9IChkb2MuY29tcGF0TW9kZSB8fCBcIlwiKSA9PT0gXCJDU1MxQ29tcGF0XCI7XG4gICAgICAgIHZhciB4ID0gc3VwcG9ydFBhZ2VPZmZzZXRcbiAgICAgICAgICAgID8gd2luZG93LnBhZ2VYT2Zmc2V0XG4gICAgICAgICAgICA6IGlzQ1NTMUNvbXBhdFxuICAgICAgICAgICAgICAgID8gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICAgICAgOiBkb2MuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IHN1cHBvcnRQYWdlT2Zmc2V0XG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgICAgICAgICAgOiBpc0NTUzFDb21wYXRcbiAgICAgICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgOiBkb2MuYm9keS5zY3JvbGxUb3A7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgY29uc3RhbnRzIGluc3RlYWRcbiAgICAvLyBvZiBhY2Nlc3Npbmcgd2luZG93LiogYXMgc29vbiBhcyB0aGUgbW9kdWxlIG5lZWRzIGl0XG4gICAgLy8gc28gdGhhdCB3ZSBkbyBub3QgY29tcHV0ZSBhbnl0aGluZyBpZiBub3QgbmVlZGVkXG4gICAgZnVuY3Rpb24gZ2V0QWN0aW9ucygpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBldmVudHMgdG8gYmluZC4gSUUxMSBpbXBsZW1lbnRzIHBvaW50ZXJFdmVudHMgd2l0aG91dFxuICAgICAgICAvLyBhIHByZWZpeCwgd2hpY2ggYnJlYWtzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgSUUxMCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IFwicG9pbnRlcmRvd25cIixcbiAgICAgICAgICAgICAgICAgIG1vdmU6IFwicG9pbnRlcm1vdmVcIixcbiAgICAgICAgICAgICAgICAgIGVuZDogXCJwb2ludGVydXBcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcIk1TUG9pbnRlckRvd25cIixcbiAgICAgICAgICAgICAgICAgICAgICBtb3ZlOiBcIk1TUG9pbnRlck1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBlbmQ6IFwiTVNQb2ludGVyVXBcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgbW92ZTogXCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBcIm1vdXNldXAgdG91Y2hlbmRcIlxuICAgICAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZFxuICAgIC8vIElzc3VlICM3ODVcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1Bhc3NpdmUoKSB7XG4gICAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIG9wdHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5DU1MgJiYgQ1NTLnN1cHBvcnRzICYmIENTUy5zdXBwb3J0cyhcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIik7XG4gICAgfVxuXG4gICAgLy9lbmRyZWdpb25cblxuICAgIC8vcmVnaW9uIFJhbmdlIENhbGN1bGF0aW9uXG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgYSBzdWItcmFuZ2UgaW4gcmVsYXRpb24gdG8gYSBmdWxsIHJhbmdlLlxuICAgIGZ1bmN0aW9uIHN1YlJhbmdlUmF0aW8ocGEsIHBiKSB7XG4gICAgICAgIHJldHVybiAxMDAgLyAocGIgLSBwYSk7XG4gICAgfVxuXG4gICAgLy8gKHBlcmNlbnRhZ2UpIEhvdyBtYW55IHBlcmNlbnQgaXMgdGhpcyB2YWx1ZSBvZiB0aGlzIHJhbmdlP1xuICAgIGZ1bmN0aW9uIGZyb21QZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSwgc3RhcnRSYW5nZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICogMTAwKSAvIChyYW5nZVtzdGFydFJhbmdlICsgMV0gLSByYW5nZVtzdGFydFJhbmdlXSk7XG4gICAgfVxuXG4gICAgLy8gKHBlcmNlbnRhZ2UpIFdoZXJlIGlzIHRoaXMgdmFsdWUgb24gdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiB0b1BlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmcm9tUGVyY2VudGFnZShyYW5nZSwgcmFuZ2VbMF0gPCAwID8gdmFsdWUgKyBNYXRoLmFicyhyYW5nZVswXSkgOiB2YWx1ZSAtIHJhbmdlWzBdLCAwKTtcbiAgICB9XG5cbiAgICAvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xuICAgIGZ1bmN0aW9uIGlzUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAqIChyYW5nZVsxXSAtIHJhbmdlWzBdKSkgLyAxMDAgKyByYW5nZVswXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRKKHZhbHVlLCBhcnIpIHtcbiAgICAgICAgdmFyIGogPSAxO1xuXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+PSBhcnJbal0pIHtcbiAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqO1xuICAgIH1cblxuICAgIC8vIChwZXJjZW50YWdlKSBJbnB1dCBhIHZhbHVlLCBmaW5kIHdoZXJlLCBvbiBhIHNjYWxlIG9mIDAtMTAwLCBpdCBhcHBsaWVzLlxuICAgIGZ1bmN0aW9uIHRvU3RlcHBpbmcoeFZhbCwgeFBjdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IHhWYWwuc2xpY2UoLTEpWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4VmFsKTtcbiAgICAgICAgdmFyIHZhID0geFZhbFtqIC0gMV07XG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgcGIgPSB4UGN0W2pdO1xuXG4gICAgICAgIHJldHVybiBwYSArIHRvUGVyY2VudGFnZShbdmEsIHZiXSwgdmFsdWUpIC8gc3ViUmFuZ2VSYXRpbyhwYSwgcGIpO1xuICAgIH1cblxuICAgIC8vICh2YWx1ZSkgSW5wdXQgYSBwZXJjZW50YWdlLCBmaW5kIHdoZXJlIGl0IGlzIG9uIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXG4gICAgZnVuY3Rpb24gZnJvbVN0ZXBwaW5nKHhWYWwsIHhQY3QsIHZhbHVlKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHJhbmdlIGdyb3VwIHRoYXQgZml0cyAxMDBcbiAgICAgICAgaWYgKHZhbHVlID49IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHhWYWwuc2xpY2UoLTEpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4UGN0KTtcbiAgICAgICAgdmFyIHZhID0geFZhbFtqIC0gMV07XG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xuICAgICAgICB2YXIgcGIgPSB4UGN0W2pdO1xuXG4gICAgICAgIHJldHVybiBpc1BlcmNlbnRhZ2UoW3ZhLCB2Yl0sICh2YWx1ZSAtIHBhKSAqIHN1YlJhbmdlUmF0aW8ocGEsIHBiKSk7XG4gICAgfVxuXG4gICAgLy8gKHBlcmNlbnRhZ2UpIEdldCB0aGUgc3RlcCB0aGF0IGFwcGxpZXMgYXQgYSBjZXJ0YWluIHZhbHVlLlxuICAgIGZ1bmN0aW9uIGdldFN0ZXAoeFBjdCwgeFN0ZXBzLCBzbmFwLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4UGN0KTtcbiAgICAgICAgdmFyIGEgPSB4UGN0W2ogLSAxXTtcbiAgICAgICAgdmFyIGIgPSB4UGN0W2pdO1xuXG4gICAgICAgIC8vIElmICdzbmFwJyBpcyBzZXQsIHN0ZXBzIGFyZSB1c2VkIGFzIGZpeGVkIHBvaW50cyBvbiB0aGUgc2xpZGVyLlxuICAgICAgICBpZiAoc25hcCkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBwb3NpdGlvbiwgYSBvciBiLlxuICAgICAgICAgICAgaWYgKHZhbHVlIC0gYSA+IChiIC0gYSkgLyAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF4U3RlcHNbaiAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geFBjdFtqIC0gMV0gKyBjbG9zZXN0KHZhbHVlIC0geFBjdFtqIC0gMV0sIHhTdGVwc1tqIC0gMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVudHJ5UG9pbnQoaW5kZXgsIHZhbHVlLCB0aGF0KSB7XG4gICAgICAgIHZhciBwZXJjZW50YWdlO1xuXG4gICAgICAgIC8vIFdyYXAgbnVtZXJpY2FsIGlucHV0IGluIGFuIGFycmF5LlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWplY3QgYW55IGludmFsaWQgaW5wdXQsIGJ5IHRlc3Rpbmcgd2hldGhlciB2YWx1ZSBpcyBhbiBhcnJheS5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnIGNvbnRhaW5zIGludmFsaWQgdmFsdWUuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ292ZXJ0IG1pbi9tYXggc3ludGF4IHRvIDAgYW5kIDEwMC5cbiAgICAgICAgaWYgKGluZGV4ID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgcGVyY2VudGFnZSA9IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBjb3JyZWN0IGlucHV0LlxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhwZXJjZW50YWdlKSB8fCAhaXNOdW1lcmljKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnIHZhbHVlIGlzbid0IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdmFsdWVzLlxuICAgICAgICB0aGF0LnhQY3QucHVzaChwZXJjZW50YWdlKTtcbiAgICAgICAgdGhhdC54VmFsLnB1c2godmFsdWVbMF0pO1xuXG4gICAgICAgIC8vIE5hTiB3aWxsIGV2YWx1YXRlIHRvIGZhbHNlIHRvbywgYnV0IHRvIGtlZXBcbiAgICAgICAgLy8gbG9nZ2luZyBjbGVhciwgc2V0IHN0ZXAgZXhwbGljaXRseS4gTWFrZSBzdXJlXG4gICAgICAgIC8vIG5vdCB0byBvdmVycmlkZSB0aGUgJ3N0ZXAnIHNldHRpbmcgd2l0aCBmYWxzZS5cbiAgICAgICAgaWYgKCFwZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlWzFdKSkge1xuICAgICAgICAgICAgICAgIHRoYXQueFN0ZXBzWzBdID0gdmFsdWVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LnhTdGVwcy5wdXNoKGlzTmFOKHZhbHVlWzFdKSA/IGZhbHNlIDogdmFsdWVbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC54SGlnaGVzdENvbXBsZXRlU3RlcC5wdXNoKDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0ZXBQb2ludChpLCBuLCB0aGF0KSB7XG4gICAgICAgIC8vIElnbm9yZSAnZmFsc2UnIHN0ZXBwaW5nLlxuICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0ZXAgb3ZlciB6ZXJvLWxlbmd0aCByYW5nZXMgKCM5NDgpO1xuICAgICAgICBpZiAodGhhdC54VmFsW2ldID09PSB0aGF0LnhWYWxbaSArIDFdKSB7XG4gICAgICAgICAgICB0aGF0LnhTdGVwc1tpXSA9IHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSB0aGF0LnhWYWxbaV07XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhY3RvciB0byByYW5nZSByYXRpb1xuICAgICAgICB0aGF0LnhTdGVwc1tpXSA9XG4gICAgICAgICAgICBmcm9tUGVyY2VudGFnZShbdGhhdC54VmFsW2ldLCB0aGF0LnhWYWxbaSArIDFdXSwgbiwgMCkgLyBzdWJSYW5nZVJhdGlvKHRoYXQueFBjdFtpXSwgdGhhdC54UGN0W2kgKyAxXSk7XG5cbiAgICAgICAgdmFyIHRvdGFsU3RlcHMgPSAodGhhdC54VmFsW2kgKyAxXSAtIHRoYXQueFZhbFtpXSkgLyB0aGF0LnhOdW1TdGVwc1tpXTtcbiAgICAgICAgdmFyIGhpZ2hlc3RTdGVwID0gTWF0aC5jZWlsKE51bWJlcih0b3RhbFN0ZXBzLnRvRml4ZWQoMykpIC0gMSk7XG4gICAgICAgIHZhciBzdGVwID0gdGhhdC54VmFsW2ldICsgdGhhdC54TnVtU3RlcHNbaV0gKiBoaWdoZXN0U3RlcDtcblxuICAgICAgICB0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwW2ldID0gc3RlcDtcbiAgICB9XG5cbiAgICAvL2VuZHJlZ2lvblxuXG4gICAgLy9yZWdpb24gU3BlY3RydW1cblxuICAgIGZ1bmN0aW9uIFNwZWN0cnVtKGVudHJ5LCBzbmFwLCBzaW5nbGVTdGVwKSB7XG4gICAgICAgIHRoaXMueFBjdCA9IFtdO1xuICAgICAgICB0aGlzLnhWYWwgPSBbXTtcbiAgICAgICAgdGhpcy54U3RlcHMgPSBbc2luZ2xlU3RlcCB8fCBmYWxzZV07XG4gICAgICAgIHRoaXMueE51bVN0ZXBzID0gW2ZhbHNlXTtcbiAgICAgICAgdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcCA9IFtdO1xuXG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG5cbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIgb3JkZXJlZCA9IFtdOyAvLyBbMCwgJ21pbiddLCBbMSwgJzUwJSddLCBbMiwgJ21heCddXG5cbiAgICAgICAgLy8gTWFwIHRoZSBvYmplY3Qga2V5cyB0byBhbiBhcnJheS5cbiAgICAgICAgZm9yIChpbmRleCBpbiBlbnRyeSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5Lmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChbZW50cnlbaW5kZXhdLCBpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBhbGwgZW50cmllcyBieSB2YWx1ZSAobnVtZXJpYyBzb3J0KS5cbiAgICAgICAgaWYgKG9yZGVyZWQubGVuZ3RoICYmIHR5cGVvZiBvcmRlcmVkWzBdWzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBvcmRlcmVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhWzBdWzBdIC0gYlswXVswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgYWxsIGVudHJpZXMgdG8gc3VicmFuZ2VzLlxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBvcmRlcmVkLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaGFuZGxlRW50cnlQb2ludChvcmRlcmVkW2luZGV4XVsxXSwgb3JkZXJlZFtpbmRleF1bMF0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGFjdHVhbCBzdGVwIHZhbHVlcy5cbiAgICAgICAgLy8geFN0ZXBzIGlzIHNvcnRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB4UGN0IGFuZCB4VmFsLlxuICAgICAgICB0aGlzLnhOdW1TdGVwcyA9IHRoaXMueFN0ZXBzLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIENvbnZlcnQgYWxsIG51bWVyaWMgc3RlcHMgdG8gdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHN1YnJhbmdlIHRoZXkgcmVwcmVzZW50LlxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgdmFyIGRpc3RhbmNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMueE51bVN0ZXBzLmxlbmd0aCAtIDE7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGxhc3QgXCJyYW5nZVwiIGNhbid0IGNvbnRhaW4gc3RlcCBzaXplIGFzIGl0IGlzIHB1cmVseSBhbiBlbmRwb2ludC5cbiAgICAgICAgICAgIHZhciBzdGVwID0gdGhpcy54TnVtU3RlcHNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoc3RlcCAmJiAodmFsdWUgLyBzdGVwKSAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgVkVSU0lPTiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIik6ICdsaW1pdCcsICdtYXJnaW4nIGFuZCAncGFkZGluZycgb2YgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy54UGN0W2luZGV4XSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiUgcmFuZ2UgbXVzdCBiZSBkaXZpc2libGUgYnkgc3RlcC5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJjZW50dWFsIGRpc3RhbmNlIGluIGN1cnJlbnQgcmFuZ2Ugb2YgbGltaXQsIG1hcmdpbiBvciBwYWRkaW5nXG4gICAgICAgICAgICBkaXN0YW5jZXNbaW5kZXhdID0gZnJvbVBlcmNlbnRhZ2UodGhpcy54VmFsLCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlcztcbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJjZW50dWFsIGRpc3RhbmNlIG92ZXIgdGhlIHdob2xlIHNjYWxlIG9mIHJhbmdlcy5cbiAgICAvLyBkaXJlY3Rpb246IDAgPSBiYWNrd2FyZHMgLyAxID0gZm9yd2FyZHNcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0QWJzb2x1dGVEaXN0YW5jZSA9IGZ1bmN0aW9uKHZhbHVlLCBkaXN0YW5jZXMsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgeFBjdF9pbmRleCA9IDA7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHJhbmdlIHdoZXJlIHRvIHN0YXJ0IGNhbGN1bGF0aW9uXG4gICAgICAgIGlmICh2YWx1ZSA8IHRoaXMueFBjdFt0aGlzLnhQY3QubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZSA+IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICB4UGN0X2luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRoaXMueFBjdFt0aGlzLnhQY3QubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHhQY3RfaW5kZXggPSB0aGlzLnhQY3QubGVuZ3RoIC0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGxvb2tpbmcgYmFja3dhcmRzIGFuZCB0aGUgdmFsdWUgaXMgZXhhY3RseSBhdCBhIHJhbmdlIHNlcGFyYXRvciB0aGVuIGxvb2sgb25lIHJhbmdlIGZ1cnRoZXJcbiAgICAgICAgaWYgKCFkaXJlY3Rpb24gJiYgdmFsdWUgPT09IHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0pIHtcbiAgICAgICAgICAgIHhQY3RfaW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydF9mYWN0b3I7XG4gICAgICAgIHZhciByZXN0X2ZhY3RvciA9IDE7XG5cbiAgICAgICAgdmFyIHJlc3RfcmVsX2Rpc3RhbmNlID0gZGlzdGFuY2VzW3hQY3RfaW5kZXhdO1xuXG4gICAgICAgIHZhciByYW5nZV9wY3QgPSAwO1xuXG4gICAgICAgIHZhciByZWxfcmFuZ2VfZGlzdGFuY2UgPSAwO1xuICAgICAgICB2YXIgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgcmFuZ2VfY291bnRlciA9IDA7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdoYXQgcGFydCBvZiB0aGUgc3RhcnQgcmFuZ2UgdGhlIHZhbHVlIGlzXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHN0YXJ0X2ZhY3RvciA9ICh2YWx1ZSAtIHRoaXMueFBjdFt4UGN0X2luZGV4XSkgLyAodGhpcy54UGN0W3hQY3RfaW5kZXggKyAxXSAtIHRoaXMueFBjdFt4UGN0X2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAodGhpcy54UGN0W3hQY3RfaW5kZXggKyAxXSAtIHZhbHVlKSAvICh0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdIC0gdGhpcy54UGN0W3hQY3RfaW5kZXhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIHVudGlsIHRoZSBjb21wbGV0ZSBkaXN0YW5jZSBhY3Jvc3MgcmFuZ2VzIGlzIGNhbGN1bGF0ZWRcbiAgICAgICAgd2hpbGUgKHJlc3RfcmVsX2Rpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwZXJjZW50YWdlIG9mIHRvdGFsIHJhbmdlXG4gICAgICAgICAgICByYW5nZV9wY3QgPSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDEgKyByYW5nZV9jb3VudGVyXSAtIHRoaXMueFBjdFt4UGN0X2luZGV4ICsgcmFuZ2VfY291bnRlcl07XG5cbiAgICAgICAgICAgIC8vIERldGVjdCBpZiB0aGUgbWFyZ2luLCBwYWRkaW5nIG9yIGxpbWl0IGlzIGxhcmdlciB0aGVuIHRoZSBjdXJyZW50IHJhbmdlIGFuZCBjYWxjdWxhdGVcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdICogcmVzdF9mYWN0b3IgKyAxMDAgLSBzdGFydF9mYWN0b3IgKiAxMDAgPiAxMDApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBsYXJnZXIgdGhlbiB0YWtlIHRoZSBwZXJjZW50dWFsIGRpc3RhbmNlIG9mIHRoZSB3aG9sZSByYW5nZVxuICAgICAgICAgICAgICAgIHJlbF9yYW5nZV9kaXN0YW5jZSA9IHJhbmdlX3BjdCAqIHN0YXJ0X2ZhY3RvcjtcbiAgICAgICAgICAgICAgICAvLyBSZXN0IGZhY3RvciBvZiByZWxhdGl2ZSBwZXJjZW50dWFsIGRpc3RhbmNlIHN0aWxsIHRvIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICByZXN0X2ZhY3RvciA9IChyZXN0X3JlbF9kaXN0YW5jZSAtIDEwMCAqIHN0YXJ0X2ZhY3RvcikgLyBkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdO1xuICAgICAgICAgICAgICAgIC8vIFNldCBzdGFydCBmYWN0b3IgdG8gMSBhcyBmb3IgbmV4dCByYW5nZSBpdCBkb2VzIG5vdCBhcHBseS5cbiAgICAgICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzbWFsbGVyIG9yIGVxdWFsIHRoZW4gdGFrZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvZiB0aGUgY2FsY3VsYXRlIHBlcmNlbnR1YWwgcGFydCBvZiB0aGF0IHJhbmdlXG4gICAgICAgICAgICAgICAgcmVsX3JhbmdlX2Rpc3RhbmNlID0gKChkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdICogcmFuZ2VfcGN0KSAvIDEwMCkgKiByZXN0X2ZhY3RvcjtcbiAgICAgICAgICAgICAgICAvLyBObyByZXN0IGxlZnQgYXMgdGhlIHJlc3QgZml0cyBpbiBjdXJyZW50IHJhbmdlXG4gICAgICAgICAgICAgICAgcmVzdF9mYWN0b3IgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSBhYnNfZGlzdGFuY2VfY291bnRlciAtIHJlbF9yYW5nZV9kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAvLyBMaW1pdCByYW5nZSB0byBmaXJzdCByYW5nZSB3aGVuIGRpc3RhbmNlIGJlY29tZXMgb3V0c2lkZSBvZiBtaW5pbXVtIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMueFBjdC5sZW5ndGggKyByYW5nZV9jb3VudGVyID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VfY291bnRlci0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWJzX2Rpc3RhbmNlX2NvdW50ZXIgPSBhYnNfZGlzdGFuY2VfY291bnRlciArIHJlbF9yYW5nZV9kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAvLyBMaW1pdCByYW5nZSB0byBsYXN0IHJhbmdlIHdoZW4gZGlzdGFuY2UgYmVjb21lcyBvdXRzaWRlIG9mIG1heGltdW0gcmFuZ2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy54UGN0Lmxlbmd0aCAtIHJhbmdlX2NvdW50ZXIgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZV9jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXN0IG9mIHJlbGF0aXZlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugc3RpbGwgdG8gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgcmVzdF9yZWxfZGlzdGFuY2UgPSBkaXN0YW5jZXNbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdICogcmVzdF9mYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgKyBhYnNfZGlzdGFuY2VfY291bnRlcjtcbiAgICB9O1xuXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLnRvU3RlcHBpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRvU3RlcHBpbmcodGhpcy54VmFsLCB0aGlzLnhQY3QsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5mcm9tU3RlcHBpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnJvbVN0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXRTdGVwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRTdGVwKHRoaXMueFBjdCwgdGhpcy54U3RlcHMsIHRoaXMuc25hcCwgdmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmdldERlZmF1bHRTdGVwID0gZnVuY3Rpb24odmFsdWUsIGlzRG93biwgc2l6ZSkge1xuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHRoaXMueFBjdCk7XG5cbiAgICAgICAgLy8gV2hlbiBhdCB0aGUgdG9wIG9yIHN0ZXBwaW5nIGRvd24sIGxvb2sgYXQgdGhlIHByZXZpb3VzIHN1Yi1yYW5nZVxuICAgICAgICBpZiAodmFsdWUgPT09IDEwMCB8fCAoaXNEb3duICYmIHZhbHVlID09PSB0aGlzLnhQY3RbaiAtIDFdKSkge1xuICAgICAgICAgICAgaiA9IE1hdGgubWF4KGogLSAxLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy54VmFsW2pdIC0gdGhpcy54VmFsW2ogLSAxXSkgLyBzaXplO1xuICAgIH07XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0TmVhcmJ5U3RlcHMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHRoaXMueFBjdCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0ZXBCZWZvcmU6IHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDJdLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2ogLSAyXSxcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzU3RlcDoge1xuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqIC0gMV0sXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDFdLFxuICAgICAgICAgICAgICAgIGhpZ2hlc3RTdGVwOiB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwW2ogLSAxXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0ZXBBZnRlcjoge1xuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRoaXMueFZhbFtqXSxcbiAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqXSxcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY291bnRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0ZXBEZWNpbWFscyA9IHRoaXMueE51bVN0ZXBzLm1hcChjb3VudERlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIHN0ZXBEZWNpbWFscyk7XG4gICAgfTtcblxuICAgIC8vIE91dHNpZGUgdGVzdGluZ1xuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlcCh0aGlzLnRvU3RlcHBpbmcodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgLy9lbmRyZWdpb25cblxuICAgIC8vcmVnaW9uIE9wdGlvbnNcblxuICAgIC8qXHRFdmVyeSBpbnB1dCBvcHRpb24gaXMgdGVzdGVkIGFuZCBwYXJzZWQuIFRoaXMnbGwgcHJldmVudFxuICAgICAgICBlbmRsZXNzIHZhbGlkYXRpb24gaW4gaW50ZXJuYWwgbWV0aG9kcy4gVGhlc2UgdGVzdHMgYXJlXG4gICAgICAgIHN0cnVjdHVyZWQgd2l0aCBhbiBpdGVtIGZvciBldmVyeSBvcHRpb24gYXZhaWxhYmxlLiBBblxuICAgICAgICBvcHRpb24gY2FuIGJlIG1hcmtlZCBhcyByZXF1aXJlZCBieSBzZXR0aW5nIHRoZSAncicgZmxhZy5cbiAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gaXMgcHJvdmlkZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICAgICAgICAtIFRoZSBwcm92aWRlZCB2YWx1ZSBmb3IgdGhlIG9wdGlvbjtcbiAgICAgICAgICAgIC0gQSByZWZlcmVuY2UgdG8gdGhlIG9wdGlvbnMgb2JqZWN0O1xuICAgICAgICAgICAgLSBUaGUgbmFtZSBmb3IgdGhlIG9wdGlvbjtcblxuICAgICAgICBUaGUgdGVzdGluZyBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIHdoZW4gYW4gZXJyb3IgaXMgZGV0ZWN0ZWQsXG4gICAgICAgIG9yIHRydWUgd2hlbiBldmVyeXRoaW5nIGlzIE9LLiBJdCBjYW4gYWxzbyBtb2RpZnkgdGhlIG9wdGlvblxuICAgICAgICBvYmplY3QsIHRvIG1ha2Ugc3VyZSBhbGwgdmFsdWVzIGNhbiBiZSBjb3JyZWN0bHkgbG9vcGVkIGVsc2V3aGVyZS4gKi9cblxuICAgIC8vcmVnaW9uIERlZmF1bHRzXG5cbiAgICB2YXIgZGVmYXVsdEZvcm1hdHRlciA9IHtcbiAgICAgICAgdG86IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS50b0ZpeGVkKDIpO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tOiBOdW1iZXJcbiAgICB9O1xuXG4gICAgdmFyIGNzc0NsYXNzZXMgPSB7XG4gICAgICAgIHRhcmdldDogXCJ0YXJnZXRcIixcbiAgICAgICAgYmFzZTogXCJiYXNlXCIsXG4gICAgICAgIG9yaWdpbjogXCJvcmlnaW5cIixcbiAgICAgICAgaGFuZGxlOiBcImhhbmRsZVwiLFxuICAgICAgICBoYW5kbGVMb3dlcjogXCJoYW5kbGUtbG93ZXJcIixcbiAgICAgICAgaGFuZGxlVXBwZXI6IFwiaGFuZGxlLXVwcGVyXCIsXG4gICAgICAgIHRvdWNoQXJlYTogXCJ0b3VjaC1hcmVhXCIsXG4gICAgICAgIGhvcml6b250YWw6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICB2ZXJ0aWNhbDogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcImJhY2tncm91bmRcIixcbiAgICAgICAgY29ubmVjdDogXCJjb25uZWN0XCIsXG4gICAgICAgIGNvbm5lY3RzOiBcImNvbm5lY3RzXCIsXG4gICAgICAgIGx0cjogXCJsdHJcIixcbiAgICAgICAgcnRsOiBcInJ0bFwiLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uTHRyOiBcInR4dC1kaXItbHRyXCIsXG4gICAgICAgIHRleHREaXJlY3Rpb25SdGw6IFwidHh0LWRpci1ydGxcIixcbiAgICAgICAgZHJhZ2dhYmxlOiBcImRyYWdnYWJsZVwiLFxuICAgICAgICBkcmFnOiBcInN0YXRlLWRyYWdcIixcbiAgICAgICAgdGFwOiBcInN0YXRlLXRhcFwiLFxuICAgICAgICBhY3RpdmU6IFwiYWN0aXZlXCIsXG4gICAgICAgIHRvb2x0aXA6IFwidG9vbHRpcFwiLFxuICAgICAgICBwaXBzOiBcInBpcHNcIixcbiAgICAgICAgcGlwc0hvcml6b250YWw6IFwicGlwcy1ob3Jpem9udGFsXCIsXG4gICAgICAgIHBpcHNWZXJ0aWNhbDogXCJwaXBzLXZlcnRpY2FsXCIsXG4gICAgICAgIG1hcmtlcjogXCJtYXJrZXJcIixcbiAgICAgICAgbWFya2VySG9yaXpvbnRhbDogXCJtYXJrZXItaG9yaXpvbnRhbFwiLFxuICAgICAgICBtYXJrZXJWZXJ0aWNhbDogXCJtYXJrZXItdmVydGljYWxcIixcbiAgICAgICAgbWFya2VyTm9ybWFsOiBcIm1hcmtlci1ub3JtYWxcIixcbiAgICAgICAgbWFya2VyTGFyZ2U6IFwibWFya2VyLWxhcmdlXCIsXG4gICAgICAgIG1hcmtlclN1YjogXCJtYXJrZXItc3ViXCIsXG4gICAgICAgIHZhbHVlOiBcInZhbHVlXCIsXG4gICAgICAgIHZhbHVlSG9yaXpvbnRhbDogXCJ2YWx1ZS1ob3Jpem9udGFsXCIsXG4gICAgICAgIHZhbHVlVmVydGljYWw6IFwidmFsdWUtdmVydGljYWxcIixcbiAgICAgICAgdmFsdWVOb3JtYWw6IFwidmFsdWUtbm9ybWFsXCIsXG4gICAgICAgIHZhbHVlTGFyZ2U6IFwidmFsdWUtbGFyZ2VcIixcbiAgICAgICAgdmFsdWVTdWI6IFwidmFsdWUtc3ViXCJcbiAgICB9O1xuXG4gICAgLy8gTmFtZXNwYWNlcyBvZiBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnNcbiAgICB2YXIgSU5URVJOQUxfRVZFTlRfTlMgPSB7XG4gICAgICAgIHRvb2x0aXBzOiBcIi5fX3Rvb2x0aXBzXCIsXG4gICAgICAgIGFyaWE6IFwiLl9fYXJpYVwiXG4gICAgfTtcblxuICAgIC8vZW5kcmVnaW9uXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChlbnRyeSkge1xuICAgICAgICAvLyBBbnkgb2JqZWN0IHdpdGggYSB0byBhbmQgZnJvbSBtZXRob2QgaXMgc3VwcG9ydGVkLlxuICAgICAgICBpZiAoaXNWYWxpZEZvcm1hdHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZm9ybWF0JyByZXF1aXJlcyAndG8nIGFuZCAnZnJvbScgbWV0aG9kcy5cIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3N0ZXAnIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzdGVwIG9wdGlvbiBjYW4gc3RpbGwgYmUgdXNlZCB0byBzZXQgc3RlcHBpbmdcbiAgICAgICAgLy8gZm9yIGxpbmVhciBzbGlkZXJzLiBPdmVyd3JpdHRlbiBpZiBzZXQgaW4gJ3JhbmdlJy5cbiAgICAgICAgcGFyc2VkLnNpbmdsZVN0ZXAgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0S2V5Ym9hcmRQYWdlTXVsdGlwbGllcihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAna2V5Ym9hcmRQYWdlTXVsdGlwbGllcicgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkUGFnZU11bHRpcGxpZXIgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0S2V5Ym9hcmREZWZhdWx0U3RlcChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAna2V5Ym9hcmREZWZhdWx0U3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmtleWJvYXJkRGVmYXVsdFN0ZXAgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0UmFuZ2UocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBGaWx0ZXIgaW5jb3JyZWN0IGlucHV0LlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgaXMgbm90IGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXRjaCBtaXNzaW5nIHN0YXJ0IG9yIGVuZC5cbiAgICAgICAgaWYgKGVudHJ5Lm1pbiA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5Lm1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IE1pc3NpbmcgJ21pbicgb3IgJ21heCcgaW4gJ3JhbmdlJy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXRjaCBlcXVhbCBzdGFydCBvciBlbmQuXG4gICAgICAgIGlmIChlbnRyeS5taW4gPT09IGVudHJ5Lm1heCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnICdtaW4nIGFuZCAnbWF4JyBjYW5ub3QgYmUgZXF1YWwuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLnNwZWN0cnVtID0gbmV3IFNwZWN0cnVtKGVudHJ5LCBwYXJzZWQuc25hcCwgcGFyc2VkLnNpbmdsZVN0ZXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RTdGFydChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXQuIFZhbHVlcyBhcmVuJ3QgdGVzdGVkLCBhcyB0aGUgcHVibGljIC52YWwgbWV0aG9kXG4gICAgICAgIC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdzdGFydCcgb3B0aW9uIGlzIGluY29ycmVjdC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgbnVtYmVyIG9mIGhhbmRsZXMuXG4gICAgICAgIHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcbiAgICAgICAgLy8gYmUgY2FsbGVkIHdpdGggdGhlIHN0YXJ0IG9wdGlvbnMuXG4gICAgICAgIHBhcnNlZC5zdGFydCA9IGVudHJ5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RTbmFwKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXG4gICAgICAgIHBhcnNlZC5zbmFwID0gZW50cnk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0QW5pbWF0ZShwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIEVuZm9yY2UgMTAwJSBzdGVwcGluZyB3aXRoaW4gc3VicmFuZ2VzLlxuICAgICAgICBwYXJzZWQuYW5pbWF0ZSA9IGVudHJ5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEFuaW1hdGlvbkR1cmF0aW9uKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgcGFyc2VkLmFuaW1hdGlvbkR1cmF0aW9uID0gZW50cnk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnYW5pbWF0aW9uRHVyYXRpb24nIG9wdGlvbiBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RDb25uZWN0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgdmFyIGNvbm5lY3QgPSBbZmFsc2VdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICAvLyBNYXAgbGVnYWN5IG9wdGlvbnNcbiAgICAgICAgaWYgKGVudHJ5ID09PSBcImxvd2VyXCIpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW3RydWUsIGZhbHNlXTtcbiAgICAgICAgfSBlbHNlIGlmIChlbnRyeSA9PT0gXCJ1cHBlclwiKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgYm9vbGVhbiBvcHRpb25zXG4gICAgICAgIGlmIChlbnRyeSA9PT0gdHJ1ZSB8fCBlbnRyeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29ubmVjdC5wdXNoKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlamVjdCBpbnZhbGlkIGlucHV0XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoIHx8IGVudHJ5Lmxlbmd0aCAhPT0gcGFyc2VkLmhhbmRsZXMgKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjb25uZWN0JyBvcHRpb24gZG9lc24ndCBtYXRjaCBoYW5kbGUgY291bnQuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29ubmVjdCA9IGVudHJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmNvbm5lY3QgPSBjb25uZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFNldCBvcmllbnRhdGlvbiB0byBhbiBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeVxuICAgICAgICAvLyBhcnJheSBzZWxlY3Rpb24uXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQub3J0ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RNYXJnaW4ocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJc3N1ZSAjNTgyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLm1hcmdpbiA9IHBhcnNlZC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlbnRyeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdExpbWl0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdsaW1pdCcgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQubGltaXQgPSBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnkpO1xuXG4gICAgICAgIGlmICghcGFyc2VkLmxpbWl0IHx8IHBhcnNlZC5oYW5kbGVzIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgK1xuICAgICAgICAgICAgICAgICAgICBWRVJTSU9OICtcbiAgICAgICAgICAgICAgICAgICAgXCIpOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFBhZGRpbmcocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICB2YXIgaW5kZXg7XG5cbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpICYmICFBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSAmJiAhKGVudHJ5Lmxlbmd0aCA9PT0gMiB8fCBpc051bWVyaWMoZW50cnlbMF0pIHx8IGlzTnVtZXJpYyhlbnRyeVsxXSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtlbnRyeSwgZW50cnldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ2dldERpc3RhbmNlJyByZXR1cm5zIGZhbHNlIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICAgICAgcGFyc2VkLnBhZGRpbmcgPSBbcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5WzBdKSwgcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5WzFdKV07XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFyc2VkLnNwZWN0cnVtLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBsYXN0IFwicmFuZ2VcIiBjYW4ndCBjb250YWluIHN0ZXAgc2l6ZSBhcyBpdCBpcyBwdXJlbHkgYW4gZW5kcG9pbnQuXG4gICAgICAgICAgICBpZiAocGFyc2VkLnBhZGRpbmdbMF1baW5kZXhdIDwgMCB8fCBwYXJzZWQucGFkZGluZ1sxXVtpbmRleF0gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIocykuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsUGFkZGluZyA9IGVudHJ5WzBdICsgZW50cnlbMV07XG4gICAgICAgIHZhciBmaXJzdFZhbHVlID0gcGFyc2VkLnNwZWN0cnVtLnhWYWxbMF07XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSBwYXJzZWQuc3BlY3RydW0ueFZhbFtwYXJzZWQuc3BlY3RydW0ueFZhbC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodG90YWxQYWRkaW5nIC8gKGxhc3RWYWx1ZSAtIGZpcnN0VmFsdWUpID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3Qgbm90IGV4Y2VlZCAxMDAlIG9mIHRoZSByYW5nZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0RGlyZWN0aW9uKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gU2V0IGRpcmVjdGlvbiBhcyBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeSBwYXJzaW5nLlxuICAgICAgICAvLyBJbnZlcnQgY29ubmVjdGlvbiBmb3IgUlRMIHNsaWRlcnMsIHNvIHRoYXQgdGhlIHByb3BlclxuICAgICAgICAvLyBoYW5kbGVzIGdldCB0aGUgY29ubmVjdC9iYWNrZ3JvdW5kIGNsYXNzZXMuXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsdHJcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJydGxcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQuZGlyID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZGlyZWN0aW9uJyBvcHRpb24gd2FzIG5vdCByZWNvZ25pemVkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RCZWhhdmlvdXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nLlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgYW55IGtleXdvcmRzLlxuICAgICAgICAvLyBOb25lIGFyZSByZXF1aXJlZC5cbiAgICAgICAgdmFyIHRhcCA9IGVudHJ5LmluZGV4T2YoXCJ0YXBcIikgPj0gMDtcbiAgICAgICAgdmFyIGRyYWcgPSBlbnRyeS5pbmRleE9mKFwiZHJhZ1wiKSA+PSAwO1xuICAgICAgICB2YXIgZml4ZWQgPSBlbnRyeS5pbmRleE9mKFwiZml4ZWRcIikgPj0gMDtcbiAgICAgICAgdmFyIHNuYXAgPSBlbnRyeS5pbmRleE9mKFwic25hcFwiKSA+PSAwO1xuICAgICAgICB2YXIgaG92ZXIgPSBlbnRyeS5pbmRleE9mKFwiaG92ZXJcIikgPj0gMDtcbiAgICAgICAgdmFyIHVuY29uc3RyYWluZWQgPSBlbnRyeS5pbmRleE9mKFwidW5jb25zdHJhaW5lZFwiKSA+PSAwO1xuXG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5oYW5kbGVzICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZml4ZWQnIGJlaGF2aW91ciBtdXN0IGJlIHVzZWQgd2l0aCAyIGhhbmRsZXNcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBtYXJnaW4gdG8gZW5mb3JjZSBmaXhlZCBzdGF0ZVxuICAgICAgICAgICAgdGVzdE1hcmdpbihwYXJzZWQsIHBhcnNlZC5zdGFydFsxXSAtIHBhcnNlZC5zdGFydFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5jb25zdHJhaW5lZCAmJiAocGFyc2VkLm1hcmdpbiB8fCBwYXJzZWQubGltaXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd1bmNvbnN0cmFpbmVkJyBiZWhhdmlvdXIgY2Fubm90IGJlIHVzZWQgd2l0aCBtYXJnaW4gb3IgbGltaXRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5ldmVudHMgPSB7XG4gICAgICAgICAgICB0YXA6IHRhcCB8fCBzbmFwLFxuICAgICAgICAgICAgZHJhZzogZHJhZyxcbiAgICAgICAgICAgIGZpeGVkOiBmaXhlZCxcbiAgICAgICAgICAgIHNuYXA6IHNuYXAsXG4gICAgICAgICAgICBob3ZlcjogaG92ZXIsXG4gICAgICAgICAgICB1bmNvbnN0cmFpbmVkOiB1bmNvbnN0cmFpbmVkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFRvb2x0aXBzKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMgPSBhc0FycmF5KGVudHJ5KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlZC50b29sdGlwcy5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBtdXN0IHBhc3MgYSBmb3JtYXR0ZXIgZm9yIGFsbCBoYW5kbGVzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzLmZvckVhY2goZnVuY3Rpb24oZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZm9ybWF0dGVyICE9PSBcImJvb2xlYW5cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGZvcm1hdHRlciAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZm9ybWF0dGVyLnRvICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3Rvb2x0aXBzJyBtdXN0IGJlIHBhc3NlZCBhIGZvcm1hdHRlciBvciAnZmFsc2UnLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RBcmlhRm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgcGFyc2VkLmFyaWFGb3JtYXQgPSBlbnRyeTtcbiAgICAgICAgdmFsaWRhdGVGb3JtYXQoZW50cnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RGb3JtYXQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBwYXJzZWQuZm9ybWF0ID0gZW50cnk7XG4gICAgICAgIHZhbGlkYXRlRm9ybWF0KGVudHJ5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0S2V5Ym9hcmRTdXBwb3J0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgcGFyc2VkLmtleWJvYXJkU3VwcG9ydCA9IGVudHJ5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdrZXlib2FyZFN1cHBvcnQnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0RG9jdW1lbnRFbGVtZW50KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhZHZhbmNlZCBvcHRpb24uIFBhc3NlZCB2YWx1ZXMgYXJlIHVzZWQgd2l0aG91dCB2YWxpZGF0aW9uLlxuICAgICAgICBwYXJzZWQuZG9jdW1lbnRFbGVtZW50ID0gZW50cnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdENzc1ByZWZpeChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwic3RyaW5nXCIgJiYgZW50cnkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjc3NQcmVmaXgnIG11c3QgYmUgYSBzdHJpbmcgb3IgYGZhbHNlYC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuY3NzUHJlZml4ID0gZW50cnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdENzc0NsYXNzZXMocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjc3NDbGFzc2VzJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZC5jc3NQcmVmaXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhcnNlZC5jc3NDbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3Nlc1trZXldID0gcGFyc2VkLmNzc1ByZWZpeCArIGVudHJ5W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3NlcyA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVzdCBhbGwgZGV2ZWxvcGVyIHNldHRpbmdzIGFuZCBwYXJzZSB0byBhc3N1bXB0aW9uLXNhZmUgdmFsdWVzLlxuICAgIGZ1bmN0aW9uIHRlc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVG8gcHJvdmUgYSBmaXggZm9yICM1MzcsIGZyZWV6ZSBvcHRpb25zIGhlcmUuXG4gICAgICAgIC8vIElmIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAgICAvLyBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBsaW1pdDogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXG4gICAgICAgICAgICBmb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUZXN0cyBhcmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHByZXNlbnRlZCBoZXJlLlxuICAgICAgICB2YXIgdGVzdHMgPSB7XG4gICAgICAgICAgICBzdGVwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U3RlcCB9LFxuICAgICAgICAgICAga2V5Ym9hcmRQYWdlTXVsdGlwbGllcjogeyByOiBmYWxzZSwgdDogdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIgfSxcbiAgICAgICAgICAgIGtleWJvYXJkRGVmYXVsdFN0ZXA6IHsgcjogZmFsc2UsIHQ6IHRlc3RLZXlib2FyZERlZmF1bHRTdGVwIH0sXG4gICAgICAgICAgICBzdGFydDogeyByOiB0cnVlLCB0OiB0ZXN0U3RhcnQgfSxcbiAgICAgICAgICAgIGNvbm5lY3Q6IHsgcjogdHJ1ZSwgdDogdGVzdENvbm5lY3QgfSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogeyByOiB0cnVlLCB0OiB0ZXN0RGlyZWN0aW9uIH0sXG4gICAgICAgICAgICBzbmFwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U25hcCB9LFxuICAgICAgICAgICAgYW5pbWF0ZTogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGUgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiB7IHI6IGZhbHNlLCB0OiB0ZXN0QW5pbWF0aW9uRHVyYXRpb24gfSxcbiAgICAgICAgICAgIHJhbmdlOiB7IHI6IHRydWUsIHQ6IHRlc3RSYW5nZSB9LFxuICAgICAgICAgICAgb3JpZW50YXRpb246IHsgcjogZmFsc2UsIHQ6IHRlc3RPcmllbnRhdGlvbiB9LFxuICAgICAgICAgICAgbWFyZ2luOiB7IHI6IGZhbHNlLCB0OiB0ZXN0TWFyZ2luIH0sXG4gICAgICAgICAgICBsaW1pdDogeyByOiBmYWxzZSwgdDogdGVzdExpbWl0IH0sXG4gICAgICAgICAgICBwYWRkaW5nOiB7IHI6IGZhbHNlLCB0OiB0ZXN0UGFkZGluZyB9LFxuICAgICAgICAgICAgYmVoYXZpb3VyOiB7IHI6IHRydWUsIHQ6IHRlc3RCZWhhdmlvdXIgfSxcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RBcmlhRm9ybWF0IH0sXG4gICAgICAgICAgICBmb3JtYXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RGb3JtYXQgfSxcbiAgICAgICAgICAgIHRvb2x0aXBzOiB7IHI6IGZhbHNlLCB0OiB0ZXN0VG9vbHRpcHMgfSxcbiAgICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDogeyByOiB0cnVlLCB0OiB0ZXN0S2V5Ym9hcmRTdXBwb3J0IH0sXG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQ6IHsgcjogZmFsc2UsIHQ6IHRlc3REb2N1bWVudEVsZW1lbnQgfSxcbiAgICAgICAgICAgIGNzc1ByZWZpeDogeyByOiB0cnVlLCB0OiB0ZXN0Q3NzUHJlZml4IH0sXG4gICAgICAgICAgICBjc3NDbGFzc2VzOiB7IHI6IHRydWUsIHQ6IHRlc3RDc3NDbGFzc2VzIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgICAgIGJlaGF2aW91cjogXCJ0YXBcIixcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgICAgIGNzc1ByZWZpeDogXCJub1VpLVwiLFxuICAgICAgICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICAgICAgICAgIGtleWJvYXJkUGFnZU11bHRpcGxpZXI6IDUsXG4gICAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiAxMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFyaWFGb3JtYXQgZGVmYXVsdHMgdG8gcmVndWxhciBmb3JtYXQsIGlmIGFueS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICYmICFvcHRpb25zLmFyaWFGb3JtYXQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYXJpYUZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVuIGFsbCBvcHRpb25zIHRocm91Z2ggYSB0ZXN0aW5nIG1lY2hhbmlzbSB0byBlbnN1cmUgY29ycmVjdFxuICAgICAgICAvLyBpbnB1dC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgb3B0aW9ucyBtaWdodCBnZXQgbW9kaWZpZWQgdG9cbiAgICAgICAgLy8gYmUgaGFuZGxlZCBwcm9wZXJseS4gRS5nLiB3cmFwcGluZyBpbnRlZ2VycyBpbiBhcnJheXMuXG4gICAgICAgIE9iamVjdC5rZXlzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXNuJ3Qgc2V0LCBidXQgaXQgaXMgcmVxdWlyZWQsIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKCFpc1NldChvcHRpb25zW25hbWVdKSAmJiBkZWZhdWx0c1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RzW25hbWVdLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVzdHNbbmFtZV0udChwYXJzZWQsICFpc1NldChvcHRpb25zW25hbWVdKSA/IGRlZmF1bHRzW25hbWVdIDogb3B0aW9uc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvcndhcmQgcGlwcyBvcHRpb25zXG4gICAgICAgIHBhcnNlZC5waXBzID0gb3B0aW9ucy5waXBzO1xuXG4gICAgICAgIC8vIEFsbCByZWNlbnQgYnJvd3NlcnMgYWNjZXB0IHVucHJlZml4ZWQgdHJhbnNmb3JtLlxuICAgICAgICAvLyBXZSBuZWVkIC1tcy0gZm9yIElFOSBhbmQgLXdlYmtpdC0gZm9yIG9sZGVyIEFuZHJvaWQ7XG4gICAgICAgIC8vIEFzc3VtZSB1c2Ugb2YgLXdlYmtpdC0gaWYgdW5wcmVmaXhlZCBhbmQgLW1zLSBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD10cmFuc2Zvcm1zMmRcbiAgICAgICAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbXNQcmVmaXggPSBkLnN0eWxlLm1zVHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBub1ByZWZpeCA9IGQuc3R5bGUudHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcGFyc2VkLnRyYW5zZm9ybVJ1bGUgPSBub1ByZWZpeCA/IFwidHJhbnNmb3JtXCIgOiBtc1ByZWZpeCA/IFwibXNUcmFuc2Zvcm1cIiA6IFwid2Via2l0VHJhbnNmb3JtXCI7XG5cbiAgICAgICAgLy8gUGlwcyBkb24ndCBtb3ZlLCBzbyB3ZSBjYW4gcGxhY2UgdGhlbSB1c2luZyBsZWZ0L3RvcC5cbiAgICAgICAgdmFyIHN0eWxlcyA9IFtbXCJsZWZ0XCIsIFwidG9wXCJdLCBbXCJyaWdodFwiLCBcImJvdHRvbVwiXV07XG5cbiAgICAgICAgcGFyc2VkLnN0eWxlID0gc3R5bGVzW3BhcnNlZC5kaXJdW3BhcnNlZC5vcnRdO1xuXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuXG4gICAgLy9lbmRyZWdpb25cblxuICAgIGZ1bmN0aW9uIHNjb3BlKHRhcmdldCwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICAgICAgICB2YXIgc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgPSBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpO1xuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gc3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgJiYgZ2V0U3VwcG9ydHNQYXNzaXZlKCk7XG5cbiAgICAgICAgLy8gQWxsIHZhcmlhYmxlcyBsb2NhbCB0byAnc2NvcGUnIGFyZSBwcmVmaXhlZCB3aXRoICdzY29wZV8nXG5cbiAgICAgICAgLy8gU2xpZGVyIERPTSBOb2Rlc1xuICAgICAgICB2YXIgc2NvcGVfVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgc2NvcGVfQmFzZTtcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZXM7XG4gICAgICAgIHZhciBzY29wZV9Db25uZWN0cztcbiAgICAgICAgdmFyIHNjb3BlX1BpcHM7XG4gICAgICAgIHZhciBzY29wZV9Ub29sdGlwcztcblxuICAgICAgICAvLyBTbGlkZXIgc3RhdGUgdmFsdWVzXG4gICAgICAgIHZhciBzY29wZV9TcGVjdHJ1bSA9IG9wdGlvbnMuc3BlY3RydW07XG4gICAgICAgIHZhciBzY29wZV9WYWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0xvY2F0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc2NvcGVfSGFuZGxlTnVtYmVycyA9IFtdO1xuICAgICAgICB2YXIgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHNjb3BlX0V2ZW50cyA9IHt9O1xuXG4gICAgICAgIC8vIEV4cG9zZWQgQVBJXG4gICAgICAgIHZhciBzY29wZV9TZWxmO1xuXG4gICAgICAgIC8vIERvY3VtZW50IE5vZGVzXG4gICAgICAgIHZhciBzY29wZV9Eb2N1bWVudCA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5kb2N1bWVudEVsZW1lbnQgfHwgc2NvcGVfRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgc2NvcGVfQm9keSA9IHNjb3BlX0RvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgLy8gUGlwcyBjb25zdGFudHNcbiAgICAgICAgdmFyIFBJUFNfTk9ORSA9IC0xO1xuICAgICAgICB2YXIgUElQU19OT19WQUxVRSA9IDA7XG4gICAgICAgIHZhciBQSVBTX0xBUkdFX1ZBTFVFID0gMTtcbiAgICAgICAgdmFyIFBJUFNfU01BTExfVkFMVUUgPSAyO1xuXG4gICAgICAgIC8vIEZvciBob3Jpem9udGFsIHNsaWRlcnMgaW4gc3RhbmRhcmQgbHRyIGRvY3VtZW50cyxcbiAgICAgICAgLy8gbWFrZSAubm9VaS1vcmlnaW4gb3ZlcmZsb3cgdG8gdGhlIGxlZnQgc28gdGhlIGRvY3VtZW50IGRvZXNuJ3Qgc2Nyb2xsLlxuICAgICAgICB2YXIgc2NvcGVfRGlyT2Zmc2V0ID0gc2NvcGVfRG9jdW1lbnQuZGlyID09PSBcInJ0bFwiIHx8IG9wdGlvbnMub3J0ID09PSAxID8gMCA6IDEwMDtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgbm9kZSwgYWRkcyBpdCB0byB0YXJnZXQsIHJldHVybnMgdGhlIG5ldyBub2RlLlxuICAgICAgICBmdW5jdGlvbiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBkaXYgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBhIG9yaWdpbiB0byB0aGUgYmFzZVxuICAgICAgICBmdW5jdGlvbiBhZGRPcmlnaW4oYmFzZSwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5vcmlnaW4pO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZE5vZGVUbyhvcmlnaW4sIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGUpO1xuXG4gICAgICAgICAgICBhZGROb2RlVG8oaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMudG91Y2hBcmVhKTtcblxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImRhdGEtaGFuZGxlXCIsIGhhbmRsZU51bWJlcik7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleWJvYXJkU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcbiAgICAgICAgICAgICAgICAvLyAwID0gZm9jdXNhYmxlIGFuZCByZWFjaGFibGVcbiAgICAgICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRLZXlkb3duKGV2ZW50LCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInNsaWRlclwiKTtcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIG9wdGlvbnMub3J0ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpO1xuXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlTG93ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVOdW1iZXIgPT09IG9wdGlvbnMuaGFuZGxlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oYW5kbGVVcHBlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgbm9kZXMgZm9yIGNvbm5lY3QgZWxlbWVudHNcbiAgICAgICAgZnVuY3Rpb24gYWRkQ29ubmVjdChiYXNlLCBhZGQpIHtcbiAgICAgICAgICAgIGlmICghYWRkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBoYW5kbGVzIHRvIHRoZSBzbGlkZXIgYmFzZS5cbiAgICAgICAgZnVuY3Rpb24gYWRkRWxlbWVudHMoY29ubmVjdE9wdGlvbnMsIGJhc2UpIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0QmFzZSA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdHMpO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzID0gW107XG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cyA9IFtdO1xuXG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cy5wdXNoKGFkZENvbm5lY3QoY29ubmVjdEJhc2UsIGNvbm5lY3RPcHRpb25zWzBdKSk7XG5cbiAgICAgICAgICAgIC8vIFs6Ojo6Tz09PT1PPT09PU89PT09XVxuICAgICAgICAgICAgLy8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmhhbmRsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBhZGRlZCBoYW5kbGVzLlxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMucHVzaChhZGRPcmlnaW4oYmFzZSwgaSkpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnNbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbaSArIDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIGEgc2luZ2xlIHNsaWRlci5cbiAgICAgICAgZnVuY3Rpb24gYWRkU2xpZGVyKGFkZFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQXBwbHkgY2xhc3NlcyBhbmQgZGF0YSB0byB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFyZ2V0KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMubHRyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMucnRsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3J0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuaG9yaXpvbnRhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZlcnRpY2FsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHREaXJlY3Rpb24gPSBnZXRDb21wdXRlZFN0eWxlKGFkZFRhcmdldCkuZGlyZWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAodGV4dERpcmVjdGlvbiA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRleHREaXJlY3Rpb25SdGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50ZXh0RGlyZWN0aW9uTHRyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5iYXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvb2x0aXAoaGFuZGxlLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTm9kZVRvKGhhbmRsZS5maXJzdENoaWxkLCBvcHRpb25zLmNzc0NsYXNzZXMudG9vbHRpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1NsaWRlckRpc2FibGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1RhcmdldC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGUgdGhlIHNsaWRlciBkcmFnZ2luZyBpZiBhbnkgaGFuZGxlIGlzIGRpc2FibGVkXG4gICAgICAgIGZ1bmN0aW9uIGlzSGFuZGxlRGlzYWJsZWQoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlT3JpZ2luID0gc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU9yaWdpbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvb2x0aXBzKCkge1xuICAgICAgICAgICAgaWYgKHNjb3BlX1Rvb2x0aXBzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzKTtcbiAgICAgICAgICAgICAgICBzY29wZV9Ub29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY29wZV9Ub29sdGlwcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdG9vbHRpcHMgb3B0aW9uIGlzIGEgc2hvcnRoYW5kIGZvciB1c2luZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBzKCkge1xuICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHMoKTtcblxuICAgICAgICAgICAgLy8gVG9vbHRpcHMgYXJlIGFkZGVkIHdpdGggb3B0aW9ucy50b29sdGlwcyBpbiBvcmlnaW5hbCBvcmRlci5cbiAgICAgICAgICAgIHNjb3BlX1Rvb2x0aXBzID0gc2NvcGVfSGFuZGxlcy5tYXAoYWRkVG9vbHRpcCk7XG5cbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMudG9vbHRpcHMsIGZ1bmN0aW9uKHZhbHVlcywgaGFuZGxlTnVtYmVyLCB1bmVuY29kZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlX1Rvb2x0aXBzW2hhbmRsZU51bWJlcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHZhbHVlc1toYW5kbGVOdW1iZXJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IG9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXS50byh1bmVuY29kZWRbaGFuZGxlTnVtYmVyXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHNbaGFuZGxlTnVtYmVyXS5pbm5lckhUTUwgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXJpYSgpIHtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KFwidXBkYXRlXCIgKyBJTlRFUk5BTF9FVkVOVF9OUy5hcmlhKTtcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMuYXJpYSwgZnVuY3Rpb24odmFsdWVzLCBoYW5kbGVOdW1iZXIsIHVuZW5jb2RlZCwgdGFwLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgQXJpYSBWYWx1ZXMgZm9yIGFsbCBoYW5kbGVzLCBhcyBhIGNoYW5nZSBpbiBvbmUgY2hhbmdlcyBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIHRoZSBuZXh0LlxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2NvcGVfSGFuZGxlc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbiA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBpbmRleCwgMCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDEwMCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHBvc2l0aW9uc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0dGVkIHZhbHVlIGZvciBkaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gb3B0aW9ucy5hcmlhRm9ybWF0LnRvKHVuZW5jb2RlZFtpbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcCB0byBzbGlkZXIgcmFuZ2UgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhtaW4pLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhtYXgpLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICAgICAgICAgIG5vdyA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhub3cpLnRvRml4ZWQoMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVtaW5cIiwgbWluKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVtYXhcIiwgbWF4KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIiwgbm93KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWV0ZXh0XCIsIHRleHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cChtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcmFuZ2UuXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJyYW5nZVwiIHx8IG1vZGUgPT09IFwic3RlcHNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS54VmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJjb3VudFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcyA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndmFsdWVzJyAoPj0gMikgcmVxdWlyZWQgZm9yIG1vZGUgJ2NvdW50Jy5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGl2aWRlIDAgLSAxMDAgaW4gJ2NvdW50JyBwYXJ0cy5cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB2YWx1ZXMgLSAxO1xuICAgICAgICAgICAgICAgIHZhciBzcHJlYWQgPSAxMDAgLyBpbnRlcnZhbDtcblxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gTGlzdCB0aGVzZSBwYXJ0cyBhbmQgaGF2ZSB0aGVtIGhhbmRsZWQgYXMgJ3Bvc2l0aW9ucycuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGludGVydmFsLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ludGVydmFsXSA9IGludGVydmFsICogc3ByZWFkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKDEwMCk7XG5cbiAgICAgICAgICAgICAgICBtb2RlID0gXCJwb3NpdGlvbnNcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwicG9zaXRpb25zXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXAgYWxsIHBlcmNlbnRhZ2VzIHRvIG9uLXJhbmdlIHZhbHVlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHN0ZXBwZWQgPyBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwidmFsdWVzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgbXVzdCBiZSBzdGVwcGVkLCBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBwZXJjZW50YWdlIGZpcnN0LlxuICAgICAgICAgICAgICAgIGlmIChzdGVwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHBlcmNlbnRhZ2UsIGFwcGx5IHN0ZXAsIHJldHVybiB0byB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoc2NvcGVfU3BlY3RydW0uZ2V0U3RlcChzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3ByZWFkKGRlbnNpdHksIG1vZGUsIGdyb3VwKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBzYWZlSW5jcmVtZW50KHZhbHVlLCBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBmbG9hdGluZyBwb2ludCB2YXJpYW5jZSBieSBkcm9wcGluZyB0aGUgc21hbGxlc3QgZGVjaW1hbCBwbGFjZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSArIGluY3JlbWVudCkudG9GaXhlZCg3KSAvIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleGVzID0ge307XG4gICAgICAgICAgICB2YXIgZmlyc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgICAgIHZhciBsYXN0SW5SYW5nZSA9IHNjb3BlX1NwZWN0cnVtLnhWYWxbc2NvcGVfU3BlY3RydW0ueFZhbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlnbm9yZUxhc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwcmV2UGN0ID0gMDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZ3JvdXAsIHNvcnQgaXQgYW5kIGZpbHRlciBhd2F5IGFsbCBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgZ3JvdXAgPSB1bmlxdWUoXG4gICAgICAgICAgICAgICAgZ3JvdXAuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJhbmdlIHN0YXJ0cyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBncm91cC51bnNoaWZ0KGZpcnN0SW5SYW5nZSk7XG4gICAgICAgICAgICAgICAgaWdub3JlRmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMaWtld2lzZSBmb3IgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgaWYgKGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdICE9PSBsYXN0SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLnB1c2gobGFzdEluUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlnbm9yZUxhc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uKGN1cnJlbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgYW5kIHRoZSBsb3dlciArIHVwcGVyIHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgcTtcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaCA9IGdyb3VwW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIG5ld1BjdDtcbiAgICAgICAgICAgICAgICB2YXIgcGN0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgcGN0UG9zO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwcztcbiAgICAgICAgICAgICAgICB2YXIgcmVhbFN0ZXBzO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwU2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgaXNTdGVwcyA9IG1vZGUgPT09IFwic3RlcHNcIjtcblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgJ3N0ZXBzJyBtb2RlLCB1c2UgdGhlIHByb3ZpZGVkIHN0ZXBzLlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgc3RlcCBvbiB0byB0aGUgbmV4dCBzdWJyYW5nZS5cbiAgICAgICAgICAgICAgICBpZiAoaXNTdGVwcykge1xuICAgICAgICAgICAgICAgICAgICBzdGVwID0gc2NvcGVfU3BlY3RydW0ueE51bVN0ZXBzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGEgJ2Z1bGwnIHN0ZXAuXG4gICAgICAgICAgICAgICAgaWYgKCFzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBoaWdoIC0gbG93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvdyBjYW4gYmUgMCwgc28gdGVzdCBmb3IgZmFsc2UuIEluZGV4IDAgaXMgYWxyZWFkeSBoYW5kbGVkLlxuICAgICAgICAgICAgICAgIGlmIChsb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBoaWdoIGlzIHVuZGVmaW5lZCB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIE1ha2Ugc3VyZSBpdCBpdGVyYXRlcyBvbmNlICgjMTA4OClcbiAgICAgICAgICAgICAgICBpZiAoaGlnaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBsb3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN0ZXAgaXNuJ3QgMCwgd2hpY2ggd291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCAoIzY1NClcbiAgICAgICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoc3RlcCwgMC4wMDAwMDAxKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgYWxsIHN0ZXBzIGluIHRoZSBzdWJyYW5nZS5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSA9IHNhZmVJbmNyZW1lbnQoaSwgc3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwZXJjZW50YWdlIHZhbHVlIGZvciB0aGUgY3VycmVudCBzdGVwLFxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNpemUgZm9yIHRoZSBzdWJyYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgbmV3UGN0ID0gc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyhpKTtcbiAgICAgICAgICAgICAgICAgICAgcGN0RGlmZmVyZW5jZSA9IG5ld1BjdCAtIHByZXZQY3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RlcHMgPSBwY3REaWZmZXJlbmNlIC8gZGVuc2l0eTtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFN0ZXBzID0gTWF0aC5yb3VuZChzdGVwcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByYXRpbyByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgcGVyY2VudGFnZS1zcGFjZSBhIHBvaW50IGluZGljYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGEgZGVuc2l0eSAxIHRoZSBwb2ludHMvcGVyY2VudGFnZSA9IDEuIEZvciBkZW5zaXR5IDIsIHRoYXQgcGVyY2VudGFnZSBuZWVkcyB0byBiZSByZS1kaXZpZGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBzcHJlYWQgdGhlIG9mZnNldCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgc3RlcFNpemUgPSBwY3REaWZmZXJlbmNlIC8gcmVhbFN0ZXBzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERpdmlkZSBhbGwgcG9pbnRzIGV2ZW5seSwgYWRkaW5nIHRoZSBjb3JyZWN0IG51bWJlciB0byB0aGlzIHN1YnJhbmdlLlxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdXAgdG8gPD0gc28gdGhhdCAxMDAlIGdldHMgYSBwb2ludCwgZXZlbnQgaWYgaWdub3JlTGFzdCBpcyBzZXQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocSA9IDE7IHEgPD0gcmVhbFN0ZXBzOyBxICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByYXRpbyBiZXR3ZWVuIHRoZSByb3VuZGVkIHZhbHVlIGFuZCB0aGUgYWN0dWFsIHNpemUgbWlnaHQgYmUgfjElIG9mZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY3QgdGhlIHBlcmNlbnRhZ2Ugb2Zmc2V0IGJ5IHRoZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXIgc3VicmFuZ2UuIGRlbnNpdHkgPSAxIHdpbGwgcmVzdWx0IGluIDEwMCBwb2ludHMgb24gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmdWxsIHJhbmdlLCAyIGZvciA1MCwgNCBmb3IgMjUsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBjdFBvcyA9IHByZXZQY3QgKyBxICogc3RlcFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzW3BjdFBvcy50b0ZpeGVkKDUpXSA9IFtzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcocGN0UG9zKSwgMF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBncm91cC5pbmRleE9mKGkpID4gLTEgPyBQSVBTX0xBUkdFX1ZBTFVFIDogaXNTdGVwcyA/IFBJUFNfU01BTExfVkFMVUUgOiBQSVBTX05PX1ZBTFVFO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZm9yY2UgdGhlICdpZ25vcmVGaXJzdCcgb3B0aW9uIGJ5IG92ZXJ3cml0aW5nIHRoZSB0eXBlIGZvciAwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluZGV4ICYmIGlnbm9yZUZpcnN0ICYmIGkgIT09IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA9PT0gaGlnaCAmJiBpZ25vcmVMYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgJ3R5cGUnIG9mIHRoaXMgcG9pbnQuIDAgPSBwbGFpbiwgMSA9IHJlYWwgdmFsdWUsIDIgPSBzdGVwIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1tuZXdQY3QudG9GaXhlZCg1KV0gPSBbaSwgdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlcmNlbnRhZ2UgY291bnQuXG4gICAgICAgICAgICAgICAgICAgIHByZXZQY3QgPSBuZXdQY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkTWFya2luZyhzcHJlYWQsIGZpbHRlckZ1bmMsIGZvcm1hdHRlcikge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWVTaXplQ2xhc3NlcyA9IFtdO1xuICAgICAgICAgICAgdmFsdWVTaXplQ2xhc3Nlc1tQSVBTX05PX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZU5vcm1hbDtcbiAgICAgICAgICAgIHZhbHVlU2l6ZUNsYXNzZXNbUElQU19MQVJHRV9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVMYXJnZTtcbiAgICAgICAgICAgIHZhbHVlU2l6ZUNsYXNzZXNbUElQU19TTUFMTF9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVTdWI7XG5cbiAgICAgICAgICAgIHZhciBtYXJrZXJTaXplQ2xhc3NlcyA9IFtdO1xuICAgICAgICAgICAgbWFya2VyU2l6ZUNsYXNzZXNbUElQU19OT19WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyTm9ybWFsO1xuICAgICAgICAgICAgbWFya2VyU2l6ZUNsYXNzZXNbUElQU19MQVJHRV9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyTGFyZ2U7XG4gICAgICAgICAgICBtYXJrZXJTaXplQ2xhc3Nlc1tQSVBTX1NNQUxMX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJTdWI7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyA9IFtvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVIb3Jpem9udGFsLCBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVWZXJ0aWNhbF07XG4gICAgICAgICAgICB2YXIgbWFya2VyT3JpZW50YXRpb25DbGFzc2VzID0gW29wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJIb3Jpem9udGFsLCBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyVmVydGljYWxdO1xuXG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBvcHRpb25zLmNzc0NsYXNzZXMucGlwcyk7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBvcHRpb25zLm9ydCA9PT0gMCA/IG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzSG9yaXpvbnRhbCA6IG9wdGlvbnMuY3NzQ2xhc3Nlcy5waXBzVmVydGljYWwpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDbGFzc2VzKHR5cGUsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gc291cmNlID09PSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudGF0aW9uQ2xhc3NlcyA9IGEgPyB2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyA6IG1hcmtlck9yaWVudGF0aW9uQ2xhc3NlcztcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZUNsYXNzZXMgPSBhID8gdmFsdWVTaXplQ2xhc3NlcyA6IG1hcmtlclNpemVDbGFzc2VzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSArIFwiIFwiICsgb3JpZW50YXRpb25DbGFzc2VzW29wdGlvbnMub3J0XSArIFwiIFwiICsgc2l6ZUNsYXNzZXNbdHlwZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFNwcmVhZChvZmZzZXQsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGZpbHRlciBmdW5jdGlvbiwgaWYgaXQgaXMgc2V0LlxuICAgICAgICAgICAgICAgIHR5cGUgPSBmaWx0ZXJGdW5jID8gZmlsdGVyRnVuYyh2YWx1ZSwgdHlwZSkgOiB0eXBlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBJUFNfTk9ORSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgbWFya2VyIGZvciBldmVyeSBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlcik7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtvcHRpb25zLnN0eWxlXSA9IG9mZnNldCArIFwiJVwiO1xuXG4gICAgICAgICAgICAgICAgLy8gVmFsdWVzIGFyZSBvbmx5IGFwcGVuZGVkIGZvciBwb2ludHMgbWFya2VkICcxJyBvciAnMicuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPiBQSVBTX05PX1ZBTFVFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBhZGROb2RlVG8oZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtvcHRpb25zLnN0eWxlXSA9IG9mZnNldCArIFwiJVwiO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IGZvcm1hdHRlci50byh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBlbmQgYWxsIHBvaW50cy5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNwcmVhZCkuZm9yRWFjaChmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBhZGRTcHJlYWQob2Zmc2V0LCBzcHJlYWRbb2Zmc2V0XVswXSwgc3ByZWFkW29mZnNldF1bMV0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUGlwcygpIHtcbiAgICAgICAgICAgIGlmIChzY29wZV9QaXBzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudChzY29wZV9QaXBzKTtcbiAgICAgICAgICAgICAgICBzY29wZV9QaXBzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBpcHMoZ3JpZCkge1xuICAgICAgICAgICAgLy8gRml4ICM2NjlcbiAgICAgICAgICAgIHJlbW92ZVBpcHMoKTtcblxuICAgICAgICAgICAgdmFyIG1vZGUgPSBncmlkLm1vZGU7XG4gICAgICAgICAgICB2YXIgZGVuc2l0eSA9IGdyaWQuZGVuc2l0eSB8fCAxO1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IGdyaWQuZmlsdGVyIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGdyaWQudmFsdWVzIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHN0ZXBwZWQgPSBncmlkLnN0ZXBwZWQgfHwgZmFsc2U7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBnZXRHcm91cChtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQpO1xuICAgICAgICAgICAgdmFyIHNwcmVhZCA9IGdlbmVyYXRlU3ByZWFkKGRlbnNpdHksIG1vZGUsIGdyb3VwKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBncmlkLmZvcm1hdCB8fCB7XG4gICAgICAgICAgICAgICAgdG86IE1hdGgucm91bmRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNjb3BlX1BpcHMgPSBzY29wZV9UYXJnZXQuYXBwZW5kQ2hpbGQoYWRkTWFya2luZyhzcHJlYWQsIGZpbHRlciwgZm9ybWF0KSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzY29wZV9QaXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvcnRoYW5kIGZvciBiYXNlIGRpbWVuc2lvbnMuXG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTaXplKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBzY29wZV9CYXNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIGFsdCA9IFwib2Zmc2V0XCIgKyBbXCJXaWR0aFwiLCBcIkhlaWdodFwiXVtvcHRpb25zLm9ydF07XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vcnQgPT09IDAgPyByZWN0LndpZHRoIHx8IHNjb3BlX0Jhc2VbYWx0XSA6IHJlY3QuaGVpZ2h0IHx8IHNjb3BlX0Jhc2VbYWx0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZXIgZm9yIGF0dGFjaGluZyBldmVudHMgdHJvdWdoIGEgcHJveHkuXG4gICAgICAgIGZ1bmN0aW9uIGF0dGFjaEV2ZW50KGV2ZW50cywgZWxlbWVudCwgY2FsbGJhY2ssIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gJ2ZpbHRlcicgZXZlbnRzIHRvIHRoZSBzbGlkZXIuXG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGEgbm9kZSwgbm90IGEgbm9kZUxpc3RcblxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlID0gZml4RXZlbnQoZSwgZGF0YS5wYWdlT2Zmc2V0LCBkYXRhLnRhcmdldCB8fCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIGZpeEV2ZW50IHJldHVybnMgZmFsc2UgaWYgdGhpcyBldmVudCBoYXMgYSBkaWZmZXJlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBoYW5kbGluZyAobXVsdGktKSB0b3VjaCBldmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkb05vdFJlamVjdCBpcyBwYXNzZWQgYnkgYWxsIGVuZCBldmVudHMgdG8gbWFrZSBzdXJlIHJlbGVhc2VkIHRvdWNoZXNcbiAgICAgICAgICAgICAgICAvLyBhcmUgbm90IHJlamVjdGVkLCBsZWF2aW5nIHRoZSBzbGlkZXIgXCJzdHVja1wiIHRvIHRoZSBjdXJzb3I7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2xpZGVyRGlzYWJsZWQoKSAmJiAhZGF0YS5kb05vdFJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBhbiBhY3RpdmUgJ3RhcCcgdHJhbnNpdGlvbiBpcyB0YWtpbmcgcGxhY2UuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSByaWdodCBvciBtaWRkbGUgY2xpY2tzIG9uIHN0YXJ0ICM0NTRcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5ob3ZlciAmJiBlLmJ1dHRvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vICdzdXBwb3J0c1Bhc3NpdmUnIGlzIG9ubHkgdHJ1ZSBpZiBhIGJyb3dzZXIgYWxzbyBzdXBwb3J0cyB0b3VjaC1hY3Rpb246IG5vbmUgaW4gQ1NTLlxuICAgICAgICAgICAgICAgIC8vIGlPUyBzYWZhcmkgZG9lcyBub3QsIHNvIGl0IGRvZXNuJ3QgZ2V0IHRvIGJlbmVmaXQgZnJvbSBwYXNzaXZlIHNjcm9sbGluZy4gaU9TIGRvZXMgc3VwcG9ydFxuICAgICAgICAgICAgICAgIC8vIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uLCBidXQgdGhhdCBhbGxvd3MgcGFubmluZywgd2hpY2ggYnJlYWtzXG4gICAgICAgICAgICAgICAgLy8gc2xpZGVycyBhZnRlciB6b29taW5nL29uIG5vbi1yZXNwb25zaXZlIHBhZ2VzLlxuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzMzExMlxuICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydHNQYXNzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlLmNhbGNQb2ludCA9IGUucG9pbnRzW29wdGlvbnMub3J0XTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIGV2ZW50IGhhbmRsZXIgd2l0aCB0aGUgZXZlbnQgWyBhbmQgYWRkaXRpb25hbCBkYXRhIF0uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZGF0YSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBCaW5kIGEgY2xvc3VyZSBvbiB0aGUgdGFyZ2V0IGZvciBldmVyeSBldmVudCB0eXBlLlxuICAgICAgICAgICAgZXZlbnRzLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG1ldGhvZCwgc3VwcG9ydHNQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbWV0aG9kcy5wdXNoKFtldmVudE5hbWUsIG1ldGhvZF0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvdmlkZSBhIGNsZWFuIGV2ZW50IHdpdGggc3RhbmRhcmRpemVkIG9mZnNldCB2YWx1ZXMuXG4gICAgICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGUsIHBhZ2VPZmZzZXQsIGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIHRoZSB0eXBlLCB3aGljaCBjYW4gYmVcbiAgICAgICAgICAgIC8vIHRvdWNoLCBtb3VzZSBvciBwb2ludGVyLiBPZmZzZXQgY2hhbmdlcyBuZWVkIHRvIGJlXG4gICAgICAgICAgICAvLyBtYWRlIG9uIGFuIGV2ZW50IHNwZWNpZmljIGJhc2lzLlxuICAgICAgICAgICAgdmFyIHRvdWNoID0gZS50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA9PT0gMDtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUudHlwZS5pbmRleE9mKFwibW91c2VcIikgPT09IDA7XG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IGUudHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA9PT0gMDtcblxuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgeTtcblxuICAgICAgICAgICAgLy8gSUUxMCBpbXBsZW1lbnRlZCBwb2ludGVyIGV2ZW50cyB3aXRoIGEgcHJlZml4O1xuICAgICAgICAgICAgaWYgKGUudHlwZS5pbmRleE9mKFwiTVNQb2ludGVyXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVycm9uZW91cyBldmVudHMgc2VlbSB0byBiZSBwYXNzZWQgaW4gb2NjYXNpb25hbGx5IG9uIGlPUy9pUGFkT1MgYWZ0ZXIgdXNlciBmaW5pc2hlcyBpbnRlcmFjdGluZyB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgc2xpZGVyLiBUaGV5IGFwcGVhciB0byBiZSBvZiB0eXBlIE1vdXNlRXZlbnQsIHlldCB0aGV5IGRvbid0IGhhdmUgdXN1YWwgcHJvcGVydGllcyBzZXQuIElnbm9yZVxuICAgICAgICAgICAgLy8gZXZlbnRzIHRoYXQgaGF2ZSBubyB0b3VjaGVzIG9yIGJ1dHRvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZW0uICgjMTA1NywgIzEwNzksICMxMDk1KVxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhZS5idXR0b25zICYmICFlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBvbmx5IHRoaW5nIG9uZSBoYW5kbGUgc2hvdWxkIGJlIGNvbmNlcm5lZCBhYm91dCBpcyB0aGUgdG91Y2hlcyB0aGF0IG9yaWdpbmF0ZWQgb24gdG9wIG9mIGl0LlxuICAgICAgICAgICAgaWYgKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGEgdG91Y2ggb3JpZ2luYXRlZCBvbiB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICAgIHZhciBpc1RvdWNoT25UYXJnZXQgPSBmdW5jdGlvbihjaGVja1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1RvdWNoLnRhcmdldCA9PT0gZXZlbnRUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmNvbnRhaW5zKGNoZWNrVG91Y2gudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoZWNrVG91Y2gudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgY2hlY2tUb3VjaC50YXJnZXQuc2hhZG93Um9vdC5jb250YWlucyhldmVudFRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIHRvdWNoc3RhcnQgZXZlbnRzLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBzdGlsbCBubyBtb3JlIHRoYW4gb25lXG4gICAgICAgICAgICAgICAgLy8gdG91Y2ggb24gdGhlIHRhcmdldCBzbyB3ZSBsb29rIGFtb25nc3QgYWxsIHRvdWNoZXMuXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFRvdWNoZXMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZS50b3VjaGVzLCBpc1RvdWNoT25UYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiBvbmUgdG91Y2ggcGVyIGhhbmRsZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IHRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSBvdGhlciBjYXNlcywgZmluZCBvbiBjaGFuZ2VkVG91Y2hlcyBpcyBlbm91Z2guXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoZS5jaGFuZ2VkVG91Y2hlcywgaXNUb3VjaE9uVGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYW5jZWwgaWYgdGhlIHRhcmdldCB0b3VjaCBoYXMgbm90IG1vdmVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFRvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0VG91Y2gucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRUb3VjaC5wYWdlWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0IHx8IGdldFBhZ2VPZmZzZXQoc2NvcGVfRG9jdW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAobW91c2UgfHwgcG9pbnRlcikge1xuICAgICAgICAgICAgICAgIHggPSBlLmNsaWVudFggKyBwYWdlT2Zmc2V0Lng7XG4gICAgICAgICAgICAgICAgeSA9IGUuY2xpZW50WSArIHBhZ2VPZmZzZXQueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5wYWdlT2Zmc2V0ID0gcGFnZU9mZnNldDtcbiAgICAgICAgICAgIGUucG9pbnRzID0gW3gsIHldO1xuICAgICAgICAgICAgZS5jdXJzb3IgPSBtb3VzZSB8fCBwb2ludGVyOyAvLyBGaXggIzQzNVxuXG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYW5zbGF0ZSBhIGNvb3JkaW5hdGUgaW4gdGhlIGRvY3VtZW50IHRvIGEgcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNQb2ludFRvUGVyY2VudGFnZShjYWxjUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNhbGNQb2ludCAtIG9mZnNldChzY29wZV9CYXNlLCBvcHRpb25zLm9ydCk7XG4gICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSAobG9jYXRpb24gKiAxMDApIC8gYmFzZVNpemUoKTtcblxuICAgICAgICAgICAgLy8gQ2xhbXAgcHJvcG9zYWwgYmV0d2VlbiAwJSBhbmQgMTAwJVxuICAgICAgICAgICAgLy8gT3V0LW9mLWJvdW5kIGNvb3JkaW5hdGVzIG1heSBvY2N1ciB3aGVuIC5ub1VpLWJhc2UgcHNldWRvLWVsZW1lbnRzXG4gICAgICAgICAgICAvLyBhcmUgdXNlZCAoZS5nLiBjb250YWluZWQgaGFuZGxlcyBmZWF0dXJlKVxuICAgICAgICAgICAgcHJvcG9zYWwgPSBsaW1pdChwcm9wb3NhbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRpciA/IDEwMCAtIHByb3Bvc2FsIDogcHJvcG9zYWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIGhhbmRsZSBjbG9zZXN0IHRvIGEgY2VydGFpbiBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEhhbmRsZShjbGlja2VkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzbWFsbGVzdERpZmZlcmVuY2UgPSAxMDA7XG4gICAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZWQgaGFuZGxlcyBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICAgIGlmIChpc0hhbmRsZURpc2FibGVkKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZVBvc2l0aW9uID0gc2NvcGVfTG9jYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZVdpdGhUaGlzSGFuZGxlID0gTWF0aC5hYnMoaGFuZGxlUG9zaXRpb24gLSBjbGlja2VkUG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgICAgIHZhciBjbGlja0F0RWRnZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA9PT0gMTAwICYmIHNtYWxsZXN0RGlmZmVyZW5jZSA9PT0gMTAwO1xuXG4gICAgICAgICAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHRoaXMgaGFuZGxlIGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXNseSBjaGVja2VkIGhhbmRsZVxuICAgICAgICAgICAgICAgIHZhciBpc0Nsb3NlciA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA8IHNtYWxsZXN0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9zZXJBZnRlciA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA8PSBzbWFsbGVzdERpZmZlcmVuY2UgJiYgY2xpY2tlZFBvc2l0aW9uID4gaGFuZGxlUG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNDbG9zZXIgfHwgaXNDbG9zZXJBZnRlciB8fCBjbGlja0F0RWRnZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3REaWZmZXJlbmNlID0gZGlmZmVyZW5jZVdpdGhUaGlzSGFuZGxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZSAnZW5kJyB3aGVuIGEgbW91c2Ugb3IgcGVuIGxlYXZlcyB0aGUgZG9jdW1lbnQuXG4gICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50TGVhdmUoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlb3V0XCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiAmJiBldmVudC5yZWxhdGVkVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIG1vdmVtZW50IG9uIGRvY3VtZW50IGZvciBoYW5kbGUgYW5kIHJhbmdlIGRyYWcuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50TW92ZShldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gRml4ICM0OThcbiAgICAgICAgICAgIC8vIENoZWNrIHZhbHVlIG9mIC5idXR0b25zIGluICdzdGFydCcgdG8gd29yayBhcm91bmQgYSBidWcgaW4gSUUxMCBtb2JpbGUgKGRhdGEuYnV0dG9uc1Byb3BlcnR5KS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvOTI3MDA1L21vYmlsZS1pZTEwLXdpbmRvd3MtcGhvbmUtYnV0dG9ucy1wcm9wZXJ0eS1vZi1wb2ludGVybW92ZS1ldmVudC1hbHdheXMtemVyb1xuICAgICAgICAgICAgLy8gSUU5IGhhcyAuYnV0dG9ucyBhbmQgLndoaWNoIHplcm8gb24gbW91c2Vtb3ZlLlxuICAgICAgICAgICAgLy8gRmlyZWZveCBicmVha3MgdGhlIHNwZWMgTUROIGRlZmluZXMuXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZihcIk1TSUUgOVwiKSA9PT0gLTEgJiYgZXZlbnQuYnV0dG9ucyA9PT0gMCAmJiBkYXRhLmJ1dHRvbnNQcm9wZXJ0eSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVuZChldmVudCwgZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBtb3ZpbmcgdXAgb3IgZG93blxuICAgICAgICAgICAgdmFyIG1vdmVtZW50ID0gKG9wdGlvbnMuZGlyID8gLTEgOiAxKSAqIChldmVudC5jYWxjUG9pbnQgLSBkYXRhLnN0YXJ0Q2FsY1BvaW50KTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbW92ZW1lbnQgaW50byBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciB3aWR0aC9oZWlnaHRcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IChtb3ZlbWVudCAqIDEwMCkgLyBkYXRhLmJhc2VTaXplO1xuXG4gICAgICAgICAgICBtb3ZlSGFuZGxlcyhtb3ZlbWVudCA+IDAsIHByb3Bvc2FsLCBkYXRhLmxvY2F0aW9ucywgZGF0YS5oYW5kbGVOdW1iZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuYmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudCwgY2FsbCBjYWxsYmFja3MuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50RW5kKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBUaGUgaGFuZGxlIGlzIG5vIGxvbmdlciBhY3RpdmUsIHNvIHJlbW92ZSB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhkYXRhLmhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50IC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVuYmluZCB0aGUgbW92ZSBhbmQgZW5kIGV2ZW50cywgd2hpY2ggYXJlIGFkZGVkIG9uICdzdGFydCcuXG4gICAgICAgICAgICBkYXRhLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9Eb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjWzBdLCBjWzFdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGRyYWdnaW5nIGNsYXNzLlxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xuICAgICAgICAgICAgICAgIHNldFppbmRleCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnNvciBzdHlsZXMgYW5kIHRleHQtc2VsZWN0aW9uIGV2ZW50cyBib3VuZCB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgcHJldmVudERlZmF1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YS5oYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwiZW5kXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQuXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50U3RhcnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBldmVudCBpZiBhbnkgaGFuZGxlIGlzIGRpc2FibGVkXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLnNvbWUoaXNIYW5kbGVEaXNhYmxlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoYW5kbGU7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmhhbmRsZU51bWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGhhbmRsZU9yaWdpbi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgKz0gMTtcblxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlIGhhbmRsZSBhcyAnYWN0aXZlJyBzbyBpdCBjYW4gYmUgc3R5bGVkLlxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBtb3ZlIGFuZCBlbmQgZXZlbnRzLlxuICAgICAgICAgICAgdmFyIG1vdmVFdmVudCA9IGF0dGFjaEV2ZW50KGFjdGlvbnMubW92ZSwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudE1vdmUsIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXZlbnQgdGFyZ2V0IGhhcyBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcHJvcGFnYXRlIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCB3ZSBrZWVwXG4gICAgICAgICAgICAgICAgLy8gcmVseWluZyBvbiBpdCB0byBleHRyYWN0IHRhcmdldCB0b3VjaGVzLlxuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q2FsY1BvaW50OiBldmVudC5jYWxjUG9pbnQsXG4gICAgICAgICAgICAgICAgYmFzZVNpemU6IGJhc2VTaXplKCksXG4gICAgICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnMsXG4gICAgICAgICAgICAgICAgYnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIGRvTm90UmVqZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVyc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBvdXRFdmVudCA9IGF0dGFjaEV2ZW50KFwibW91c2VvdXRcIiwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudExlYXZlLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogZGF0YS5oYW5kbGVOdW1iZXJzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgcHVzaGVkIHRoZSBsaXN0ZW5lcnMgaW4gdGhlIGxpc3RlbmVyIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRpbmdcbiAgICAgICAgICAgIC8vIGEgbmV3IG9uZSBhcyBpdCBoYXMgYWxyZWFkeSBiZWVuIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIG1vdmVFdmVudC5jb25jYXQoZW5kRXZlbnQsIG91dEV2ZW50KSk7XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2VsZWN0aW9uIGlzbid0IGFuIGlzc3VlIG9uIHRvdWNoIGRldmljZXMsXG4gICAgICAgICAgICAvLyBzbyBhZGRpbmcgY3Vyc29yIHN0eWxlcyBjYW4gYmUgc2tpcHBlZC5cbiAgICAgICAgICAgIGlmIChldmVudC5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRoZSAnSScgY3Vyc29yIGFuZCBleHRlbmQgdGhlIHJhbmdlLWRyYWcgY3Vyc29yLlxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcblxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlIHRhcmdldCB3aXRoIGEgZHJhZ2dpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmcgdGhlIGhhbmRsZXMuXG4gICAgICAgICAgICAgICAgLy8gSW4gbm9VaVNsaWRlciA8PSA5LjIuMCwgdGhpcyB3YXMgaGFuZGxlZCBieSBjYWxsaW5nIHByZXZlbnREZWZhdWx0IG9uIG1vdXNlL3RvdWNoIHN0YXJ0L21vdmUsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgc2Nyb2xsIGJsb2NraW5nLiBUaGUgc2VsZWN0c3RhcnQgZXZlbnQgaXMgc3VwcG9ydGVkIGJ5IEZpcmVGb3ggc3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDUyLFxuICAgICAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhlIG9ubHkgaG9sZG91dCBpcyBpT1MgU2FmYXJpLiBUaGlzIGRvZXNuJ3QgbWF0dGVyOiB0ZXh0IHNlbGVjdGlvbiBpc24ndCB0cmlnZ2VyZWQgdGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gVGhlICdjdXJzb3InIGZsYWcgaXMgZmFsc2UuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zZWxlY3RzdGFydFxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInN0YXJ0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxuICAgICAgICBmdW5jdGlvbiBldmVudFRhcChldmVudCkge1xuICAgICAgICAgICAgLy8gVGhlIHRhcCBldmVudCBzaG91bGRuJ3QgcHJvcGFnYXRlIHVwXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XG4gICAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZ2V0Q2xvc2VzdEhhbmRsZShwcm9wb3NhbCk7XG5cbiAgICAgICAgICAgIC8vIFRhY2tsZSB0aGUgY2FzZSB0aGF0IGFsbCBoYW5kbGVzIGFyZSAnZGlzYWJsZWQnLlxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZsYWcgdGhlIHNsaWRlciBhcyBpdCBpcyBub3cgaW4gYSB0cmFuc2l0aW9uYWwgc3RhdGUuXG4gICAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRha2VzIGEgY29uZmlndXJhYmxlIGFtb3VudCBvZiBtcyAoZGVmYXVsdCAzMDApLiBSZS1lbmFibGUgdGhlIHNsaWRlciBhZnRlciB0aGF0LlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3NGb3Ioc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwLCBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgcHJvcG9zYWwsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICBzZXRaaW5kZXgoKTtcblxuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRzLnNuYXApIHtcbiAgICAgICAgICAgICAgICBldmVudFN0YXJ0KGV2ZW50LCB7IGhhbmRsZU51bWJlcnM6IFtoYW5kbGVOdW1iZXJdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZXMgYSAnaG92ZXInIGV2ZW50IGZvciBhIGhvdmVyZWQgbW91c2UvcGVuIHBvc2l0aW9uLlxuICAgICAgICBmdW5jdGlvbiBldmVudEhvdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSBjYWxjUG9pbnRUb1BlcmNlbnRhZ2UoZXZlbnQuY2FsY1BvaW50KTtcblxuICAgICAgICAgICAgdmFyIHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcChwcm9wb3NhbCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcodG8pO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJob3ZlclwiID09PSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlX1NlbGYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGVzIGtleWRvd24gb24gZm9jdXNlZCBoYW5kbGVzXG4gICAgICAgIC8vIERvbid0IG1vdmUgdGhlIGRvY3VtZW50IHdoZW4gcHJlc3NpbmcgYXJyb3cga2V5cyBvbiBmb2N1c2VkIGhhbmRsZXNcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRLZXlkb3duKGV2ZW50LCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgfHwgaXNIYW5kbGVEaXNhYmxlZChoYW5kbGVOdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEtleXMgPSBbXCJMZWZ0XCIsIFwiUmlnaHRcIl07XG4gICAgICAgICAgICB2YXIgdmVydGljYWxLZXlzID0gW1wiRG93blwiLCBcIlVwXCJdO1xuICAgICAgICAgICAgdmFyIGxhcmdlU3RlcEtleXMgPSBbXCJQYWdlRG93blwiLCBcIlBhZ2VVcFwiXTtcbiAgICAgICAgICAgIHZhciBlZGdlS2V5cyA9IFtcIkhvbWVcIiwgXCJFbmRcIl07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpciAmJiAhb3B0aW9ucy5vcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBhbiByaWdodC10by1sZWZ0IHNsaWRlciwgdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXMgYWN0IGludmVydGVkXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9ydCAmJiAhb3B0aW9ucy5kaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBhIHRvcC10by1ib3R0b20gc2xpZGVyLCB0aGUgdXAgYW5kIGRvd24ga2V5cyBhY3QgaW52ZXJ0ZWRcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGxhcmdlU3RlcEtleXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdHJpcCBcIkFycm93XCIgZm9yIElFIGNvbXBhdGliaWxpdHkuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxuICAgICAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleS5yZXBsYWNlKFwiQXJyb3dcIiwgXCJcIik7XG5cbiAgICAgICAgICAgIHZhciBpc0xhcmdlRG93biA9IGtleSA9PT0gbGFyZ2VTdGVwS2V5c1swXTtcbiAgICAgICAgICAgIHZhciBpc0xhcmdlVXAgPSBrZXkgPT09IGxhcmdlU3RlcEtleXNbMV07XG4gICAgICAgICAgICB2YXIgaXNEb3duID0ga2V5ID09PSB2ZXJ0aWNhbEtleXNbMF0gfHwga2V5ID09PSBob3Jpem9udGFsS2V5c1swXSB8fCBpc0xhcmdlRG93bjtcbiAgICAgICAgICAgIHZhciBpc1VwID0ga2V5ID09PSB2ZXJ0aWNhbEtleXNbMV0gfHwga2V5ID09PSBob3Jpem9udGFsS2V5c1sxXSB8fCBpc0xhcmdlVXA7XG4gICAgICAgICAgICB2YXIgaXNNaW4gPSBrZXkgPT09IGVkZ2VLZXlzWzBdO1xuICAgICAgICAgICAgdmFyIGlzTWF4ID0ga2V5ID09PSBlZGdlS2V5c1sxXTtcblxuICAgICAgICAgICAgaWYgKCFpc0Rvd24gJiYgIWlzVXAgJiYgIWlzTWluICYmICFpc01heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgdG87XG5cbiAgICAgICAgICAgIGlmIChpc1VwIHx8IGlzRG93bikge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gb3B0aW9ucy5rZXlib2FyZFBhZ2VNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0Rvd24gPyAwIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHMgPSBnZXROZXh0U3RlcHNGb3JIYW5kbGUoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IHN0ZXBzW2RpcmVjdGlvbl07XG5cbiAgICAgICAgICAgICAgICAvLyBBdCB0aGUgZWRnZSBvZiBhIHNsaWRlciwgZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBObyBzdGVwIHNldCwgdXNlIHRoZSBkZWZhdWx0IG9mIDEwJSBvZiB0aGUgc3ViLXJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS5nZXREZWZhdWx0U3RlcChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5rZXlib2FyZERlZmF1bHRTdGVwXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzTGFyZ2VVcCB8fCBpc0xhcmdlRG93bikge1xuICAgICAgICAgICAgICAgICAgICBzdGVwICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RlcCBvdmVyIHplcm8tbGVuZ3RoIHJhbmdlcyAoIzk0OCk7XG4gICAgICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWNyZW1lbnQgZm9yIGRvd24gc3RlcHNcbiAgICAgICAgICAgICAgICBzdGVwID0gKGlzRG93biA/IC0xIDogMSkgKiBzdGVwO1xuXG4gICAgICAgICAgICAgICAgdG8gPSBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSArIHN0ZXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF4KSB7XG4gICAgICAgICAgICAgICAgLy8gRW5kIGtleVxuICAgICAgICAgICAgICAgIHRvID0gb3B0aW9ucy5zcGVjdHJ1bS54VmFsW29wdGlvbnMuc3BlY3RydW0ueFZhbC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSG9tZSBrZXlcbiAgICAgICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyh0byksIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJzbGlkZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdHRhY2ggZXZlbnRzIHRvIHNldmVyYWwgc2xpZGVyIHBhcnRzLlxuICAgICAgICBmdW5jdGlvbiBiaW5kU2xpZGVyRXZlbnRzKGJlaGF2aW91cikge1xuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBzdGFuZGFyZCBkcmFnIGV2ZW50IHRvIHRoZSBoYW5kbGVzLlxuICAgICAgICAgICAgaWYgKCFiZWhhdmlvdXIuZml4ZWQpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgYXJlIG9ubHkgYm91bmQgdG8gdGhlIHZpc3VhbCBoYW5kbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCwgbm90IHRoZSAncmVhbCcgb3JpZ2luIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMuc3RhcnQsIGhhbmRsZS5jaGlsZHJlblswXSwgZXZlbnRTdGFydCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogW2luZGV4XVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSB0YXAgZXZlbnQgdG8gdGhlIHNsaWRlciBiYXNlLlxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci50YXApIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBzY29wZV9CYXNlLCBldmVudFRhcCwge30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJlIGhvdmVyIGV2ZW50c1xuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5ob3Zlcikge1xuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMubW92ZSwgc2NvcGVfQmFzZSwgZXZlbnRIb3Zlciwge1xuICAgICAgICAgICAgICAgICAgICBob3ZlcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHRoZSByYW5nZSBkcmFnZ2FibGUuXG4gICAgICAgICAgICBpZiAoYmVoYXZpb3VyLmRyYWcpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9Db25uZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5lY3QsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ID09PSBmYWxzZSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gc2NvcGVfQ29ubmVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUJlZm9yZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUFmdGVyID0gc2NvcGVfSGFuZGxlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudEhvbGRlcnMgPSBbY29ubmVjdF07XG5cbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoY29ubmVjdCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWdnYWJsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcmFuZ2UgaXMgZml4ZWQsIHRoZSBlbnRpcmUgcmFuZ2UgY2FuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGRyYWdnZWQgYnkgdGhlIGhhbmRsZXMuIFRoZSBoYW5kbGUgaW4gdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbiB3aWxsIHByb3BhZ2F0ZSB0aGUgc3RhcnQgZXZlbnQgdXB3YXJkLFxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaXQgbmVlZHMgdG8gYmUgYm91bmQgbWFudWFsbHkgb24gdGhlIG90aGVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVoYXZpb3VyLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEhvbGRlcnMucHVzaChoYW5kbGVCZWZvcmUuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQWZ0ZXIuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLmZvckVhY2goZnVuY3Rpb24oZXZlbnRIb2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMuc3RhcnQsIGV2ZW50SG9sZGVyLCBldmVudFN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlczogW2hhbmRsZUJlZm9yZSwgaGFuZGxlQWZ0ZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IFtpbmRleCAtIDEsIGluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0YWNoIGFuIGV2ZW50IHRvIHRoaXMgc2xpZGVyLCBwb3NzaWJseSBpbmNsdWRpbmcgYSBuYW1lc3BhY2VcbiAgICAgICAgZnVuY3Rpb24gYmluZEV2ZW50KG5hbWVzcGFjZWRFdmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdID0gc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0gfHwgW107XG4gICAgICAgICAgICBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XS5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGJvdW5kIGlzICd1cGRhdGUsJyBmaXJlIGl0IGltbWVkaWF0ZWx5IGZvciBhbGwgaGFuZGxlcy5cbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VkRXZlbnQuc3BsaXQoXCIuXCIpWzBdID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0ludGVybmFsTmFtZXNwYWNlKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gSU5URVJOQUxfRVZFTlRfTlMuYXJpYSB8fCBuYW1lc3BhY2UgPT09IElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5kbyBhdHRhY2htZW50IG9mIGV2ZW50XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50KG5hbWVzcGFjZWRFdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmFtZXNwYWNlZEV2ZW50ICYmIG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF07XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZXZlbnQgPyBuYW1lc3BhY2VkRXZlbnQuc3Vic3RyaW5nKGV2ZW50Lmxlbmd0aCkgOiBuYW1lc3BhY2VkRXZlbnQ7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbihiaW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRFdmVudCA9IGJpbmQuc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgICAgICAgICAgIHZhciB0TmFtZXNwYWNlID0gYmluZC5zdWJzdHJpbmcodEV2ZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKCghZXZlbnQgfHwgZXZlbnQgPT09IHRFdmVudCkgJiYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSB0TmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSBwcm90ZWN0ZWQgaW50ZXJuYWwgZXZlbnQgaWYgaW50ZW50aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsTmFtZXNwYWNlKHROYW1lc3BhY2UpIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjb3BlX0V2ZW50c1tiaW5kXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0ZXJuYWwgZXZlbnQgaGFuZGxpbmdcbiAgICAgICAgZnVuY3Rpb24gZmlyZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlTnVtYmVyLCB0YXApIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBldmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2xpZGVyIHB1YmxpYyBBUEkgYXMgdGhlIHNjb3BlICgndGhpcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfU2VsZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdmFsdWVzIGFzIGFycmF5LCBzbyBhcmdfMVthcmdfMl0gaXMgYWx3YXlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpbmRleCwgMCBvciAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuLWZvcm1hdHRlZCBzbGlkZXIgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnQgaXMgZmlyZWQgYnkgdGFwLCB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFwIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgb2Zmc2V0IG9mIHRoZSBoYW5kbGUsIGluIHJlbGF0aW9uIHRvIHRoZSBzbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHNsaWRlciBwdWJsaWMgQVBJIHRvIGFuIGFjY2Vzc2libGUgcGFyYW1ldGVyIHdoZW4gdGhpcyBpcyB1bmF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1NlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBoYW5kbGUgcG9zaXRpb25pbmcgbG9naWMgc28gdGhlIE1vdmUgZXZlbnQgY2FuIHVzZSBpdCwgdG9vXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrSGFuZGxlUG9zaXRpb24ocmVmZXJlbmNlLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBnZXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBGb3Igc2xpZGVycyB3aXRoIG11bHRpcGxlIGhhbmRsZXMsIGxpbWl0IG1vdmVtZW50IHRvIHRoZSBvdGhlciBoYW5kbGUuXG4gICAgICAgICAgICAvLyBBcHBseSB0aGUgbWFyZ2luIG9wdGlvbiBieSBhZGRpbmcgaXQgdG8gdGhlIGhhbmRsZSBwb3NpdGlvbnMuXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tCYWNrd2FyZCAmJiBoYW5kbGVOdW1iZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZShyZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0sIG9wdGlvbnMubWFyZ2luLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5tYXJnaW4sIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgbGltaXQgb3B0aW9uIGhhcyB0aGUgb3Bwb3NpdGUgZWZmZWN0LCBsaW1pdGluZyBoYW5kbGVzIHRvIGFcbiAgICAgICAgICAgIC8vIG1heGltdW0gZGlzdGFuY2UgZnJvbSBhbm90aGVyLiBMaW1pdCBtdXN0IGJlID4gMCwgYXMgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBoYW5kbGVzIHdvdWxkIGJlIHVubW92YWJsZS5cbiAgICAgICAgICAgIGlmIChzY29wZV9IYW5kbGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5saW1pdCkge1xuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UocmVmZXJlbmNlW2hhbmRsZU51bWJlciAtIDFdLCBvcHRpb25zLmxpbWl0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSwgb3B0aW9ucy5saW1pdCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBwYWRkaW5nIG9wdGlvbiBrZWVwcyB0aGUgaGFuZGxlcyBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIGVkZ2VzIG9mIHRoZSBzbGlkZXIuIFBhZGRpbmcgbXVzdCBiZSA+IDAuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UoMCwgb3B0aW9ucy5wYWRkaW5nWzBdLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UoMTAwLCBvcHRpb25zLnBhZGRpbmdbMV0sIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodG8pO1xuXG4gICAgICAgICAgICAvLyBMaW1pdCBwZXJjZW50YWdlIHRvIHRoZSAwIC0gMTAwIHJhbmdlXG4gICAgICAgICAgICB0byA9IGxpbWl0KHRvKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGlmIGhhbmRsZSBjYW4ndCBtb3ZlXG4gICAgICAgICAgICBpZiAodG8gPT09IHJlZmVyZW5jZVtoYW5kbGVOdW1iZXJdICYmICFnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlcyBzbGlkZXIgb3JpZW50YXRpb24gdG8gY3JlYXRlIENTUyBydWxlcy4gYSA9IGJhc2UgdmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIGluUnVsZU9yZGVyKHYsIGEpIHtcbiAgICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XG4gICAgICAgICAgICByZXR1cm4gKG8gPyBhIDogdikgKyBcIiwgXCIgKyAobyA/IHYgOiBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vdmVzIGhhbmRsZShzKSBieSBhIHBlcmNlbnRhZ2VcbiAgICAgICAgLy8gKGJvb2wsICUgdG8gbW92ZSwgWyUgd2hlcmUgaGFuZGxlIHN0YXJ0ZWQsIC4uLl0sIFtpbmRleCBpbiBzY29wZV9IYW5kbGVzLCAuLi5dKVxuICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcyh1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbHMgPSBsb2NhdGlvbnMuc2xpY2UoKTtcblxuICAgICAgICAgICAgdmFyIGIgPSBbIXVwd2FyZCwgdXB3YXJkXTtcbiAgICAgICAgICAgIHZhciBmID0gW3Vwd2FyZCwgIXVwd2FyZF07XG5cbiAgICAgICAgICAgIC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnMgPSBoYW5kbGVOdW1iZXJzLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSB3aGljaCBoYW5kbGUgaXMgJ2xlYWRpbmcnLlxuICAgICAgICAgICAgLy8gSWYgdGhhdCBvbmUgY2FuJ3QgbW92ZSB0aGUgc2Vjb25kIGNhbid0IGVpdGhlci5cbiAgICAgICAgICAgIGlmICh1cHdhcmQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIsIG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdICsgcHJvcG9zYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBiW29dLFxuICAgICAgICAgICAgICAgICAgICAgICAgZltvXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBvbmUgb2YgdGhlIGhhbmRsZXMgY2FuJ3QgbW92ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwgPSB0byAtIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWxzW2hhbmRsZU51bWJlcl0gPSB0bztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB1c2luZyBvbmUgaGFuZGxlLCBjaGVjayBiYWNrd2FyZCBBTkQgZm9yd2FyZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IGYgPSBbdHJ1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBTdGVwIDI6IFRyeSB0byBzZXQgdGhlIGhhbmRsZXMgd2l0aCB0aGUgZm91bmQgcGVyY2VudGFnZVxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlciwgbykge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgbG9jYXRpb25zW2hhbmRsZU51bWJlcl0gKyBwcm9wb3NhbCwgYltvXSwgZltvXSkgfHwgc3RhdGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3RlcCAzOiBJZiBhIGhhbmRsZSBtb3ZlZCwgZmlyZSBldmVudHNcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUYWtlcyBhIGJhc2UgdmFsdWUgYW5kIGFuIG9mZnNldC4gVGhpcyBvZmZzZXQgaXMgdXNlZCBmb3IgdGhlIGNvbm5lY3QgYmFyIHNpemUuXG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIGRlc2lnbiBmb3IgdGhpcyBmZWF0dXJlLCB0aGUgb3JpZ2luIGVsZW1lbnQgd2FzIDElIHdpZGUuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGEgcm91bmRpbmcgYnVnIGluIENocm9tZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gaW4gdGhpcyBtYW5uZXI6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTc5ODIyM1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlyID8gMTAwIC0gYSAtIGIgOiBhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0bykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxvY2F0aW9ucy5cbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXG4gICAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IDEwICogKHRyYW5zZm9ybURpcmVjdGlvbih0bywgMCkgLSBzY29wZV9EaXJPZmZzZXQpO1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVJ1bGUgPSBcInRyYW5zbGF0ZShcIiArIGluUnVsZU9yZGVyKHRyYW5zbGF0aW9uICsgXCIlXCIsIFwiMFwiKSArIFwiKVwiO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGVbb3B0aW9ucy50cmFuc2Zvcm1SdWxlXSA9IHRyYW5zbGF0ZVJ1bGU7XG5cbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3QoaGFuZGxlTnVtYmVyICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGVzIGJlZm9yZSB0aGUgc2xpZGVyIG1pZGRsZSBhcmUgc3RhY2tlZCBsYXRlciA9IGhpZ2hlcixcbiAgICAgICAgLy8gSGFuZGxlcyBhZnRlciB0aGUgbWlkZGxlIGxhdGVyIGlzIGxvd2VyXG4gICAgICAgIC8vIFtbN10gWzhdIC4uLi4uLi4uLi4gfCAuLi4uLi4uLi4uIFs1XSBbNF1cbiAgICAgICAgZnVuY3Rpb24gc2V0WmluZGV4KCkge1xuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHZhciBkaXIgPSBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSA+IDUwID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHZhciB6SW5kZXggPSAzICsgKHNjb3BlX0hhbmRsZXMubGVuZ3RoICsgZGlyICogaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGUuekluZGV4ID0gekluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IHN1Z2dlc3RlZCB2YWx1ZXMgYW5kIGFwcGx5IG1hcmdpbiwgc3RlcC5cbiAgICAgICAgLy8gaWYgZXhhY3RJbnB1dCBpcyB0cnVlLCBkb24ndCBydW4gY2hlY2tIYW5kbGVQb3NpdGlvbiwgdGhlbiB0aGUgaGFuZGxlIGNhbiBiZSBwbGFjZWQgaW4gYmV0d2VlbiBzdGVwcyAoIzQzNilcbiAgICAgICAgZnVuY3Rpb24gc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGV4YWN0SW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghZXhhY3RJbnB1dCkge1xuICAgICAgICAgICAgICAgIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlcyBzdHlsZSBhdHRyaWJ1dGUgZm9yIGNvbm5lY3Qgbm9kZXNcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdChpbmRleCkge1xuICAgICAgICAgICAgLy8gU2tpcCBjb25uZWN0cyBzZXQgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmICghc2NvcGVfQ29ubmVjdHNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbCA9IDA7XG4gICAgICAgICAgICB2YXIgaCA9IDEwMDtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbCA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBoID0gc2NvcGVfTG9jYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgdXNlIHR3byBydWxlczpcbiAgICAgICAgICAgIC8vICd0cmFuc2xhdGUnIHRvIGNoYW5nZSB0aGUgbGVmdC90b3Agb2Zmc2V0O1xuICAgICAgICAgICAgLy8gJ3NjYWxlJyB0byBjaGFuZ2UgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50O1xuICAgICAgICAgICAgLy8gQXMgdGhlIGVsZW1lbnQgaGFzIGEgd2lkdGggb2YgMTAwJSwgYSB0cmFuc2xhdGlvbiBvZiAxMDAlIGlzIGVxdWFsIHRvIDEwMCUgb2YgdGhlIHBhcmVudCAoLm5vVWktYmFzZSlcbiAgICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVSdWxlID0gXCJ0cmFuc2xhdGUoXCIgKyBpblJ1bGVPcmRlcih0cmFuc2Zvcm1EaXJlY3Rpb24obCwgY29ubmVjdFdpZHRoKSArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciBzY2FsZVJ1bGUgPSBcInNjYWxlKFwiICsgaW5SdWxlT3JkZXIoY29ubmVjdFdpZHRoIC8gMTAwLCBcIjFcIikgKyBcIilcIjtcblxuICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHNbaW5kZXhdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSB0cmFuc2xhdGVSdWxlICsgXCIgXCIgKyBzY2FsZVJ1bGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZXMgdmFsdWUgcGFzc2VkIHRvIC5zZXQgbWV0aG9kLiBSZXR1cm5zIGN1cnJlbnQgdmFsdWUgaWYgbm90IHBhcnNlLWFibGUuXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVUb1ZhbHVlKHRvLCBoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgd2l0aCBudWxsIGluZGljYXRlcyBhbiAnaWdub3JlJy5cbiAgICAgICAgICAgIC8vIElucHV0dGluZyAnZmFsc2UnIGlzIGludmFsaWQuXG4gICAgICAgICAgICBpZiAodG8gPT09IG51bGwgfHwgdG8gPT09IGZhbHNlIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXB0IHRvIGRlY29kZSBpdC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0byA9IFN0cmluZyh0byk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvID0gb3B0aW9ucy5mb3JtYXQuZnJvbSh0byk7XG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pO1xuXG4gICAgICAgICAgICAvLyBJZiBwYXJzaW5nIHRoZSBudW1iZXIgZmFpbGVkLCB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzTmFOKHRvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBzbGlkZXIgdmFsdWUuXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0KGlucHV0LCBmaXJlU2V0RXZlbnQsIGV4YWN0SW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBhc0FycmF5KGlucHV0KTtcbiAgICAgICAgICAgIHZhciBpc0luaXQgPSBzY29wZV9Mb2NhdGlvbnNbMF0gPT09IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLy8gRXZlbnQgZmlyZXMgYnkgZGVmYXVsdFxuICAgICAgICAgICAgZmlyZVNldEV2ZW50ID0gZmlyZVNldEV2ZW50ID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFmaXJlU2V0RXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBpcyBvcHRpb25hbC5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5pdGlhbCB2YWx1ZXMgd2VyZSBzZXQgYmVmb3JlIHVzaW5nIGFuaW1hdGVkIHBsYWNlbWVudC5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgJiYgIWlzSW5pdCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IHBhc3MsIHdpdGhvdXQgbG9va0FoZWFkIGJ1dCB3aXRoIGxvb2tCYWNrd2FyZC4gVmFsdWVzIGFyZSBzZXQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlc1toYW5kbGVOdW1iZXJdLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCBmYWxzZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGkgPSBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSA/IDAgOiAxO1xuXG4gICAgICAgICAgICAvLyBTZWNvbmRhcnkgcGFzc2VzLiBOb3cgdGhhdCBhbGwgYmFzZSB2YWx1ZXMgYXJlIHNldCwgYXBwbHkgY29uc3RyYWludHMuXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGFsbCBoYW5kbGVzIHRvIGVuc3VyZSBjb25zdHJhaW50cyBhcmUgYXBwbGllZCBmb3IgdGhlIGVudGlyZSBzbGlkZXIgKElzc3VlICMxMDA5KVxuICAgICAgICAgICAgZm9yICg7IGkgPCBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSwgdHJ1ZSwgdHJ1ZSwgZXhhY3RJbnB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFppbmRleCgpO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJlIHRoZSBldmVudCBvbmx5IGZvciBoYW5kbGVzIHRoYXQgcmVjZWl2ZWQgYSBuZXcgdmFsdWUsIGFzIHBlciAjNTc5XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1toYW5kbGVOdW1iZXJdICE9PSBudWxsICYmIGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHNsaWRlciB0byBpbml0aWFsIHZhbHVlc1xuICAgICAgICBmdW5jdGlvbiB2YWx1ZVJlc2V0KGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9ucy5zdGFydCwgZmlyZVNldEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB2YWx1ZSBmb3IgYSBzaW5nbGUgaGFuZGxlXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdmFsdWUsIGZpcmVTZXRFdmVudCwgZXhhY3RJbnB1dCkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIG51bWVyaWMgaW5wdXRcbiAgICAgICAgICAgIGhhbmRsZU51bWJlciA9IE51bWJlcihoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgICBpZiAoIShoYW5kbGVOdW1iZXIgPj0gMCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVOdW1iZXJzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IGludmFsaWQgaGFuZGxlIG51bWJlciwgZ290OiBcIiArIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvb2sgYm90aCBiYWNrd2FyZCBhbmQgZm9yd2FyZCwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0aGlzIGhhbmRsZSB0byBcInB1c2hcIiBvdGhlciBoYW5kbGVzICgjOTYwKTtcbiAgICAgICAgICAgIC8vIFRoZSBleGFjdElucHV0IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGlnbm9yZSBzbGlkZXIgc3RlcHBpbmcgKCM0MzYpXG4gICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCByZXNvbHZlVG9WYWx1ZSh2YWx1ZSwgaGFuZGxlTnVtYmVyKSwgdHJ1ZSwgdHJ1ZSwgZXhhY3RJbnB1dCk7XG5cbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgICBpZiAoZmlyZVNldEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIHNsaWRlciB2YWx1ZS5cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVHZXQoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gc2NvcGVfVmFsdWVzLm1hcChvcHRpb25zLmZvcm1hdC50byk7XG5cbiAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIGhhbmRsZSBpcyB1c2VkLCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmVzIGNsYXNzZXMgZnJvbSB0aGUgcm9vdCBhbmQgZW1wdGllcyBpdC5cbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwcm90ZWN0ZWQgaW50ZXJuYWwgbGlzdGVuZXJzXG4gICAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy5hcmlhKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY3NzQ2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jc3NDbGFzc2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzW2tleV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBzY29wZV9UYXJnZXQucmVtb3ZlQ2hpbGQoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgc2NvcGVfVGFyZ2V0Lm5vVWlTbGlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHNGb3JIYW5kbGUoaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIHZhciBuZWFyYnlTdGVwcyA9IHNjb3BlX1NwZWN0cnVtLmdldE5lYXJieVN0ZXBzKGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlX1ZhbHVlc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgdmFyIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XG4gICAgICAgICAgICB2YXIgZGVjcmVtZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gSWYgc25hcHBlZCwgZGlyZWN0bHkgdXNlIGRlZmluZWQgc3RlcCB2YWx1ZVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc25hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIC0gbmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5zdGFydFZhbHVlIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWUgfHwgbnVsbFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IHZhbHVlIGluIHRoaXMgc3RlcCBtb3ZlcyBpbnRvIHRoZSBuZXh0IHN0ZXAsXG4gICAgICAgICAgICAvLyB0aGUgaW5jcmVtZW50IGlzIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBzdGVwIC0gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICsgaW5jcmVtZW50ID4gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ID0gbmVhcmJ5U3RlcHMuc3RlcEFmdGVyLnN0YXJ0VmFsdWUgLSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBiZXlvbmQgdGhlIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RlcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5zdGVwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIGhhbmRsZSBpcyBhdCB0aGUgc3RhcnQgb2YgYSBzdGVwLCBpdCBhbHdheXMgc3RlcHMgYmFjayBpbnRvIHRoZSBwcmV2aW91cyBzdGVwIGZpcnN0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuaGlnaGVzdFN0ZXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vdywgaWYgYXQgdGhlIHNsaWRlciBlZGdlcywgdGhlcmUgaXMgbm8gaW4vZGVjcmVtZW50XG4gICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IDEwMCkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXMgcGVyICMzOTEsIHRoZSBjb21wYXJpc29uIGZvciB0aGUgZGVjcmVtZW50IHN0ZXAgY2FuIGhhdmUgc29tZSByb3VuZGluZyBpc3N1ZXMuXG4gICAgICAgICAgICB2YXIgc3RlcERlY2ltYWxzID0gc2NvcGVfU3BlY3RydW0uY291bnRTdGVwRGVjaW1hbHMoKTtcblxuICAgICAgICAgICAgLy8gUm91bmQgcGVyICMzOTFcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IG51bGwgJiYgaW5jcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IE51bWJlcihpbmNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudCAhPT0gbnVsbCAmJiBkZWNyZW1lbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gTnVtYmVyKGRlY3JlbWVudC50b0ZpeGVkKHN0ZXBEZWNpbWFscykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2RlY3JlbWVudCwgaW5jcmVtZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGVwIHNpemUgZm9yIHRoZSBzbGlkZXIuXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRTdGVwcygpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9IYW5kbGVOdW1iZXJzLm1hcChnZXROZXh0U3RlcHNGb3JIYW5kbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlYWJsZTogbWFyZ2luLCBsaW1pdCwgcGFkZGluZywgc3RlcCwgcmFuZ2UsIGFuaW1hdGUsIHNuYXBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhvcHRpb25zVG9VcGRhdGUsIGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgLy8gU3BlY3RydW0gaXMgY3JlYXRlZCB1c2luZyB0aGUgcmFuZ2UsIHNuYXAsIGRpcmVjdGlvbiBhbmQgc3RlcCBvcHRpb25zLlxuICAgICAgICAgICAgLy8gJ3NuYXAnIGFuZCAnc3RlcCcgY2FuIGJlIHVwZGF0ZWQuXG4gICAgICAgICAgICAvLyBJZiAnc25hcCcgYW5kICdzdGVwJyBhcmUgbm90IHBhc3NlZCwgdGhleSBzaG91bGQgcmVtYWluIHVuY2hhbmdlZC5cbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVHZXQoKTtcblxuICAgICAgICAgICAgdmFyIHVwZGF0ZUFibGUgPSBbXG4gICAgICAgICAgICAgICAgXCJtYXJnaW5cIixcbiAgICAgICAgICAgICAgICBcImxpbWl0XCIsXG4gICAgICAgICAgICAgICAgXCJwYWRkaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJyYW5nZVwiLFxuICAgICAgICAgICAgICAgIFwiYW5pbWF0ZVwiLFxuICAgICAgICAgICAgICAgIFwic25hcFwiLFxuICAgICAgICAgICAgICAgIFwic3RlcFwiLFxuICAgICAgICAgICAgICAgIFwiZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgXCJwaXBzXCIsXG4gICAgICAgICAgICAgICAgXCJ0b29sdGlwc1wiXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGNoYW5nZSBvcHRpb25zIHRoYXQgd2UncmUgYWN0dWFsbHkgcGFzc2VkIHRvIHVwZGF0ZS5cbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHVuZGVmaW5lZC4gbnVsbCByZW1vdmVzIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIExvYWQgbmV3IG9wdGlvbnMgaW50byB0aGUgc2xpZGVyIHN0YXRlXG4gICAgICAgICAgICB1cGRhdGVBYmxlLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zVG9VcGRhdGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gbmV3T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2NvcGVfU3BlY3RydW0gPSBuZXdPcHRpb25zLnNwZWN0cnVtO1xuXG4gICAgICAgICAgICAvLyBMaW1pdCwgbWFyZ2luIGFuZCBwYWRkaW5nIGRlcGVuZCBvbiB0aGUgc3BlY3RydW0gYnV0IGFyZSBzdG9yZWQgb3V0c2lkZSBvZiBpdC4gKCM2NzcpXG4gICAgICAgICAgICBvcHRpb25zLm1hcmdpbiA9IG5ld09wdGlvbnMubWFyZ2luO1xuICAgICAgICAgICAgb3B0aW9ucy5saW1pdCA9IG5ld09wdGlvbnMubGltaXQ7XG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBuZXdPcHRpb25zLnBhZGRpbmc7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwaXBzLCByZW1vdmVzIGV4aXN0aW5nLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlUGlwcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b29sdGlwcykge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGN1cnJlbnQgcG9zaXRpb25pbmcgc28gdmFsdWVTZXQgZm9yY2VzIGFuIHVwZGF0ZS5cbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9uc1RvVXBkYXRlLnN0YXJ0IHx8IHYsIGZpcmVTZXRFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBzdGVwc1xuICAgICAgICBmdW5jdGlvbiBzZXR1cFNsaWRlcigpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYmFzZSBlbGVtZW50LCBpbml0aWFsaXplIEhUTUwgYW5kIHNldCBjbGFzc2VzLlxuICAgICAgICAgICAgLy8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXG4gICAgICAgICAgICBzY29wZV9CYXNlID0gYWRkU2xpZGVyKHNjb3BlX1RhcmdldCk7XG5cbiAgICAgICAgICAgIGFkZEVsZW1lbnRzKG9wdGlvbnMuY29ubmVjdCwgc2NvcGVfQmFzZSk7XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCB1c2VyIGV2ZW50cy5cbiAgICAgICAgICAgIGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpO1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHB1YmxpYyB2YWx1ZSBtZXRob2QgdG8gc2V0IHRoZSBzdGFydCB2YWx1ZXMuXG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHMpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcmlhKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR1cFNsaWRlcigpO1xuXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICAgICAgc2NvcGVfU2VsZiA9IHtcbiAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgICAgICBzdGVwczogZ2V0TmV4dFN0ZXBzLFxuICAgICAgICAgICAgb246IGJpbmRFdmVudCxcbiAgICAgICAgICAgIG9mZjogcmVtb3ZlRXZlbnQsXG4gICAgICAgICAgICBnZXQ6IHZhbHVlR2V0LFxuICAgICAgICAgICAgc2V0OiB2YWx1ZVNldCxcbiAgICAgICAgICAgIHNldEhhbmRsZTogdmFsdWVTZXRIYW5kbGUsXG4gICAgICAgICAgICByZXNldDogdmFsdWVSZXNldCxcbiAgICAgICAgICAgIC8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZywgZG9uJ3QgdXNlIHRoaXMgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIF9fbW92ZUhhbmRsZXM6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgICAgICAgICAgICBtb3ZlSGFuZGxlcyhhLCBiLCBzY29wZV9Mb2NhdGlvbnMsIGMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9yaWdpbmFsT3B0aW9ucywgLy8gSXNzdWUgIzYwMCwgIzY3OFxuICAgICAgICAgICAgdXBkYXRlT3B0aW9uczogdXBkYXRlT3B0aW9ucyxcbiAgICAgICAgICAgIHRhcmdldDogc2NvcGVfVGFyZ2V0LCAvLyBJc3N1ZSAjNTk3XG4gICAgICAgICAgICByZW1vdmVQaXBzOiByZW1vdmVQaXBzLFxuICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHM6IHJlbW92ZVRvb2x0aXBzLFxuICAgICAgICAgICAgZ2V0VG9vbHRpcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9Ub29sdGlwcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRPcmlnaW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfSGFuZGxlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaXBzOiBwaXBzIC8vIElzc3VlICM1OTRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2NvcGVfU2VsZjtcbiAgICB9XG5cbiAgICAvLyBSdW4gdGhlIHN0YW5kYXJkIGluaXRpYWxpemVyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZSh0YXJnZXQsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IGNyZWF0ZSByZXF1aXJlcyBhIHNpbmdsZSBlbGVtZW50LCBnb3Q6IFwiICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBzbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmICh0YXJnZXQubm9VaVNsaWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCB0aGUgb3B0aW9ucyBhbmQgY3JlYXRlIHRoZSBzbGlkZXIgZW52aXJvbm1lbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zLCB0YXJnZXQpO1xuICAgICAgICB2YXIgYXBpID0gc2NvcGUodGFyZ2V0LCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMpO1xuXG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xuXG4gICAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuXG4gICAgLy8gVXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gZm9yIGZ1dHVyZSBleHBhbmRhYmlsaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZywgZG9uJ3QgdXNlIHRoaXMgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgX19zcGVjdHJ1bTogU3BlY3RydW0sXG4gICAgICAgIHZlcnNpb246IFZFUlNJT04sXG4gICAgICAgIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IGNsYXNzZXMsIGFsbG93cyBnbG9iYWwgY2hhbmdlcy5cbiAgICAgICAgLy8gVXNlIHRoZSBjc3NDbGFzc2VzIG9wdGlvbiBmb3IgY2hhbmdlcyB0byBvbmUgc2xpZGVyLlxuICAgICAgICBjc3NDbGFzc2VzOiBjc3NDbGFzc2VzLFxuICAgICAgICBjcmVhdGU6IGluaXRpYWxpemVcbiAgICB9O1xufSk7XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG5cdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IG1vZHVsZVsnZGVmYXVsdCddIDpcblx0XHQoKSA9PiBtb2R1bGU7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvYXBwL2xheW91dC5qc1wiKTtcbi8vIFRoaXMgZW50cnkgbW9kdWxlIHVzZWQgJ2V4cG9ydHMnIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbiJdLCJzb3VyY2VSb290IjoiIn0=