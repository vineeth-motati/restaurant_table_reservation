/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/app/auth.js":
/*!*************************!*\
  !*** ./src/app/auth.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "auth": () => /* binding */ auth,
/* harmony export */   "db": () => /* binding */ db
/* harmony export */ });
// import { auth } from './index.js';
var signupForm = document.querySelector('#signup-form-container__form');
var loginForm = document.querySelector('#login-form-container__form');
var logout = document.getElementById('logout');
var login = document.getElementById('login');
login.style.display = 'inline';
logout.style.display = 'none'; // For Firebase JS SDK v7.20.0 and later, measurementId is optional

if (firebase.apps.length === 0) {
  var firebaseConfig = {
    apiKey: 'AIzaSyAzU8SX0q9-UsmGn9kdAJWWr9b5jFQWUIM',
    authDomain: 'restaurant-84fc2.firebaseapp.com',
    projectId: 'restaurant-84fc2',
    storageBucket: 'restaurant-84fc2.appspot.com',
    messagingSenderId: '225866172527',
    appId: '1:225866172527:web:a134a87c7de3ea4173659a',
    measurementId: 'G-79Q7DGCSGJ'
  }; // Initialize Firebase

  firebase.initializeApp(firebaseConfig);
}

var auth = firebase.auth();
var db = firebase.database();

if (localStorage.getItem('loggedIn') === null) {
  auth.onAuthStateChanged(function (user) {
    if (user) {
      localStorage.setItem('loggedIn', 'true');
    } else {
      localStorage.setItem('loggedIn', 'false');
    }
  });
} // Controls displaying Username on header


auth.onAuthStateChanged(function (user) {
  if (user && localStorage.getItem('loggedIn') === 'true') {
    var link = '';

    if (user.email.indexOf('vineat') !== -1) {
      link = '/manager.html';
    } else {
      link = '/user.html';
    }

    document.getElementById('greet-wrapper').innerHTML = "<a href=\"".concat(link, "\" id=\"greet\">") + "Hello, ".concat(user.displayName) + '</a>';
    logout.style.display = 'inline';
    login.style.display = 'none';
  } else {
    document.getElementById('greet-wrapper').innerHTML = "";
    logout.style.display = 'none';
    login.style.display = 'inline';
  }
}); // Controls redirection from authourization page

function redirect(email) {
  if (email.indexOf('@vineat.com') !== -1) {
    // document.getElementById('greet').href = '/manager.html';
    window.location = '/manager.html';
  } else {
    // document.getElementById('greet').href = '/user.html';
    window.location = '/user.html';
  }
} // Saves data into Database


function writeUserData(userId, name, email) {
  firebase.database().ref('users/' + userId).set({
    username: name,
    email: email
  });
}

function toggleSignup() {
  document.getElementById('login-toggle').style.backgroundColor = '#fff';
  document.getElementById('login-toggle').style.color = '#222';
  document.getElementById('signup-toggle').style.backgroundColor = '#00a2ff';
  document.getElementById('signup-toggle').style.color = '#fff';
  document.getElementById('login-form-container').style.display = 'none';
  document.getElementById('signup-form-container').style.display = 'block';
}

window.toggleSignup = toggleSignup;

function toggleLogin() {
  document.getElementById('login-toggle').style.backgroundColor = '#00a2ff';
  document.getElementById('login-toggle').style.color = '#fff';
  document.getElementById('signup-toggle').style.backgroundColor = '#fff';
  document.getElementById('signup-toggle').style.color = '#222';
  document.getElementById('signup-form-container').style.display = 'none';
  document.getElementById('login-form-container').style.display = 'block';
}

window.toggleLogin = toggleLogin; // Signup functionality

if (signupForm) {
  signupForm.addEventListener('submit', function (e) {
    e.preventDefault();

    if (localStorage.getItem('loggedIn') === 'true') {
      alert('User already logged in\nPlease logout to continue');
      loginForm.reset();
    } else if (localStorage.getItem('loggedIn') === 'false') {
      var username = signupForm['sign-up-username'].value;
      var email = signupForm['sign-up-email'].value;
      var password = signupForm['sign-up-password'].value;
      auth.createUserWithEmailAndPassword(email, password).then(function (cred) {
        auth.currentUser.updateProfile({
          displayName: username
        });
        writeUserData(cred.user.uid, username, email);
        console.log(cred.user);
        signupForm.reset();
        alert('Sucessfully signed up\n You can log in now');
      })["catch"](function (error) {
        alert(error.message);
      });
    } // console.log(email, password);

  });
} // Login Functionality


if (loginForm) {
  loginForm.addEventListener('submit', function (e) {
    e.preventDefault();

    if (localStorage.getItem('loggedIn') === 'true') {
      alert('User already logged in\nPlease logout to continue');
      loginForm.reset();
    } else if (localStorage.getItem('loggedIn') === 'false') {
      var email = loginForm['log-in-email'].value;
      var password = loginForm['log-in-password'].value;
      auth.signInWithEmailAndPassword(email, password).then(function (cred) {
        console.log(cred.user);
        loginForm.reset();
        alert('Sucessfully logged in');
        localStorage.setItem('loggedIn', 'true');
        localStorage.setItem('loggedInUser', JSON.stringify(cred.user));
        var user = JSON.parse(localStorage.getItem('loggedInUser'));
        redirect(user.email.toLowerCase());
      })["catch"](function (error) {
        alert(error.message);
      });
    }
  });
} // Logout Functionality


if (logout) {
  logout.addEventListener('click', function (e) {
    e.preventDefault();

    if (localStorage.getItem('loggedIn') === 'true') {
      auth.signOut().then(function () {
        alert('Sucessfully logged out');
        localStorage.setItem('loggedIn', 'false');
        localStorage.setItem('loggedInUser', '');
        window.location = 'auth.html';
      });
    } else if (localStorage.getItem('loggedIn') === 'false') {
      alert('You are not logged in');
    }
  });
}

/***/ }),

/***/ "./src/app/layout.js":
/*!***************************!*\
  !*** ./src/app/layout.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth */ "./src/app/auth.js");
/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fabric */ "./node_modules/fabric/dist/fabric.js");
/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fabric__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nouislider */ "./node_modules/nouislider/distribute/nouislider.js");
/* harmony import */ var nouislider__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(nouislider__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var nouislider_distribute_nouislider_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nouislider/distribute/nouislider.css */ "./node_modules/nouislider/distribute/nouislider.css");

 // console.log('hello, Manager');




var canvas;
var number;
var grid = 30;
var backgroundColor = '#626262';
var lineStroke = '#ebebeb';
var tableFill = 'rgba(187, 187, 187, 0.7)';
var tableStroke = '#5c5c5c';
var tableShadow = 'rgba(0, 0, 0, 0.4) 3px 3px 7px';
var chairFill = 'rgba(75, 75, 75, 0.7)';
var chairStroke = '#32230b';
var chairShadow = 'rgba(0, 0, 0, 0.4) 3px 3px 7px'; // var barFill = 'rgba(0, 93, 127, 0.7)';

var barFill = 'rgba(0, 162, 255, 0.7)';
var barStroke = '#003e54';
var barShadow = 'rgba(0, 0, 0, 0.4) 3px 3px 7px';
var barText = 'Bar';
var wallFill = 'rgba(136, 136, 136, 0.7)';
var wallStroke = '#686868';
var wallShadow = 'rgba(0, 0, 0, 0.4) 5px 5px 20px';
var photoUrlLandscape = 'https://images8.alphacoders.com/292/292379.jpg',
    photoUrlPortrait = 'https://presspack.rte.ie/wp-content/blogs.dir/2/files/2015/04/AMC_TWD_Maggie_Portraits_4817_V1.jpg';
var widthEl = document.getElementById('width');
var heightEl = document.getElementById('height');
var canvasEl = document.getElementById('canvas');

if (localStorage.getItem('widthEl') && localStorage.getItem('heightEl')) {
  document.getElementById('width').value = localStorage.getItem('widthEl');
  document.getElementById('height').value = localStorage.getItem('heightEl');
} else {
  localStorage.setItem('heightEl', heightEl.value);
  localStorage.setItem('widthEl', widthEl.value);
}

canvasEl.setAttribute('width', localStorage.getItem('widthEl'));
canvasEl.setAttribute('height', localStorage.getItem('heightEl'));

function initCanvas() {
  if (canvas) {
    canvas.clear();
    canvas.dispose();
  }

  canvas = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Canvas('canvas');
  number = parseInt(localStorage.getItem('totalTables')) + 1; // number = 1;

  canvas.backgroundColor = backgroundColor; // canvas.setBackgroundImage(
  //     'https://presspack.rte.ie/wp-content/blogs.dir/2/files/2015/04/AMC_TWD_Maggie_Portraits_4817_V1.jpg',
  //     canvas.renderAll.bind(canvas)
  // );

  for (var i = 0; i < canvas.height / grid; i++) {
    var lineX = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Line([0, i * grid, canvas.height, i * grid], {
      stroke: lineStroke,
      selectable: false,
      name: 'line'
    });
    var lineY = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Line([i * grid, 0, i * grid, canvas.height], {
      stroke: lineStroke,
      selectable: false,
      name: 'line'
    }); // canvas.add(lineX);
    // canvas.add(lineY);

    sendLinesToBack();
  }

  canvas.on('object:moving', function (e) {
    snapToGrid(e.target);
  });
  canvas.on('object:scaling', function (e) {
    if (e.target.scaleX > 5) {
      e.target.scaleX = 5;
    }

    if (e.target.scaleY > 5) {
      e.target.scaleY = 5;
    }

    if (!e.target.strokeWidthUnscaled && e.target.strokeWidth) {
      e.target.strokeWidthUnscaled = e.target.strokeWidth;
    }

    if (e.target.strokeWidthUnscaled) {
      e.target.strokeWidth = e.target.strokeWidthUnscaled / e.target.scaleX;

      if (e.target.strokeWidth === e.target.strokeWidthUnscaled) {
        e.target.strokeWidth = e.target.strokeWidthUnscaled / e.target.scaleY;
      }
    }
  });
  canvas.on('object:modified', function (e) {
    e.target.scaleX = e.target.scaleX >= 0.25 ? Math.round(e.target.scaleX * 2) / 2 : 0.5;
    e.target.scaleY = e.target.scaleY >= 0.25 ? Math.round(e.target.scaleY * 2) / 2 : 0.5;
    snapToGrid(e.target);

    if (e.target.name === 'table') {
      canvas.bringToFront(e.target);
    } else {
      canvas.sendToBack(e.target);
    }

    sendLinesToBack();
  });
  canvas.on('object:moving', function (e) {
    checkBoudningBox(e);
  });
  canvas.on('object:rotating', function (e) {
    checkBoudningBox(e);
  });
  canvas.on('object:scaling', function (e) {
    checkBoudningBox(e);
  });
}

initCanvas();

function resizeCanvas() {
  widthEl = document.getElementById('width');
  heightEl = document.getElementById('height');
  canvasEl.width = widthEl.value ? widthEl.value : 302;
  canvasEl.height = heightEl.value ? heightEl.value : 812;
  var canvasContainerEl = document.querySelectorAll('.canvas-container')[0];
  canvasContainerEl.style.width = canvasEl.width;
  canvasContainerEl.style.height = canvasEl.height;
}

resizeCanvas();
widthEl.addEventListener('change', function () {
  resizeCanvas();
  initCanvas(); // addDefaultObjects();

  canvasLoader('json_canvas');
  sendLinesToBack();
});
heightEl.addEventListener('change', function () {
  resizeCanvas();
  initCanvas(); // addDefaultObjects();

  canvasLoader('json_canvas');
  sendLinesToBack();
});

function generateId() {
  return Math.random().toString(36).substr(2, 8);
}

function addRect(left, top, width, height) {
  var id = generateId();
  var o = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Rect({
    width: width,
    height: height,
    fill: tableFill,
    stroke: tableStroke,
    strokeWidth: 2,
    shadow: tableShadow,
    rx: 10,
    ry: 10,
    originX: 'center',
    originY: 'center',
    centeredRotation: true,
    snapAngle: 45,
    selectable: true
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.IText(number.toString(), {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'table',
    id: id,
    number: number
  });
  canvas.add(g);
  number++;
  return g;
}

function addCircle(left, top, radius) {
  var id = generateId();
  var o = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Circle({
    radius: radius,
    fill: tableFill,
    stroke: tableStroke,
    strokeWidth: 2,
    shadow: tableShadow,
    originX: 'center',
    originY: 'center',
    centeredRotation: true
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.IText(number.toString(), {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'table',
    id: id,
    number: number
  });
  canvas.add(g);
  number++;
  return g;
}

function addTriangle(left, top, radius) {
  var id = generateId();
  var o = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Triangle({
    radius: radius,
    fill: tableFill,
    stroke: tableStroke,
    strokeWidth: 2,
    shadow: tableShadow,
    originX: 'center',
    originY: 'center',
    centeredRotation: true
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.IText(number.toString(), {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'table',
    id: id,
    number: number
  });
  canvas.add(g);
  number++;
  return g;
}

function addChair(left, top, width, height) {
  var o = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Rect({
    left: left,
    top: top,
    width: 30,
    height: 30,
    fill: chairFill,
    stroke: chairStroke,
    strokeWidth: 2,
    shadow: chairShadow,
    originX: 'left',
    originY: 'top',
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'chair',
    id: generateId()
  });
  canvas.add(o);
  return o;
}

function addBar(left, top, width, height) {
  var o = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Rect({
    width: width,
    height: height,
    fill: barFill,
    stroke: barStroke,
    strokeWidth: 2,
    shadow: barShadow,
    originX: 'center',
    originY: 'center',
    name: 'bar',
    id: generateId()
  });
  var t = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.IText(barText, {
    fontFamily: 'Calibri',
    fontSize: 14,
    fill: '#000',
    textAlign: 'center',
    originX: 'center',
    originY: 'center'
  });
  var g = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Group([o, t], {
    left: left,
    top: top,
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'bar'
  });
  canvas.add(g);
  return g;
}

function addWall(left, top, width, height) {
  var o = new fabric__WEBPACK_IMPORTED_MODULE_1__.fabric.Rect({
    left: left,
    top: top,
    width: width,
    height: height,
    fill: wallFill,
    stroke: wallStroke,
    strokeWidth: 2,
    shadow: wallShadow,
    originX: 'left',
    originY: 'top',
    centeredRotation: true,
    snapAngle: 45,
    selectable: true,
    name: 'wall',
    id: generateId()
  });
  canvas.add(o);
  return o;
}

function snapToGrid(target) {
  target.set({
    left: Math.round(target.left / (grid / 2)) * grid / 2,
    top: Math.round(target.top / (grid / 2)) * grid / 2
  });
}

function checkBoudningBox(e) {
  var obj = e.target;

  if (!obj) {
    return;
  }

  obj.setCoords();
  var objBoundingBox = obj.getBoundingRect();

  if (objBoundingBox.top < 0) {
    obj.set('top', 0);
    obj.setCoords();
  }

  if (objBoundingBox.left > canvas.width - objBoundingBox.width) {
    obj.set('left', canvas.width - objBoundingBox.width);
    obj.setCoords();
  }

  if (objBoundingBox.top > canvas.height - objBoundingBox.height) {
    obj.set('top', canvas.height - objBoundingBox.height);
    obj.setCoords();
  }

  if (objBoundingBox.left < 0) {
    obj.set('left', 0);
    obj.setCoords();
  }
}

function sendLinesToBack() {
  canvas.getObjects().map(function (o) {
    if (o.name === 'line') {
      canvas.sendToBack(o);
    }
  });
}

document.querySelectorAll('.rectangle')[0].addEventListener('click', function () {
  var o = addRect(0, 0, 60, 60);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.circle')[0].addEventListener('click', function () {
  var o = addCircle(0, 0, 30);
  canvas.setActiveObject(o);
}); // document
//     .querySelectorAll('.triangle')[0]
//     .addEventListener('click', function () {
//         const o = addTriangle(0, 0, 30);
//         canvas.setActiveObject(o);
//     });

document.querySelectorAll('.chair')[0].addEventListener('click', function () {
  var o = addChair(0, 0);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.bar')[0].addEventListener('click', function () {
  var o = addBar(0, 0, 180, 60);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.wall')[0].addEventListener('click', function () {
  var o = addWall(0, 0, 60, 180);
  canvas.setActiveObject(o);
});
document.querySelectorAll('.remove')[0].addEventListener('click', function () {
  var o = canvas.getActiveObject();

  if (o) {
    // o.remove();
    canvas.remove(o);
    canvas.discardActiveObject();
    canvas.renderAll();
  }
});

if (document.querySelectorAll('.customer-mode')[0]) {
  document.querySelectorAll('.customer-mode')[0].addEventListener('click', function () {
    canvas.getObjects().map(function (o) {
      o.hasControls = false;
      o.lockMovementX = true;
      o.lockMovementY = true;

      if (o.type != 'group' || o._objects[1].text == 'Bar') {
        o.selectable = false;
      }

      o.borderColor = '#34a5e7';
      o.borderScaleFactor = 2.5;
    });
    canvas.selection = false;
    canvas.hoverCursor = 'pointer';
    canvas.discardActiveObject();
    canvas.renderAll();
    document.querySelectorAll('.admin-menu')[0].style.display = 'none';
    document.querySelectorAll('.customer-menu')[0].style.display = 'block';
  });
}

canvas.getObjects().map(function (o) {
  o.hasControls = true;
  o.lockMovementX = false;
  o.lockMovementY = false;

  if (o.name === 'chair' || o.name === 'bar' || o.name === 'wall') {
    o.selectable = true;
  }

  o.borderColor = 'rgba(102, 153, 255, 0.75)';
  o.borderScaleFactor = 1;
});
canvas.selection = true;
canvas.hoverCursor = 'move';
canvas.discardActiveObject();
canvas.renderAll();
document.querySelectorAll('.admin-menu')[0].style.display = 'block'; // document.querySelectorAll('.customer-menu')[0].style.display = 'none';

var arrayOfTablesNos;
var userTableNos;

function saveReservation(userId, tableNo) {
  var date = document.querySelector('.reservation-date').value;
  var time = document.querySelector('.reservation-time').value;
  _auth__WEBPACK_IMPORTED_MODULE_0__.db.ref('reservations/' + date + '/' + time).once('value', function (snap) {
    arrayOfTablesNos = snap.val(); // console.log('iterating again');

    if (arrayOfTablesNos) {
      var s = arrayOfTablesNos.reservedTableNo; // console.log(arrayOfTablesNos.reservedTableNo);
      // console.log(s);

      if (s.indexOf(tableNo) !== -1) {
        alert('Table Unavailable right now!');
        throw new Error('Table Unavailable right now!');
      }

      _auth__WEBPACK_IMPORTED_MODULE_0__.db.ref('reservations/' + date + '/' + time).set({
        reservedTableNo: arrayOfTablesNos.reservedTableNo + ',' + tableNo
      });
    } else {
      _auth__WEBPACK_IMPORTED_MODULE_0__.db.ref('reservations/' + date + '/' + time).set({
        reservedTableNo: tableNo
      });
    }

    document.querySelector('.check-availability').click();
    alert('Sucessfully reserved!');
  }).then(function () {
    _auth__WEBPACK_IMPORTED_MODULE_0__.db.ref('users/' + userId + '/reservations/' + date + '/' + time).once('value', function (snap) {
      // console.log(date, time, snap);
      userTableNos = snap.val();

      if (userTableNos) {
        var s = userTableNos.tableNo;

        if (s.indexOf(tableNo) !== -1) {
          alert('Table already reserved!');
          throw new Error('Table already reserved!');
        }

        _auth__WEBPACK_IMPORTED_MODULE_0__.db.ref('users/' + userId + '/reservations/' + date + '/' + time).set({
          tableNo: userTableNos.tableNo + ',' + tableNo
        });
      } else {
        _auth__WEBPACK_IMPORTED_MODULE_0__.db.ref('users/' + userId + '/reservations/' + date + '/' + time).set({
          tableNo: tableNo
        });
      }
    });
  })["catch"](function (error) {
    alert(error);
  });
}

if (document.querySelectorAll('.submit')[0]) {
  document.querySelectorAll('.submit')[0].addEventListener('click', function () {
    var obj = canvas.getActiveObject();

    if (obj) {
      // console.log('added');
      localStorage.setItem('selectedObj', JSON.stringify(obj));
      var selectedObj = JSON.parse(localStorage.getItem('selectedObj'));
      var user = _auth__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser;

      if (user) {
        // console.log('loggedIn');
        if (selectedObj.objects[1].text === 'Reserved') {
          alert('Table Unavailable right now!');
          throw new Error('Table Unavailable right now!');
        } else {
          saveReservation(user.uid, selectedObj.objects[1].text);
        }
      } else {
        alert('Please login to continue');
        window.location = '/auth.html';
      }
    } else {
      alert('Please select any table');
    }
  });
}

function addDefaultObjects() {
  addChair(15, 105);
  addChair(15, 135);
  addChair(75, 105);
  addChair(75, 135);
  addChair(225, 75);
  addChair(255, 75);
  addChair(225, 135);
  addChair(255, 135);
  addChair(225, 195);
  addChair(255, 195);
  addChair(225, 255);
  addChair(255, 255);
  addChair(15, 195);
  addChair(45, 195);
  addChair(15, 255);
  addChair(45, 255);
  addChair(15, 315);
  addChair(45, 315);
  addChair(15, 375);
  addChair(45, 375);
  addChair(225, 315);
  addChair(255, 315);
  addChair(225, 375);
  addChair(255, 375);
  addChair(15, 435);
  addChair(15, 495);
  addChair(15, 555);
  addChair(15, 615);
  addChair(225, 615);
  addChair(255, 615);
  addChair(195, 495);
  addChair(195, 525);
  addChair(255, 495);
  addChair(255, 525);
  addChair(225, 675);
  addChair(255, 675);
  addRect(30, 90, 60, 90);
  addRect(210, 90, 90, 60);
  addRect(210, 210, 90, 60);
  addRect(0, 210, 90, 60);
  addRect(0, 330, 90, 60);
  addRect(210, 330, 90, 60);
  addRect(0, 450, 60, 60);
  addRect(0, 570, 60, 60);
  addRect(210, 480, 60, 90);
  addRect(210, 630, 90, 60);
  addBar(120, 0, 180, 60);
  addWall(120, 510, 60, 60);
} // addDefaultObjects();


var totalTables = 0;

function controlNumbering(json_canvas) {
  for (var i = 0; i < json_canvas.objects.length; i++) {
    // console.log(json_canvas.objects[i]);
    if (json_canvas.objects[i].type == 'group') {
      if (parseInt(json_canvas.objects[i].objects[1].text)) {
        // console.log(json_canvas.objects[i].objects[1].text);
        totalTables++;
        localStorage.setItem('totalTables', totalTables);
      }
    }
  }

  totalTables = 0;
  return json_canvas;
}

document.getElementById('save').addEventListener('click', function () {
  var json_canvas = canvas.toJSON();
  json_canvas = controlNumbering(json_canvas);
  localStorage.setItem('json_canvas', JSON.stringify(json_canvas));
  localStorage.setItem('heightEl', heightEl.value);
  localStorage.setItem('widthEl', widthEl.value);
}); // canvas.clear();

function canvasLoader() {
  var jsonVariable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'json_canvas';
  var json = JSON.parse(localStorage.getItem(jsonVariable));
  canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
}

canvasLoader('json_canvas');
sendLinesToBack();

if (document.querySelector('.check-availability')) {
  // Checks the availability of the tables
  document.querySelector('.check-availability').addEventListener('click', function () {
    // console.log('clicked');
    var reserDate = document.getElementsByClassName('reservation-date')[0].value;
    var reserTime = document.getElementsByClassName('reservation-time')[0].value;

    if (!reserDate || !reserTime) {
      alert('Please enter the date and time');
      return;
    }

    var availRef = _auth__WEBPACK_IMPORTED_MODULE_0__.db.ref('reservations/' + reserDate + '/' + reserTime);
    availRef.once('value', function (snap) {
      // console.log(snap.val());
      if (snap.val() != null) {
        // alert('There are no reservations');
        // throw new Error('There are no reservations');
        // return;
        return snap.val();
      } else {
        return;
      }
    }).then(function (reservedTables) {
      // console.log(reservedTables.val());
      if (reservedTables.val() == null) {
        canvasLoader('json_canvas');
        document.querySelectorAll('.customer-mode')[0].click();
        return;
      }

      var reservedTableNoArray = reservedTables.val().reservedTableNo.split(','); // console.log(reservedTableNoArray);

      var jsonCanvasRealtime = JSON.parse(localStorage.getItem('json_canvas')); // console.log(typeof jsonCanvasRealtime);

      reservedTableNoArray.forEach(function (ele) {
        jsonCanvasRealtime.objects.forEach(function (obj) {
          if (obj.type === 'group') {
            if (obj.objects[1].text == ele) {
              // console.log(obj.objects[1].text);
              obj.objects[1].text = 'Reserved'; // console.log(obj.objects[1].text);

              obj.selectable = false;
            }
          }
        });
      }); // console.log(jsonCanvasRealtime);

      localStorage.setItem('json_canvas_realtime', JSON.stringify(jsonCanvasRealtime));
      canvasLoader('json_canvas_realtime');
      document.querySelectorAll('.customer-mode')[0].click();
    }); // localStorage.setItem('json_canvas_realtime');
    // canvasLoader('json_canvas');
  });
}

/***/ }),

/***/ "./node_modules/fabric/dist/fabric.js":
/*!********************************************!*\
  !*** ./node_modules/fabric/dist/fabric.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* build: `node build.js modules=ALL exclude=gestures,accessors requirejs minifier=uglifyjs` */
/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

var fabric = fabric || { version: '4.3.1' };
if (true) {
  exports.fabric = fabric;
}
/* _AMD_START_ */
else {}
/* _AMD_END_ */
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  if (document instanceof (typeof HTMLDocument !== 'undefined' ? HTMLDocument : Document)) {
    fabric.document = document;
  }
  else {
    fabric.document = document.implementation.createHTMLDocument('');
  }
  fabric.window = window;
}
else {
  // assume we're running under node.js when document/window are not present
  var jsdom = __webpack_require__(/*! jsdom */ "?3216");
  var virtualWindow = new jsdom.JSDOM(
    decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
    {
      features: {
        FetchExternalResources: ['img']
      },
      resources: 'usable'
    }).window;
  fabric.document = virtualWindow.document;
  fabric.jsdomImplForWrapper = __webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ "?aa72").implForWrapper;
  fabric.nodeCanvas = __webpack_require__(/*! jsdom/lib/jsdom/utils */ "?c310").Canvas;
  fabric.window = virtualWindow;
  DOMParser = fabric.window.DOMParser;
}

/**
 * True when in environment that supports touch events
 * @type boolean
 */
fabric.isTouchSupported = 'ontouchstart' in fabric.window || 'ontouchstart' in fabric.document ||
  (fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0);

/**
 * True when in environment that's probably Node.js
 * @type boolean
 */
fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                      typeof window === 'undefined';

/* _FROM_SVG_START_ */
/**
 * Attributes parsed from all SVG elements
 * @type array
 */
fabric.SHARED_ATTRIBUTES = [
  'display',
  'transform',
  'fill', 'fill-opacity', 'fill-rule',
  'opacity',
  'stroke', 'stroke-dasharray', 'stroke-linecap', 'stroke-dashoffset',
  'stroke-linejoin', 'stroke-miterlimit',
  'stroke-opacity', 'stroke-width',
  'id', 'paint-order', 'vector-effect',
  'instantiated_by_use', 'clip-path',
];
/* _FROM_SVG_END_ */

/**
 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
 */
fabric.DPI = 96;
fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)';
fabric.commaWsp = '(?:\\s+,?\\s*|,\\s*)';
fabric.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig;
fabric.reNonWord = /[ \n\.,;!\?\-]/;
fabric.fontPaths = { };
fabric.iMatrix = [1, 0, 0, 1, 0, 0];
fabric.svgNS = 'http://www.w3.org/2000/svg';

/**
 * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.perfLimitSizeTotal = 2097152;

/**
 * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.maxCacheSideLimit = 4096;

/**
 * Lowest pixel limit for cache canvases, set at 256PX
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.minCacheSideLimit = 256;

/**
 * Cache Object for widths of chars in text rendering.
 */
fabric.charWidthsCache = { };

/**
 * if webgl is enabled and available, textureSize will determine the size
 * of the canvas backend
 * @since 2.0.0
 * @type Number
 * @default
 */
fabric.textureSize = 2048;

/**
 * When 'true', style information is not retained when copy/pasting text, making
 * pasted text use destination style.
 * Defaults to 'false'.
 * @type Boolean
 * @default
 */
fabric.disableStyleCopyPaste = false;

/**
 * Enable webgl for filtering picture is available
 * A filtering backend will be initialized, this will both take memory and
 * time since a default 2048x2048 canvas will be created for the gl context
 * @since 2.0.0
 * @type Boolean
 * @default
 */
fabric.enableGLFiltering = true;

/**
 * Device Pixel Ratio
 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
 */
fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                          fabric.window.webkitDevicePixelRatio ||
                          fabric.window.mozDevicePixelRatio ||
                          1;
/**
 * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,
 * which is unitless and not rendered equally across browsers.
 *
 * Values that work quite well (as of October 2017) are:
 * - Chrome: 1.5
 * - Edge: 1.75
 * - Firefox: 0.9
 * - Safari: 0.95
 *
 * @since 2.0.0
 * @type Number
 * @default 1
 */
fabric.browserShadowBlurConstant = 1;

/**
 * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.arcToSegmentsCache = { };

/**
 * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.
 * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing
 * you do not get any speed benefit and you get a big object in memory.
 * The object was a private variable before, while now is appended to the lib so that you have access to it and you
 * can eventually clear it.
 * It was an internal variable, is accessible since version 2.3.4
 */
fabric.boundsOfCurveCache = { };

/**
 * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better
 * @default true
 */
fabric.cachesBoundsOfCurve = true;

/**
 * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on
 * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true
 * this has to be set before instantiating the filtering backend ( before filtering the first image )
 * @type Boolean
 * @default false
 */
fabric.forceGLPutImageData = false;

fabric.initFilterBackend = function() {
  if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
    console.log('max texture size: ' + fabric.maxTextureSize);
    return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
  }
  else if (fabric.Canvas2dFilterBackend) {
    return (new fabric.Canvas2dFilterBackend());
  }
};


if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
  window.fabric = fabric;
}


(function() {

  /**
   * @private
   * @param {String} eventName
   * @param {Function} handler
   */
  function _removeEventListener(eventName, handler) {
    if (!this.__eventListeners[eventName]) {
      return;
    }
    var eventListener = this.__eventListeners[eventName];
    if (handler) {
      eventListener[eventListener.indexOf(handler)] = false;
    }
    else {
      fabric.util.array.fill(eventListener, false);
    }
  }

  /**
   * Observes specified event
   * @memberOf fabric.Observable
   * @alias on
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
   * @return {Self} thisArg
   * @chainable
   */
  function on(eventName, handler) {
    if (!this.__eventListeners) {
      this.__eventListeners = { };
    }
    // one object with key/value pairs was passed
    if (arguments.length === 1) {
      for (var prop in eventName) {
        this.on(prop, eventName[prop]);
      }
    }
    else {
      if (!this.__eventListeners[eventName]) {
        this.__eventListeners[eventName] = [];
      }
      this.__eventListeners[eventName].push(handler);
    }
    return this;
  }

  /**
   * Stops event observing for a particular event handler. Calling this method
   * without arguments removes all handlers for all events
   * @memberOf fabric.Observable
   * @alias off
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function to be deleted from EventListeners
   * @return {Self} thisArg
   * @chainable
   */
  function off(eventName, handler) {
    if (!this.__eventListeners) {
      return this;
    }

    // remove all key/value pairs (event name -> event handler)
    if (arguments.length === 0) {
      for (eventName in this.__eventListeners) {
        _removeEventListener.call(this, eventName);
      }
    }
    // one object with key/value pairs was passed
    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
      for (var prop in eventName) {
        _removeEventListener.call(this, prop, eventName[prop]);
      }
    }
    else {
      _removeEventListener.call(this, eventName, handler);
    }
    return this;
  }

  /**
   * Fires event with an optional options object
   * @memberOf fabric.Observable
   * @param {String} eventName Event name to fire
   * @param {Object} [options] Options object
   * @return {Self} thisArg
   * @chainable
   */
  function fire(eventName, options) {
    if (!this.__eventListeners) {
      return this;
    }

    var listenersForEvent = this.__eventListeners[eventName];
    if (!listenersForEvent) {
      return this;
    }

    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
    }
    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
      return value !== false;
    });
    return this;
  }

  /**
   * @namespace fabric.Observable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
   * @see {@link http://fabricjs.com/events|Events demo}
   */
  fabric.Observable = {
    fire: fire,
    on: on,
    off: off,
  };
})();


/**
 * @namespace fabric.Collection
 */
fabric.Collection = {

  _objects: [],

  /**
   * Adds objects to collection, Canvas or Group, then renders canvas
   * (if `renderOnAddRemove` is not `false`).
   * in case of Group no changes to bounding box are made.
   * Objects should be instances of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the add method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  add: function () {
    this._objects.push.apply(this._objects, arguments);
    if (this._onObjectAdded) {
      for (var i = 0, length = arguments.length; i < length; i++) {
        this._onObjectAdded(arguments[i]);
      }
    }
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
   * An object should be an instance of (or inherit from) fabric.Object
   * Use of this function is highly discouraged for groups.
   * you can add a bunch of objects with the insertAt method but then you NEED
   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
   * @param {Object} object Object to insert
   * @param {Number} index Index to insert object at
   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
   * @return {Self} thisArg
   * @chainable
   */
  insertAt: function (object, index, nonSplicing) {
    var objects = this._objects;
    if (nonSplicing) {
      objects[index] = object;
    }
    else {
      objects.splice(index, 0, object);
    }
    this._onObjectAdded && this._onObjectAdded(object);
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  remove: function() {
    var objects = this._objects,
        index, somethingRemoved = false;

    for (var i = 0, length = arguments.length; i < length; i++) {
      index = objects.indexOf(arguments[i]);

      // only call onObjectRemoved if an object was actually removed
      if (index !== -1) {
        somethingRemoved = true;
        objects.splice(index, 1);
        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
      }
    }

    this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
    return this;
  },

  /**
   * Executes given function for each object in this group
   * @param {Function} callback
   *                   Callback invoked with current object as first argument,
   *                   index - as second and an array of all objects - as third.
   *                   Callback is invoked in a context of Global Object (e.g. `window`)
   *                   when no `context` argument is given
   *
   * @param {Object} context Context (aka thisObject)
   * @return {Self} thisArg
   * @chainable
   */
  forEachObject: function(callback, context) {
    var objects = this.getObjects();
    for (var i = 0, len = objects.length; i < len; i++) {
      callback.call(context, objects[i], i, objects);
    }
    return this;
  },

  /**
   * Returns an array of children objects of this instance
   * Type parameter introduced in 1.3.10
   * since 2.3.5 this method return always a COPY of the array;
   * @param {String} [type] When specified, only objects of this type are returned
   * @return {Array}
   */
  getObjects: function(type) {
    if (typeof type === 'undefined') {
      return this._objects.concat();
    }
    return this._objects.filter(function(o) {
      return o.type === type;
    });
  },

  /**
   * Returns object at specified index
   * @param {Number} index
   * @return {Self} thisArg
   */
  item: function (index) {
    return this._objects[index];
  },

  /**
   * Returns true if collection contains no objects
   * @return {Boolean} true if collection is empty
   */
  isEmpty: function () {
    return this._objects.length === 0;
  },

  /**
   * Returns a size of a collection (i.e: length of an array containing its objects)
   * @return {Number} Collection size
   */
  size: function() {
    return this._objects.length;
  },

  /**
   * Returns true if collection contains an object
   * @param {Object} object Object to check against
   * @return {Boolean} `true` if collection contains an object
   */
  contains: function(object) {
    return this._objects.indexOf(object) > -1;
  },

  /**
   * Returns number representation of a collection complexity
   * @return {Number} complexity
   */
  complexity: function () {
    return this._objects.reduce(function (memo, current) {
      memo += current.complexity ? current.complexity() : 0;
      return memo;
    }, 0);
  }
};


/**
 * @namespace fabric.CommonMethods
 */
fabric.CommonMethods = {

  /**
   * Sets object's properties from options
   * @param {Object} [options] Options object
   */
  _setOptions: function(options) {
    for (var prop in options) {
      this.set(prop, options[prop]);
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Gradient to
   */
  _initGradient: function(filler, property) {
    if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
      this.set(property, new fabric.Gradient(filler));
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Pattern to
   * @param {Function} [callback] callback to invoke after pattern load
   */
  _initPattern: function(filler, property, callback) {
    if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
      this.set(property, new fabric.Pattern(filler, callback));
    }
    else {
      callback && callback();
    }
  },

  /**
   * @private
   */
  _setObject: function(obj) {
    for (var prop in obj) {
      this._set(prop, obj[prop]);
    }
  },

  /**
   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
   * @param {String|Object} key Property name or object (if object, iterate over the object properties)
   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  set: function(key, value) {
    if (typeof key === 'object') {
      this._setObject(key);
    }
    else {
      this._set(key, value);
    }
    return this;
  },

  _set: function(key, value) {
    this[key] = value;
  },

  /**
   * Toggles specified property from `true` to `false` or from `false` to `true`
   * @param {String} property Property to toggle
   * @return {fabric.Object} thisArg
   * @chainable
   */
  toggle: function(property) {
    var value = this.get(property);
    if (typeof value === 'boolean') {
      this.set(property, !value);
    }
    return this;
  },

  /**
   * Basic getter
   * @param {String} property Property name
   * @return {*} value of a property
   */
  get: function(property) {
    return this[property];
  }
};


(function(global) {

  var sqrt = Math.sqrt,
      atan2 = Math.atan2,
      pow = Math.pow,
      PiBy180 = Math.PI / 180,
      PiBy2 = Math.PI / 2;

  /**
   * @namespace fabric.util
   */
  fabric.util = {

    /**
     * Calculate the cos of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    cos: function(angle) {
      if (angle === 0) { return 1; }
      if (angle < 0) {
        // cos(a) = cos(-a)
        angle = -angle;
      }
      var angleSlice = angle / PiBy2;
      switch (angleSlice) {
        case 1: case 3: return 0;
        case 2: return -1;
      }
      return Math.cos(angle);
    },

    /**
     * Calculate the sin of an angle, avoiding returning floats for known results
     * @static
     * @memberOf fabric.util
     * @param {Number} angle the angle in radians or in degree
     * @return {Number}
     */
    sin: function(angle) {
      if (angle === 0) { return 0; }
      var angleSlice = angle / PiBy2, sign = 1;
      if (angle < 0) {
        // sin(-a) = -sin(a)
        sign = -1;
      }
      switch (angleSlice) {
        case 1: return sign;
        case 2: return 0;
        case 3: return -sign;
      }
      return Math.sin(angle);
    },

    /**
     * Removes value from an array.
     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
     * @static
     * @memberOf fabric.util
     * @param {Array} array
     * @param {*} value
     * @return {Array} original array
     */
    removeFromArray: function(array, value) {
      var idx = array.indexOf(value);
      if (idx !== -1) {
        array.splice(idx, 1);
      }
      return array;
    },

    /**
     * Returns random number between 2 specified ones.
     * @static
     * @memberOf fabric.util
     * @param {Number} min lower limit
     * @param {Number} max upper limit
     * @return {Number} random value (between min and max)
     */
    getRandomInt: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    /**
     * Transforms degrees to radians.
     * @static
     * @memberOf fabric.util
     * @param {Number} degrees value in degrees
     * @return {Number} value in radians
     */
    degreesToRadians: function(degrees) {
      return degrees * PiBy180;
    },

    /**
     * Transforms radians to degrees.
     * @static
     * @memberOf fabric.util
     * @param {Number} radians value in radians
     * @return {Number} value in degrees
     */
    radiansToDegrees: function(radians) {
      return radians / PiBy180;
    },

    /**
     * Rotates `point` around `origin` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {fabric.Point} point The point to rotate
     * @param {fabric.Point} origin The origin of the rotation
     * @param {Number} radians The radians of the angle for the rotation
     * @return {fabric.Point} The new rotated point
     */
    rotatePoint: function(point, origin, radians) {
      point.subtractEquals(origin);
      var v = fabric.util.rotateVector(point, radians);
      return new fabric.Point(v.x, v.y).addEquals(origin);
    },

    /**
     * Rotates `vector` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {Object} vector The vector to rotate (x and y)
     * @param {Number} radians The radians of the angle for the rotation
     * @return {Object} The new rotated point
     */
    rotateVector: function(vector, radians) {
      var sin = fabric.util.sin(radians),
          cos = fabric.util.cos(radians),
          rx = vector.x * cos - vector.y * sin,
          ry = vector.x * sin + vector.y * cos;
      return {
        x: rx,
        y: ry
      };
    },

    /**
     * Apply transform t to point p
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Point} p The point to transform
     * @param  {Array} t The transform
     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
     * @return {fabric.Point} The transformed point
     */
    transformPoint: function(p, t, ignoreOffset) {
      if (ignoreOffset) {
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y,
          t[1] * p.x + t[3] * p.y
        );
      }
      return new fabric.Point(
        t[0] * p.x + t[2] * p.y + t[4],
        t[1] * p.x + t[3] * p.y + t[5]
      );
    },

    /**
     * Returns coordinates of points's bounding rectangle (left, top, width, height)
     * @param {Array} points 4 points array
     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix
     * @return {Object} Object with left, top, width, height properties
     */
    makeBoundingBoxFromPoints: function(points, transform) {
      if (transform) {
        for (var i = 0; i < points.length; i++) {
          points[i] = fabric.util.transformPoint(points[i], transform);
        }
      }
      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
          minX = fabric.util.array.min(xPoints),
          maxX = fabric.util.array.max(xPoints),
          width = maxX - minX,
          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
          minY = fabric.util.array.min(yPoints),
          maxY = fabric.util.array.max(yPoints),
          height = maxY - minY;

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Invert transformation t
     * @static
     * @memberOf fabric.util
     * @param {Array} t The transform
     * @return {Array} The inverted transform
     */
    invertTransform: function(t) {
      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
      r[4] = -o.x;
      r[5] = -o.y;
      return r;
    },

    /**
     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
     * @static
     * @memberOf fabric.util
     * @param {Number|String} number number to operate on
     * @param {Number} fractionDigits number of fraction digits to "leave"
     * @return {Number}
     */
    toFixed: function(number, fractionDigits) {
      return parseFloat(Number(number).toFixed(fractionDigits));
    },

    /**
     * Converts from attribute value to pixel value if applicable.
     * Returns converted pixels or original value not converted.
     * @param {Number|String} value number to operate on
     * @param {Number} fontSize
     * @return {Number|String}
     */
    parseUnit: function(value, fontSize) {
      var unit = /\D{0,2}$/.exec(value),
          number = parseFloat(value);
      if (!fontSize) {
        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }
      switch (unit[0]) {
        case 'mm':
          return number * fabric.DPI / 25.4;

        case 'cm':
          return number * fabric.DPI / 2.54;

        case 'in':
          return number * fabric.DPI;

        case 'pt':
          return number * fabric.DPI / 72; // or * 4 / 3

        case 'pc':
          return number * fabric.DPI / 72 * 12; // or * 16

        case 'em':
          return number * fontSize;

        default:
          return number;
      }
    },

    /**
     * Function which always returns `false`.
     * @static
     * @memberOf fabric.util
     * @return {Boolean}
     */
    falseFunction: function() {
      return false;
    },

    /**
     * Returns klass "Class" object of given namespace
     * @memberOf fabric.util
     * @param {String} type Type of object (eg. 'circle')
     * @param {String} namespace Namespace to get klass "Class" object from
     * @return {Object} klass "Class"
     */
    getKlass: function(type, namespace) {
      // capitalize first letter only
      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
      return fabric.util.resolveNamespace(namespace)[type];
    },

    /**
     * Returns array of attributes for given svg that fabric parses
     * @memberOf fabric.util
     * @param {String} type Type of svg element (eg. 'circle')
     * @return {Array} string names of supported attributes
     */
    getSvgAttributes: function(type) {
      var attributes = [
        'instantiated_by_use',
        'style',
        'id',
        'class'
      ];
      switch (type) {
        case 'linearGradient':
          attributes = attributes.concat(['x1', 'y1', 'x2', 'y2', 'gradientUnits', 'gradientTransform']);
          break;
        case 'radialGradient':
          attributes = attributes.concat(['gradientUnits', 'gradientTransform', 'cx', 'cy', 'r', 'fx', 'fy', 'fr']);
          break;
        case 'stop':
          attributes = attributes.concat(['offset', 'stop-color', 'stop-opacity']);
          break;
      }
      return attributes;
    },

    /**
     * Returns object of given namespace
     * @memberOf fabric.util
     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
     * @return {Object} Object for given namespace (default fabric)
     */
    resolveNamespace: function(namespace) {
      if (!namespace) {
        return fabric;
      }

      var parts = namespace.split('.'),
          len = parts.length, i,
          obj = global || fabric.window;

      for (i = 0; i < len; ++i) {
        obj = obj[parts[i]];
      }

      return obj;
    },

    /**
     * Loads image element from given url and passes it to a callback
     * @memberOf fabric.util
     * @param {String} url URL representing an image
     * @param {Function} callback Callback; invoked with loaded image
     * @param {*} [context] Context to invoke callback in
     * @param {Object} [crossOrigin] crossOrigin value to set image element to
     */
    loadImage: function(url, callback, context, crossOrigin) {
      if (!url) {
        callback && callback.call(context, url);
        return;
      }

      var img = fabric.util.createImage();

      /** @ignore */
      var onLoadCallback = function () {
        callback && callback.call(context, img, false);
        img = img.onload = img.onerror = null;
      };

      img.onload = onLoadCallback;
      /** @ignore */
      img.onerror = function() {
        fabric.log('Error loading ' + img.src);
        callback && callback.call(context, null, true);
        img = img.onload = img.onerror = null;
      };

      // data-urls appear to be buggy with crossOrigin
      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
      // see https://code.google.com/p/chromium/issues/detail?id=315152
      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
      // crossOrigin null is the same as not set.
      if (url.indexOf('data') !== 0 &&
        crossOrigin !== undefined &&
        crossOrigin !== null) {
        img.crossOrigin = crossOrigin;
      }

      // IE10 / IE11-Fix: SVG contents from data: URI
      // will only be available if the IMG is present
      // in the DOM (and visible)
      if (url.substring(0,14) === 'data:image/svg') {
        img.onload = null;
        fabric.util.loadImageInDom(img, onLoadCallback);
      }

      img.src = url;
    },

    /**
     * Attaches SVG image with data: URL to the dom
     * @memberOf fabric.util
     * @param {Object} img Image object with data:image/svg src
     * @param {Function} callback Callback; invoked with loaded image
     * @return {Object} DOM element (div containing the SVG image)
     */
    loadImageInDom: function(img, onLoadCallback) {
      var div = fabric.document.createElement('div');
      div.style.width = div.style.height = '1px';
      div.style.left = div.style.top = '-100%';
      div.style.position = 'absolute';
      div.appendChild(img);
      fabric.document.querySelector('body').appendChild(div);
      /**
       * Wrap in function to:
       *   1. Call existing callback
       *   2. Cleanup DOM
       */
      img.onload = function () {
        onLoadCallback();
        div.parentNode.removeChild(div);
        div = null;
      };
    },

    /**
     * Creates corresponding fabric instances from their object representations
     * @static
     * @memberOf fabric.util
     * @param {Array} objects Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * @param {String} namespace Namespace to get klass "Class" object from
     * @param {Function} reviver Method for further parsing of object elements,
     * called after each fabric object created.
     */
    enlivenObjects: function(objects, callback, namespace, reviver) {
      objects = objects || [];

      var enlivenedObjects = [],
          numLoadedObjects = 0,
          numTotalObjects = objects.length;

      function onLoaded() {
        if (++numLoadedObjects === numTotalObjects) {
          callback && callback(enlivenedObjects.filter(function(obj) {
            // filter out undefined objects (objects that gave error)
            return obj;
          }));
        }
      }

      if (!numTotalObjects) {
        callback && callback(enlivenedObjects);
        return;
      }

      objects.forEach(function (o, index) {
        // if sparse array
        if (!o || !o.type) {
          onLoaded();
          return;
        }
        var klass = fabric.util.getKlass(o.type, namespace);
        klass.fromObject(o, function (obj, error) {
          error || (enlivenedObjects[index] = obj);
          reviver && reviver(o, obj, error);
          onLoaded();
        });
      });
    },

    /**
     * Create and wait for loading of patterns
     * @static
     * @memberOf fabric.util
     * @param {Array} patterns Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * called after each fabric object created.
     */
    enlivenPatterns: function(patterns, callback) {
      patterns = patterns || [];

      function onLoaded() {
        if (++numLoadedPatterns === numPatterns) {
          callback && callback(enlivenedPatterns);
        }
      }

      var enlivenedPatterns = [],
          numLoadedPatterns = 0,
          numPatterns = patterns.length;

      if (!numPatterns) {
        callback && callback(enlivenedPatterns);
        return;
      }

      patterns.forEach(function (p, index) {
        if (p && p.source) {
          new fabric.Pattern(p, function(pattern) {
            enlivenedPatterns[index] = pattern;
            onLoaded();
          });
        }
        else {
          enlivenedPatterns[index] = p;
          onLoaded();
        }
      });
    },

    /**
     * Groups SVG elements (usually those retrieved from SVG document)
     * @static
     * @memberOf fabric.util
     * @param {Array} elements SVG elements to group
     * @param {Object} [options] Options object
     * @param {String} path Value to set sourcePath to
     * @return {fabric.Object|fabric.Group}
     */
    groupSVGElements: function(elements, options, path) {
      var object;
      if (elements && elements.length === 1) {
        return elements[0];
      }
      if (options) {
        if (options.width && options.height) {
          options.centerPoint = {
            x: options.width / 2,
            y: options.height / 2
          };
        }
        else {
          delete options.width;
          delete options.height;
        }
      }
      object = new fabric.Group(elements, options);
      if (typeof path !== 'undefined') {
        object.sourcePath = path;
      }
      return object;
    },

    /**
     * Populates an object with properties of another object
     * @static
     * @memberOf fabric.util
     * @param {Object} source Source object
     * @param {Object} destination Destination object
     * @return {Array} properties Properties names to include
     */
    populateWithProperties: function(source, destination, properties) {
      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
        for (var i = 0, len = properties.length; i < len; i++) {
          if (properties[i] in source) {
            destination[properties[i]] = source[properties[i]];
          }
        }
      }
    },

    /**
     * Draws a dashed line between two points
     *
     * This method is used to draw dashed line around selection area.
     * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
     *
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x  start x coordinate
     * @param {Number} y start y coordinate
     * @param {Number} x2 end x coordinate
     * @param {Number} y2 end y coordinate
     * @param {Array} da dash array pattern
     */
    drawDashedLine: function(ctx, x, y, x2, y2, da) {
      var dx = x2 - x,
          dy = y2 - y,
          len = sqrt(dx * dx + dy * dy),
          rot = atan2(dy, dx),
          dc = da.length,
          di = 0,
          draw = true;

      ctx.save();
      ctx.translate(x, y);
      ctx.moveTo(0, 0);
      ctx.rotate(rot);

      x = 0;
      while (len > x) {
        x += da[di++ % dc];
        if (x > len) {
          x = len;
        }
        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
        draw = !draw;
      }

      ctx.restore();
    },

    /**
     * Creates canvas element
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    createCanvasElement: function() {
      return fabric.document.createElement('canvas');
    },

    /**
     * Creates a canvas element that is a copy of another and is also painted
     * @param {CanvasElement} canvas to copy size and content of
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    copyCanvasElement: function(canvas) {
      var newCanvas = fabric.util.createCanvasElement();
      newCanvas.width = canvas.width;
      newCanvas.height = canvas.height;
      newCanvas.getContext('2d').drawImage(canvas, 0, 0);
      return newCanvas;
    },

    /**
     * since 2.6.0 moved from canvas instance to utility.
     * @param {CanvasElement} canvasEl to copy size and content of
     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too
     * @param {Number} quality <= 1 and > 0
     * @static
     * @memberOf fabric.util
     * @return {String} data url
     */
    toDataURL: function(canvasEl, format, quality) {
      return canvasEl.toDataURL('image/' + format, quality);
    },

    /**
     * Creates image element (works on client and node)
     * @static
     * @memberOf fabric.util
     * @return {HTMLImageElement} HTML image element
     */
    createImage: function() {
      return fabric.document.createElement('img');
    },

    /**
     * Multiply matrix A by matrix B to nest transformations
     * @static
     * @memberOf fabric.util
     * @param  {Array} a First transformMatrix
     * @param  {Array} b Second transformMatrix
     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
     * @return {Array} The product of the two transform matrices
     */
    multiplyTransformMatrices: function(a, b, is2x2) {
      // Matrix multiply a * b
      return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
      ];
    },

    /**
     * Decomposes standard 2x3 matrix into transform components
     * @static
     * @memberOf fabric.util
     * @param  {Array} a transformMatrix
     * @return {Object} Components of transform
     */
    qrDecompose: function(a) {
      var angle = atan2(a[1], a[0]),
          denom = pow(a[0], 2) + pow(a[1], 2),
          scaleX = sqrt(denom),
          scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX,
          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
      return {
        angle: angle / PiBy180,
        scaleX: scaleX,
        scaleY: scaleY,
        skewX: skewX / PiBy180,
        skewY: 0,
        translateX: a[4],
        translateY: a[5]
      };
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.angle] angle in degrees
     * @return {Number[]} transform matrix
     */
    calcRotateMatrix: function(options) {
      if (!options.angle) {
        return fabric.iMatrix.concat();
      }
      var theta = fabric.util.degreesToRadians(options.angle),
          cos = fabric.util.cos(theta),
          sin = fabric.util.sin(theta);
      return [cos, sin, -sin, cos, 0, 0];
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet.
     * is called DimensionsTransformMatrix because those properties are the one that influence
     * the size of the resulting box of the object.
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.scaleX]
     * @param  {Number} [options.scaleY]
     * @param  {Boolean} [options.flipX]
     * @param  {Boolean} [options.flipY]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.skewX]
     * @return {Number[]} transform matrix
     */
    calcDimensionsMatrix: function(options) {
      var scaleX = typeof options.scaleX === 'undefined' ? 1 : options.scaleX,
          scaleY = typeof options.scaleY === 'undefined' ? 1 : options.scaleY,
          scaleMatrix = [
            options.flipX ? -scaleX : scaleX,
            0,
            0,
            options.flipY ? -scaleY : scaleY,
            0,
            0],
          multiply = fabric.util.multiplyTransformMatrices,
          degreesToRadians = fabric.util.degreesToRadians;
      if (options.skewX) {
        scaleMatrix = multiply(
          scaleMatrix,
          [1, 0, Math.tan(degreesToRadians(options.skewX)), 1],
          true);
      }
      if (options.skewY) {
        scaleMatrix = multiply(
          scaleMatrix,
          [1, Math.tan(degreesToRadians(options.skewY)), 0, 1],
          true);
      }
      return scaleMatrix;
    },

    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enlived yet
     * @static
     * @memberOf fabric.util
     * @param  {Object} options
     * @param  {Number} [options.angle]
     * @param  {Number} [options.scaleX]
     * @param  {Number} [options.scaleY]
     * @param  {Boolean} [options.flipX]
     * @param  {Boolean} [options.flipY]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.skewX]
     * @param  {Number} [options.translateX]
     * @param  {Number} [options.translateY]
     * @return {Number[]} transform matrix
     */
    composeMatrix: function(options) {
      var matrix = [1, 0, 0, 1, options.translateX || 0, options.translateY || 0],
          multiply = fabric.util.multiplyTransformMatrices;
      if (options.angle) {
        matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));
      }
      if (options.scaleX !== 1 || options.scaleY !== 1 ||
          options.skewX || options.skewY || options.flipX || options.flipY) {
        matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));
      }
      return matrix;
    },

    /**
     * reset an object transform state to neutral. Top and left are not accounted for
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to transform
     */
    resetObjectTransform: function (target) {
      target.scaleX = 1;
      target.scaleY = 1;
      target.skewX = 0;
      target.skewY = 0;
      target.flipX = false;
      target.flipY = false;
      target.rotate(0);
    },

    /**
     * Extract Object transform values
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Object} target object to read from
     * @return {Object} Components of transform
     */
    saveObjectTransform: function (target) {
      return {
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        skewX: target.skewX,
        skewY: target.skewY,
        angle: target.angle,
        left: target.left,
        flipX: target.flipX,
        flipY: target.flipY,
        top: target.top
      };
    },

    /**
     * Returns true if context has transparent pixel
     * at specified location (taking tolerance into account)
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x x coordinate
     * @param {Number} y y coordinate
     * @param {Number} tolerance Tolerance
     */
    isTransparent: function(ctx, x, y, tolerance) {

      // If tolerance is > 0 adjust start coords to take into account.
      // If moves off Canvas fix to 0
      if (tolerance > 0) {
        if (x > tolerance) {
          x -= tolerance;
        }
        else {
          x = 0;
        }
        if (y > tolerance) {
          y -= tolerance;
        }
        else {
          y = 0;
        }
      }

      var _isTransparent = true, i, temp,
          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
          l = imageData.data.length;

      // Split image data - for tolerance > 1, pixelDataSize = 4;
      for (i = 3; i < l; i += 4) {
        temp = imageData.data[i];
        _isTransparent = temp <= 0;
        if (_isTransparent === false) {
          break; // Stop if colour found
        }
      }

      imageData = null;

      return _isTransparent;
    },

    /**
     * Parse preserveAspectRatio attribute from element
     * @param {string} attribute to be parsed
     * @return {Object} an object containing align and meetOrSlice attribute
     */
    parsePreserveAspectRatioAttribute: function(attribute) {
      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
          aspectRatioAttrs = attribute.split(' '), align;

      if (aspectRatioAttrs && aspectRatioAttrs.length) {
        meetOrSlice = aspectRatioAttrs.pop();
        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
          align = meetOrSlice;
          meetOrSlice = 'meet';
        }
        else if (aspectRatioAttrs.length) {
          align = aspectRatioAttrs.pop();
        }
      }
      //divide align in alignX and alignY
      alignX = align !== 'none' ? align.slice(1, 4) : 'none';
      alignY = align !== 'none' ? align.slice(5, 8) : 'none';
      return {
        meetOrSlice: meetOrSlice,
        alignX: alignX,
        alignY: alignY
      };
    },

    /**
     * Clear char widths cache for the given font family or all the cache if no
     * fontFamily is specified.
     * Use it if you know you are loading fonts in a lazy way and you are not waiting
     * for custom fonts to load properly when adding text objects to the canvas.
     * If a text object is added when its own font is not loaded yet, you will get wrong
     * measurement and so wrong bounding boxes.
     * After the font cache is cleared, either change the textObject text content or call
     * initDimensions() to trigger a recalculation
     * @memberOf fabric.util
     * @param {String} [fontFamily] font family to clear
     */
    clearFabricFontCache: function(fontFamily) {
      fontFamily = (fontFamily || '').toLowerCase();
      if (!fontFamily) {
        fabric.charWidthsCache = { };
      }
      else if (fabric.charWidthsCache[fontFamily]) {
        delete fabric.charWidthsCache[fontFamily];
      }
    },

    /**
     * Given current aspect ratio, determines the max width and height that can
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Number} ar aspect ratio
     * @param {Number} maximumArea Maximum area you want to achieve
     * @return {Object.x} Limited dimensions by X
     * @return {Object.y} Limited dimensions by Y
     */
    limitDimsByArea: function(ar, maximumArea) {
      var roughWidth = Math.sqrt(maximumArea * ar),
          perfLimitSizeY = Math.floor(maximumArea / roughWidth);
      return { x: Math.floor(roughWidth), y: perfLimitSizeY };
    },

    capValue: function(min, value, max) {
      return Math.max(min, Math.min(value, max));
    },

    /**
     * Finds the scale for the object source to fit inside the object destination,
     * keeping aspect ratio intact.
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Object | fabric.Object} source
     * @param {Number} source.height natural unscaled height of the object
     * @param {Number} source.width natural unscaled width of the object
     * @param {Object | fabric.Object} destination
     * @param {Number} destination.height natural unscaled height of the object
     * @param {Number} destination.width natural unscaled width of the object
     * @return {Number} scale factor to apply to source to fit into destination
     */
    findScaleToFit: function(source, destination) {
      return Math.min(destination.width / source.width, destination.height / source.height);
    },

    /**
     * Finds the scale for the object source to cover entirely the object destination,
     * keeping aspect ratio intact.
     * respect the total allowed area for the cache.
     * @memberOf fabric.util
     * @param {Object | fabric.Object} source
     * @param {Number} source.height natural unscaled height of the object
     * @param {Number} source.width natural unscaled width of the object
     * @param {Object | fabric.Object} destination
     * @param {Number} destination.height natural unscaled height of the object
     * @param {Number} destination.width natural unscaled width of the object
     * @return {Number} scale factor to apply to source to cover destination
     */
    findScaleToCover: function(source, destination) {
      return Math.max(destination.width / source.width, destination.height / source.height);
    },

    /**
     * given an array of 6 number returns something like `"matrix(...numbers)"`
     * @memberOf fabric.util
     * @param {Array} transform an array with 6 numbers
     * @return {String} transform matrix for svg
     * @return {Object.y} Limited dimensions by Y
     */
    matrixToSVG: function(transform) {
      return 'matrix(' + transform.map(function(value) {
        return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);
      }).join(' ') + ')';
    },

    /**
     * given a width and height, return the size of the bounding box
     * that can contains the box with width/height with applied transform
     * described in options.
     * Use to calculate the boxes around objects for controls.
     * @memberOf fabric.util
     * @param {Number} width
     * @param {Number} height
     * @param {Object} options
     * @param {Number} options.scaleX
     * @param {Number} options.scaleY
     * @param {Number} options.skewX
     * @param {Number} options.skewY
     * @return {Object.x} width of containing
     * @return {Object.y} height of containing
     */
    sizeAfterTransform: function(width, height, options) {
      var dimX = width / 2, dimY = height / 2,
          points = [
            {
              x: -dimX,
              y: -dimY
            },
            {
              x: dimX,
              y: -dimY
            },
            {
              x: -dimX,
              y: dimY
            },
            {
              x: dimX,
              y: dimY
            }],
          transformMatrix = fabric.util.calcDimensionsMatrix(options),
          bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);
      return {
        x: bbox.width,
        y: bbox.height,
      };
    }
  };
})( true ? exports : 0);


(function() {
  var _join = Array.prototype.join,
      commandLengths = {
        m: 2,
        l: 2,
        h: 1,
        v: 1,
        c: 6,
        s: 4,
        q: 4,
        t: 2,
        a: 7
      },
      repeatedCommands = {
        m: 'l',
        M: 'L'
      };
  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
    var costh2 = fabric.util.cos(th2),
        sinth2 = fabric.util.sin(th2),
        costh3 = fabric.util.cos(th3),
        sinth3 = fabric.util.sin(th3),
        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

    return ['C',
      cp1X, cp1Y,
      cp2X, cp2Y,
      toX, toY
    ];
  }

  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
   * http://mozilla.org/MPL/2.0/
   */
  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
    var PI = Math.PI, th = rotateX * PI / 180,
        sinTh = fabric.util.sin(th),
        cosTh = fabric.util.cos(th),
        fromX = 0, fromY = 0;

    rx = Math.abs(rx);
    ry = Math.abs(ry);

    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
        root = 0;

    if (pl < 0) {
      var s = Math.sqrt(1 - pl / (rx2 * ry2));
      rx *= s;
      ry *= s;
    }
    else {
      root = (large === sweep ? -1.0 : 1.0) *
              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
    }

    var cx = root * rx * py / ry,
        cy = -root * ry * px / rx,
        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

    if (sweep === 0 && dtheta > 0) {
      dtheta -= 2 * PI;
    }
    else if (sweep === 1 && dtheta < 0) {
      dtheta += 2 * PI;
    }

    // Convert into cubic bezier segments <= 90deg
    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
        result = [], mDelta = dtheta / segments,
        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
        th3 = mTheta + mDelta;

    for (var i = 0; i < segments; i++) {
      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
      fromX = result[i][5];
      fromY = result[i][6];
      mTheta = th3;
      th3 += mDelta;
    }
    return result;
  }

  /*
   * Private
   */
  function calcVectorAngle(ux, uy, vx, vy) {
    var ta = Math.atan2(uy, ux),
        tb = Math.atan2(vy, vx);
    if (tb >= ta) {
      return tb - ta;
    }
    else {
      return 2 * Math.PI - (ta - tb);
    }
  }

  /**
   * Calculate bounding box of a beziercurve
   * @param {Number} x0 starting point
   * @param {Number} y0
   * @param {Number} x1 first control point
   * @param {Number} y1
   * @param {Number} x2 secondo control point
   * @param {Number} y2
   * @param {Number} x3 end of bezier
   * @param {Number} y3
   */
  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
  // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?
  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
    var argsString;
    if (fabric.cachesBoundsOfCurve) {
      argsString = _join.call(arguments);
      if (fabric.boundsOfCurveCache[argsString]) {
        return fabric.boundsOfCurveCache[argsString];
      }
    }

    var sqrt = Math.sqrt,
        min = Math.min, max = Math.max,
        abs = Math.abs, tvalues = [],
        bounds = [[], []],
        a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    b = 6 * x0 - 12 * x1 + 6 * x2;
    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
    c = 3 * x1 - 3 * x0;

    for (var i = 0; i < 2; ++i) {
      if (i > 0) {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (abs(a) < 1e-12) {
        if (abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      if (b2ac < 0) {
        continue;
      }
      sqrtb2ac = sqrt(b2ac);
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    var x, y, j = tvalues.length, jlen = j, mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
      bounds[0][j] = x;

      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
      bounds[1][j] = y;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    var result = [
      {
        x: min.apply(null, bounds[0]),
        y: min.apply(null, bounds[1])
      },
      {
        x: max.apply(null, bounds[0]),
        y: max.apply(null, bounds[1])
      }
    ];
    if (fabric.cachesBoundsOfCurve) {
      fabric.boundsOfCurveCache[argsString] = result;
    }
    return result;
  }

  /**
   * Converts arc to a bunch of bezier curves
   * @param {Number} fx starting point x
   * @param {Number} fy starting point y
   * @param {Array} coords Arc command
   */
  function fromArcToBeziers(fx, fy, coords) {
    var rx = coords[1],
        ry = coords[2],
        rot = coords[3],
        large = coords[4],
        sweep = coords[5],
        tx = coords[6],
        ty = coords[7],
        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segsNorm.length; i < len; i++) {
      segsNorm[i][1] += fx;
      segsNorm[i][2] += fy;
      segsNorm[i][3] += fx;
      segsNorm[i][4] += fy;
      segsNorm[i][5] += fx;
      segsNorm[i][6] += fy;
    }
    return segsNorm;
  };

  /**
   * This function take a parsed SVG path and make it simpler for fabricJS logic.
   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )
   * S converted in C, T converted in Q, A converted in C.
   * @param {Array} path the array of commands of a parsed svg path for fabric.Path
   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path
   */
  function makePathSimpler(path) {
    // x and y represent the last point of the path. the previous command point.
    // we add them to each relative command to make it an absolute comment.
    // we also swap the v V h H with L, because are easier to transform.
    var x = 0, y = 0, len = path.length,
        // x1 and y1 represent the last point of the subpath. the subpath is started with
        // m or M command. When a z or Z command is drawn, x and y need to be resetted to
        // the last x1 and y1.
        x1 = 0, y1 = 0, current, i, converted,
        // previous will host the letter of the previous command, to handle S and T.
        // controlX and controlY will host the previous reflected control point
        destinationPath = [], previous, controlX, controlY;
    for (i = 0; i < len; ++i) {
      converted = false;
      current = path[i].slice(0);
      switch (current[0]) { // first letter
        case 'l': // lineto, relative
          current[0] = 'L';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'L':
          x = current[1];
          y = current[2];
          break;
        case 'h': // horizontal lineto, relative
          current[1] += x;
          // falls through
        case 'H':
          current[0] = 'L';
          current[2] = y;
          x = current[1];
          break;
        case 'v': // vertical lineto, relative
          current[1] += y;
          // falls through
        case 'V':
          current[0] = 'L';
          y = current[1];
          current[1] = x;
          current[2] = y;
          break;
        case 'm': // moveTo, relative
          current[0] = 'M';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'M':
          x = current[1];
          y = current[2];
          x1 = current[1];
          y1 = current[2];
          break;
        case 'c': // bezierCurveTo, relative
          current[0] = 'C';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          current[5] += x;
          current[6] += y;
          // falls through
        case 'C':
          controlX = current[3];
          controlY = current[4];
          x = current[5];
          y = current[6];
          break;
        case 's': // shorthand cubic bezierCurveTo, relative
          current[0] = 'S';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          // falls through
        case 'S':
          // would be sScC but since we are swapping sSc for C, we check just that.
          if (previous === 'C') {
            // calculate reflection of previous control points
            controlX = 2 * x - controlX;
            controlY = 2 * y - controlY;
          }
          else {
            // If there is no previous command or if the previous command was not a C, c, S, or s,
            // the control point is coincident with the current point
            controlX = x;
            controlY = y;
          }
          x = current[3];
          y = current[4];
          current[0] = 'C';
          current[5] = current[3];
          current[6] = current[4];
          current[3] = current[1];
          current[4] = current[2];
          current[1] = controlX;
          current[2] = controlY;
          // current[3] and current[4] are NOW the second control point.
          // we keep it for the next reflection.
          controlX = current[3];
          controlY = current[4];
          break;
        case 'q': // quadraticCurveTo, relative
          current[0] = 'Q';
          current[1] += x;
          current[2] += y;
          current[3] += x;
          current[4] += y;
          // falls through
        case 'Q':
          controlX = current[1];
          controlY = current[2];
          x = current[3];
          y = current[4];
          break;
        case 't': // shorthand quadraticCurveTo, relative
          current[0] = 'T';
          current[1] += x;
          current[2] += y;
          // falls through
        case 'T':
          if (previous === 'Q') {
            // calculate reflection of previous control point
            controlX = 2 * x - controlX;
            controlY = 2 * y - controlY;
          }
          else {
            // If there is no previous command or if the previous command was not a Q, q, T or t,
            // assume the control point is coincident with the current point
            controlX = x;
            controlY = y;
          }
          current[0] = 'Q';
          x = current[1];
          y = current[2];
          current[1] = controlX;
          current[2] = controlY;
          current[3] = x;
          current[4] = y;
          break;
        case 'a':
          current[0] = 'A';
          current[6] += x;
          current[7] += y;
          // falls through
        case 'A':
          converted = true;
          destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));
          x = current[6];
          y = current[7];
          break;
        case 'z':
        case 'Z':
          x = x1;
          y = y1;
          break;
        default:
      }
      if (!converted) {
        destinationPath.push(current);
      }
      previous = current[0];
    }
    return destinationPath;
  };

  /**
   * Calc length from point x1,y1 to x2,y2
   * @param {Number} x1 starting point x
   * @param {Number} y1 starting point y
   * @param {Number} x2 starting point x
   * @param {Number} y2 starting point y
   * @return {Number} length of segment
   */
  function calcLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }

  // functions for the Cubic beizer
  // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350
  function CB1(t) {
    return t * t * t;
  }
  function CB2(t) {
    return 3 * t * t * (1 - t);
  }
  function CB3(t) {
    return 3 * t * (1 - t) * (1 - t);
  }
  function CB4(t) {
    return (1 - t) * (1 - t) * (1 - t);
  }

  function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    return function(pct) {
      var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);
      return {
        x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,
        y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4
      };
    };
  }

  function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    return function (pct) {
      var invT = 1 - pct,
          tangentX = (3 * invT * invT * (p2x - p1x)) + (6 * invT * pct * (p3x - p2x)) +
          (3 * pct * pct * (p4x - p3x)),
          tangentY = (3 * invT * invT * (p2y - p1y)) + (6 * invT * pct * (p3y - p2y)) +
          (3 * pct * pct * (p4y - p3y));
      return Math.atan2(tangentY, tangentX);
    };
  }

  function QB1(t) {
    return t * t;
  }

  function QB2(t) {
    return 2 * t * (1 - t);
  }

  function QB3(t) {
    return (1 - t) * (1 - t);
  }

  function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
    return function(pct) {
      var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);
      return {
        x: p3x * c1 + p2x * c2 + p1x * c3,
        y: p3y * c1 + p2y * c2 + p1y * c3
      };
    };
  }

  function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
    return function (pct) {
      var invT = 1 - pct,
          tangentX = (2 * invT * (p2x - p1x)) + (2 * pct * (p3x - p2x)),
          tangentY = (2 * invT * (p2y - p1y)) + (2 * pct * (p3y - p2y));
      return Math.atan2(tangentY, tangentX);
    };
  }


  // this will run over a path segment ( a cubic or quadratic segment) and approximate it
  // with 100 segemnts. This will good enough to calculate the length of the curve
  function pathIterator(iterator, x1, y1) {
    var tempP = { x: x1, y: y1 }, p, tmpLen = 0, perc;
    for (perc = 0.01; perc <= 1; perc += 0.01) {
      p = iterator(perc);
      tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);
      tempP = p;
    }
    return tmpLen;
  }

  /**
   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1
   * that correspond to that pixels run over the path.
   * The percentage will be then used to find the correct point on the canvas for the path.
   * @param {Array} segInfo fabricJS collection of information on a parsed path
   * @param {Number} distance from starting point, in pixels.
   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;
   */
  function findPercentageForDistance(segInfo, distance) {
    var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = { x: segInfo.x, y: segInfo.y },
        p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
    // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100
    // the path
    while (tmpLen < distance && perc <= 1 && nextStep > 0.0001) {
      p = iterator(perc);
      lastPerc = perc;
      nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);
      // compare tmpLen each cycle with distance, decide next perc to test.
      if ((nextLen + tmpLen) > distance) {
        // we discard this step and we make smaller steps.
        nextStep /= 2;
        perc -= nextStep;
      }
      else {
        tempP = p;
        perc += nextStep;
        tmpLen += nextLen;
      }
    }
    p.angle = angleFinder(lastPerc);
    return p;
  }

  /**
   * Run over a parsed and simplifed path and extrac some informations.
   * informations are length of each command and starting point
   * @param {Array} path fabricJS parsed path commands
   * @return {Array} path commands informations
   */
  function getPathSegmentsInfo(path) {
    var totalLength = 0, len = path.length, current,
        //x2 and y2 are the coords of segment start
        //x1 and y1 are the coords of the current point
        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;
    for (var i = 0; i < len; i++) {
      current = path[i];
      tempInfo = {
        x: x1,
        y: y1,
        command: current[0],
      };
      switch (current[0]) { //first letter
        case 'M':
          tempInfo.length = 0;
          x2 = x1 = current[1];
          y2 = y1 = current[2];
          break;
        case 'L':
          tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);
          x1 = current[1];
          y1 = current[2];
          break;
        case 'C':
          iterator = getPointOnCubicBezierIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4],
            current[5],
            current[6]
          );
          angleFinder = getTangentCubicIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4],
            current[5],
            current[6]
          );
          tempInfo.iterator = iterator;
          tempInfo.angleFinder = angleFinder;
          tempInfo.length = pathIterator(iterator, x1, y1);
          x1 = current[5];
          y1 = current[6];
          break;
        case 'Q':
          iterator = getPointOnQuadraticBezierIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4]
          );
          angleFinder = getTangentQuadraticIterator(
            x1,
            y1,
            current[1],
            current[2],
            current[3],
            current[4]
          );
          tempInfo.iterator = iterator;
          tempInfo.angleFinder = angleFinder;
          tempInfo.length = pathIterator(iterator, x1, y1);
          x1 = current[3];
          y1 = current[4];
          break;
        case 'Z':
        case 'z':
          // we add those in order to ease calculations later
          tempInfo.destX = x2;
          tempInfo.destY = y2;
          tempInfo.length = calcLineLength(x1, y1, x2, y2);
          x1 = x2;
          y1 = y2;
          break;
      }
      totalLength += tempInfo.length;
      info.push(tempInfo);
    }
    info.push({ length: totalLength, x: x1, y: y1 });
    return info;
  }

  function getPointOnPath(path, distance, infos) {
    if (!infos) {
      infos = getPathSegmentsInfo(path);
    }
    var i = 0;
    while ((distance - infos[i].length > 0) && i < (infos.length - 2)) {
      distance -= infos[i].length;
      i++;
    }
    // var distance = infos[infos.length - 1] * perc;
    var segInfo = infos[i], segPercent = distance / segInfo.length,
        command = segInfo.command, segment = path[i], info;

    switch (command) {
      case 'M':
        return { x: segInfo.x, y: segInfo.y, angle: 0 };
      case 'Z':
      case 'z':
        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
          new fabric.Point(segInfo.destX, segInfo.destY),
          segPercent
        );
        info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);
        return info;
      case 'L':
        info = new fabric.Point(segInfo.x, segInfo.y).lerp(
          new fabric.Point(segment[1], segment[2]),
          segPercent
        );
        info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);
        return info;
      case 'C':
        return findPercentageForDistance(segInfo, distance);
      case 'Q':
        return findPercentageForDistance(segInfo, distance);
    }
  }

  function parsePath(pathString) {
    var result = [],
        coords = [],
        currentPath,
        parsed,
        re = fabric.rePathCommand,
        rNumber = '[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*',
        rNumberCommaWsp = '(' + rNumber + ')' + fabric.commaWsp,
        rFlagCommaWsp = '([01])' + fabric.commaWsp + '?',
        rArcSeq = rNumberCommaWsp + '?' + rNumberCommaWsp + '?' + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp +
          rNumberCommaWsp + '?(' + rNumber + ')',
        regArcArgumentSequence = new RegExp(rArcSeq, 'g'),
        match,
        coordsStr,
        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
        path;
    if (!pathString || !pathString.match) {
      return result;
    }
    path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

    for (var i = 0, coordsParsed, len = path.length; i < len; i++) {
      currentPath = path[i];

      coordsStr = currentPath.slice(1).trim();
      coords.length = 0;

      var command = currentPath.charAt(0);
      coordsParsed = [command];

      if (command.toLowerCase() === 'a') {
        // arcs have special flags that apparently don't require spaces so handle special
        for (var args; (args = regArcArgumentSequence.exec(coordsStr));) {
          for (var j = 1; j < args.length; j++) {
            coords.push(args[j]);
          }
        }
      }
      else {
        while ((match = re.exec(coordsStr))) {
          coords.push(match[0]);
        }
      }

      for (var j = 0, jlen = coords.length; j < jlen; j++) {
        parsed = parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          coordsParsed.push(parsed);
        }
      }

      var commandLength = commandLengths[command.toLowerCase()],
          repeatedCommand = repeatedCommands[command] || command;

      if (coordsParsed.length - 1 > commandLength) {
        for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
          result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
          command = repeatedCommand;
        }
      }
      else {
        result.push(coordsParsed);
      }
    }

    return result;
  };

  /**
   * Calculate bounding box of a elliptic-arc
   * @deprecated
   * @param {Number} fx start point of arc
   * @param {Number} fy
   * @param {Number} rx horizontal radius
   * @param {Number} ry vertical radius
   * @param {Number} rot angle of horizontal axis
   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
   * @param {Number} tx end point of arc
   * @param {Number} ty
   */
  function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

    var fromX = 0, fromY = 0, bound, bounds = [],
        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segs.length; i < len; i++) {
      bound = getBoundsOfCurve(fromX, fromY, segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5], segs[i][6]);
      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
      fromX = segs[i][5];
      fromY = segs[i][6];
    }
    return bounds;
  };

  /**
   * Draws arc
   * @deprecated
   * @param {CanvasRenderingContext2D} ctx
   * @param {Number} fx
   * @param {Number} fy
   * @param {Array} coords coords of the arc, without the front 'A/a'
   */
  function drawArc(ctx, fx, fy, coords) {
    coords = coords.slice(0).unshift('X'); // command A or a does not matter
    var beziers = fromArcToBeziers(fx, fy, coords);
    beziers.forEach(function(bezier) {
      ctx.bezierCurveTo.apply(ctx, bezier.slice(1));
    });
  };

  fabric.util.parsePath = parsePath;
  fabric.util.makePathSimpler = makePathSimpler;
  fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;
  fabric.util.fromArcToBeziers = fromArcToBeziers;
  /**
   * Typo of `fromArcToBeziers` kept for not breaking the api once corrected.
   * Will be removed in fabric 5.0
   * @deprecated
   */
  fabric.util.fromArcToBeizers = fromArcToBeziers;
  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
  fabric.util.getPointOnPath = getPointOnPath;
  // kept because we do not want to make breaking changes.
  // but useless and deprecated.
  fabric.util.getBoundsOfArc = getBoundsOfArc;
  fabric.util.drawArc = drawArc;
})();


(function() {

  var slice = Array.prototype.slice;

  /**
   * Invokes method on all items in a given array
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} method Name of a method to invoke
   * @return {Array}
   */
  function invoke(array, method) {
    var args = slice.call(arguments, 2), result = [];
    for (var i = 0, len = array.length; i < len; i++) {
      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
    }
    return result;
  }

  /**
   * Finds maximum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function max(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 >= value2;
    });
  }

  /**
   * Finds minimum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function min(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 < value2;
    });
  }

  /**
   * @private
   */
  function fill(array, value) {
    var k = array.length;
    while (k--) {
      array[k] = value;
    }
    return array;
  }

  /**
   * @private
   */
  function find(array, byProperty, condition) {
    if (!array || array.length === 0) {
      return;
    }

    var i = array.length - 1,
        result = byProperty ? array[i][byProperty] : array[i];
    if (byProperty) {
      while (i--) {
        if (condition(array[i][byProperty], result)) {
          result = array[i][byProperty];
        }
      }
    }
    else {
      while (i--) {
        if (condition(array[i], result)) {
          result = array[i];
        }
      }
    }
    return result;
  }

  /**
   * @namespace fabric.util.array
   */
  fabric.util.array = {
    fill: fill,
    invoke: invoke,
    min: min,
    max: max
  };

})();


(function() {
  /**
   * Copies all enumerable properties of one js object to another
   * this does not and cannot compete with generic utils.
   * Does not clone or extend fabric.Object subclasses.
   * This is mostly for internal use and has extra handling for fabricJS objects
   * it skips the canvas and group properties in deep cloning.
   * @memberOf fabric.util.object
   * @param {Object} destination Where to copy to
   * @param {Object} source Where to copy from
   * @return {Object}
   */

  function extend(destination, source, deep) {
    // JScript DontEnum bug is not taken care of
    // the deep clone is for internal use, is not meant to avoid
    // javascript traps or cloning html element or self referenced objects.
    if (deep) {
      if (!fabric.isLikelyNode && source instanceof Element) {
        // avoid cloning deep images, canvases,
        destination = source;
      }
      else if (source instanceof Array) {
        destination = [];
        for (var i = 0, len = source.length; i < len; i++) {
          destination[i] = extend({ }, source[i], deep);
        }
      }
      else if (source && typeof source === 'object') {
        for (var property in source) {
          if (property === 'canvas' || property === 'group') {
            // we do not want to clone this props at all.
            // we want to keep the keys in the copy
            destination[property] = null;
          }
          else if (source.hasOwnProperty(property)) {
            destination[property] = extend({ }, source[property], deep);
          }
        }
      }
      else {
        // this sounds odd for an extend but is ok for recursive use
        destination = source;
      }
    }
    else {
      for (var property in source) {
        destination[property] = source[property];
      }
    }
    return destination;
  }

  /**
   * Creates an empty object and copies all enumerable properties of another object to it
   * @memberOf fabric.util.object
   * TODO: this function return an empty object if you try to clone null
   * @param {Object} object Object to clone
   * @return {Object}
   */
  function clone(object, deep) {
    return extend({ }, object, deep);
  }

  /** @namespace fabric.util.object */
  fabric.util.object = {
    extend: extend,
    clone: clone
  };
  fabric.util.object.extend(fabric.util, fabric.Observable);
})();


(function() {

  /**
   * Camelizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to camelize
   * @return {String} Camelized version of a string
   */
  function camelize(string) {
    return string.replace(/-+(.)?/g, function(match, character) {
      return character ? character.toUpperCase() : '';
    });
  }

  /**
   * Capitalizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to capitalize
   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
   * and other letters stay untouched, if false first letter is capitalized
   * and other letters are converted to lowercase.
   * @return {String} Capitalized version of a string
   */
  function capitalize(string, firstLetterOnly) {
    return string.charAt(0).toUpperCase() +
      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
  }

  /**
   * Escapes XML in a string
   * @memberOf fabric.util.string
   * @param {String} string String to escape
   * @return {String} Escaped version of a string
   */
  function escapeXml(string) {
    return string.replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  /**
   * Divide a string in the user perceived single units
   * @memberOf fabric.util.string
   * @param {String} textstring String to escape
   * @return {Array} array containing the graphemes
   */
  function graphemeSplit(textstring) {
    var i = 0, chr, graphemes = [];
    for (i = 0, chr; i < textstring.length; i++) {
      if ((chr = getWholeChar(textstring, i)) === false) {
        continue;
      }
      graphemes.push(chr);
    }
    return graphemes;
  }

  // taken from mdn in the charAt doc page.
  function getWholeChar(str, i) {
    var code = str.charCodeAt(i);

    if (isNaN(code)) {
      return ''; // Position not found
    }
    if (code < 0xD800 || code > 0xDFFF) {
      return str.charAt(i);
    }

    // High surrogate (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 <= code && code <= 0xDBFF) {
      if (str.length <= (i + 1)) {
        throw 'High surrogate without following low surrogate';
      }
      var next = str.charCodeAt(i + 1);
      if (0xDC00 > next || next > 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return str.charAt(i) + str.charAt(i + 1);
    }
    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
    if (i === 0) {
      throw 'Low surrogate without preceding high surrogate';
    }
    var prev = str.charCodeAt(i - 1);

    // (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 > prev || prev > 0xDBFF) {
      throw 'Low surrogate without preceding high surrogate';
    }
    // We can pass over low surrogates now as the second component
    // in a pair which we have already processed
    return false;
  }


  /**
   * String utilities
   * @namespace fabric.util.string
   */
  fabric.util.string = {
    camelize: camelize,
    capitalize: capitalize,
    escapeXml: escapeXml,
    graphemeSplit: graphemeSplit
  };
})();


(function() {

  var slice = Array.prototype.slice, emptyFunction = function() { },

      IS_DONTENUM_BUGGY = (function() {
        for (var p in { toString: 1 }) {
          if (p === 'toString') {
            return false;
          }
        }
        return true;
      })(),

      /** @ignore */
      addMethods = function(klass, source, parent) {
        for (var property in source) {

          if (property in klass.prototype &&
              typeof klass.prototype[property] === 'function' &&
              (source[property] + '').indexOf('callSuper') > -1) {

            klass.prototype[property] = (function(property) {
              return function() {

                var superclass = this.constructor.superclass;
                this.constructor.superclass = parent;
                var returnValue = source[property].apply(this, arguments);
                this.constructor.superclass = superclass;

                if (property !== 'initialize') {
                  return returnValue;
                }
              };
            })(property);
          }
          else {
            klass.prototype[property] = source[property];
          }

          if (IS_DONTENUM_BUGGY) {
            if (source.toString !== Object.prototype.toString) {
              klass.prototype.toString = source.toString;
            }
            if (source.valueOf !== Object.prototype.valueOf) {
              klass.prototype.valueOf = source.valueOf;
            }
          }
        }
      };

  function Subclass() { }

  function callSuper(methodName) {
    var parentMethod = null,
        _this = this;

    // climb prototype chain to find method not equal to callee's method
    while (_this.constructor.superclass) {
      var superClassMethod = _this.constructor.superclass.prototype[methodName];
      if (_this[methodName] !== superClassMethod) {
        parentMethod = superClassMethod;
        break;
      }
      // eslint-disable-next-line
      _this = _this.constructor.superclass.prototype;
    }

    if (!parentMethod) {
      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
    }

    return (arguments.length > 1)
      ? parentMethod.apply(this, slice.call(arguments, 1))
      : parentMethod.call(this);
  }

  /**
   * Helper for creation of "classes".
   * @memberOf fabric.util
   * @param {Function} [parent] optional "Class" to inherit from
   * @param {Object} [properties] Properties shared by all instances of this class
   *                  (be careful modifying objects defined here as this would affect all instances)
   */
  function createClass() {
    var parent = null,
        properties = slice.call(arguments, 0);

    if (typeof properties[0] === 'function') {
      parent = properties.shift();
    }
    function klass() {
      this.initialize.apply(this, arguments);
    }

    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      Subclass.prototype = parent.prototype;
      klass.prototype = new Subclass();
      parent.subclasses.push(klass);
    }
    for (var i = 0, length = properties.length; i < length; i++) {
      addMethods(klass, properties[i], parent);
    }
    if (!klass.prototype.initialize) {
      klass.prototype.initialize = emptyFunction;
    }
    klass.prototype.constructor = klass;
    klass.prototype.callSuper = callSuper;
    return klass;
  }

  fabric.util.createClass = createClass;
})();


(function () {
  // since ie11 can use addEventListener but they do not support options, i need to check
  var couldUseAttachEvent = !!fabric.document.createElement('div').attachEvent,
      touchEvents = ['touchstart', 'touchmove', 'touchend'];
  /**
   * Adds an event listener to an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.addListener = function(element, eventName, handler, options) {
    element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
  };

  /**
   * Removes an event listener from an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.removeListener = function(element, eventName, handler, options) {
    element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
  };

  function getTouchInfo(event) {
    var touchProp = event.changedTouches;
    if (touchProp && touchProp[0]) {
      return touchProp[0];
    }
    return event;
  }

  fabric.util.getPointer = function(event) {
    var element = event.target,
        scroll = fabric.util.getScrollLeftTop(element),
        _evt = getTouchInfo(event);
    return {
      x: _evt.clientX + scroll.left,
      y: _evt.clientY + scroll.top
    };
  };

  fabric.util.isTouchEvent = function(event) {
    return touchEvents.indexOf(event.type) > -1 || event.pointerType === 'touch';
  };
})();


(function () {

  /**
   * Cross-browser wrapper for setting element's style
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {Object} styles
   * @return {HTMLElement} Element that was passed as a first argument
   */
  function setStyle(element, styles) {
    var elementStyle = element.style;
    if (!elementStyle) {
      return element;
    }
    if (typeof styles === 'string') {
      element.style.cssText += ';' + styles;
      return styles.indexOf('opacity') > -1
        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
        : element;
    }
    for (var property in styles) {
      if (property === 'opacity') {
        setOpacity(element, styles[property]);
      }
      else {
        var normalizedProperty = (property === 'float' || property === 'cssFloat')
          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
          : property;
        elementStyle[normalizedProperty] = styles[property];
      }
    }
    return element;
  }

  var parseEl = fabric.document.createElement('div'),
      supportsOpacity = typeof parseEl.style.opacity === 'string',
      supportsFilters = typeof parseEl.style.filter === 'string',
      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

      /** @ignore */
      setOpacity = function (element) { return element; };

  if (supportsOpacity) {
    /** @ignore */
    setOpacity = function(element, value) {
      element.style.opacity = value;
      return element;
    };
  }
  else if (supportsFilters) {
    /** @ignore */
    setOpacity = function(element, value) {
      var es = element.style;
      if (element.currentStyle && !element.currentStyle.hasLayout) {
        es.zoom = 1;
      }
      if (reOpacity.test(es.filter)) {
        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
        es.filter = es.filter.replace(reOpacity, value);
      }
      else {
        es.filter += ' alpha(opacity=' + (value * 100) + ')';
      }
      return element;
    };
  }

  fabric.util.setStyle = setStyle;

})();


(function() {

  var _slice = Array.prototype.slice;

  /**
   * Takes id and returns an element with that id (if one exists in a document)
   * @memberOf fabric.util
   * @param {String|HTMLElement} id
   * @return {HTMLElement|null}
   */
  function getById(id) {
    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
  }

  var sliceCanConvertNodelists,
      /**
       * Converts an array-like object (e.g. arguments or NodeList) to an array
       * @memberOf fabric.util
       * @param {Object} arrayLike
       * @return {Array}
       */
      toArray = function(arrayLike) {
        return _slice.call(arrayLike, 0);
      };

  try {
    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
  }
  catch (err) { }

  if (!sliceCanConvertNodelists) {
    toArray = function(arrayLike) {
      var arr = new Array(arrayLike.length), i = arrayLike.length;
      while (i--) {
        arr[i] = arrayLike[i];
      }
      return arr;
    };
  }

  /**
   * Creates specified element with specified attributes
   * @memberOf fabric.util
   * @param {String} tagName Type of an element to create
   * @param {Object} [attributes] Attributes to set on an element
   * @return {HTMLElement} Newly created element
   */
  function makeElement(tagName, attributes) {
    var el = fabric.document.createElement(tagName);
    for (var prop in attributes) {
      if (prop === 'class') {
        el.className = attributes[prop];
      }
      else if (prop === 'for') {
        el.htmlFor = attributes[prop];
      }
      else {
        el.setAttribute(prop, attributes[prop]);
      }
    }
    return el;
  }

  /**
   * Adds class to an element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to add class to
   * @param {String} className Class to add to an element
   */
  function addClass(element, className) {
    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
      element.className += (element.className ? ' ' : '') + className;
    }
  }

  /**
   * Wraps element with another element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to wrap
   * @param {HTMLElement|String} wrapper Element to wrap with
   * @param {Object} [attributes] Attributes to set on a wrapper
   * @return {HTMLElement} wrapper
   */
  function wrapElement(element, wrapper, attributes) {
    if (typeof wrapper === 'string') {
      wrapper = makeElement(wrapper, attributes);
    }
    if (element.parentNode) {
      element.parentNode.replaceChild(wrapper, element);
    }
    wrapper.appendChild(element);
    return wrapper;
  }

  /**
   * Returns element scroll offsets
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to operate on
   * @return {Object} Object with left/top values
   */
  function getScrollLeftTop(element) {

    var left = 0,
        top = 0,
        docElement = fabric.document.documentElement,
        body = fabric.document.body || {
          scrollLeft: 0, scrollTop: 0
        };

    // While loop checks (and then sets element to) .parentNode OR .host
    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
    //  but the .parentNode of a root ShadowDOM node will always be null, instead
    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
    while (element && (element.parentNode || element.host)) {

      // Set element to element parent, or 'host' in case of ShadowDOM
      element = element.parentNode || element.host;

      if (element === fabric.document) {
        left = body.scrollLeft || docElement.scrollLeft || 0;
        top = body.scrollTop ||  docElement.scrollTop || 0;
      }
      else {
        left += element.scrollLeft || 0;
        top += element.scrollTop || 0;
      }

      if (element.nodeType === 1 && element.style.position === 'fixed') {
        break;
      }
    }

    return { left: left, top: top };
  }

  /**
   * Returns offset for a given element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get offset for
   * @return {Object} Object with "left" and "top" properties
   */
  function getElementOffset(element) {
    var docElem,
        doc = element && element.ownerDocument,
        box = { left: 0, top: 0 },
        offset = { left: 0, top: 0 },
        scrollLeftTop,
        offsetAttributes = {
          borderLeftWidth: 'left',
          borderTopWidth:  'top',
          paddingLeft:     'left',
          paddingTop:      'top'
        };

    if (!doc) {
      return offset;
    }

    for (var attr in offsetAttributes) {
      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
    }

    docElem = doc.documentElement;
    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
      box = element.getBoundingClientRect();
    }

    scrollLeftTop = getScrollLeftTop(element);

    return {
      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
    };
  }

  /**
   * Returns style attribute value of a given element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get style attribute for
   * @param {String} attr Style attribute to get for element
   * @return {String} Style attribute value of the given element.
   */
  var getElementStyle;
  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
    getElementStyle = function(element, attr) {
      var style = fabric.document.defaultView.getComputedStyle(element, null);
      return style ? style[attr] : undefined;
    };
  }
  else {
    getElementStyle = function(element, attr) {
      var value = element.style[attr];
      if (!value && element.currentStyle) {
        value = element.currentStyle[attr];
      }
      return value;
    };
  }

  (function () {
    var style = fabric.document.documentElement.style,
        selectProp = 'userSelect' in style
          ? 'userSelect'
          : 'MozUserSelect' in style
            ? 'MozUserSelect'
            : 'WebkitUserSelect' in style
              ? 'WebkitUserSelect'
              : 'KhtmlUserSelect' in style
                ? 'KhtmlUserSelect'
                : '';

    /**
     * Makes element unselectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make unselectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementUnselectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = fabric.util.falseFunction;
      }
      if (selectProp) {
        element.style[selectProp] = 'none';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = 'on';
      }
      return element;
    }

    /**
     * Makes element selectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make selectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementSelectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = null;
      }
      if (selectProp) {
        element.style[selectProp] = '';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = '';
      }
      return element;
    }

    fabric.util.makeElementUnselectable = makeElementUnselectable;
    fabric.util.makeElementSelectable = makeElementSelectable;
  })();

  function getNodeCanvas(element) {
    var impl = fabric.jsdomImplForWrapper(element);
    return impl._canvas || impl._image;
  };

  function cleanUpJsdomNode(element) {
    if (!fabric.isLikelyNode) {
      return;
    }
    var impl = fabric.jsdomImplForWrapper(element);
    if (impl) {
      impl._image = null;
      impl._canvas = null;
      // unsure if necessary
      impl._currentSrc = null;
      impl._attributes = null;
      impl._classList = null;
    }
  }

  function setImageSmoothing(ctx, value) {
    ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
      || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
    ctx.imageSmoothingEnabled = value;
  }

  /**
   * setImageSmoothing sets the context imageSmoothingEnabled property.
   * Used by canvas and by ImageObject.
   * @memberOf fabric.util
   * @since 4.0.0
   * @param {HTMLRenderingContext2D} ctx to set on
   * @param {Boolean} value true or false
   */
  fabric.util.setImageSmoothing = setImageSmoothing;
  fabric.util.getById = getById;
  fabric.util.toArray = toArray;
  fabric.util.addClass = addClass;
  fabric.util.makeElement = makeElement;
  fabric.util.wrapElement = wrapElement;
  fabric.util.getScrollLeftTop = getScrollLeftTop;
  fabric.util.getElementOffset = getElementOffset;
  fabric.util.getNodeCanvas = getNodeCanvas;
  fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;

})();


(function() {

  function addParamToUrl(url, param) {
    return url + (/\?/.test(url) ? '&' : '?') + param;
  }

  function emptyFn() { }

  /**
   * Cross-browser abstraction for sending XMLHttpRequest
   * @memberOf fabric.util
   * @param {String} url URL to send XMLHttpRequest to
   * @param {Object} [options] Options object
   * @param {String} [options.method="GET"]
   * @param {String} [options.parameters] parameters to append to url in GET or in body
   * @param {String} [options.body] body to send with POST or PUT request
   * @param {Function} options.onComplete Callback to invoke when request is completed
   * @return {XMLHttpRequest} request
   */
  function request(url, options) {
    options || (options = { });

    var method = options.method ? options.method.toUpperCase() : 'GET',
        onComplete = options.onComplete || function() { },
        xhr = new fabric.window.XMLHttpRequest(),
        body = options.body || options.parameters;

    /** @ignore */
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        onComplete(xhr);
        xhr.onreadystatechange = emptyFn;
      }
    };

    if (method === 'GET') {
      body = null;
      if (typeof options.parameters === 'string') {
        url = addParamToUrl(url, options.parameters);
      }
    }

    xhr.open(method, url, true);

    if (method === 'POST' || method === 'PUT') {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    xhr.send(body);
    return xhr;
  }

  fabric.util.request = request;
})();


/**
 * Wrapper around `console.log` (when available)
 * @param {*} [values] Values to log
 */
fabric.log = console.log;

/**
 * Wrapper around `console.warn` (when available)
 * @param {*} [values] Values to log as a warning
 */
fabric.warn = console.warn;


(function() {

  function noop() {
    return false;
  }

  function defaultEasing(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Number} [options.startValue=0] Starting value
   * @param {Number} [options.endValue=100] Ending value
   * @param {Number} [options.byValue=100] Value to modify the property by
   * @param {Function} [options.easing] Easing function
   * @param {Number} [options.duration=500] Duration of change (in ms)
   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
   */
  function animate(options) {

    requestAnimFrame(function(timestamp) {
      options || (options = { });

      var start = timestamp || +new Date(),
          duration = options.duration || 500,
          finish = start + duration, time,
          onChange = options.onChange || noop,
          abort = options.abort || noop,
          onComplete = options.onComplete || noop,
          easing = options.easing || defaultEasing,
          startValue = 'startValue' in options ? options.startValue : 0,
          endValue = 'endValue' in options ? options.endValue : 100,
          byValue = options.byValue || endValue - startValue;

      options.onStart && options.onStart();

      (function tick(ticktime) {
        // TODO: move abort call after calculation
        // and pass (current,valuePerc, timePerc) as arguments
        time = ticktime || +new Date();
        var currentTime = time > finish ? duration : (time - start),
            timePerc = currentTime / duration,
            current = easing(currentTime, startValue, byValue, duration),
            valuePerc = Math.abs((current - startValue) / byValue);
        if (abort()) {
          onComplete(endValue, 1, 1);
          return;
        }
        if (time > finish) {
          onChange(endValue, 1, 1);
          onComplete(endValue, 1, 1);
          return;
        }
        else {
          onChange(current, valuePerc, timePerc);
          requestAnimFrame(tick);
        }
      })(start);
    });
  }

  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                          fabric.window.webkitRequestAnimationFrame ||
                          fabric.window.mozRequestAnimationFrame    ||
                          fabric.window.oRequestAnimationFrame      ||
                          fabric.window.msRequestAnimationFrame     ||
                          function(callback) {
                            return fabric.window.setTimeout(callback, 1000 / 60);
                          };

  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

  /**
   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
   * @memberOf fabric.util
   * @param {Function} callback Callback to invoke
   * @param {DOMElement} element optional Element to associate with animation
   */
  function requestAnimFrame() {
    return _requestAnimFrame.apply(fabric.window, arguments);
  }

  function cancelAnimFrame() {
    return _cancelAnimFrame.apply(fabric.window, arguments);
  }

  fabric.util.animate = animate;
  fabric.util.requestAnimFrame = requestAnimFrame;
  fabric.util.cancelAnimFrame = cancelAnimFrame;
})();


(function() {
  // Calculate an in-between color. Returns a "rgba()" string.
  // Credit: Edwin Martin <edwin@bitstorm.org>
  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
  function calculateColor(begin, end, pos) {
    var color = 'rgba('
        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
    color += ')';
    return color;
  }

  /**
   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {String} fromColor The starting color in hex or rgb(a) format.
   * @param {String} toColor The starting color in hex or rgb(a) format.
   * @param {Number} [duration] Duration of change (in ms).
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.
   */
  function animateColor(fromColor, toColor, duration, options) {
    var startColor = new fabric.Color(fromColor).getSource(),
        endColor = new fabric.Color(toColor).getSource(),
        originalOnComplete = options.onComplete,
        originalOnChange = options.onChange;
    options = options || {};

    fabric.util.animate(fabric.util.object.extend(options, {
      duration: duration || 500,
      startValue: startColor,
      endValue: endColor,
      byValue: endColor,
      easing: function (currentTime, startValue, byValue, duration) {
        var posValue = options.colorEasing
          ? options.colorEasing(currentTime, duration)
          : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
        return calculateColor(startValue, byValue, posValue);
      },
      // has to take in account for color restoring;
      onComplete: function(current, valuePerc, timePerc) {
        if (originalOnComplete) {
          return originalOnComplete(
            calculateColor(endColor, endColor, 0),
            valuePerc,
            timePerc
          );
        }
      },
      onChange: function(current, valuePerc, timePerc) {
        if (originalOnChange) {
          if (Array.isArray(current)) {
            return originalOnChange(
              calculateColor(current, current, 0),
              valuePerc,
              timePerc
            );
          }
          originalOnChange(current, valuePerc, timePerc);
        }
      }
    }));
  }

  fabric.util.animateColor = animateColor;

})();


(function() {

  function normalize(a, c, p, s) {
    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    }
    else {
      //handle the 0/0 case:
      if (c === 0 && a === 0) {
        s = p / (2 * Math.PI) * Math.asin(1);
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
    }
    return { a: a, c: c, p: p, s: s };
  }

  function elastic(opts, t, d) {
    return opts.a *
      Math.pow(2, 10 * (t -= 1)) *
      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
  }

  /**
   * Cubic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }

  /**
   * Cubic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCubic(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }

  /**
   * Quartic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuart(t, b, c, d) {
    return c * (t /= d) * t * t * t + b;
  }

  /**
   * Quartic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuart(t, b, c, d) {
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  }

  /**
   * Quartic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuart(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t + b;
    }
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }

  /**
   * Quintic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuint(t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  }

  /**
   * Quintic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuint(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  }

  /**
   * Quintic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuint(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }

  /**
   * Sinusoidal easing in
   * @memberOf fabric.util.ease
   */
  function easeInSine(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Sinusoidal easing out
   * @memberOf fabric.util.ease
   */
  function easeOutSine(t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
  }

  /**
   * Sinusoidal easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutSine(t, b, c, d) {
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
  }

  /**
   * Exponential easing in
   * @memberOf fabric.util.ease
   */
  function easeInExpo(t, b, c, d) {
    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
  }

  /**
   * Exponential easing out
   * @memberOf fabric.util.ease
   */
  function easeOutExpo(t, b, c, d) {
    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  }

  /**
   * Exponential easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutExpo(t, b, c, d) {
    if (t === 0) {
      return b;
    }
    if (t === d) {
      return b + c;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
    }
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }

  /**
   * Circular easing in
   * @memberOf fabric.util.ease
   */
  function easeInCirc(t, b, c, d) {
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
  }

  /**
   * Circular easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCirc(t, b, c, d) {
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
  }

  /**
   * Circular easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCirc(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
    }
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }

  /**
   * Elastic easing in
   * @memberOf fabric.util.ease
   */
  function easeInElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return -elastic(opts, t, d) + b;
  }

  /**
   * Elastic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
  }

  /**
   * Elastic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d / 2;
    if (t === 2) {
      return b + c;
    }
    if (!p) {
      p = d * (0.3 * 1.5);
    }
    var opts = normalize(a, c, p, s);
    if (t < 1) {
      return -0.5 * elastic(opts, t, d) + b;
    }
    return opts.a * Math.pow(2, -10 * (t -= 1)) *
      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
  }

  /**
   * Backwards easing in
   * @memberOf fabric.util.ease
   */
  function easeInBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  }

  /**
   * Backwards easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  }

  /**
   * Backwards easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
    }
    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
  }

  /**
   * Bouncing easing in
   * @memberOf fabric.util.ease
   */
  function easeInBounce(t, b, c, d) {
    return c - easeOutBounce (d - t, 0, c, d) + b;
  }

  /**
   * Bouncing easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBounce(t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
      return c * (7.5625 * t * t) + b;
    }
    else if (t < (2 / 2.75)) {
      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
    }
    else if (t < (2.5 / 2.75)) {
      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
    }
    else {
      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    }
  }

  /**
   * Bouncing easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBounce(t, b, c, d) {
    if (t < d / 2) {
      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
    }
    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  }

  /**
   * Easing functions
   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
   * @namespace fabric.util.ease
   */
  fabric.util.ease = {

    /**
     * Quadratic easing in
     * @memberOf fabric.util.ease
     */
    easeInQuad: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },

    /**
     * Quadratic easing out
     * @memberOf fabric.util.ease
     */
    easeOutQuad: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },

    /**
     * Quadratic easing in and out
     * @memberOf fabric.util.ease
     */
    easeInOutQuad: function(t, b, c, d) {
      t /= (d / 2);
      if (t < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },

    /**
     * Cubic easing in
     * @memberOf fabric.util.ease
     */
    easeInCubic: function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    },

    easeOutCubic: easeOutCubic,
    easeInOutCubic: easeInOutCubic,
    easeInQuart: easeInQuart,
    easeOutQuart: easeOutQuart,
    easeInOutQuart: easeInOutQuart,
    easeInQuint: easeInQuint,
    easeOutQuint: easeOutQuint,
    easeInOutQuint: easeInOutQuint,
    easeInSine: easeInSine,
    easeOutSine: easeOutSine,
    easeInOutSine: easeInOutSine,
    easeInExpo: easeInExpo,
    easeOutExpo: easeOutExpo,
    easeInOutExpo: easeInOutExpo,
    easeInCirc: easeInCirc,
    easeOutCirc: easeOutCirc,
    easeInOutCirc: easeInOutCirc,
    easeInElastic: easeInElastic,
    easeOutElastic: easeOutElastic,
    easeInOutElastic: easeInOutElastic,
    easeInBack: easeInBack,
    easeOutBack: easeOutBack,
    easeInOutBack: easeInOutBack,
    easeInBounce: easeInBounce,
    easeOutBounce: easeOutBounce,
    easeInOutBounce: easeInOutBounce
  };

})();


(function(global) {

  'use strict';

  /**
   * @name fabric
   * @namespace
   */

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      parseUnit = fabric.util.parseUnit,
      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

      svgValidTagNames = ['path', 'circle', 'polygon', 'polyline', 'ellipse', 'rect', 'line',
        'image', 'text'],
      svgViewBoxElements = ['symbol', 'image', 'marker', 'pattern', 'view', 'svg'],
      svgInvalidAncestors = ['pattern', 'defs', 'symbol', 'metadata', 'clipPath', 'mask', 'desc'],
      svgValidParents = ['symbol', 'g', 'a', 'svg', 'clipPath', 'defs'],

      attributesMap = {
        cx:                   'left',
        x:                    'left',
        r:                    'radius',
        cy:                   'top',
        y:                    'top',
        display:              'visible',
        visibility:           'visible',
        transform:            'transformMatrix',
        'fill-opacity':       'fillOpacity',
        'fill-rule':          'fillRule',
        'font-family':        'fontFamily',
        'font-size':          'fontSize',
        'font-style':         'fontStyle',
        'font-weight':        'fontWeight',
        'letter-spacing':     'charSpacing',
        'paint-order':        'paintFirst',
        'stroke-dasharray':   'strokeDashArray',
        'stroke-dashoffset':  'strokeDashOffset',
        'stroke-linecap':     'strokeLineCap',
        'stroke-linejoin':    'strokeLineJoin',
        'stroke-miterlimit':  'strokeMiterLimit',
        'stroke-opacity':     'strokeOpacity',
        'stroke-width':       'strokeWidth',
        'text-decoration':    'textDecoration',
        'text-anchor':        'textAnchor',
        opacity:              'opacity',
        'clip-path':          'clipPath',
        'clip-rule':          'clipRule',
        'vector-effect':      'strokeUniform',
        'image-rendering':    'imageSmoothing',
      },

      colorAttributes = {
        stroke: 'strokeOpacity',
        fill:   'fillOpacity'
      },

      fSize = 'font-size', cPath = 'clip-path';

  fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
  fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
  fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
  fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);

  fabric.cssRules = { };
  fabric.gradientDefs = { };
  fabric.clipPaths = { };

  function normalizeAttr(attr) {
    // transform attribute names
    if (attr in attributesMap) {
      return attributesMap[attr];
    }
    return attr;
  }

  function normalizeValue(attr, value, parentAttributes, fontSize) {
    var isArray = Object.prototype.toString.call(value) === '[object Array]',
        parsed;

    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
      value = '';
    }
    else if (attr === 'strokeUniform') {
      return (value === 'non-scaling-stroke');
    }
    else if (attr === 'strokeDashArray') {
      if (value === 'none') {
        value = null;
      }
      else {
        value = value.replace(/,/g, ' ').split(/\s+/).map(parseFloat);
      }
    }
    else if (attr === 'transformMatrix') {
      if (parentAttributes && parentAttributes.transformMatrix) {
        value = multiplyTransformMatrices(
          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
      }
      else {
        value = fabric.parseTransformAttribute(value);
      }
    }
    else if (attr === 'visible') {
      value = value !== 'none' && value !== 'hidden';
      // display=none on parent element always takes precedence over child element
      if (parentAttributes && parentAttributes.visible === false) {
        value = false;
      }
    }
    else if (attr === 'opacity') {
      value = parseFloat(value);
      if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
        value *= parentAttributes.opacity;
      }
    }
    else if (attr === 'textAnchor' /* text-anchor */) {
      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
    }
    else if (attr === 'charSpacing') {
      // parseUnit returns px and we convert it to em
      parsed = parseUnit(value, fontSize) / fontSize * 1000;
    }
    else if (attr === 'paintFirst') {
      var fillIndex = value.indexOf('fill');
      var strokeIndex = value.indexOf('stroke');
      var value = 'fill';
      if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
        value = 'stroke';
      }
      else if (fillIndex === -1 && strokeIndex > -1) {
        value = 'stroke';
      }
    }
    else if (attr === 'href' || attr === 'xlink:href' || attr === 'font') {
      return value;
    }
    else if (attr === 'imageSmoothing') {
      return (value === 'optimizeQuality');
    }
    else {
      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
    }

    return (!isArray && isNaN(parsed) ? value : parsed);
  }

  /**
    * @private
    */
  function getSvgRegex(arr) {
    return new RegExp('^(' + arr.join('|') + ')\\b', 'i');
  }

  /**
   * @private
   * @param {Object} attributes Array of attributes to parse
   */
  function _setStrokeFillOpacity(attributes) {
    for (var attr in colorAttributes) {

      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
        continue;
      }

      if (typeof attributes[attr] === 'undefined') {
        if (!fabric.Object.prototype[attr]) {
          continue;
        }
        attributes[attr] = fabric.Object.prototype[attr];
      }

      if (attributes[attr].indexOf('url(') === 0) {
        continue;
      }

      var color = new fabric.Color(attributes[attr]);
      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
    }
    return attributes;
  }

  /**
   * @private
   */
  function _getMultipleNodes(doc, nodeNames) {
    var nodeName, nodeArray = [], nodeList, i, len;
    for (i = 0, len = nodeNames.length; i < len; i++) {
      nodeName = nodeNames[i];
      nodeList = doc.getElementsByTagName(nodeName);
      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
    }
    return nodeArray;
  }

  /**
   * Parses "transform" attribute, returning an array of values
   * @static
   * @function
   * @memberOf fabric
   * @param {String} attributeValue String containing attribute value
   * @return {Array} Array of 6 elements representing transformation matrix
   */
  fabric.parseTransformAttribute = (function() {
    function rotateMatrix(matrix, args) {
      var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]),
          x = 0, y = 0;
      if (args.length === 3) {
        x = args[1];
        y = args[2];
      }

      matrix[0] = cos;
      matrix[1] = sin;
      matrix[2] = -sin;
      matrix[3] = cos;
      matrix[4] = x - (cos * x - sin * y);
      matrix[5] = y - (sin * x + cos * y);
    }

    function scaleMatrix(matrix, args) {
      var multiplierX = args[0],
          multiplierY = (args.length === 2) ? args[1] : args[0];

      matrix[0] = multiplierX;
      matrix[3] = multiplierY;
    }

    function skewMatrix(matrix, args, pos) {
      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
    }

    function translateMatrix(matrix, args) {
      matrix[4] = args[0];
      if (args.length === 2) {
        matrix[5] = args[1];
      }
    }

    // identity matrix
    var iMatrix = fabric.iMatrix,

        // == begin transform regexp
        number = fabric.reNum,

        commaWsp = fabric.commaWsp,

        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + ')' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        matrix = '(?:(matrix)\\s*\\(\\s*' +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' +
                  '\\s*\\))',

        transform = '(?:' +
                    matrix + '|' +
                    translate + '|' +
                    scale + '|' +
                    rotate + '|' +
                    skewX + '|' +
                    skewY +
                    ')',

        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

        transformList = '^\\s*(?:' + transforms + '?)\\s*$',

        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
        reTransformList = new RegExp(transformList),
        // == end transform regexp

        reTransform = new RegExp(transform, 'g');

    return function(attributeValue) {

      // start with identity matrix
      var matrix = iMatrix.concat(),
          matrices = [];

      // return if no argument was given or
      // an argument does not match transform attribute regexp
      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
        return matrix;
      }

      attributeValue.replace(reTransform, function(match) {

        var m = new RegExp(transform).exec(match).filter(function (match) {
              // match !== '' && match != null
              return (!!match);
            }),
            operation = m[1],
            args = m.slice(2).map(parseFloat);

        switch (operation) {
          case 'translate':
            translateMatrix(matrix, args);
            break;
          case 'rotate':
            args[0] = fabric.util.degreesToRadians(args[0]);
            rotateMatrix(matrix, args);
            break;
          case 'scale':
            scaleMatrix(matrix, args);
            break;
          case 'skewX':
            skewMatrix(matrix, args, 2);
            break;
          case 'skewY':
            skewMatrix(matrix, args, 1);
            break;
          case 'matrix':
            matrix = args;
            break;
        }

        // snapshot current matrix into matrices array
        matrices.push(matrix.concat());
        // reset
        matrix = iMatrix.concat();
      });

      var combinedMatrix = matrices[0];
      while (matrices.length > 1) {
        matrices.shift();
        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
      }
      return combinedMatrix;
    };
  })();

  /**
   * @private
   */
  function parseStyleString(style, oStyle) {
    var attr, value;
    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
      var pair = chunk.split(':');

      attr = pair[0].trim().toLowerCase();
      value =  pair[1].trim();

      oStyle[attr] = value;
    });
  }

  /**
   * @private
   */
  function parseStyleObject(style, oStyle) {
    var attr, value;
    for (var prop in style) {
      if (typeof style[prop] === 'undefined') {
        continue;
      }

      attr = prop.toLowerCase();
      value = style[prop];

      oStyle[attr] = value;
    }
  }

  /**
   * @private
   */
  function getGlobalStylesForElement(element, svgUid) {
    var styles = { };
    for (var rule in fabric.cssRules[svgUid]) {
      if (elementMatchesRule(element, rule.split(' '))) {
        for (var property in fabric.cssRules[svgUid][rule]) {
          styles[property] = fabric.cssRules[svgUid][rule][property];
        }
      }
    }
    return styles;
  }

  /**
   * @private
   */
  function elementMatchesRule(element, selectors) {
    var firstMatching, parentMatching = true;
    //start from rightmost selector.
    firstMatching = selectorMatches(element, selectors.pop());
    if (firstMatching && selectors.length) {
      parentMatching = doesSomeParentMatch(element, selectors);
    }
    return firstMatching && parentMatching && (selectors.length === 0);
  }

  function doesSomeParentMatch(element, selectors) {
    var selector, parentMatching = true;
    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
      if (parentMatching) {
        selector = selectors.pop();
      }
      element = element.parentNode;
      parentMatching = selectorMatches(element, selector);
    }
    return selectors.length === 0;
  }

  /**
   * @private
   */
  function selectorMatches(element, selector) {
    var nodeName = element.nodeName,
        classNames = element.getAttribute('class'),
        id = element.getAttribute('id'), matcher, i;
    // i check if a selector matches slicing away part from it.
    // if i get empty string i should match
    matcher = new RegExp('^' + nodeName, 'i');
    selector = selector.replace(matcher, '');
    if (id && selector.length) {
      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
      selector = selector.replace(matcher, '');
    }
    if (classNames && selector.length) {
      classNames = classNames.split(' ');
      for (i = classNames.length; i--;) {
        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
    }
    return selector.length === 0;
  }

  /**
   * @private
   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM
   */
  function elementById(doc, id) {
    var el;
    doc.getElementById && (el = doc.getElementById(id));
    if (el) {
      return el;
    }
    var node, i, len, nodelist = doc.getElementsByTagName('*');
    for (i = 0, len = nodelist.length; i < len; i++) {
      node = nodelist[i];
      if (id === node.getAttribute('id')) {
        return node;
      }
    }
  }

  /**
   * @private
   */
  function parseUseDirectives(doc) {
    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;
    while (nodelist.length && i < nodelist.length) {
      var el = nodelist[i],
          xlink = (el.getAttribute('xlink:href') || el.getAttribute('href')).substr(1),
          x = el.getAttribute('x') || 0,
          y = el.getAttribute('y') || 0,
          el2 = elementById(doc, xlink).cloneNode(true),
          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
          parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;

      applyViewboxTransform(el2);
      if (/^svg$/i.test(el2.nodeName)) {
        var el3 = el2.ownerDocument.createElementNS(namespace, 'g');
        for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
        }
        // el2.firstChild != null
        while (el2.firstChild) {
          el3.appendChild(el2.firstChild);
        }
        el2 = el3;
      }

      for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
        attr = attrs.item(j);
        if (attr.nodeName === 'x' || attr.nodeName === 'y' ||
          attr.nodeName === 'xlink:href' || attr.nodeName === 'href') {
          continue;
        }

        if (attr.nodeName === 'transform') {
          currentTrans = attr.nodeValue + ' ' + currentTrans;
        }
        else {
          el2.setAttribute(attr.nodeName, attr.nodeValue);
        }
      }

      el2.setAttribute('transform', currentTrans);
      el2.setAttribute('instantiated_by_use', '1');
      el2.removeAttribute('id');
      parentNode = el.parentNode;
      parentNode.replaceChild(el2, el);
      // some browsers do not shorten nodelist after replaceChild (IE8)
      if (nodelist.length === oldLength) {
        i++;
      }
    }
  }

  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
  // matches, e.g.: +14.56e-12, etc.
  var reViewBoxAttrValue = new RegExp(
    '^' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*' +
    '$'
  );

  /**
   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
   */
  function applyViewboxTransform(element) {
    if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {
      return;
    }
    var viewBoxAttr = element.getAttribute('viewBox'),
        scaleX = 1,
        scaleY = 1,
        minX = 0,
        minY = 0,
        viewBoxWidth, viewBoxHeight, matrix, el,
        widthAttr = element.getAttribute('width'),
        heightAttr = element.getAttribute('height'),
        x = element.getAttribute('x') || 0,
        y = element.getAttribute('y') || 0,
        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
        missingViewBox = (!viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
        toBeParsed = missingViewBox && missingDimAttr,
        parsedDim = { }, translateMatrix = '', widthDiff = 0, heightDiff = 0;

    parsedDim.width = 0;
    parsedDim.height = 0;
    parsedDim.toBeParsed = toBeParsed;

    if (missingViewBox) {
      if (((x || y) && element.parentNode.nodeName !== '#document')) {
        translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
        matrix = (element.getAttribute('transform') || '') + translateMatrix;
        element.setAttribute('transform', matrix);
        element.removeAttribute('x');
        element.removeAttribute('y');
      }
    }

    if (toBeParsed) {
      return parsedDim;
    }

    if (missingViewBox) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      // set a transform for elements that have x y and are inner(only) SVGs
      return parsedDim;
    }
    minX = -parseFloat(viewBoxAttr[1]);
    minY = -parseFloat(viewBoxAttr[2]);
    viewBoxWidth = parseFloat(viewBoxAttr[3]);
    viewBoxHeight = parseFloat(viewBoxAttr[4]);
    parsedDim.minX = minX;
    parsedDim.minY = minY;
    parsedDim.viewBoxWidth = viewBoxWidth;
    parsedDim.viewBoxHeight = viewBoxHeight;
    if (!missingDimAttr) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      scaleX = parsedDim.width / viewBoxWidth;
      scaleY = parsedDim.height / viewBoxHeight;
    }
    else {
      parsedDim.width = viewBoxWidth;
      parsedDim.height = viewBoxHeight;
    }

    // default is to preserve aspect ratio
    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
    if (preserveAspectRatio.alignX !== 'none') {
      //translate all container for the effect of Mid, Min, Max
      if (preserveAspectRatio.meetOrSlice === 'meet') {
        scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
        // calculate additional translation to move the viewbox
      }
      if (preserveAspectRatio.meetOrSlice === 'slice') {
        scaleY = scaleX = (scaleX > scaleY ? scaleX : scaleY);
        // calculate additional translation to move the viewbox
      }
      widthDiff = parsedDim.width - viewBoxWidth * scaleX;
      heightDiff = parsedDim.height - viewBoxHeight * scaleX;
      if (preserveAspectRatio.alignX === 'Mid') {
        widthDiff /= 2;
      }
      if (preserveAspectRatio.alignY === 'Mid') {
        heightDiff /= 2;
      }
      if (preserveAspectRatio.alignX === 'Min') {
        widthDiff = 0;
      }
      if (preserveAspectRatio.alignY === 'Min') {
        heightDiff = 0;
      }
    }

    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
      return parsedDim;
    }
    if ((x || y) && element.parentNode.nodeName !== '#document') {
      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
    }

    matrix = translateMatrix + ' matrix(' + scaleX +
                  ' 0' +
                  ' 0 ' +
                  scaleY + ' ' +
                  (minX * scaleX + widthDiff) + ' ' +
                  (minY * scaleY + heightDiff) + ') ';
    // seems unused.
    // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);
    if (element.nodeName === 'svg') {
      el = element.ownerDocument.createElementNS(fabric.svgNS, 'g');
      // element.firstChild != null
      while (element.firstChild) {
        el.appendChild(element.firstChild);
      }
      element.appendChild(el);
    }
    else {
      el = element;
      el.removeAttribute('x');
      el.removeAttribute('y');
      matrix = el.getAttribute('transform') + matrix;
    }
    el.setAttribute('transform', matrix);
    return parsedDim;
  }

  function hasAncestorWithNodeName(element, nodeName) {
    while (element && (element = element.parentNode)) {
      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
        && !element.getAttribute('instantiated_by_use')) {
        return true;
      }
    }
    return false;
  }

  /**
   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
   * @static
   * @function
   * @memberOf fabric
   * @param {SVGDocument} doc SVG document to parse
   * @param {Function} callback Callback to call when parsing is finished;
   * It's being passed an array of elements (parsed from a document).
   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
   * @param {Object} [parsingOptions] options for parsing document
   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
   */
  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
    if (!doc) {
      return;
    }

    parseUseDirectives(doc);

    var svgUid =  fabric.Object.__uid++, i, len,
        options = applyViewboxTransform(doc),
        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
    options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
    options.svgUid = svgUid;

    if (descendants.length === 0 && fabric.isLikelyNode) {
      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
      // https://github.com/ajaxorg/node-o3-xml/issues/21
      descendants = doc.selectNodes('//*[name(.)!="svg"]');
      var arr = [];
      for (i = 0, len = descendants.length; i < len; i++) {
        arr[i] = descendants[i];
      }
      descendants = arr;
    }

    var elements = descendants.filter(function(el) {
      applyViewboxTransform(el);
      return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', '')) &&
            !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement
    });
    if (!elements || (elements && !elements.length)) {
      callback && callback([], {});
      return;
    }
    var clipPaths = { };
    descendants.filter(function(el) {
      return el.nodeName.replace('svg:', '') === 'clipPath';
    }).forEach(function(el) {
      var id = el.getAttribute('id');
      clipPaths[id] = fabric.util.toArray(el.getElementsByTagName('*')).filter(function(el) {
        return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace('svg:', ''));
      });
    });
    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
    fabric.clipPaths[svgUid] = clipPaths;
    // Precedence of rules:   style > class > attribute
    fabric.parseElements(elements, function(instances, elements) {
      if (callback) {
        callback(instances, options, elements, descendants);
        delete fabric.gradientDefs[svgUid];
        delete fabric.cssRules[svgUid];
        delete fabric.clipPaths[svgUid];
      }
    }, clone(options), reviver, parsingOptions);
  };

  function recursivelyParseGradientsXlink(doc, gradient) {
    var gradientsAttrs = ['gradientTransform', 'x1', 'x2', 'y1', 'y2', 'gradientUnits', 'cx', 'cy', 'r', 'fx', 'fy'],
        xlinkAttr = 'xlink:href',
        xLink = gradient.getAttribute(xlinkAttr).substr(1),
        referencedGradient = elementById(doc, xLink);
    if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
      recursivelyParseGradientsXlink(doc, referencedGradient);
    }
    gradientsAttrs.forEach(function(attr) {
      if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
        gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
      }
    });
    if (!gradient.children.length) {
      var referenceClone = referencedGradient.cloneNode(true);
      while (referenceClone.firstChild) {
        gradient.appendChild(referenceClone.firstChild);
      }
    }
    gradient.removeAttribute(xlinkAttr);
  }

  var reFontDeclaration = new RegExp(
    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
      fabric.reNum +
    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

  extend(fabric, {
    /**
     * Parses a short font declaration, building adding its properties to a style object
     * @static
     * @function
     * @memberOf fabric
     * @param {String} value font declaration
     * @param {Object} oStyle definition
     */
    parseFontDeclaration: function(value, oStyle) {
      var match = value.match(reFontDeclaration);

      if (!match) {
        return;
      }
      var fontStyle = match[1],
          // font variant is not used
          // fontVariant = match[2],
          fontWeight = match[3],
          fontSize = match[4],
          lineHeight = match[5],
          fontFamily = match[6];

      if (fontStyle) {
        oStyle.fontStyle = fontStyle;
      }
      if (fontWeight) {
        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
      }
      if (fontSize) {
        oStyle.fontSize = parseUnit(fontSize);
      }
      if (fontFamily) {
        oStyle.fontFamily = fontFamily;
      }
      if (lineHeight) {
        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
      }
    },

    /**
     * Parses an SVG document, returning all of the gradient declarations found in it
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
     */
    getGradientDefs: function(doc) {
      var tagArray = [
            'linearGradient',
            'radialGradient',
            'svg:linearGradient',
            'svg:radialGradient'],
          elList = _getMultipleNodes(doc, tagArray),
          el, j = 0, gradientDefs = { };
      j = elList.length;
      while (j--) {
        el = elList[j];
        if (el.getAttribute('xlink:href')) {
          recursivelyParseGradientsXlink(doc, el);
        }
        gradientDefs[el.getAttribute('id')] = el;
      }
      return gradientDefs;
    },

    /**
     * Returns an object of attributes' name/value, given element and an array of attribute names;
     * Parses parent "g" nodes recursively upwards.
     * @static
     * @memberOf fabric
     * @param {DOMElement} element Element to parse
     * @param {Array} attributes Array of attributes to parse
     * @return {Object} object containing parsed attributes' names/values
     */
    parseAttributes: function(element, attributes, svgUid) {

      if (!element) {
        return;
      }

      var value,
          parentAttributes = { },
          fontSize, parentFontSize;

      if (typeof svgUid === 'undefined') {
        svgUid = element.getAttribute('svgUid');
      }
      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
      if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
      }

      var ownAttributes = attributes.reduce(function(memo, attr) {
        value = element.getAttribute(attr);
        if (value) { // eslint-disable-line
          memo[attr] = value;
        }
        return memo;
      }, { });
      // add values parsed from style, which take precedence over attributes
      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
      var cssAttrs = extend(
        getGlobalStylesForElement(element, svgUid),
        fabric.parseStyleAttribute(element)
      );
      ownAttributes = extend(
        ownAttributes,
        cssAttrs
      );
      if (cssAttrs[cPath]) {
        element.setAttribute(cPath, cssAttrs[cPath]);
      }
      fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;
      if (ownAttributes[fSize]) {
        // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.
        ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);
      }

      var normalizedAttr, normalizedValue, normalizedStyle = {};
      for (var attr in ownAttributes) {
        normalizedAttr = normalizeAttr(attr);
        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
        normalizedStyle[normalizedAttr] = normalizedValue;
      }
      if (normalizedStyle && normalizedStyle.font) {
        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
      }
      var mergedAttrs = extend(parentAttributes, normalizedStyle);
      return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
    },

    /**
     * Transforms an array of svg elements to corresponding fabric.* instances
     * @static
     * @memberOf fabric
     * @param {Array} elements Array of elements to parse
     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
     * @param {Object} [options] Options object
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     */
    parseElements: function(elements, callback, options, reviver, parsingOptions) {
      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
    },

    /**
     * Parses "style" attribute, retuning an object with values
     * @static
     * @memberOf fabric
     * @param {SVGElement} element Element to parse
     * @return {Object} Objects with values parsed from style attribute of an element
     */
    parseStyleAttribute: function(element) {
      var oStyle = { },
          style = element.getAttribute('style');

      if (!style) {
        return oStyle;
      }

      if (typeof style === 'string') {
        parseStyleString(style, oStyle);
      }
      else {
        parseStyleObject(style, oStyle);
      }

      return oStyle;
    },

    /**
     * Parses "points" attribute, returning an array of values
     * @static
     * @memberOf fabric
     * @param {String} points points attribute string
     * @return {Array} array of points
     */
    parsePointsAttribute: function(points) {

      // points attribute is required and must not be empty
      if (!points) {
        return null;
      }

      // replace commas with whitespace and remove bookending whitespace
      points = points.replace(/,/g, ' ').trim();

      points = points.split(/\s+/);
      var parsedPoints = [], i, len;

      for (i = 0, len = points.length; i < len; i += 2) {
        parsedPoints.push({
          x: parseFloat(points[i]),
          y: parseFloat(points[i + 1])
        });
      }

      // odd number of points is an error
      // if (parsedPoints.length % 2 !== 0) {
      //   return null;
      // }

      return parsedPoints;
    },

    /**
     * Returns CSS rules for a given SVG document
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} CSS rules of this document
     */
    getCSSRules: function(doc) {
      var styles = doc.getElementsByTagName('style'), i, len,
          allRules = { }, rules;

      // very crude parsing of style contents
      for (i = 0, len = styles.length; i < len; i++) {
        var styleContents = styles[i].textContent;

        // remove comments
        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
        if (styleContents.trim() === '') {
          continue;
        }
        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
        rules = rules.map(function(rule) { return rule.trim(); });
        // eslint-disable-next-line no-loop-func
        rules.forEach(function(rule) {

          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
              ruleObj = { }, declaration = match[2].trim(),
              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);

          for (i = 0, len = propertyValuePairs.length; i < len; i++) {
            var pair = propertyValuePairs[i].split(/\s*:\s*/),
                property = pair[0],
                value = pair[1];
            ruleObj[property] = value;
          }
          rule = match[1];
          rule.split(',').forEach(function(_rule) {
            _rule = _rule.replace(/^svg/i, '').trim();
            if (_rule === '') {
              return;
            }
            if (allRules[_rule]) {
              fabric.util.object.extend(allRules[_rule], ruleObj);
            }
            else {
              allRules[_rule] = fabric.util.object.clone(ruleObj);
            }
          });
        });
      }
      return allRules;
    },

    /**
     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
     * @memberOf fabric
     * @param {String} url
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromURL: function(url, callback, reviver, options) {

      url = url.replace(/^\n\s*/, '').trim();
      new fabric.util.request(url, {
        method: 'get',
        onComplete: onComplete
      });

      function onComplete(r) {

        var xml = r.responseXML;
        if (!xml || !xml.documentElement) {
          callback && callback(null);
          return false;
        }

        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
          callback && callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    },

    /**
     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
     * @memberOf fabric
     * @param {String} string
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromString: function(string, callback, reviver, options) {
      var parser = new fabric.window.DOMParser(),
          doc = parser.parseFromString(string.trim(), 'text/xml');
      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
        callback(results, _options, elements, allElements);
      }, reviver, options);
    }
  });

})( true ? exports : 0);


fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {
  this.elements = elements;
  this.callback = callback;
  this.options = options;
  this.reviver = reviver;
  this.svgUid = (options && options.svgUid) || 0;
  this.parsingOptions = parsingOptions;
  this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
  this.doc = doc;
};

(function(proto) {
  proto.parse = function() {
    this.instances = new Array(this.elements.length);
    this.numElements = this.elements.length;
    this.createObjects();
  };

  proto.createObjects = function() {
    var _this = this;
    this.elements.forEach(function(element, i) {
      element.setAttribute('svgUid', _this.svgUid);
      _this.createObject(element, i);
    });
  };

  proto.findTag = function(el) {
    return fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
  };

  proto.createObject = function(el, index) {
    var klass = this.findTag(el);
    if (klass && klass.fromElement) {
      try {
        klass.fromElement(el, this.createCallback(index, el), this.options);
      }
      catch (err) {
        fabric.log(err);
      }
    }
    else {
      this.checkIfDone();
    }
  };

  proto.createCallback = function(index, el) {
    var _this = this;
    return function(obj) {
      var _options;
      _this.resolveGradient(obj, el, 'fill');
      _this.resolveGradient(obj, el, 'stroke');
      if (obj instanceof fabric.Image && obj._originalElement) {
        _options = obj.parsePreserveAspectRatioAttribute(el);
      }
      obj._removeTransformMatrix(_options);
      _this.resolveClipPath(obj, el);
      _this.reviver && _this.reviver(el, obj);
      _this.instances[index] = obj;
      _this.checkIfDone();
    };
  };

  proto.extractPropertyDefinition = function(obj, property, storage) {
    var value = obj[property], regex = this.regexUrl;
    if (!regex.test(value)) {
      return;
    }
    regex.lastIndex = 0;
    var id = regex.exec(value)[1];
    regex.lastIndex = 0;
    return fabric[storage][this.svgUid][id];
  };

  proto.resolveGradient = function(obj, el, property) {
    var gradientDef = this.extractPropertyDefinition(obj, property, 'gradientDefs');
    if (gradientDef) {
      var opacityAttr = el.getAttribute(property + '-opacity');
      var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
      obj.set(property, gradient);
    }
  };

  proto.createClipPathCallback = function(obj, container) {
    return function(_newObj) {
      _newObj._removeTransformMatrix();
      _newObj.fillRule = _newObj.clipRule;
      container.push(_newObj);
    };
  };

  proto.resolveClipPath = function(obj, usingElement) {
    var clipPath = this.extractPropertyDefinition(obj, 'clipPath', 'clipPaths'),
        element, klass, objTransformInv, container, gTransform, options;
    if (clipPath) {
      container = [];
      objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
      // move the clipPath tag as sibling to the real element that is using it
      var clipPathTag = clipPath[0].parentNode;
      var clipPathOwner = usingElement;
      while (clipPathOwner.parentNode && clipPathOwner.getAttribute('clip-path') !== obj.clipPath) {
        clipPathOwner = clipPathOwner.parentNode;
      }
      clipPathOwner.parentNode.appendChild(clipPathTag);
      for (var i = 0; i < clipPath.length; i++) {
        element = clipPath[i];
        klass = this.findTag(element);
        klass.fromElement(
          element,
          this.createClipPathCallback(obj, container),
          this.options
        );
      }
      if (container.length === 1) {
        clipPath = container[0];
      }
      else {
        clipPath = new fabric.Group(container);
      }
      gTransform = fabric.util.multiplyTransformMatrices(
        objTransformInv,
        clipPath.calcTransformMatrix()
      );
      if (clipPath.clipPath) {
        this.resolveClipPath(clipPath, clipPathOwner);
      }
      var options = fabric.util.qrDecompose(gTransform);
      clipPath.flipX = false;
      clipPath.flipY = false;
      clipPath.set('scaleX', options.scaleX);
      clipPath.set('scaleY', options.scaleY);
      clipPath.angle = options.angle;
      clipPath.skewX = options.skewX;
      clipPath.skewY = 0;
      clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, 'center', 'center');
      obj.clipPath = clipPath;
    }
    else {
      // if clip-path does not resolve to any element, delete the property.
      delete obj.clipPath;
    }
  };

  proto.checkIfDone = function() {
    if (--this.numElements === 0) {
      this.instances = this.instances.filter(function(el) {
        // eslint-disable-next-line no-eq-null, eqeqeq
        return el != null;
      });
      this.callback(this.instances, this.elements);
    }
  };
})(fabric.ElementsParser.prototype);


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Point) {
    fabric.warn('fabric.Point is already defined');
    return;
  }

  fabric.Point = Point;

  /**
   * Point class
   * @class fabric.Point
   * @memberOf fabric
   * @constructor
   * @param {Number} x
   * @param {Number} y
   * @return {fabric.Point} thisArg
   */
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  Point.prototype = /** @lends fabric.Point.prototype */ {

    type: 'point',

    constructor: Point,

    /**
     * Adds another point to this one and returns another one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point instance with added values
     */
    add: function (that) {
      return new Point(this.x + that.x, this.y + that.y);
    },

    /**
     * Adds another point to this one
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    addEquals: function (that) {
      this.x += that.x;
      this.y += that.y;
      return this;
    },

    /**
     * Adds value to this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point} new Point with added value
     */
    scalarAdd: function (scalar) {
      return new Point(this.x + scalar, this.y + scalar);
    },

    /**
     * Adds value to this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarAddEquals: function (scalar) {
      this.x += scalar;
      this.y += scalar;
      return this;
    },

    /**
     * Subtracts another point from this point and returns a new one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point object with subtracted values
     */
    subtract: function (that) {
      return new Point(this.x - that.x, this.y - that.y);
    },

    /**
     * Subtracts another point from this point
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    subtractEquals: function (that) {
      this.x -= that.x;
      this.y -= that.y;
      return this;
    },

    /**
     * Subtracts value from this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    scalarSubtract: function (scalar) {
      return new Point(this.x - scalar, this.y - scalar);
    },

    /**
     * Subtracts value from this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarSubtractEquals: function (scalar) {
      this.x -= scalar;
      this.y -= scalar;
      return this;
    },

    /**
     * Multiplies this point by a value and returns a new one
     * TODO: rename in scalarMultiply in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    multiply: function (scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    },

    /**
     * Multiplies this point by a value
     * TODO: rename in scalarMultiplyEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    multiplyEquals: function (scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    },

    /**
     * Divides this point by a value and returns a new one
     * TODO: rename in scalarDivide in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    divide: function (scalar) {
      return new Point(this.x / scalar, this.y / scalar);
    },

    /**
     * Divides this point by a value
     * TODO: rename in scalarDivideEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    divideEquals: function (scalar) {
      this.x /= scalar;
      this.y /= scalar;
      return this;
    },

    /**
     * Returns true if this point is equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    eq: function (that) {
      return (this.x === that.x && this.y === that.y);
    },

    /**
     * Returns true if this point is less than another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lt: function (that) {
      return (this.x < that.x && this.y < that.y);
    },

    /**
     * Returns true if this point is less than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lte: function (that) {
      return (this.x <= that.x && this.y <= that.y);
    },

    /**

     * Returns true if this point is greater another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gt: function (that) {
      return (this.x > that.x && this.y > that.y);
    },

    /**
     * Returns true if this point is greater than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gte: function (that) {
      return (this.x >= that.x && this.y >= that.y);
    },

    /**
     * Returns new point which is the result of linear interpolation with this one and another one
     * @param {fabric.Point} that
     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
     * @return {fabric.Point}
     */
    lerp: function (that, t) {
      if (typeof t === 'undefined') {
        t = 0.5;
      }
      t = Math.max(Math.min(1, t), 0);
      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
    },

    /**
     * Returns distance from this point and another one
     * @param {fabric.Point} that
     * @return {Number}
     */
    distanceFrom: function (that) {
      var dx = this.x - that.x,
          dy = this.y - that.y;
      return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Returns the point between this point and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    midPointFrom: function (that) {
      return this.lerp(that);
    },

    /**
     * Returns a new point which is the min of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    min: function (that) {
      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
    },

    /**
     * Returns a new point which is the max of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    max: function (that) {
      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
    },

    /**
     * Returns string representation of this point
     * @return {String}
     */
    toString: function () {
      return this.x + ',' + this.y;
    },

    /**
     * Sets x/y of this point
     * @param {Number} x
     * @param {Number} y
     * @chainable
     */
    setXY: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * Sets x of this point
     * @param {Number} x
     * @chainable
     */
    setX: function (x) {
      this.x = x;
      return this;
    },

    /**
     * Sets y of this point
     * @param {Number} y
     * @chainable
     */
    setY: function (y) {
      this.y = y;
      return this;
    },

    /**
     * Sets x/y of this point from another point
     * @param {fabric.Point} that
     * @chainable
     */
    setFromPoint: function (that) {
      this.x = that.x;
      this.y = that.y;
      return this;
    },

    /**
     * Swaps x/y of this point and another point
     * @param {fabric.Point} that
     */
    swap: function (that) {
      var x = this.x,
          y = this.y;
      this.x = that.x;
      this.y = that.y;
      that.x = x;
      that.y = y;
    },

    /**
     * return a cloned instance of the point
     * @return {fabric.Point}
     */
    clone: function () {
      return new Point(this.x, this.y);
    }
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Intersection) {
    fabric.warn('fabric.Intersection is already defined');
    return;
  }

  /**
   * Intersection class
   * @class fabric.Intersection
   * @memberOf fabric
   * @constructor
   */
  function Intersection(status) {
    this.status = status;
    this.points = [];
  }

  fabric.Intersection = Intersection;

  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

    constructor: Intersection,

    /**
     * Appends a point to intersection
     * @param {fabric.Point} point
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoint: function (point) {
      this.points.push(point);
      return this;
    },

    /**
     * Appends points to intersection
     * @param {Array} points
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoints: function (points) {
      this.points = this.points.concat(points);
      return this;
    }
  };

  /**
   * Checks if one line intersects another
   * TODO: rename in intersectSegmentSegment
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {fabric.Point} b1
   * @param {fabric.Point} b2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
    var result,
        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    if (uB !== 0) {
      var ua = uaT / uB,
          ub = ubT / uB;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        result = new Intersection('Intersection');
        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
      }
      else {
        result = new Intersection();
      }
    }
    else {
      if (uaT === 0 || ubT === 0) {
        result = new Intersection('Coincident');
      }
      else {
        result = new Intersection('Parallel');
      }
    }
    return result;
  };

  /**
   * Checks if line intersects polygon
   * TODO: rename in intersectSegmentPolygon
   * fix detection of coincident
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {Array} points
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
    var result = new Intersection(),
        length = points.length,
        b1, b2, inter, i;

    for (i = 0; i < length; i++) {
      b1 = points[i];
      b2 = points[(i + 1) % length];
      inter = Intersection.intersectLineLine(a1, a2, b1, b2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects another polygon
   * @static
   * @param {Array} points1
   * @param {Array} points2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
    var result = new Intersection(),
        length = points1.length, i;

    for (i = 0; i < length; i++) {
      var a1 = points1[i],
          a2 = points1[(i + 1) % length],
          inter = Intersection.intersectLinePolygon(a1, a2, points2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects rectangle
   * @static
   * @param {Array} points
   * @param {fabric.Point} r1
   * @param {fabric.Point} r2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
    var min = r1.min(r2),
        max = r1.max(r2),
        topRight = new fabric.Point(max.x, min.y),
        bottomLeft = new fabric.Point(min.x, max.y),
        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
        result = new Intersection();

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Color) {
    fabric.warn('fabric.Color is already defined.');
    return;
  }

  /**
   * Color class
   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
   *
   * @class fabric.Color
   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
   * @return {fabric.Color} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
   */
  function Color(color) {
    if (!color) {
      this.setSource([0, 0, 0, 1]);
    }
    else {
      this._tryParsingColor(color);
    }
  }

  fabric.Color = Color;

  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

    /**
     * @private
     * @param {String|Array} color Color value to parse
     */
    _tryParsingColor: function(color) {
      var source;

      if (color in Color.colorNameMap) {
        color = Color.colorNameMap[color];
      }

      if (color === 'transparent') {
        source = [255, 255, 255, 0];
      }

      if (!source) {
        source = Color.sourceFromHex(color);
      }
      if (!source) {
        source = Color.sourceFromRgb(color);
      }
      if (!source) {
        source = Color.sourceFromHsl(color);
      }
      if (!source) {
        //if color is not recognize let's make black as canvas does
        source = [0, 0, 0, 1];
      }
      if (source) {
        this.setSource(source);
      }
    },

    /**
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @private
     * @param {Number} r Red color value
     * @param {Number} g Green color value
     * @param {Number} b Blue color value
     * @return {Array} Hsl color
     */
    _rgbToHsl: function(r, g, b) {
      r /= 255; g /= 255; b /= 255;

      var h, s, l,
          max = fabric.util.array.max([r, g, b]),
          min = fabric.util.array.min([r, g, b]);

      l = (max + min) / 2;

      if (max === min) {
        h = s = 0; // achromatic
      }
      else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }

      return [
        Math.round(h * 360),
        Math.round(s * 100),
        Math.round(l * 100)
      ];
    },

    /**
     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @return {Array}
     */
    getSource: function() {
      return this._source;
    },

    /**
     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @param {Array} source
     */
    setSource: function(source) {
      this._source = source;
    },

    /**
     * Returns color representation in RGB format
     * @return {String} ex: rgb(0-255,0-255,0-255)
     */
    toRgb: function() {
      var source = this.getSource();
      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
    },

    /**
     * Returns color representation in RGBA format
     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
     */
    toRgba: function() {
      var source = this.getSource();
      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
    },

    /**
     * Returns color representation in HSL format
     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
     */
    toHsl: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
    },

    /**
     * Returns color representation in HSLA format
     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
     */
    toHsla: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
    },

    /**
     * Returns color representation in HEX format
     * @return {String} ex: FF5555
     */
    toHex: function() {
      var source = this.getSource(), r, g, b;

      r = source[0].toString(16);
      r = (r.length === 1) ? ('0' + r) : r;

      g = source[1].toString(16);
      g = (g.length === 1) ? ('0' + g) : g;

      b = source[2].toString(16);
      b = (b.length === 1) ? ('0' + b) : b;

      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
    },

    /**
     * Returns color representation in HEXA format
     * @return {String} ex: FF5555CC
     */
    toHexa: function() {
      var source = this.getSource(), a;

      a = Math.round(source[3] * 255);
      a = a.toString(16);
      a = (a.length === 1) ? ('0' + a) : a;

      return this.toHex() + a.toUpperCase();
    },

    /**
     * Gets value of alpha channel for this color
     * @return {Number} 0-1
     */
    getAlpha: function() {
      return this.getSource()[3];
    },

    /**
     * Sets value of alpha channel for this color
     * @param {Number} alpha Alpha value 0-1
     * @return {fabric.Color} thisArg
     */
    setAlpha: function(alpha) {
      var source = this.getSource();
      source[3] = alpha;
      this.setSource(source);
      return this;
    },

    /**
     * Transforms color to its grayscale representation
     * @return {fabric.Color} thisArg
     */
    toGrayscale: function() {
      var source = this.getSource(),
          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
          currentAlpha = source[3];
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Transforms color to its black and white representation
     * @param {Number} threshold
     * @return {fabric.Color} thisArg
     */
    toBlackWhite: function(threshold) {
      var source = this.getSource(),
          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
          currentAlpha = source[3];

      threshold = threshold || 127;

      average = (Number(average) < Number(threshold)) ? 0 : 255;
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Overlays color with another color
     * @param {String|fabric.Color} otherColor
     * @return {fabric.Color} thisArg
     */
    overlayWith: function(otherColor) {
      if (!(otherColor instanceof Color)) {
        otherColor = new Color(otherColor);
      }

      var result = [],
          alpha = this.getAlpha(),
          otherAlpha = 0.5,
          source = this.getSource(),
          otherSource = otherColor.getSource(), i;

      for (i = 0; i < 3; i++) {
        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
      }

      result[3] = alpha;
      this.setSource(result);
      return this;
    }
  };

  /**
   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  // eslint-disable-next-line max-len
  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;

  /**
   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

  /**
   * Map of the 148 color names with HEX code
   * @static
   * @field
   * @memberOf fabric.Color
   * @see: https://www.w3.org/TR/css3-color/#svg-color
   */
  fabric.Color.colorNameMap = {
    aliceblue:            '#F0F8FF',
    antiquewhite:         '#FAEBD7',
    aqua:                 '#00FFFF',
    aquamarine:           '#7FFFD4',
    azure:                '#F0FFFF',
    beige:                '#F5F5DC',
    bisque:               '#FFE4C4',
    black:                '#000000',
    blanchedalmond:       '#FFEBCD',
    blue:                 '#0000FF',
    blueviolet:           '#8A2BE2',
    brown:                '#A52A2A',
    burlywood:            '#DEB887',
    cadetblue:            '#5F9EA0',
    chartreuse:           '#7FFF00',
    chocolate:            '#D2691E',
    coral:                '#FF7F50',
    cornflowerblue:       '#6495ED',
    cornsilk:             '#FFF8DC',
    crimson:              '#DC143C',
    cyan:                 '#00FFFF',
    darkblue:             '#00008B',
    darkcyan:             '#008B8B',
    darkgoldenrod:        '#B8860B',
    darkgray:             '#A9A9A9',
    darkgrey:             '#A9A9A9',
    darkgreen:            '#006400',
    darkkhaki:            '#BDB76B',
    darkmagenta:          '#8B008B',
    darkolivegreen:       '#556B2F',
    darkorange:           '#FF8C00',
    darkorchid:           '#9932CC',
    darkred:              '#8B0000',
    darksalmon:           '#E9967A',
    darkseagreen:         '#8FBC8F',
    darkslateblue:        '#483D8B',
    darkslategray:        '#2F4F4F',
    darkslategrey:        '#2F4F4F',
    darkturquoise:        '#00CED1',
    darkviolet:           '#9400D3',
    deeppink:             '#FF1493',
    deepskyblue:          '#00BFFF',
    dimgray:              '#696969',
    dimgrey:              '#696969',
    dodgerblue:           '#1E90FF',
    firebrick:            '#B22222',
    floralwhite:          '#FFFAF0',
    forestgreen:          '#228B22',
    fuchsia:              '#FF00FF',
    gainsboro:            '#DCDCDC',
    ghostwhite:           '#F8F8FF',
    gold:                 '#FFD700',
    goldenrod:            '#DAA520',
    gray:                 '#808080',
    grey:                 '#808080',
    green:                '#008000',
    greenyellow:          '#ADFF2F',
    honeydew:             '#F0FFF0',
    hotpink:              '#FF69B4',
    indianred:            '#CD5C5C',
    indigo:               '#4B0082',
    ivory:                '#FFFFF0',
    khaki:                '#F0E68C',
    lavender:             '#E6E6FA',
    lavenderblush:        '#FFF0F5',
    lawngreen:            '#7CFC00',
    lemonchiffon:         '#FFFACD',
    lightblue:            '#ADD8E6',
    lightcoral:           '#F08080',
    lightcyan:            '#E0FFFF',
    lightgoldenrodyellow: '#FAFAD2',
    lightgray:            '#D3D3D3',
    lightgrey:            '#D3D3D3',
    lightgreen:           '#90EE90',
    lightpink:            '#FFB6C1',
    lightsalmon:          '#FFA07A',
    lightseagreen:        '#20B2AA',
    lightskyblue:         '#87CEFA',
    lightslategray:       '#778899',
    lightslategrey:       '#778899',
    lightsteelblue:       '#B0C4DE',
    lightyellow:          '#FFFFE0',
    lime:                 '#00FF00',
    limegreen:            '#32CD32',
    linen:                '#FAF0E6',
    magenta:              '#FF00FF',
    maroon:               '#800000',
    mediumaquamarine:     '#66CDAA',
    mediumblue:           '#0000CD',
    mediumorchid:         '#BA55D3',
    mediumpurple:         '#9370DB',
    mediumseagreen:       '#3CB371',
    mediumslateblue:      '#7B68EE',
    mediumspringgreen:    '#00FA9A',
    mediumturquoise:      '#48D1CC',
    mediumvioletred:      '#C71585',
    midnightblue:         '#191970',
    mintcream:            '#F5FFFA',
    mistyrose:            '#FFE4E1',
    moccasin:             '#FFE4B5',
    navajowhite:          '#FFDEAD',
    navy:                 '#000080',
    oldlace:              '#FDF5E6',
    olive:                '#808000',
    olivedrab:            '#6B8E23',
    orange:               '#FFA500',
    orangered:            '#FF4500',
    orchid:               '#DA70D6',
    palegoldenrod:        '#EEE8AA',
    palegreen:            '#98FB98',
    paleturquoise:        '#AFEEEE',
    palevioletred:        '#DB7093',
    papayawhip:           '#FFEFD5',
    peachpuff:            '#FFDAB9',
    peru:                 '#CD853F',
    pink:                 '#FFC0CB',
    plum:                 '#DDA0DD',
    powderblue:           '#B0E0E6',
    purple:               '#800080',
    rebeccapurple:        '#663399',
    red:                  '#FF0000',
    rosybrown:            '#BC8F8F',
    royalblue:            '#4169E1',
    saddlebrown:          '#8B4513',
    salmon:               '#FA8072',
    sandybrown:           '#F4A460',
    seagreen:             '#2E8B57',
    seashell:             '#FFF5EE',
    sienna:               '#A0522D',
    silver:               '#C0C0C0',
    skyblue:              '#87CEEB',
    slateblue:            '#6A5ACD',
    slategray:            '#708090',
    slategrey:            '#708090',
    snow:                 '#FFFAFA',
    springgreen:          '#00FF7F',
    steelblue:            '#4682B4',
    tan:                  '#D2B48C',
    teal:                 '#008080',
    thistle:              '#D8BFD8',
    tomato:               '#FF6347',
    turquoise:            '#40E0D0',
    violet:               '#EE82EE',
    wheat:                '#F5DEB3',
    white:                '#FFFFFF',
    whitesmoke:           '#F5F5F5',
    yellow:               '#FFFF00',
    yellowgreen:          '#9ACD32'
  };

  /**
   * @private
   * @param {Number} p
   * @param {Number} q
   * @param {Number} t
   * @return {Number}
   */
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }

  /**
   * Returns new color object, when given a color in RGB format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
   * @return {fabric.Color}
   */
  fabric.Color.fromRgb = function(color) {
    return Color.fromSource(Color.sourceFromRgb(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
   * @return {Array} source
   */
  fabric.Color.sourceFromRgb = function(color) {
    var match = color.match(Color.reRGBa);
    if (match) {
      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

      return [
        parseInt(r, 10),
        parseInt(g, 10),
        parseInt(b, 10),
        match[4] ? parseFloat(match[4]) : 1
      ];
    }
  };

  /**
   * Returns new color object, when given a color in RGBA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromRgba = Color.fromRgb;

  /**
   * Returns new color object, when given a color in HSL format
   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
   * @memberOf fabric.Color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsl = function(color) {
    return Color.fromSource(Color.sourceFromHsl(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
   * @memberOf fabric.Color
   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
   * @return {Array} source
   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
   */
  fabric.Color.sourceFromHsl = function(color) {
    var match = color.match(Color.reHSLa);
    if (!match) {
      return;
    }

    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
        r, g, b;

    if (s === 0) {
      r = g = b = l;
    }
    else {
      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
          p = l * 2 - q;

      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255),
      match[4] ? parseFloat(match[4]) : 1
    ];
  };

  /**
   * Returns new color object, when given a color in HSLA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsla = Color.fromHsl;

  /**
   * Returns new color object, when given a color in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color Color value ex: FF5555
   * @return {fabric.Color}
   */
  fabric.Color.fromHex = function(color) {
    return Color.fromSource(Color.sourceFromHex(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color ex: FF5555 or FF5544CC (RGBa)
   * @return {Array} source
   */
  fabric.Color.sourceFromHex = function(color) {
    if (color.match(Color.reHex)) {
      var value = color.slice(color.indexOf('#') + 1),
          isShortNotation = (value.length === 3 || value.length === 4),
          isRGBa = (value.length === 8 || value.length === 4),
          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

      return [
        parseInt(r, 16),
        parseInt(g, 16),
        parseInt(b, 16),
        parseFloat((parseInt(a, 16) / 255).toFixed(2))
      ];
    }
  };

  /**
   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
   * @static
   * @memberOf fabric.Color
   * @param {Array} source
   * @return {fabric.Color}
   */
  fabric.Color.fromSource = function(source) {
    var oColor = new Color();
    oColor.setSource(source);
    return oColor;
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      scaleMap = ['e', 'se', 's', 'sw', 'w', 'nw', 'n', 'ne', 'e'],
      skewMap = ['ns', 'nesw', 'ew', 'nwse'],
      controls = {},
      LEFT = 'left', TOP = 'top', RIGHT = 'right', BOTTOM = 'bottom', CENTER = 'center',
      opposite = {
        top: BOTTOM,
        bottom: TOP,
        left: RIGHT,
        right: LEFT,
        center: CENTER,
      }, radiansToDegrees = fabric.util.radiansToDegrees,
      sign = (Math.sign || function(x) { return ((x > 0) - (x < 0)) || +x; });

  /**
   * Combine control position and object angle to find the control direction compared
   * to the object center.
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   * @param {fabric.Control} control the control class
   * @return {Number} 0 - 7 a quadrant number
   */
  function findCornerQuadrant(fabricObject, control) {
    var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;
    return Math.round((cornerAngle % 360) / 45);
  }

  function fireEvent(eventName, options) {
    var target = options.transform.target,
        canvas = target.canvas,
        canvasOptions = fabric.util.object.clone(options);
    canvasOptions.target = target;
    canvas && canvas.fire('object:' + eventName, canvasOptions);
    target.fire(eventName, options);
  }

  /**
   * Inspect event and fabricObject properties to understand if the scaling action
   * @param {Event} eventData from the user action
   * @param {fabric.Object} fabricObject the fabric object about to scale
   * @return {Boolean} true if scale is proportional
   */
  function scaleIsProportional(eventData, fabricObject) {
    var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey,
        uniformIsToggled = eventData[uniScaleKey];
    return (canvas.uniformScaling && !uniformIsToggled) ||
    (!canvas.uniformScaling && uniformIsToggled);
  }

  /**
   * Checks if transform is centered
   * @param {Object} transform transform data
   * @return {Boolean} true if transform is centered
   */
  function isTransformCentered(transform) {
    return transform.originX === CENTER && transform.originY === CENTER;
  }

  /**
   * Inspect fabricObject to understand if the current scaling action is allowed
   * @param {fabric.Object} fabricObject the fabric object about to scale
   * @param {String} by 'x' or 'y' or ''
   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally
   * @return {Boolean} true if scaling is not allowed at current conditions
   */
  function scalingIsForbidden(fabricObject, by, scaleProportionally) {
    var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;
    if (lockX && lockY) {
      return true;
    }
    if (!by && (lockX || lockY) && scaleProportionally) {
      return true;
    }
    if (lockX && by === 'x') {
      return true;
    }
    if (lockY && by === 'y') {
      return true;
    }
    return false;
  }

  /**
   * return the correct cursor style for the scale action
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function scaleCursorStyleHandler(eventData, control, fabricObject) {
    var notAllowed = 'not-allowed',
        scaleProportionally = scaleIsProportional(eventData, fabricObject),
        by = '';
    if (control.x !== 0 && control.y === 0) {
      by = 'x';
    }
    else if (control.x === 0 && control.y !== 0) {
      by = 'y';
    }
    if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {
      return notAllowed;
    }
    var n = findCornerQuadrant(fabricObject, control);
    return scaleMap[n] + '-resize';
  }

  /**
   * return the correct cursor style for the skew action
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function skewCursorStyleHandler(eventData, control, fabricObject) {
    var notAllowed = 'not-allowed';
    if (control.x !== 0 && fabricObject.lockSkewingY) {
      return notAllowed;
    }
    if (control.y !== 0 && fabricObject.lockSkewingX) {
      return notAllowed;
    }
    var n = findCornerQuadrant(fabricObject, control) % 4;
    return skewMap[n] + '-resize';
  }

  /**
   * Combine skew and scale style handlers to cover fabric standard use case
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {
    if (eventData[fabricObject.canvas.altActionKey]) {
      return controls.skewCursorStyleHandler(eventData, control, fabricObject);
    }
    return controls.scaleCursorStyleHandler(eventData, control, fabricObject);
  }

  /**
   * Inspect event, control and fabricObject to return the correct action name
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} an action name
   */
  function scaleOrSkewActionName(eventData, control, fabricObject) {
    var isAlternative = eventData[fabricObject.canvas.altActionKey];
    if (control.x === 0) {
      // then is scaleY or skewX
      return isAlternative ? 'skewX' : 'scaleY';
    }
    if (control.y === 0) {
      // then is scaleY or skewX
      return isAlternative ? 'skewY' : 'scaleX';
    }
  }

  /**
   * Find the correct style for the control that is used for rotation.
   * this function is very simple and it just take care of not-allowed or standard cursor
   * @param {Event} eventData the javascript event that is causing the scale
   * @param {fabric.Control} control the control that is interested in the action
   * @param {fabric.Object} fabricObject the fabric object that is interested in the action
   * @return {String} a valid css string for the cursor
   */
  function rotationStyleHandler(eventData, control, fabricObject) {
    if (fabricObject.lockRotation) {
      return 'not-allowed';
    }
    return control.cursorStyle;
  }

  function commonEventInfo(eventData, transform, x, y) {
    return {
      e: eventData,
      transform: transform,
      pointer: {
        x: x,
        y: y,
      }
    };
  }

  /**
   * Wrap an action handler with saving/restoring object position on the transform.
   * this is the code that permits to objects to keep their position while transforming.
   * @param {Function} actionHandler the function to wrap
   * @return {Function} a function with an action handler signature
   */
  function wrapWithFixedAnchor(actionHandler) {
    return function(eventData, transform, x, y) {
      var target = transform.target, centerPoint = target.getCenterPoint(),
          constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY),
          actionPerformed = actionHandler(eventData, transform, x, y);
      target.setPositionByOrigin(constraint, transform.originX, transform.originY);
      return actionPerformed;
    };
  }

  /**
   * Transforms a point described by x and y in a distance from the top left corner of the object
   * bounding box.
   * @param {Object} transform
   * @param {String} originX
   * @param {String} originY
   * @param {number} x
   * @param {number} y
   * @return {Fabric.Point} the normalized point
   */
  function getLocalPoint(transform, originX, originY, x, y) {
    var target = transform.target,
        control = target.controls[transform.corner],
        zoom = target.canvas.getZoom(),
        padding = target.padding / zoom,
        localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);
    if (localPoint.x >= padding) {
      localPoint.x -= padding;
    }
    if (localPoint.x <= -padding) {
      localPoint.x += padding;
    }
    if (localPoint.y >= padding) {
      localPoint.y -= padding;
    }
    if (localPoint.y <= padding) {
      localPoint.y += padding;
    }
    localPoint.x -= control.offsetX;
    localPoint.y -= control.offsetY;
    return localPoint;
  }

  /**
   * Detect if the fabric object is flipped on one side.
   * @param {fabric.Object} target
   * @return {Boolean} true if one flip, but not two.
   */
  function targetHasOneFlip(target) {
    return target.flipX !== target.flipY;
  }

  /**
   * Utility function to compensate the scale factor when skew is applied on both axes
   * @private
   */
  function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {
    if (target[oppositeSkew] !== 0) {
      var newDim = target._getTransformedDimensions()[axis];
      var newValue = reference / newDim * target[scaleToCompensate];
      target.set(scaleToCompensate, newValue);
    }
  }

  /**
   * Action handler for skewing on the X axis
   * @private
   */
  function skewObjectX(eventData, transform, x, y) {
    var target = transform.target,
        // find how big the object would be, if there was no skewX. takes in account scaling
        dimNoSkew = target._getTransformedDimensions(0, target.skewY),
        localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        // the mouse is in the center of the object, and we want it to stay there.
        // so the object will grow twice as much as the mouse.
        // this makes the skew growth to localPoint * 2 - dimNoSkew.
        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x,
        currentSkew = target.skewX, newSkew;
    if (totalSkewSize < 2) {
      // let's make it easy to go back to position 0.
      newSkew = 0;
    }
    else {
      newSkew = radiansToDegrees(
        Math.atan2((totalSkewSize / target.scaleX), (dimNoSkew.y / target.scaleY))
      );
      // now we have to find the sign of the skew.
      // it mostly depend on the origin of transformation.
      if (transform.originX === LEFT && transform.originY === BOTTOM) {
        newSkew = -newSkew;
      }
      if (transform.originX === RIGHT && transform.originY === TOP) {
        newSkew = -newSkew;
      }
      if (targetHasOneFlip(target)) {
        newSkew = -newSkew;
      }
    }
    var hasSkewed = currentSkew !== newSkew;
    if (hasSkewed) {
      var dimBeforeSkewing = target._getTransformedDimensions().y;
      target.set('skewX', newSkew);
      compensateScaleForSkew(target, 'skewY', 'scaleY', 'y', dimBeforeSkewing);
      fireEvent('skewing', commonEventInfo(eventData, transform, x, y));
    }
    return hasSkewed;
  }

  /**
   * Action handler for skewing on the Y axis
   * @private
   */
  function skewObjectY(eventData, transform, x, y) {
    var target = transform.target,
        // find how big the object would be, if there was no skewX. takes in account scaling
        dimNoSkew = target._getTransformedDimensions(target.skewX, 0),
        localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        // the mouse is in the center of the object, and we want it to stay there.
        // so the object will grow twice as much as the mouse.
        // this makes the skew growth to localPoint * 2 - dimNoSkew.
        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y,
        currentSkew = target.skewY, newSkew;
    if (totalSkewSize < 2) {
      // let's make it easy to go back to position 0.
      newSkew = 0;
    }
    else {
      newSkew = radiansToDegrees(
        Math.atan2((totalSkewSize / target.scaleY), (dimNoSkew.x / target.scaleX))
      );
      // now we have to find the sign of the skew.
      // it mostly depend on the origin of transformation.
      if (transform.originX === LEFT && transform.originY === BOTTOM) {
        newSkew = -newSkew;
      }
      if (transform.originX === RIGHT && transform.originY === TOP) {
        newSkew = -newSkew;
      }
      if (targetHasOneFlip(target)) {
        newSkew = -newSkew;
      }
    }
    var hasSkewed = currentSkew !== newSkew;
    if (hasSkewed) {
      var dimBeforeSkewing = target._getTransformedDimensions().x;
      target.set('skewY', newSkew);
      compensateScaleForSkew(target, 'skewX', 'scaleX', 'x', dimBeforeSkewing);
      fireEvent('skewing', commonEventInfo(eventData, transform, x, y));
    }
    return hasSkewed;
  }

  /**
   * Wrapped Action handler for skewing on the Y axis, takes care of the
   * skew direction and determine the correct transform origin for the anchor point
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function skewHandlerX(eventData, transform, x, y) {
    // step1 figure out and change transform origin.
    // if skewX > 0 and originY bottom we anchor on right
    // if skewX > 0 and originY top we anchor on left
    // if skewX < 0 and originY bottom we anchor on left
    // if skewX < 0 and originY top we anchor on right
    // if skewX is 0, we look for mouse position to understand where are we going.
    var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;
    if (target.lockSkewingX) {
      return false;
    }
    if (currentSkew === 0) {
      var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);
      if (localPointFromCenter.x > 0) {
        // we are pulling right, anchor left;
        originX = LEFT;
      }
      else {
        // we are pulling right, anchor right
        originX = RIGHT;
      }
    }
    else {
      if (currentSkew > 0) {
        originX = originY === TOP ? LEFT : RIGHT;
      }
      if (currentSkew < 0) {
        originX = originY === TOP ? RIGHT : LEFT;
      }
      // is the object flipped on one side only? swap the origin.
      if (targetHasOneFlip(target)) {
        originX = originX === LEFT ? RIGHT : LEFT;
      }
    }

    // once we have the origin, we find the anchor point
    transform.originX = originX;
    var finalHandler = wrapWithFixedAnchor(skewObjectX);
    return finalHandler(eventData, transform, x, y);
  }

  /**
   * Wrapped Action handler for skewing on the Y axis, takes care of the
   * skew direction and determine the correct transform origin for the anchor point
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function skewHandlerY(eventData, transform, x, y) {
    // step1 figure out and change transform origin.
    // if skewY > 0 and originX left we anchor on top
    // if skewY > 0 and originX right we anchor on bottom
    // if skewY < 0 and originX left we anchor on bottom
    // if skewY < 0 and originX right we anchor on top
    // if skewY is 0, we look for mouse position to understand where are we going.
    var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;
    if (target.lockSkewingY) {
      return false;
    }
    if (currentSkew === 0) {
      var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);
      if (localPointFromCenter.y > 0) {
        // we are pulling down, anchor up;
        originY = TOP;
      }
      else {
        // we are pulling up, anchor down
        originY = BOTTOM;
      }
    }
    else {
      if (currentSkew > 0) {
        originY = originX === LEFT ? TOP : BOTTOM;
      }
      if (currentSkew < 0) {
        originY = originX === LEFT ? BOTTOM : TOP;
      }
      // is the object flipped on one side only? swap the origin.
      if (targetHasOneFlip(target)) {
        originY = originY === TOP ? BOTTOM : TOP;
      }
    }

    // once we have the origin, we find the anchor point
    transform.originY = originY;
    var finalHandler = wrapWithFixedAnchor(skewObjectY);
    return finalHandler(eventData, transform, x, y);
  }

  /**
   * Action handler for rotation and snapping, without anchor point.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   * @private
   */
  function rotationWithSnapping(eventData, transform, x, y) {
    var t = transform,
        target = t.target,
        pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);

    if (target.lockRotation) {
      return false;
    }

    var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x),
        curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x),
        angle = radiansToDegrees(curAngle - lastAngle + t.theta),
        hasRotated = true;

    if (target.snapAngle > 0) {
      var snapAngle  = target.snapAngle,
          snapThreshold  = target.snapThreshold || snapAngle,
          rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
          leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

      if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
        angle = leftAngleLocked;
      }
      else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
        angle = rightAngleLocked;
      }
    }

    // normalize angle to positive value
    if (angle < 0) {
      angle = 360 + angle;
    }
    angle %= 360;

    hasRotated = target.angle !== angle;
    target.angle = angle;
    if (hasRotated) {
      fireEvent('rotating', commonEventInfo(eventData, transform, x, y));
    }
    return hasRotated;
  }

  /**
   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @param {Object} options additional information for scaling
   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling
   * @return {Boolean} true if some change happened
   * @private
   */
  function scaleObject(eventData, transform, x, y, options) {
    options = options || {};
    var target = transform.target,
        lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY,
        by = options.by, newPoint, scaleX, scaleY, dim,
        scaleProportionally = scaleIsProportional(eventData, target),
        forbidScaling = scalingIsForbidden(target, by, scaleProportionally),
        signX, signY, gestureScale = transform.gestureScale;

    if (forbidScaling) {
      return false;
    }
    if (gestureScale) {
      scaleX = transform.scaleX * gestureScale;
      scaleY = transform.scaleY * gestureScale;
    }
    else {
      newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);
      // use of sign: We use sign to detect change of direction of an action. sign usually change when
      // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling
      // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily
      // cross many time the origin point and flip the object. so we need a way to filter out the noise.
      // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.
      signX = by !== 'y' ? sign(newPoint.x) : 1;
      signY = by !== 'x' ? sign(newPoint.y) : 1;
      if (!transform.signX) {
        transform.signX = signX;
      }
      if (!transform.signY) {
        transform.signY = signY;
      }

      if (target.lockScalingFlip &&
        (transform.signX !== signX || transform.signY !== signY)
      ) {
        return false;
      }

      dim = target._getTransformedDimensions();
      // missing detection of flip and logic to switch the origin
      if (scaleProportionally && !by) {
        // uniform scaling
        var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y),
            original = transform.original,
            originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) +
              Math.abs(dim.y * original.scaleY / target.scaleY),
            scale = distance / originalDistance, hasScaled;
        scaleX = original.scaleX * scale;
        scaleY = original.scaleY * scale;
      }
      else {
        scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);
        scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);
      }
      // if we are scaling by center, we need to double the scale
      if (isTransformCentered(transform)) {
        scaleX *= 2;
        scaleY *= 2;
      }
      if (transform.signX !== signX && by !== 'y') {
        transform.originX = opposite[transform.originX];
        scaleX *= -1;
        transform.signX = signX;
      }
      if (transform.signY !== signY && by !== 'x') {
        transform.originY = opposite[transform.originY];
        scaleY *= -1;
        transform.signY = signY;
      }
    }
    // minScale is taken are in the setter.
    var oldScaleX = target.scaleX, oldScaleY = target.scaleY;
    if (!by) {
      !lockScalingX && target.set('scaleX', scaleX);
      !lockScalingY && target.set('scaleY', scaleY);
    }
    else {
      // forbidden cases already handled on top here.
      by === 'x' && target.set('scaleX', scaleX);
      by === 'y' && target.set('scaleY', scaleY);
    }
    hasScaled = oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;
    if (hasScaled) {
      fireEvent('scaling', commonEventInfo(eventData, transform, x, y));
    }
    return hasScaled;
  }

  /**
   * Generic scaling logic, to scale from corners either equally or freely.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectFromCorner(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y);
  }

  /**
   * Scaling logic for the X axis.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectX(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y , { by: 'x' });
  }

  /**
   * Scaling logic for the Y axis.
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scaleObjectY(eventData, transform, x, y) {
    return scaleObject(eventData, transform, x, y , { by: 'y' });
  }

  /**
   * Composed action handler to either scale Y or skew X
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scalingYOrSkewingX(eventData, transform, x, y) {
    // ok some safety needed here.
    if (eventData[transform.target.canvas.altActionKey]) {
      return controls.skewHandlerX(eventData, transform, x, y);
    }
    return controls.scalingY(eventData, transform, x, y);
  }

  /**
   * Composed action handler to either scale X or skew Y
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function scalingXOrSkewingY(eventData, transform, x, y) {
    // ok some safety needed here.
    if (eventData[transform.target.canvas.altActionKey]) {
      return controls.skewHandlerY(eventData, transform, x, y);
    }
    return controls.scalingX(eventData, transform, x, y);
  }

  /**
   * Action handler to change textbox width
   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if some change happened
   */
  function changeWidth(eventData, transform, x, y) {
    var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y),
        strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1),
        multiplier = isTransformCentered(transform) ? 2 : 1,
        oldWidth = target.width, hasResized,
        newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;
    target.set('width', Math.max(newWidth, 0));
    hasResized = oldWidth !== newWidth;
    if (hasResized) {
      fireEvent('resizing', commonEventInfo(eventData, transform, x, y));
    }
    return hasResized;
  }

  /**
   * Action handler
   * @private
   * @param {Event} eventData javascript event that is doing the transform
   * @param {Object} transform javascript object containing a series of information around the current transform
   * @param {number} x current mouse x position, canvas normalized
   * @param {number} y current mouse y position, canvas normalized
   * @return {Boolean} true if the translation occurred
   */
  function dragHandler(eventData, transform, x, y) {
    var target = transform.target,
        newLeft = x - transform.offsetX,
        newTop = y - transform.offsetY,
        moveX = !target.get('lockMovementX') && target.left !== newLeft,
        moveY = !target.get('lockMovementY') && target.top !== newTop;
    moveX && target.set('left', newLeft);
    moveY && target.set('top', newTop);
    if (moveX || moveY) {
      fireEvent('moving', commonEventInfo(eventData, transform, x, y));
    }
    return moveX || moveY;
  }

  controls.scaleCursorStyleHandler = scaleCursorStyleHandler;
  controls.skewCursorStyleHandler = skewCursorStyleHandler;
  controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;
  controls.rotationWithSnapping = wrapWithFixedAnchor(rotationWithSnapping);
  controls.scalingEqually = wrapWithFixedAnchor(scaleObjectFromCorner);
  controls.scalingX = wrapWithFixedAnchor(scaleObjectX);
  controls.scalingY = wrapWithFixedAnchor(scaleObjectY);
  controls.scalingYOrSkewingX = scalingYOrSkewingX;
  controls.scalingXOrSkewingY = scalingXOrSkewingY;
  controls.changeWidth = wrapWithFixedAnchor(changeWidth);
  controls.skewHandlerX = skewHandlerX;
  controls.skewHandlerY = skewHandlerY;
  controls.dragHandler = dragHandler;
  controls.scaleOrSkewActionName = scaleOrSkewActionName;
  controls.rotationStyleHandler = rotationStyleHandler;
  controls.fireEvent = fireEvent;
  controls.wrapWithFixedAnchor = wrapWithFixedAnchor;
  controls.getLocalPoint = getLocalPoint;
  fabric.controlsUtils = controls;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      degreesToRadians = fabric.util.degreesToRadians,
      controls = fabric.controlsUtils;

  /**
   * Render a round control, as per fabric features.
   * This function is written to respect object properties like transparentCorners, cornerSize
   * cornerColor, cornerStrokeColor
   * plus the addition of offsetY and offsetX.
   * @param {CanvasRenderingContext2D} ctx context to render on
   * @param {Number} left x coordinate where the control center should be
   * @param {Number} top y coordinate where the control center should be
   * @param {Object} styleOverride override for fabric.Object controls style
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   */
  function renderCircleControl (ctx, left, top, styleOverride, fabricObject) {
    styleOverride = styleOverride || {};
    var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,
        ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,
        transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
          styleOverride.transparentCorners : this.transparentCorners,
        methodName = transparentCorners ? 'stroke' : 'fill',
        stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor),
        myLeft = left,
        myTop = top, size;
    ctx.save();
    ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
    ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
    // as soon as fabric react v5, remove ie11, use proper ellipse code.
    if (xSize > ySize) {
      size = xSize;
      ctx.scale(1.0, ySize / xSize);
      myTop = top * xSize / ySize;
    }
    else if (ySize > xSize) {
      size = ySize;
      ctx.scale(xSize / ySize, 1.0);
      myLeft = left * ySize / xSize;
    }
    else {
      size = xSize;
    }
    // this is still wrong
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);
    ctx[methodName]();
    if (stroke) {
      ctx.stroke();
    }
    ctx.restore();
  }

  /**
   * Render a square control, as per fabric features.
   * This function is written to respect object properties like transparentCorners, cornerSize
   * cornerColor, cornerStrokeColor
   * plus the addition of offsetY and offsetX.
   * @param {CanvasRenderingContext2D} ctx context to render on
   * @param {Number} left x coordinate where the control center should be
   * @param {Number} top y coordinate where the control center should be
   * @param {Object} styleOverride override for fabric.Object controls style
   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls
   */
  function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {
    styleOverride = styleOverride || {};
    var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,
        ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,
        transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
          styleOverride.transparentCorners : fabricObject.transparentCorners,
        methodName = transparentCorners ? 'stroke' : 'fill',
        stroke = !transparentCorners && (
          styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor
        ), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;
    ctx.save();
    ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
    ctx.strokeStyle = styleOverride.strokeCornerColor || fabricObject.strokeCornerColor;
    // this is still wrong
    ctx.lineWidth = 1;
    ctx.translate(left, top);
    ctx.rotate(degreesToRadians(fabricObject.angle));
    // this does not work, and fixed with ( && ) does not make sense.
    // to have real transparent corners we need the controls on upperCanvas
    // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
    ctx[methodName + 'Rect'](-xSizeBy2, -ySizeBy2, xSize, ySize);
    if (stroke) {
      ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
    }
    ctx.restore();
  }

  controls.renderCircleControl = renderCircleControl;
  controls.renderSquareControl = renderSquareControl;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  function Control(options) {
    for (var i in options) {
      this[i] = options[i];
    }
  }

  fabric.Control = Control;

  fabric.Control.prototype = /** @lends fabric.Control.prototype */ {

    /**
     * keep track of control visibility.
     * mainly for backward compatibility.
     * if you do not want to see a control, you can remove it
     * from the controlset.
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * Name of the action that the control will likely execute.
     * This is optional. FabricJS uses to identify what the user is doing for some
     * extra optimizations. If you are writing a custom control and you want to know
     * somewhere else in the code what is going on, you can use this string here.
     * you can also provide a custom getActionName if your control run multiple actions
     * depending on some external state.
     * default to scale since is the most common, used on 4 corners by default
     * @type {String}
     * @default 'scale'
     */
    actionName: 'scale',

    /**
     * Drawing angle of the control.
     * NOT used for now, but name marked as needed for internal logic
     * example: to reuse the same drawing function for different rotated controls
     * @type {Number}
     * @default 0
     */
    angle: 0,

    /**
     * Relative position of the control. X
     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    x: 0,

    /**
     * Relative position of the control. Y
     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    y: 0,

    /**
     * Horizontal offset of the control from the defined position. In pixels
     * Positive offset moves the control to the right, negative to the left.
     * It used when you want to have position of control that does not scale with
     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on
     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will
     * stay 30 pixels no matter how the object is big. Another example is having 2
     * controls in the corner, that stay in the same position when the object scale.
     * of the bounding box.
     * @type {Number}
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset of the control from the defined position. In pixels
     * Positive offset moves the control to the bottom, negative to the top.
     * @type {Number}
     * @default 0
     */
    offsetY: 0,

    /**
     * Sets the length of the control. If null, defaults to object's cornerSize.
     * Expects both sizeX and sizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    sizeX: null,

    /**
     * Sets the height of the control. If null, defaults to object's cornerSize.
     * Expects both sizeX and sizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    sizeY: null,

    /**
     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.
     * Expects both touchSizeX and touchSizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    touchSizeX: null,

    /**
     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.
     * Expects both touchSizeX and touchSizeY to be set when set.
     * @type {?Number}
     * @default null
     */
    touchSizeY: null,

    /**
     * Css cursor style to display when the control is hovered.
     * if the method `cursorStyleHandler` is provided, this property is ignored.
     * @type {String}
     * @default 'crosshair'
     */
    cursorStyle: 'crosshair',

    /**
     * If controls has an offsetY or offsetX, draw a line that connects
     * the control to the bounding box
     * @type {Boolean}
     * @default false
     */
    withConnection: false,

    /**
     * The control actionHandler, provide one to handle action ( control being moved )
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    actionHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * The control handler for mouse down, provide one to handle mouse down on control
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    mouseDownHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * The control mouseUpHandler, provide one to handle an effect on mouse up.
     * @param {Event} eventData the native mouse event
     * @param {Object} transformData properties of the current transform
     * @param {Number} x x position of the cursor
     * @param {Number} y y position of the cursor
     * @return {Boolean} true if the action/event modified the object
     */
    mouseUpHandler: function(/* eventData, transformData, x, y */) { },

    /**
     * Returns control actionHandler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getActionHandler: function(/* eventData, fabricObject, control */) {
      return this.actionHandler;
    },

    /**
     * Returns control mouseDown handler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getMouseDownHandler: function(/* eventData, fabricObject, control */) {
      return this.mouseDownHandler;
    },

    /**
     * Returns control mouseUp handler
     * @param {Event} eventData the native mouse event
     * @param {fabric.Object} fabricObject on which the control is displayed
     * @param {fabric.Control} control control for which the action handler is being asked
     * @return {Function} the action handler
     */
    getMouseUpHandler: function(/* eventData, fabricObject, control */) {
      return this.mouseUpHandler;
    },

    /**
     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate
     * function you can pass one in the constructor
     * the cursorStyle property
     * @param {Event} eventData the native mouse event
     * @param {fabric.Control} control the current control ( likely this)
     * @param {fabric.Object} object on which the control is displayed
     * @return {String}
     */
    cursorStyleHandler: function(eventData, control /* fabricObject */) {
      return control.cursorStyle;
    },

    /**
     * Returns the action name. The basic implementation just return the actionName property.
     * @param {Event} eventData the native mouse event
     * @param {fabric.Control} control the current control ( likely this)
     * @param {fabric.Object} object on which the control is displayed
     * @return {String}
     */
    getActionName: function(eventData, control /* fabricObject */) {
      return control.actionName;
    },

    /**
     * Returns controls visibility
     * @param {fabric.Object} object on which the control is displayed
     * @param {String} controlKey key where the control is memorized on the
     * @return {Boolean}
     */
    getVisibility: function(fabricObject, controlKey) {
      var objectVisibility = fabricObject._controlsVisibility;
      if (objectVisibility && typeof objectVisibility[controlKey] !== 'undefined') {
        return objectVisibility[controlKey];
      }
      return this.visible;
    },

    /**
     * Sets controls visibility
     * @param {Boolean} visibility for the object
     * @return {Void}
     */
    setVisibility: function(visibility /* name, fabricObject */) {
      this.visible = visibility;
    },


    positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */) {
      var point = fabric.util.transformPoint({
        x: this.x * dim.x + this.offsetX,
        y: this.y * dim.y + this.offsetY }, finalMatrix);
      return point;
    },

    /**
     * Returns the coords for this control based on object values.
     * @param {Number} objectAngle angle from the fabric object holding the control
     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if
     *   isTouch is true)
     * @param {Number} centerX x coordinate where the control center should be
     * @param {Number} centerY y coordinate where the control center should be
     * @param {boolean} isTouch true if touch corner, false if normal corner
     */
    calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {
      var cosHalfOffset,
          sinHalfOffset,
          cosHalfOffsetComp,
          sinHalfOffsetComp,
          xSize = (isTouch) ? this.touchSizeX : this.sizeX,
          ySize = (isTouch) ? this.touchSizeY : this.sizeY;
      if (xSize && ySize && xSize !== ySize) {
        // handle rectangular corners
        var controlTriangleAngle = Math.atan2(ySize, xSize);
        var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;
        var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);
        var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);
        cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);
        sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);
        // use complementary angle for two corners
        cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);
        sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);
      }
      else {
        // handle square corners
        // use default object corner size unless size is defined
        var cornerSize = (xSize && ySize) ? xSize : objectCornerSize;
        /* 0.7071067812 stands for sqrt(2)/2 */
        cornerHypotenuse = cornerSize * 0.7071067812;
        // complementary angles are equal since they're both 45 degrees
        var newTheta = fabric.util.degreesToRadians(45 - objectAngle);
        cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);
        sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);
      }

      return {
        tl: {
          x: centerX - sinHalfOffsetComp,
          y: centerY - cosHalfOffsetComp,
        },
        tr: {
          x: centerX + cosHalfOffset,
          y: centerY - sinHalfOffset,
        },
        bl: {
          x: centerX - cosHalfOffset,
          y: centerY + sinHalfOffset,
        },
        br: {
          x: centerX + sinHalfOffsetComp,
          y: centerY + cosHalfOffsetComp,
        },
      };
    },

    /**
    * Render function for the control.
    * When this function runs the context is unscaled. unrotate. Just retina scaled.
    * all the functions will have to translate to the point left,top before starting Drawing
    * if they want to draw a control where the position is detected.
    * left and top are the result of the positionHandler function
    * @param {RenderingContext2D} ctx the context where the control will be drawn
    * @param {Number} left position of the canvas where we are about to render the control.
    * @param {Number} top position of the canvas where we are about to render the control.
    * @param {Object} styleOverride
    * @param {fabric.Object} fabricObject the object where the control is about to be rendered
    */
    render: function(ctx, left, top, styleOverride, fabricObject) {
      styleOverride = styleOverride || {};
      switch (styleOverride.cornerStyle || fabricObject.cornerStyle) {
        case 'circle':
          fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);
          break;
        default:
          fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);
      }
    },
  };

})( true ? exports : 0);


(function() {

  /* _FROM_SVG_START_ */
  function getColorStop(el, multiplier) {
    var style = el.getAttribute('style'),
        offset = el.getAttribute('offset') || 0,
        color, colorAlpha, opacity, i;

    // convert percents to absolute values
    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
    if (style) {
      var keyValuePairs = style.split(/\s*;\s*/);

      if (keyValuePairs[keyValuePairs.length - 1] === '') {
        keyValuePairs.pop();
      }

      for (i = keyValuePairs.length; i--; ) {

        var split = keyValuePairs[i].split(/\s*:\s*/),
            key = split[0].trim(),
            value = split[1].trim();

        if (key === 'stop-color') {
          color = value;
        }
        else if (key === 'stop-opacity') {
          opacity = value;
        }
      }
    }

    if (!color) {
      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
    }
    if (!opacity) {
      opacity = el.getAttribute('stop-opacity');
    }

    color = new fabric.Color(color);
    colorAlpha = color.getAlpha();
    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
    opacity *= colorAlpha * multiplier;

    return {
      offset: offset,
      color: color.toRgb(),
      opacity: opacity
    };
  }

  function getLinearCoords(el) {
    return {
      x1: el.getAttribute('x1') || 0,
      y1: el.getAttribute('y1') || 0,
      x2: el.getAttribute('x2') || '100%',
      y2: el.getAttribute('y2') || 0
    };
  }

  function getRadialCoords(el) {
    return {
      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
      r1: 0,
      x2: el.getAttribute('cx') || '50%',
      y2: el.getAttribute('cy') || '50%',
      r2: el.getAttribute('r') || '50%'
    };
  }
  /* _FROM_SVG_END_ */

  var clone = fabric.util.object.clone;

  /**
   * Gradient class
   * @class fabric.Gradient
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
   * @see {@link fabric.Gradient#initialize} for constructor definition
   */
  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

    /**
     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetY: 0,

    /**
     * A transform matrix to apply to the gradient before painting.
     * Imported from svg gradients, is not applied with the current transform in the center.
     * Before this transform is applied, the origin point is at the top left corner of the object
     * plus the addition of offsetY and offsetX.
     * @type Number[]
     * @default null
     */
    gradientTransform: null,

    /**
     * coordinates units for coords.
     * If `pixels`, the number of coords are in the same unit of width / height.
     * If set as `percentage` the coords are still a number, but 1 means 100% of width
     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.
     * allowed values pixels or percentage.
     * @type String
     * @default 'pixels'
     */
    gradientUnits: 'pixels',

    /**
     * Gradient type linear or radial
     * @type String
     * @default 'pixels'
     */
    type: 'linear',

    /**
     * Constructor
     * @param {Object} options Options object with type, coords, gradientUnits and colorStops
     * @param {Object} [options.type] gradient type linear or radial
     * @param {Object} [options.gradientUnits] gradient units
     * @param {Object} [options.offsetX] SVG import compatibility
     * @param {Object} [options.offsetY] SVG import compatibility
     * @param {Object[]} options.colorStops contains the colorstops.
     * @param {Object} options.coords contains the coords of the gradient
     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial
     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial
     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial
     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial
     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle
     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle
     * @return {fabric.Gradient} thisArg
     */
    initialize: function(options) {
      options || (options = { });
      options.coords || (options.coords = { });

      var coords, _this = this;

      // sets everything, then coords and colorstops get sets again
      Object.keys(options).forEach(function(option) {
        _this[option] = options[option];
      });

      if (this.id) {
        this.id += '_' + fabric.Object.__uid++;
      }
      else {
        this.id = fabric.Object.__uid++;
      }

      coords = {
        x1: options.coords.x1 || 0,
        y1: options.coords.y1 || 0,
        x2: options.coords.x2 || 0,
        y2: options.coords.y2 || 0
      };

      if (this.type === 'radial') {
        coords.r1 = options.coords.r1 || 0;
        coords.r2 = options.coords.r2 || 0;
      }

      this.coords = coords;
      this.colorStops = options.colorStops.slice();
    },

    /**
     * Adds another colorStop
     * @param {Object} colorStop Object with offset and color
     * @return {fabric.Gradient} thisArg
     */
    addColorStop: function(colorStops) {
      for (var position in colorStops) {
        var color = new fabric.Color(colorStops[position]);
        this.colorStops.push({
          offset: parseFloat(position),
          color: color.toRgb(),
          opacity: color.getAlpha()
        });
      }
      return this;
    },

    /**
     * Returns object representation of a gradient
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object}
     */
    toObject: function(propertiesToInclude) {
      var object = {
        type: this.type,
        coords: this.coords,
        colorStops: this.colorStops,
        offsetX: this.offsetX,
        offsetY: this.offsetY,
        gradientUnits: this.gradientUnits,
        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an gradient
     * @param {Object} object Object to create a gradient for
     * @return {String} SVG representation of an gradient (linear/radial)
     */
    toSVG: function(object, options) {
      var coords = clone(this.coords, true), i, len, options = options || {},
          markup, commonAttributes, colorStops = clone(this.colorStops, true),
          needsSwap = coords.r1 > coords.r2,
          transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(),
          offsetX = -this.offsetX, offsetY = -this.offsetY,
          withViewport = !!options.additionalTransform,
          gradientUnits = this.gradientUnits === 'pixels' ? 'userSpaceOnUse' : 'objectBoundingBox';
      // colorStops must be sorted ascending
      colorStops.sort(function(a, b) {
        return a.offset - b.offset;
      });

      if (gradientUnits === 'objectBoundingBox') {
        offsetX /= object.width;
        offsetY /= object.height;
      }
      else {
        offsetX += object.width / 2;
        offsetY += object.height / 2;
      }
      if (object.type === 'path' && this.gradientUnits !== 'percentage') {
        offsetX -= object.pathOffset.x;
        offsetY -= object.pathOffset.y;
      }


      transform[4] -= offsetX;
      transform[5] -= offsetY;

      commonAttributes = 'id="SVGID_' + this.id +
                     '" gradientUnits="' + gradientUnits + '"';
      commonAttributes += ' gradientTransform="' + (withViewport ?
        options.additionalTransform + ' ' : '') + fabric.util.matrixToSVG(transform) + '" ';

      if (this.type === 'linear') {
        markup = [
          '<linearGradient ',
          commonAttributes,
          ' x1="', coords.x1,
          '" y1="', coords.y1,
          '" x2="', coords.x2,
          '" y2="', coords.y2,
          '">\n'
        ];
      }
      else if (this.type === 'radial') {
        // svg radial gradient has just 1 radius. the biggest.
        markup = [
          '<radialGradient ',
          commonAttributes,
          ' cx="', needsSwap ? coords.x1 : coords.x2,
          '" cy="', needsSwap ? coords.y1 : coords.y2,
          '" r="', needsSwap ? coords.r1 : coords.r2,
          '" fx="', needsSwap ? coords.x2 : coords.x1,
          '" fy="', needsSwap ? coords.y2 : coords.y1,
          '">\n'
        ];
      }

      if (this.type === 'radial') {
        if (needsSwap) {
          // svg goes from internal to external radius. if radius are inverted, swap color stops.
          colorStops = colorStops.concat();
          colorStops.reverse();
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset = 1 - colorStops[i].offset;
          }
        }
        var minRadius = Math.min(coords.r1, coords.r2);
        if (minRadius > 0) {
          // i have to shift all colorStops and add new one in 0.
          var maxRadius = Math.max(coords.r1, coords.r2),
              percentageShift = minRadius / maxRadius;
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
          }
        }
      }

      for (i = 0, len = colorStops.length; i < len; i++) {
        var colorStop = colorStops[i];
        markup.push(
          '<stop ',
          'offset="', (colorStop.offset * 100) + '%',
          '" style="stop-color:', colorStop.color,
          (typeof colorStop.opacity !== 'undefined' ? ';stop-opacity: ' + colorStop.opacity : ';'),
          '"/>\n'
        );
      }

      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

      return markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns an instance of CanvasGradient
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {CanvasGradient}
     */
    toLive: function(ctx) {
      var gradient, coords = fabric.util.object.clone(this.coords), i, len;

      if (!this.type) {
        return;
      }

      if (this.type === 'linear') {
        gradient = ctx.createLinearGradient(
          coords.x1, coords.y1, coords.x2, coords.y2);
      }
      else if (this.type === 'radial') {
        gradient = ctx.createRadialGradient(
          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
      }

      for (i = 0, len = this.colorStops.length; i < len; i++) {
        var color = this.colorStops[i].color,
            opacity = this.colorStops[i].opacity,
            offset = this.colorStops[i].offset;

        if (typeof opacity !== 'undefined') {
          color = new fabric.Color(color).setAlpha(opacity).toRgba();
        }
        gradient.addColorStop(offset, color);
      }

      return gradient;
    }
  });

  fabric.util.object.extend(fabric.Gradient, {

    /* _FROM_SVG_START_ */
    /**
     * Returns {@link fabric.Gradient} instance from an SVG element
     * @static
     * @memberOf fabric.Gradient
     * @param {SVGGradientElement} el SVG gradient element
     * @param {fabric.Object} instance
     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.
     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients
     * that uses gradientUnits as 'userSpaceOnUse' and percentages.
     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg
     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg
     * @param {Object.number} width width part of the svg tag if viewBox is not specified
     * @param {Object.number} height height part of the svg tag if viewBox is not specified
     * @return {fabric.Gradient} Gradient instance
     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
     */
    fromElement: function(el, instance, opacityAttr, svgOptions) {
      /**
       *  @example:
       *
       *  <linearGradient id="linearGrad1">
       *    <stop offset="0%" stop-color="white"/>
       *    <stop offset="100%" stop-color="black"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <linearGradient id="linearGrad2">
       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad1">
       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
       *  </radialGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad2">
       *    <stop offset="0" stop-color="rgb(255,255,255)" />
       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
       *    <stop offset="1" stop-color="rgb(255,255,255)" />
       *  </radialGradient>
       *
       */

      var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);
      multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;
      if (isNaN(multiplier)) {
        multiplier = 1;
      }

      var colorStopEls = el.getElementsByTagName('stop'),
          type,
          gradientUnits = el.getAttribute('gradientUnits') === 'userSpaceOnUse' ?
            'pixels' : 'percentage',
          gradientTransform = el.getAttribute('gradientTransform') || '',
          colorStops = [],
          coords, i, offsetX = 0, offsetY = 0,
          transformMatrix;
      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
        type = 'linear';
        coords = getLinearCoords(el);
      }
      else {
        type = 'radial';
        coords = getRadialCoords(el);
      }

      for (i = colorStopEls.length; i--; ) {
        colorStops.push(getColorStop(colorStopEls[i], multiplier));
      }

      transformMatrix = fabric.parseTransformAttribute(gradientTransform);

      __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);

      if (gradientUnits === 'pixels') {
        offsetX = -instance.left;
        offsetY = -instance.top;
      }

      var gradient = new fabric.Gradient({
        id: el.getAttribute('id'),
        type: type,
        coords: coords,
        colorStops: colorStops,
        gradientUnits: gradientUnits,
        gradientTransform: transformMatrix,
        offsetX: offsetX,
        offsetY: offsetY,
      });

      return gradient;
    }
    /* _FROM_SVG_END_ */
  });

  /**
   * @private
   */
  function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {
    var propValue, finalValue;
    Object.keys(options).forEach(function(prop) {
      propValue = options[prop];
      if (propValue === 'Infinity') {
        finalValue = 1;
      }
      else if (propValue === '-Infinity') {
        finalValue = 0;
      }
      else {
        finalValue = parseFloat(options[prop], 10);
        if (typeof propValue === 'string' && /^(\d+\.\d+)%|(\d+)%$/.test(propValue)) {
          finalValue *= 0.01;
          if (gradientUnits === 'pixels') {
            // then we need to fix those percentages here in svg parsing
            if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
              finalValue *= svgOptions.viewBoxWidth || svgOptions.width;
            }
            if (prop === 'y1' || prop === 'y2') {
              finalValue *= svgOptions.viewBoxHeight || svgOptions.height;
            }
          }
        }
      }
      options[prop] = finalValue;
    });
  }
})();


(function() {

  'use strict';

  var toFixed = fabric.util.toFixed;

  /**
   * Pattern class
   * @class fabric.Pattern
   * @see {@link http://fabricjs.com/patterns|Pattern demo}
   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
   * @see {@link fabric.Pattern#initialize} for constructor definition
   */


  fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

    /**
     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     * @type String
     * @default
     */
    repeat: 'repeat',

    /**
     * Pattern horizontal offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Pattern vertical offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @type String
     * @default
     */
    crossOrigin: '',

    /**
     * transform matrix to change the pattern, imported from svgs.
     * @type Array
     * @default
     */
    patternTransform: null,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @param {Function} [callback] function to invoke after callback init.
     * @return {fabric.Pattern} thisArg
     */
    initialize: function(options, callback) {
      options || (options = { });

      this.id = fabric.Object.__uid++;
      this.setOptions(options);
      if (!options.source || (options.source && typeof options.source !== 'string')) {
        callback && callback(this);
        return;
      }
      else {
        // img src string
        var _this = this;
        this.source = fabric.util.createImage();
        fabric.util.loadImage(options.source, function(img, isError) {
          _this.source = img;
          callback && callback(_this, isError);
        }, null, this.crossOrigin);
      }
    },

    /**
     * Returns object representation of a pattern
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of a pattern instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          source, object;

      // <img> element
      if (typeof this.source.src === 'string') {
        source = this.source.src;
      }
      // <canvas> element
      else if (typeof this.source === 'object' && this.source.toDataURL) {
        source = this.source.toDataURL();
      }

      object = {
        type: 'pattern',
        source: source,
        repeat: this.repeat,
        crossOrigin: this.crossOrigin,
        offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
        offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
        patternTransform: this.patternTransform ? this.patternTransform.concat() : null
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a pattern
     * @param {fabric.Object} object
     * @return {String} SVG representation of a pattern
     */
    toSVG: function(object) {
      var patternSource = typeof this.source === 'function' ? this.source() : this.source,
          patternWidth = patternSource.width / object.width,
          patternHeight = patternSource.height / object.height,
          patternOffsetX = this.offsetX / object.width,
          patternOffsetY = this.offsetY / object.height,
          patternImgSrc = '';
      if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
        patternHeight = 1;
        if (patternOffsetY) {
          patternHeight += Math.abs(patternOffsetY);
        }
      }
      if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
        patternWidth = 1;
        if (patternOffsetX) {
          patternWidth += Math.abs(patternOffsetX);
        }

      }
      if (patternSource.src) {
        patternImgSrc = patternSource.src;
      }
      else if (patternSource.toDataURL) {
        patternImgSrc = patternSource.toDataURL();
      }

      return '<pattern id="SVGID_' + this.id +
                    '" x="' + patternOffsetX +
                    '" y="' + patternOffsetY +
                    '" width="' + patternWidth +
                    '" height="' + patternHeight + '">\n' +
               '<image x="0" y="0"' +
                      ' width="' + patternSource.width +
                      '" height="' + patternSource.height +
                      '" xlink:href="' + patternImgSrc +
               '"></image>\n' +
             '</pattern>\n';
    },
    /* _TO_SVG_END_ */

    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Returns an instance of CanvasPattern
     * @param {CanvasRenderingContext2D} ctx Context to create pattern
     * @return {CanvasPattern}
     */
    toLive: function(ctx) {
      var source = this.source;
      // if the image failed to load, return, and allow rest to continue loading
      if (!source) {
        return '';
      }

      // if an image
      if (typeof source.src !== 'undefined') {
        if (!source.complete) {
          return '';
        }
        if (source.naturalWidth === 0 || source.naturalHeight === 0) {
          return '';
        }
      }
      return ctx.createPattern(source, this.repeat);
    }
  });
})();


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      toFixed = fabric.util.toFixed;

  if (fabric.Shadow) {
    fabric.warn('fabric.Shadow is already defined.');
    return;
  }

  /**
   * Shadow class
   * @class fabric.Shadow
   * @see {@link http://fabricjs.com/shadows|Shadow demo}
   * @see {@link fabric.Shadow#initialize} for constructor definition
   */
  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

    /**
     * Shadow color
     * @type String
     * @default
     */
    color: 'rgb(0,0,0)',

    /**
     * Shadow blur
     * @type Number
     */
    blur: 0,

    /**
     * Shadow horizontal offset
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Shadow vertical offset
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * Whether the shadow should affect stroke operations
     * @type Boolean
     * @default
     */
    affectStroke: false,

    /**
     * Indicates whether toObject should include default values
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * When `false`, the shadow will scale with the object.
     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.
     * default to false
     * @type Boolean
     * @default
     */
    nonScaling: false,

    /**
     * Constructor
     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
     * @return {fabric.Shadow} thisArg
     */
    initialize: function(options) {

      if (typeof options === 'string') {
        options = this._parseShadow(options);
      }

      for (var prop in options) {
        this[prop] = options[prop];
      }

      this.id = fabric.Object.__uid++;
    },

    /**
     * @private
     * @param {String} shadow Shadow value to parse
     * @return {Object} Shadow object with color, offsetX, offsetY and blur
     */
    _parseShadow: function(shadow) {
      var shadowStr = shadow.trim(),
          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

      return {
        color: color.trim(),
        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
        blur: parseInt(offsetsAndBlur[3], 10) || 0
      };
    },

    /**
     * Returns a string representation of an instance
     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
     * @return {String} Returns CSS3 text-shadow declaration
     */
    toString: function() {
      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a shadow
     * @param {fabric.Object} object
     * @return {String} SVG representation of a shadow
     */
    toSVG: function(object) {
      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          offset = fabric.util.rotateVector(
            { x: this.offsetX, y: this.offsetY },
            fabric.util.degreesToRadians(-object.angle)),
          BLUR_BOX = 20, color = new fabric.Color(this.color);

      if (object.width && object.height) {
        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
        // we add some extra space to filter box to contain the blur ( 20 )
        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
      }
      if (object.flipX) {
        offset.x *= -1;
      }
      if (object.flipY) {
        offset.y *= -1;
      }

      return (
        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
          '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
          '\t<feFlood flood-color="' + color.toRgb() + '" flood-opacity="' + color.getAlpha() + '"/>\n' +
          '\t<feComposite in2="oBlur" operator="in" />\n' +
          '\t<feMerge>\n' +
            '\t\t<feMergeNode></feMergeNode>\n' +
            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
          '\t</feMerge>\n' +
        '</filter>\n');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns object representation of a shadow
     * @return {Object} Object representation of a shadow instance
     */
    toObject: function() {
      if (this.includeDefaultValues) {
        return {
          color: this.color,
          blur: this.blur,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          affectStroke: this.affectStroke,
          nonScaling: this.nonScaling
        };
      }
      var obj = { }, proto = fabric.Shadow.prototype;

      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke', 'nonScaling'].forEach(function(prop) {
        if (this[prop] !== proto[prop]) {
          obj[prop] = this[prop];
        }
      }, this);

      return obj;
    }
  });

  /**
   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
   * @static
   * @field
   * @memberOf fabric.Shadow
   */
  // eslint-disable-next-line max-len
  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;

})( true ? exports : 0);


(function () {

  'use strict';

  if (fabric.StaticCanvas) {
    fabric.warn('fabric.StaticCanvas is already defined.');
    return;
  }

  // aliases for faster resolution
  var extend = fabric.util.object.extend,
      getElementOffset = fabric.util.getElementOffset,
      removeFromArray = fabric.util.removeFromArray,
      toFixed = fabric.util.toFixed,
      transformPoint = fabric.util.transformPoint,
      invertTransform = fabric.util.invertTransform,
      getNodeCanvas = fabric.util.getNodeCanvas,
      createCanvasElement = fabric.util.createCanvasElement,

      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

  /**
   * Static canvas class
   * @class fabric.StaticCanvas
   * @mixes fabric.Collection
   * @mixes fabric.Observable
   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
   * @fires before:render
   * @fires after:render
   * @fires canvas:cleared
   * @fires object:added
   * @fires object:removed
   */
  fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
    },

    /**
     * Background color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
     * @type {(String|fabric.Pattern)}
     * @default
     */
    backgroundColor: '',

    /**
     * Background image of canvas instance.
     * since 2.4.0 image caching is active, please when putting an image as background, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    backgroundImage: null,

    /**
     * Overlay color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
     * @since 1.3.9
     * @type {(String|fabric.Pattern)}
     * @default
     */
    overlayColor: '',

    /**
     * Overlay image of canvas instance.
     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the
     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
     * vale. As an alternative you can disable image objectCaching
     * @type fabric.Image
     * @default
     */
    overlayImage: null,

    /**
     * Indicates whether toObject/toDatalessObject should include default values
     * if set to false, takes precedence over the object value.
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * Indicates whether objects' state should be saved
     * @type Boolean
     * @default
     */
    stateful: false,

    /**
     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
     * since the renders are quequed and executed one per frame.
     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
     * Left default to true to do not break documentation and old app, fiddles.
     * @type Boolean
     * @default
     */
    renderOnAddRemove: true,

    /**
     * Indicates whether object controls (borders/controls) are rendered above overlay image
     * @type Boolean
     * @default
     */
    controlsAboveOverlay: false,

    /**
     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
     * @type Boolean
     * @default
     */
    allowTouchScrolling: false,

    /**
     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
     * @type Boolean
     * @default
     */
    imageSmoothingEnabled: true,

    /**
     * The transformation (in the format of Canvas transform) which focuses the viewport
     * @type Array
     * @default
     */
    viewportTransform: fabric.iMatrix.concat(),

    /**
     * if set to false background image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    backgroundVpt: true,

    /**
     * if set to false overlya image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    overlayVpt: true,

    /**
     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
     * @type Boolean
     * @default
     */
    enableRetinaScaling: true,

    /**
     * Describe canvas element extension over design
     * properties are tl,tr,bl,br.
     * if canvas is not zoomed/panned those points are the four corner of canvas
     * if canvas is viewportTransformed you those points indicate the extension
     * of canvas element in plain untrasformed coordinates
     * The coordinates get updated with @method calcViewportBoundaries.
     * @memberOf fabric.StaticCanvas.prototype
     */
    vptCoords: { },

    /**
     * Based on vptCoords and object.aCoords, skip rendering of objects that
     * are not included in current viewport.
     * May greatly help in applications with crowded canvas and use of zoom/pan
     * If One of the corner of the bounding box of the object is on the canvas
     * the objects get rendered.
     * @memberOf fabric.StaticCanvas.prototype
     * @type Boolean
     * @default
     */
    skipOffscreen: true,

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the canvas has rendered, and the context is placed in the
     * top left corner of the canvas.
     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * @private
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     */
    _initStatic: function(el, options) {
      var cb = this.requestRenderAllBound;
      this._objects = [];
      this._createLowerCanvas(el);
      this._initOptions(options);
      // only initialize retina scaling once
      if (!this.interactive) {
        this._initRetinaScaling();
      }

      if (options.overlayImage) {
        this.setOverlayImage(options.overlayImage, cb);
      }
      if (options.backgroundImage) {
        this.setBackgroundImage(options.backgroundImage, cb);
      }
      if (options.backgroundColor) {
        this.setBackgroundColor(options.backgroundColor, cb);
      }
      if (options.overlayColor) {
        this.setOverlayColor(options.overlayColor, cb);
      }
      this.calcOffset();
    },

    /**
     * @private
     */
    _isRetinaScaling: function() {
      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
    },

    /**
     * @private
     * @return {Number} retinaScaling if applied, otherwise 1;
     */
    getRetinaScaling: function() {
      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
    },

    /**
     * @private
     */
    _initRetinaScaling: function() {
      if (!this._isRetinaScaling()) {
        return;
      }
      var scaleRatio = fabric.devicePixelRatio;
      this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);
      if (this.upperCanvasEl) {
        this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);
      }
    },

    __initRetinaScaling: function(scaleRatio, canvas, context) {
      canvas.setAttribute('width', this.width * scaleRatio);
      canvas.setAttribute('height', this.height * scaleRatio);
      context.scale(scaleRatio, scaleRatio);
    },


    /**
     * Calculates canvas element offset relative to the document
     * This method is also attached as "resize" event handler of window
     * @return {fabric.Canvas} instance
     * @chainable
     */
    calcOffset: function () {
      this._offset = getElementOffset(this.lowerCanvasEl);
      return this;
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
     * @example <caption>Normal overlayImage with left/top = 0</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage with different properties</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage loaded from cross-origin</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    setOverlayImage: function (image, callback, options) {
      return this.__setBgOverlayImage('overlayImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
     * @param {Function} callback Callback to invoke when image is loaded and set as background
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
     * @example <caption>Normal backgroundImage with left/top = 0</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage with different properties</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage loaded from cross-origin</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    // TODO: fix stretched examples
    setBackgroundImage: function (image, callback, options) {
      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
     * @param {Function} callback Callback to invoke when foreground color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
     * @example <caption>Normal overlayColor - color value</caption>
     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setOverlayColor: function(overlayColor, callback) {
      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
     * @param {Function} callback Callback to invoke when background color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
     * @example <caption>Normal backgroundColor - color value</caption>
     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setBackgroundColor: function(backgroundColor, callback) {
      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
     */
    __setBgOverlayImage: function(property, image, callback, options) {
      if (typeof image === 'string') {
        fabric.util.loadImage(image, function(img, isError) {
          if (img) {
            var instance = new fabric.Image(img, options);
            this[property] = instance;
            instance.canvas = this;
          }
          callback && callback(img, isError);
        }, this, options && options.crossOrigin);
      }
      else {
        options && image.setOptions(options);
        this[property] = image;
        image && (image.canvas = this);
        callback && callback(image, false);
      }

      return this;
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
     * @param {(Object|String|null)} color Object with pattern information, color value or null
     * @param {Function} [callback] Callback is invoked when color is set
     */
    __setBgOverlayColor: function(property, color, callback) {
      this[property] = color;
      this._initGradient(color, property);
      this._initPattern(color, property, callback);
      return this;
    },

    /**
     * @private
     */
    _createCanvasElement: function() {
      var element = createCanvasElement();
      if (!element) {
        throw CANVAS_INIT_ERROR;
      }
      if (!element.style) {
        element.style = { };
      }
      if (typeof element.getContext === 'undefined') {
        throw CANVAS_INIT_ERROR;
      }
      return element;
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initOptions: function (options) {
      var lowerCanvasEl = this.lowerCanvasEl;
      this._setOptions(options);

      this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;
      this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;

      if (!this.lowerCanvasEl.style) {
        return;
      }

      lowerCanvasEl.width = this.width;
      lowerCanvasEl.height = this.height;

      lowerCanvasEl.style.width = this.width + 'px';
      lowerCanvasEl.style.height = this.height + 'px';

      this.viewportTransform = this.viewportTransform.slice();
    },

    /**
     * Creates a bottom canvas
     * @private
     * @param {HTMLElement} [canvasEl]
     */
    _createLowerCanvas: function (canvasEl) {
      // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
      if (canvasEl && canvasEl.getContext) {
        this.lowerCanvasEl = canvasEl;
      }
      else {
        this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
      }

      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');

      if (this.interactive) {
        this._applyCanvasStyle(this.lowerCanvasEl);
      }

      this.contextContainer = this.lowerCanvasEl.getContext('2d');
    },

    /**
     * Returns canvas width (in px)
     * @return {Number}
     */
    getWidth: function () {
      return this.width;
    },

    /**
     * Returns canvas height (in px)
     * @return {Number}
     */
    getHeight: function () {
      return this.height;
    },

    /**
     * Sets width of this canvas instance
     * @param {Number|String} value                         Value to set width to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setWidth: function (value, options) {
      return this.setDimensions({ width: value }, options);
    },

    /**
     * Sets height of this canvas instance
     * @param {Number|String} value                         Value to set height to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setHeight: function (value, options) {
      return this.setDimensions({ height: value }, options);
    },

    /**
     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
     * @param {Object}        dimensions                    Object with width/height properties
     * @param {Number|String} [dimensions.width]            Width of canvas element
     * @param {Number|String} [dimensions.height]           Height of canvas element
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setDimensions: function (dimensions, options) {
      var cssValue;

      options = options || {};

      for (var prop in dimensions) {
        cssValue = dimensions[prop];

        if (!options.cssOnly) {
          this._setBackstoreDimension(prop, dimensions[prop]);
          cssValue += 'px';
          this.hasLostContext = true;
        }

        if (!options.backstoreOnly) {
          this._setCssDimension(prop, cssValue);
        }
      }
      if (this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles();
      }
      this._initRetinaScaling();
      this.calcOffset();

      if (!options.cssOnly) {
        this.requestRenderAll();
      }

      return this;
    },

    /**
     * Helper for setting width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {Number} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setBackstoreDimension: function (prop, value) {
      this.lowerCanvasEl[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl[prop] = value;
      }

      if (this.cacheCanvasEl) {
        this.cacheCanvasEl[prop] = value;
      }

      this[prop] = value;

      return this;
    },

    /**
     * Helper for setting css width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {String} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setCssDimension: function (prop, value) {
      this.lowerCanvasEl.style[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl.style[prop] = value;
      }

      if (this.wrapperEl) {
        this.wrapperEl.style[prop] = value;
      }

      return this;
    },

    /**
     * Returns canvas zoom level
     * @return {Number}
     */
    getZoom: function () {
      return this.viewportTransform[0];
    },

    /**
     * Sets viewport transform of this canvas instance
     * @param {Array} vpt the transform in the form of context.transform
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setViewportTransform: function (vpt) {
      var activeObject = this._activeObject,
          backgroundObject = this.backgroundImage,
          overlayObject = this.overlayImage,
          object, i, len;
      this.viewportTransform = vpt;
      for (i = 0, len = this._objects.length; i < len; i++) {
        object = this._objects[i];
        object.group || object.setCoords(true);
      }
      if (activeObject) {
        activeObject.setCoords();
      }
      if (backgroundObject) {
        backgroundObject.setCoords(true);
      }
      if (overlayObject) {
        overlayObject.setCoords(true);
      }
      this.calcViewportBoundaries();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Sets zoom level of this canvas instance, the zoom centered around point
     * meaning that following zoom to point with the same point will have the visual
     * effect of the zoom originating from that point. The point won't move.
     * It has nothing to do with canvas center or visual center of the viewport.
     * @param {fabric.Point} point to zoom with respect to
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    zoomToPoint: function (point, value) {
      // TODO: just change the scale, preserve other transformations
      var before = point, vpt = this.viewportTransform.slice(0);
      point = transformPoint(point, invertTransform(this.viewportTransform));
      vpt[0] = value;
      vpt[3] = value;
      var after = transformPoint(point, vpt);
      vpt[4] += before.x - after.x;
      vpt[5] += before.y - after.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Sets zoom level of this canvas instance
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setZoom: function (value) {
      this.zoomToPoint(new fabric.Point(0, 0), value);
      return this;
    },

    /**
     * Pan viewport so as to place point at top left corner of canvas
     * @param {fabric.Point} point to move to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    absolutePan: function (point) {
      var vpt = this.viewportTransform.slice(0);
      vpt[4] = -point.x;
      vpt[5] = -point.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Pans viewpoint relatively
     * @param {fabric.Point} point (position vector) to move by
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    relativePan: function (point) {
      return this.absolutePan(new fabric.Point(
        -point.x - this.viewportTransform[4],
        -point.y - this.viewportTransform[5]
      ));
    },

    /**
     * Returns &lt;canvas> element corresponding to this instance
     * @return {HTMLCanvasElement}
     */
    getElement: function () {
      return this.lowerCanvasEl;
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was added
     */
    _onObjectAdded: function(obj) {
      this.stateful && obj.setupState();
      obj._set('canvas', this);
      obj.setCoords();
      this.fire('object:added', { target: obj });
      obj.fire('added');
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      this.fire('object:removed', { target: obj });
      obj.fire('removed');
      delete obj.canvas;
    },

    /**
     * Clears specified context of canvas element
     * @param {CanvasRenderingContext2D} ctx Context to clear
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clearContext: function(ctx) {
      ctx.clearRect(0, 0, this.width, this.height);
      return this;
    },

    /**
     * Returns context of canvas where objects are drawn
     * @return {CanvasRenderingContext2D}
     */
    getContext: function () {
      return this.contextContainer;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      this._objects.length = 0;
      this.backgroundImage = null;
      this.overlayImage = null;
      this.backgroundColor = '';
      this.overlayColor = '';
      if (this._hasITextHandlers) {
        this.off('mouse:up', this._mouseUpITextHandler);
        this._iTextInstances = null;
        this._hasITextHandlers = false;
      }
      this.clearContext(this.contextContainer);
      this.fire('canvas:cleared');
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Renders the canvas
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._objects);
      return this;
    },

    /**
     * Function created to be instance bound at initialization
     * used in requestAnimationFrame rendering
     * Let the fabricJS call it. If you call it manually you could have more
     * animationFrame stacking on to of each other
     * for an imperative rendering, use canvas.renderAll
     * @private
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAndReset: function() {
      this.isRendering = 0;
      this.renderAll();
    },

    /**
     * Append a renderAll request to next animation frame.
     * unless one is already in progress, in that case nothing is done
     * a boolean flag will avoid appending more.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    requestRenderAll: function () {
      if (!this.isRendering) {
        this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
      }
      return this;
    },

    /**
     * Calculate the position of the 4 corner of canvas with current viewportTransform.
     * helps to determinate when an object is in the current rendering viewport using
     * object absolute coordinates ( aCoords )
     * @return {Object} points.tl
     * @chainable
     */
    calcViewportBoundaries: function() {
      var points = { }, width = this.width, height = this.height,
          iVpt = invertTransform(this.viewportTransform);
      points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
      points.br = transformPoint({ x: width, y: height }, iVpt);
      points.tr = new fabric.Point(points.br.x, points.tl.y);
      points.bl = new fabric.Point(points.tl.x, points.br.y);
      this.vptCoords = points;
      return points;
    },

    cancelRequestedRender: function() {
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
    },

    /**
     * Renders background, objects, overlay and controls.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array} objects to render
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderCanvas: function(ctx, objects) {
      var v = this.viewportTransform, path = this.clipPath;
      this.cancelRequestedRender();
      this.calcViewportBoundaries();
      this.clearContext(ctx);
      fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);
      this.fire('before:render', { ctx: ctx, });
      this._renderBackground(ctx);

      ctx.save();
      //apply viewport transform once for all rendering process
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      this._renderObjects(ctx, objects);
      ctx.restore();
      if (!this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      if (path) {
        path.canvas = this;
        // needed to setup a couple of variables
        path.shouldCache();
        path._transformDone = true;
        path.renderCache({ forClipping: true });
        this.drawClipPathOnCanvas(ctx);
      }
      this._renderOverlay(ctx);
      if (this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      this.fire('after:render', { ctx: ctx, });
    },

    /**
     * Paint the cached clipPath on the lowerCanvasEl
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawClipPathOnCanvas: function(ctx) {
      var v = this.viewportTransform, path = this.clipPath;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4;
      ctx.globalCompositeOperation = 'destination-in';
      path.transform(ctx);
      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} objects to render
     */
    _renderObjects: function(ctx, objects) {
      var i, len;
      for (i = 0, len = objects.length; i < len; ++i) {
        objects[i] && objects[i].render(ctx);
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {string} property 'background' or 'overlay'
     */
    _renderBackgroundOrOverlay: function(ctx, property) {
      var fill = this[property + 'Color'], object = this[property + 'Image'],
          v = this.viewportTransform, needsVpt = this[property + 'Vpt'];
      if (!fill && !object) {
        return;
      }
      if (fill) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.width, 0);
        ctx.lineTo(this.width, this.height);
        ctx.lineTo(0, this.height);
        ctx.closePath();
        ctx.fillStyle = fill.toLive
          ? fill.toLive(ctx, this)
          : fill;
        if (needsVpt) {
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        }
        ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);
        var m = fill.gradientTransform || fill.patternTransform;
        m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        ctx.fill();
        ctx.restore();
      }
      if (object) {
        ctx.save();
        if (needsVpt) {
          ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
        }
        object.render(ctx);
        ctx.restore();
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'background');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderOverlay: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'overlay');
    },

    /**
     * Returns coordinates of a center of canvas.
     * Returned value is an object with top and left properties
     * @return {Object} object with "top" and "left" number values
     */
    getCenter: function () {
      return {
        top: this.height / 2,
        left: this.width / 2
      };
    },

    /**
     * Centers object horizontally in the canvas
     * @param {fabric.Object} object Object to center horizontally
     * @return {fabric.Canvas} thisArg
     */
    centerObjectH: function (object) {
      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
    },

    /**
     * Centers object vertically in the canvas
     * @param {fabric.Object} object Object to center vertically
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObjectV: function (object) {
      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
    },

    /**
     * Centers object vertically and horizontally in the canvas
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObject: function(object) {
      var center = this.getCenter();

      return this._centerObject(object, new fabric.Point(center.left, center.top));
    },

    /**
     * Centers object vertically and horizontally in the viewport
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObject: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, vpCenter);
    },

    /**
     * Centers object horizontally in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectH: function(object) {
      var vpCenter = this.getVpCenter();
      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
      return this;
    },

    /**
     * Centers object Vertically in the viewport, object.top is unchanged
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectV: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
    },

    /**
     * Calculate the point in canvas that correspond to the center of actual viewport.
     * @return {fabric.Point} vpCenter, viewport center
     * @chainable
     */
    getVpCenter: function() {
      var center = this.getCenter(),
          iVpt = invertTransform(this.viewportTransform);
      return transformPoint({ x: center.left, y: center.top }, iVpt);
    },

    /**
     * @private
     * @param {fabric.Object} object Object to center
     * @param {fabric.Point} center Center point
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    _centerObject: function(object, center) {
      object.setPositionByOrigin(center, 'center', 'center');
      object.setCoords();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Returns dataless JSON representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} json string
     */
    toDatalessJSON: function (propertiesToInclude) {
      return this.toDatalessObject(propertiesToInclude);
    },

    /**
     * Returns object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function (propertiesToInclude) {
      return this._toObjectMethod('toObject', propertiesToInclude);
    },

    /**
     * Returns dataless object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function (propertiesToInclude) {
      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
    },

    /**
     * @private
     */
    _toObjectMethod: function (methodName, propertiesToInclude) {

      var clipPath = this.clipPath, data = {
        version: fabric.version,
        objects: this._toObjects(methodName, propertiesToInclude),
      };
      if (clipPath) {
        data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);
      }
      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

      fabric.util.populateWithProperties(this, data, propertiesToInclude);

      return data;
    },

    /**
     * @private
     */
    _toObjects: function(methodName, propertiesToInclude) {
      return this._objects.filter(function(object) {
        return !object.excludeFromExport;
      }).map(function(instance) {
        return this._toObject(instance, methodName, propertiesToInclude);
      }, this);
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      var originalValue;

      if (!this.includeDefaultValues) {
        originalValue = instance.includeDefaultValues;
        instance.includeDefaultValues = false;
      }

      var object = instance[methodName](propertiesToInclude);
      if (!this.includeDefaultValues) {
        instance.includeDefaultValues = originalValue;
      }
      return object;
    },

    /**
     * @private
     */
    __serializeBgOverlay: function(methodName, propertiesToInclude) {
      var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;

      if (this.backgroundColor) {
        data.background = this.backgroundColor.toObject
          ? this.backgroundColor.toObject(propertiesToInclude)
          : this.backgroundColor;
      }

      if (this.overlayColor) {
        data.overlay = this.overlayColor.toObject
          ? this.overlayColor.toObject(propertiesToInclude)
          : this.overlayColor;
      }
      if (bgImage && !bgImage.excludeFromExport) {
        data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
      }
      if (overlay && !overlay.excludeFromExport) {
        data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);
      }

      return data;
    },

    /* _TO_SVG_START_ */
    /**
     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
     * a zoomed canvas will then produce zoomed SVG output.
     * @type Boolean
     * @default
     */
    svgViewportTransformation: true,

    /**
     * Returns SVG representation of canvas
     * @function
     * @param {Object} [options] Options object for SVG output
     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
     * @param {Object} [options.viewBox] SVG viewbox object
     * @param {Number} [options.viewBox.x] x-coordinate of viewbox
     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
     * @param {Number} [options.viewBox.width] Width of viewbox
     * @param {Number} [options.viewBox.height] Height of viewbox
     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
     * @param {String} [options.width] desired width of svg with or without units
     * @param {String} [options.height] desired height of svg with or without units
     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
     * @return {String} SVG string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
     * @example <caption>Normal SVG output</caption>
     * var svg = canvas.toSVG();
     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
     * var svg = canvas.toSVG({suppressPreamble: true});
     * @example <caption>SVG output with viewBox attribute</caption>
     * var svg = canvas.toSVG({
     *   viewBox: {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 300
     *   }
     * });
     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
     * @example <caption>Modify SVG output with reviver function</caption>
     * var svg = canvas.toSVG(null, function(svg) {
     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
     * });
     */
    toSVG: function(options, reviver) {
      options || (options = { });
      options.reviver = reviver;
      var markup = [];

      this._setSVGPreamble(markup, options);
      this._setSVGHeader(markup, options);
      if (this.clipPath) {
        markup.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n');
      }
      this._setSVGBgOverlayColor(markup, 'background');
      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);
      this._setSVGObjects(markup, reviver);
      if (this.clipPath) {
        markup.push('</g>\n');
      }
      this._setSVGBgOverlayColor(markup, 'overlay');
      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

      markup.push('</svg>');

      return markup.join('');
    },

    /**
     * @private
     */
    _setSVGPreamble: function(markup, options) {
      if (options.suppressPreamble) {
        return;
      }
      markup.push(
        '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
        '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
      );
    },

    /**
     * @private
     */
    _setSVGHeader: function(markup, options) {
      var width = options.width || this.width,
          height = options.height || this.height,
          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      if (options.viewBox) {
        viewBox = 'viewBox="' +
                options.viewBox.x + ' ' +
                options.viewBox.y + ' ' +
                options.viewBox.width + ' ' +
                options.viewBox.height + '" ';
      }
      else {
        if (this.svgViewportTransformation) {
          vpt = this.viewportTransform;
          viewBox = 'viewBox="' +
                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
        }
      }

      markup.push(
        '<svg ',
        'xmlns="http://www.w3.org/2000/svg" ',
        'xmlns:xlink="http://www.w3.org/1999/xlink" ',
        'version="1.1" ',
        'width="', width, '" ',
        'height="', height, '" ',
        viewBox,
        'xml:space="preserve">\n',
        '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
        '<defs>\n',
        this.createSVGFontFacesMarkup(),
        this.createSVGRefElementsMarkup(),
        this.createSVGClipPathMarkup(options),
        '</defs>\n'
      );
    },

    createSVGClipPathMarkup: function(options) {
      var clipPath = this.clipPath;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        return  '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          this.clipPath.toClipPathSVG(options.reviver) +
          '</clipPath>\n';
      }
      return '';
    },

    /**
     * Creates markup containing SVG referenced elements like patterns, gradients etc.
     * @return {String}
     */
    createSVGRefElementsMarkup: function() {
      var _this = this,
          markup = ['background', 'overlay'].map(function(prop) {
            var fill = _this[prop + 'Color'];
            if (fill && fill.toLive) {
              var shouldTransform = _this[prop + 'Vpt'], vpt = _this.viewportTransform,
                  object = {
                    width: _this.width / (shouldTransform ? vpt[0] : 1),
                    height: _this.height / (shouldTransform ? vpt[3] : 1)
                  };
              return fill.toSVG(
                object,
                { additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : '' }
              );
            }
          });
      return markup.join('');
    },

    /**
     * Creates markup containing SVG font faces,
     * font URLs for font faces must be collected by developers
     * and are not extracted from the DOM by fabricjs
     * @param {Array} objects Array of fabric objects
     * @return {String}
     */
    createSVGFontFacesMarkup: function() {
      var markup = '', fontList = { }, obj, fontFamily,
          style, row, rowIndex, _char, charIndex, i, len,
          fontPaths = fabric.fontPaths, objects = [];

      this._objects.forEach(function add(object) {
        objects.push(object);
        if (object._objects) {
          object._objects.forEach(add);
        }
      });

      for (i = 0, len = objects.length; i < len; i++) {
        obj = objects[i];
        fontFamily = obj.fontFamily;
        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
          continue;
        }
        fontList[fontFamily] = true;
        if (!obj.styles) {
          continue;
        }
        style = obj.styles;
        for (rowIndex in style) {
          row = style[rowIndex];
          for (charIndex in row) {
            _char = row[charIndex];
            fontFamily = _char.fontFamily;
            if (!fontList[fontFamily] && fontPaths[fontFamily]) {
              fontList[fontFamily] = true;
            }
          }
        }
      }

      for (var j in fontList) {
        markup += [
          '\t\t@font-face {\n',
          '\t\t\tfont-family: \'', j, '\';\n',
          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
          '\t\t}\n'
        ].join('');
      }

      if (markup) {
        markup = [
          '\t<style type="text/css">',
          '<![CDATA[\n',
          markup,
          ']]>',
          '</style>\n'
        ].join('');
      }

      return markup;
    },

    /**
     * @private
     */
    _setSVGObjects: function(markup, reviver) {
      var instance, i, len, objects = this._objects;
      for (i = 0, len = objects.length; i < len; i++) {
        instance = objects[i];
        if (instance.excludeFromExport) {
          continue;
        }
        this._setSVGObject(markup, instance, reviver);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      markup.push(instance.toSVG(reviver));
    },

    /**
     * @private
     */
    _setSVGBgOverlayImage: function(markup, property, reviver) {
      if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {
        markup.push(this[property].toSVG(reviver));
      }
    },

    /**
     * @private
     */
    _setSVGBgOverlayColor: function(markup, property) {
      var filler = this[property + 'Color'], vpt = this.viewportTransform, finalWidth = this.width,
          finalHeight = this.height;
      if (!filler) {
        return;
      }
      if (filler.toLive) {
        var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + 'Vpt'],
            additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : '';
        markup.push(
          '<rect transform="' + additionalTransform + ' translate(', finalWidth / 2, ',', finalHeight / 2, ')"',
          ' x="', filler.offsetX - finalWidth / 2,
          '" y="', filler.offsetY - finalHeight / 2, '" ',
          'width="',
          (repeat === 'repeat-y' || repeat === 'no-repeat'
            ? filler.source.width
            : finalWidth ),
          '" height="',
          (repeat === 'repeat-x' || repeat === 'no-repeat'
            ? filler.source.height
            : finalHeight),
          '" fill="url(#SVGID_' + filler.id + ')"',
          '></rect>\n'
        );
      }
      else {
        markup.push(
          '<rect x="0" y="0" width="100%" height="100%" ',
          'fill="', filler, '"',
          '></rect>\n'
        );
      }
    },
    /* _TO_SVG_END_ */

    /**
     * Moves an object or the objects of a multiple selection
     * to the bottom of the stack of drawn objects
     * @param {fabric.Object} object Object to send to back
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendToBack: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.unshift(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.unshift(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or the objects of a multiple selection
     * to the top of the stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringToFront: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.push(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.push(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or a selection down in stack of drawn objects
     * An optional parameter, intersecting allows to move the object in behind
     * the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendBackwards: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx > 0 + objsMoved) {
            newIdx = idx - 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== 0) {
          // if object is not on the bottom of stack
          newIdx = this._findNewLowerIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewLowerIndex: function(object, idx, intersecting) {
      var newIdx, i;

      if (intersecting) {
        newIdx = idx;

        // traverse down the stack looking for the nearest intersecting object
        for (i = idx - 1; i >= 0; --i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx - 1;
      }

      return newIdx;
    },

    /**
     * Moves an object or a selection up in stack of drawn objects
     * An optional parameter, intersecting allows to move the object in front
     * of the first intersecting object. Where intersection is calculated with
     * bounding box. If no intersection is found, there will not be change in the
     * stack.
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringForward: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx < this._objects.length - 1 - objsMoved) {
            newIdx = idx + 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== this._objects.length - 1) {
          // if object is not on top of stack (last item in an array)
          newIdx = this._findNewUpperIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewUpperIndex: function(object, idx, intersecting) {
      var newIdx, i, len;

      if (intersecting) {
        newIdx = idx;

        // traverse up the stack looking for the nearest intersecting object
        for (i = idx + 1, len = this._objects.length; i < len; ++i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx + 1;
      }

      return newIdx;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @param {Number} index Position to move to
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    moveTo: function (object, index) {
      removeFromArray(this._objects, object);
      this._objects.splice(index, 0, object);
      return this.renderOnAddRemove && this.requestRenderAll();
    },

    /**
     * Clears a canvas element and dispose objects
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      // cancel eventually ongoing renders
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
        this.isRendering = 0;
      }
      this.forEachObject(function(object) {
        object.dispose && object.dispose();
      });
      this._objects = [];
      if (this.backgroundImage && this.backgroundImage.dispose) {
        this.backgroundImage.dispose();
      }
      this.backgroundImage = null;
      if (this.overlayImage && this.overlayImage.dispose) {
        this.overlayImage.dispose();
      }
      this.overlayImage = null;
      this._iTextInstances = null;
      this.contextContainer = null;
      fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);
      this.lowerCanvasEl = undefined;
      return this;
    },

    /**
     * Returns a string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function () {
      return '#<fabric.Canvas (' + this.complexity() + '): ' +
               '{ objects: ' + this._objects.length + ' }>';
    }
  });

  extend(fabric.StaticCanvas.prototype, fabric.Observable);
  extend(fabric.StaticCanvas.prototype, fabric.Collection);
  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

    /**
     * @static
     * @type String
     * @default
     */
    EMPTY_JSON: '{"objects": [], "background": "white"}',

    /**
     * Provides a way to check support of some of the canvas methods
     * (either those of HTMLCanvasElement itself, or rendering context)
     *
     * @param {String} methodName Method to check support for;
     *                            Could be one of "setLineDash"
     * @return {Boolean | null} `true` if method is supported (or at least exists),
     *                          `null` if canvas element or context can not be initialized
     */
    supports: function (methodName) {
      var el = createCanvasElement();

      if (!el || !el.getContext) {
        return null;
      }

      var ctx = el.getContext('2d');
      if (!ctx) {
        return null;
      }

      switch (methodName) {

        case 'setLineDash':
          return typeof ctx.setLineDash !== 'undefined';

        default:
          return null;
      }
    }
  });

  /**
   * Returns Object representation of canvas
   * this alias is provided because if you call JSON.stringify on an instance,
   * the toJSON object will be invoked if it exists.
   * Having a toJSON method means you can do JSON.stringify(myCanvas)
   * @function
   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
   * @return {Object} JSON compatible object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
   * @example <caption>JSON without additional properties</caption>
   * var json = canvas.toJSON();
   * @example <caption>JSON with additional properties included</caption>
   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);
   * @example <caption>JSON without default values</caption>
   * canvas.includeDefaultValues = false;
   * var json = canvas.toJSON();
   */
  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

  if (fabric.isLikelyNode) {
    fabric.StaticCanvas.prototype.createPNGStream = function() {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createPNGStream();
    };
    fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
      var impl = getNodeCanvas(this.lowerCanvasEl);
      return impl && impl.createJPEGStream(opts);
    };
  }
})();


/**
 * BaseBrush class
 * @class fabric.BaseBrush
 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
 */
fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

  /**
   * Color of a brush
   * @type String
   * @default
   */
  color: 'rgb(0, 0, 0)',

  /**
   * Width of a brush, has to be a Number, no string literals
   * @type Number
   * @default
   */
  width: 1,

  /**
   * Shadow object representing shadow of this shape.
   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
   * @type fabric.Shadow
   * @default
   */
  shadow: null,

  /**
   * Line endings style of a brush (one of "butt", "round", "square")
   * @type String
   * @default
   */
  strokeLineCap: 'round',

  /**
   * Corner style of a brush (one of "bevel", "round", "miter")
   * @type String
   * @default
   */
  strokeLineJoin: 'round',

  /**
   * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
   * @type Number
   * @default
   */
  strokeMiterLimit:         10,

  /**
   * Stroke Dash Array.
   * @type Array
   * @default
   */
  strokeDashArray: null,

  /**
   * Sets brush styles
   * @private
   */
  _setBrushStyles: function() {
    var ctx = this.canvas.contextTop;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = this.width;
    ctx.lineCap = this.strokeLineCap;
    ctx.miterLimit = this.strokeMiterLimit;
    ctx.lineJoin = this.strokeLineJoin;
    if (fabric.StaticCanvas.supports('setLineDash')) {
      ctx.setLineDash(this.strokeDashArray || []);
    }
  },

  /**
   * Sets the transformation on given context
   * @param {RenderingContext2d} ctx context to render on
   * @private
   */
  _saveAndTransform: function(ctx) {
    var v = this.canvas.viewportTransform;
    ctx.save();
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
  },

  /**
   * Sets brush shadow styles
   * @private
   */
  _setShadow: function() {
    if (!this.shadow) {
      return;
    }

    var canvas = this.canvas,
        shadow = this.shadow,
        ctx = canvas.contextTop,
        zoom = canvas.getZoom();
    if (canvas && canvas._isRetinaScaling()) {
      zoom *= fabric.devicePixelRatio;
    }

    ctx.shadowColor = shadow.color;
    ctx.shadowBlur = shadow.blur * zoom;
    ctx.shadowOffsetX = shadow.offsetX * zoom;
    ctx.shadowOffsetY = shadow.offsetY * zoom;
  },

  needsFullRender: function() {
    var color = new fabric.Color(this.color);
    return color.getAlpha() < 1 || !!this.shadow;
  },

  /**
   * Removes brush shadow styles
   * @private
   */
  _resetShadow: function() {
    var ctx = this.canvas.contextTop;

    ctx.shadowColor = '';
    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
  }
});


(function() {
  /**
   * PencilBrush class
   * @class fabric.PencilBrush
   * @extends fabric.BaseBrush
   */
  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

    /**
     * Discard points that are less than `decimate` pixel distant from each other
     * @type Number
     * @default 0.4
     */
    decimate: 0.4,

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.PencilBrush} Instance of a pencil brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this._points = [];
    },

    /**
     * Invoked inside on mouse down and mouse move
     * @param {Object} pointer
     */
    _drawSegment: function (ctx, p1, p2) {
      var midPoint = p1.midPointFrom(p2);
      ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
      return midPoint;
    },

    /**
     * Invoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer, options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return;
      }
      this._prepareForDrawing(pointer);
      // capture coordinates immediately
      // this allows to draw dots (when movement never occurs)
      this._captureDrawingPath(pointer);
      this._render();
    },

    /**
     * Invoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer, options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return;
      }
      if (this._captureDrawingPath(pointer) && this._points.length > 1) {
        if (this.needsFullRender()) {
          // redraw curve
          // clear top canvas
          this.canvas.clearContext(this.canvas.contextTop);
          this._render();
        }
        else {
          var points = this._points, length = points.length, ctx = this.canvas.contextTop;
          // draw the curve update
          this._saveAndTransform(ctx);
          if (this.oldEnd) {
            ctx.beginPath();
            ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
          }
          this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
          ctx.stroke();
          ctx.restore();
        }
      }
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function(options) {
      if (!this.canvas._isMainEvent(options.e)) {
        return true;
      }
      this.oldEnd = undefined;
      this._finalizeAndAddPath();
      return false;
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _prepareForDrawing: function(pointer) {

      var p = new fabric.Point(pointer.x, pointer.y);

      this._reset();
      this._addPoint(p);
      this.canvas.contextTop.moveTo(p.x, p.y);
    },

    /**
     * @private
     * @param {fabric.Point} point Point to be added to points array
     */
    _addPoint: function(point) {
      if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
        return false;
      }
      this._points.push(point);
      return true;
    },

    /**
     * Clear points array and set contextTop canvas style.
     * @private
     */
    _reset: function() {
      this._points = [];
      this._setBrushStyles();
      this._setShadow();
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _captureDrawingPath: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
      return this._addPoint(pointerPoint);
    },

    /**
     * Draw a smooth path on the topCanvas using quadraticCurveTo
     * @private
     */
    _render: function() {
      var ctx  = this.canvas.contextTop, i, len,
          p1 = this._points[0],
          p2 = this._points[1];

      this._saveAndTransform(ctx);
      ctx.beginPath();
      //if we only have 2 points in the path and they are the same
      //it means that the user only clicked the canvas without moving the mouse
      //then we should be drawing a dot. A path isn't drawn between two identical dots
      //that's why we set them apart a bit
      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
        var width = this.width / 1000;
        p1 = new fabric.Point(p1.x, p1.y);
        p2 = new fabric.Point(p2.x, p2.y);
        p1.x -= width;
        p2.x += width;
      }
      ctx.moveTo(p1.x, p1.y);

      for (i = 1, len = this._points.length; i < len; i++) {
        // we pick the point between pi + 1 & pi + 2 as the
        // end point and p1 as our control point.
        this._drawSegment(ctx, p1, p2);
        p1 = this._points[i];
        p2 = this._points[i + 1];
      }
      // Draw last line as a straight line while
      // we wait for the next point to be able to calculate
      // the bezier control point
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * Converts points to SVG path
     * @param {Array} points Array of points
     * @return {String} SVG path
     */
    convertPointsToSVGPath: function(points) {
      var path = [], i, width = this.width / 1000,
          p1 = new fabric.Point(points[0].x, points[0].y),
          p2 = new fabric.Point(points[1].x, points[1].y),
          len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;

      if (manyPoints) {
        multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
        multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
      }
      path.push('M ', p1.x - multSignX * width, ' ', p1.y - multSignY * width, ' ');
      for (i = 1; i < len; i++) {
        if (!p1.eq(p2)) {
          var midPoint = p1.midPointFrom(p2);
          // p1 is our bezier control point
          // midpoint is our endpoint
          // start point is p(i-1) value.
          path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
        }
        p1 = points[i];
        if ((i + 1) < points.length) {
          p2 = points[i + 1];
        }
      }
      if (manyPoints) {
        multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
        multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
      }
      path.push('L ', p1.x + multSignX * width, ' ', p1.y + multSignY * width);
      return path;
    },

    /**
     * Creates fabric.Path object to add on canvas
     * @param {String} pathData Path data
     * @return {fabric.Path} Path to add on canvas
     */
    createPath: function(pathData) {
      var path = new fabric.Path(pathData, {
        fill: null,
        stroke: this.color,
        strokeWidth: this.width,
        strokeLineCap: this.strokeLineCap,
        strokeMiterLimit: this.strokeMiterLimit,
        strokeLineJoin: this.strokeLineJoin,
        strokeDashArray: this.strokeDashArray,
      });
      if (this.shadow) {
        this.shadow.affectStroke = true;
        path.shadow = new fabric.Shadow(this.shadow);
      }

      return path;
    },

    /**
     * Decimate points array with the decimate value
     */
    decimatePoints: function(points, distance) {
      if (points.length <= 2) {
        return points;
      }
      var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2),
          i, l = points.length - 1, lastPoint = points[0], newPoints = [lastPoint],
          cDistance;
      for (i = 1; i < l; i++) {
        cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);
        if (cDistance >= adjustedDistance) {
          lastPoint = points[i];
          newPoints.push(lastPoint);
        }
      }
      if (newPoints.length === 1) {
        newPoints.push(new fabric.Point(newPoints[0].x, newPoints[0].y));
      }
      return newPoints;
    },

    /**
     * On mouseup after drawing the path on contextTop canvas
     * we use the points captured to create an new fabric path object
     * and add it to the fabric canvas.
     */
    _finalizeAndAddPath: function() {
      var ctx = this.canvas.contextTop;
      ctx.closePath();
      if (this.decimate) {
        this._points = this.decimatePoints(this._points, this.decimate);
      }
      var pathData = this.convertPointsToSVGPath(this._points).join('');
      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
        // do not create 0 width/height paths, as they are
        // rendered inconsistently across browsers
        // Firefox 4, for example, renders a dot,
        // whereas Chrome 10 renders nothing
        this.canvas.requestRenderAll();
        return;
      }

      var path = this.createPath(pathData);
      this.canvas.clearContext(this.canvas.contextTop);
      this.canvas.fire('before:path:created', { path: path });
      this.canvas.add(path);
      this.canvas.requestRenderAll();
      path.setCoords();
      this._resetShadow();


      // fire event 'path' created
      this.canvas.fire('path:created', { path: path });
    }
  });
})();


/**
 * CircleBrush class
 * @class fabric.CircleBrush
 */
fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

  /**
   * Width of a brush
   * @type Number
   * @default
   */
  width: 10,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.CircleBrush} Instance of a circle brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.points = [];
  },

  /**
   * Invoked inside on mouse down and mouse move
   * @param {Object} pointer
   */
  drawDot: function(pointer) {
    var point = this.addPoint(pointer),
        ctx = this.canvas.contextTop;
    this._saveAndTransform(ctx);
    this.dot(ctx, point);
    ctx.restore();
  },

  dot: function(ctx, point) {
    ctx.fillStyle = point.fill;
    ctx.beginPath();
    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
    ctx.closePath();
    ctx.fill();
  },

  /**
   * Invoked on mouse down
   */
  onMouseDown: function(pointer) {
    this.points.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();
    this.drawDot(pointer);
  },

  /**
   * Render the full state of the brush
   * @private
   */
  _render: function() {
    var ctx  = this.canvas.contextTop, i, len,
        points = this.points;
    this._saveAndTransform(ctx);
    for (i = 0, len = points.length; i < len; i++) {
      this.dot(ctx, points[i]);
    }
    ctx.restore();
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    if (this.needsFullRender()) {
      this.canvas.clearContext(this.canvas.contextTop);
      this.addPoint(pointer);
      this._render();
    }
    else {
      this.drawDot(pointer);
    }
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
    this.canvas.renderOnAddRemove = false;

    var circles = [];

    for (i = 0, len = this.points.length; i < len; i++) {
      var point = this.points[i],
          circle = new fabric.Circle({
            radius: point.radius,
            left: point.x,
            top: point.y,
            originX: 'center',
            originY: 'center',
            fill: point.fill
          });

      this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));

      circles.push(circle);
    }
    var group = new fabric.Group(circles);
    group.canvas = this.canvas;

    this.canvas.fire('before:path:created', { path: group });
    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @param {Object} pointer
   * @return {fabric.Point} Just added pointer point
   */
  addPoint: function(pointer) {
    var pointerPoint = new fabric.Point(pointer.x, pointer.y),

        circleRadius = fabric.util.getRandomInt(
          Math.max(0, this.width - 20), this.width + 20) / 2,

        circleColor = new fabric.Color(this.color)
          .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
          .toRgba();

    pointerPoint.radius = circleRadius;
    pointerPoint.fill = circleColor;

    this.points.push(pointerPoint);

    return pointerPoint;
  }
});


/**
 * SprayBrush class
 * @class fabric.SprayBrush
 */
fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

  /**
   * Width of a spray
   * @type Number
   * @default
   */
  width:              10,

  /**
   * Density of a spray (number of dots per chunk)
   * @type Number
   * @default
   */
  density:            20,

  /**
   * Width of spray dots
   * @type Number
   * @default
   */
  dotWidth:           1,

  /**
   * Width variance of spray dots
   * @type Number
   * @default
   */
  dotWidthVariance:   1,

  /**
   * Whether opacity of a dot should be random
   * @type Boolean
   * @default
   */
  randomOpacity:        false,

  /**
   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
   * @type Boolean
   * @default
   */
  optimizeOverlapping:  true,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.SprayBrush} Instance of a spray brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.sprayChunks = [];
  },

  /**
   * Invoked on mouse down
   * @param {Object} pointer
   */
  onMouseDown: function(pointer) {
    this.sprayChunks.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();

    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    this.addSprayChunk(pointer);
    this.render(this.sprayChunkPoints);
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;

    var rects = [];

    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      var sprayChunk = this.sprayChunks[i];

      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

        var rect = new fabric.Rect({
          width: sprayChunk[j].width,
          height: sprayChunk[j].width,
          left: sprayChunk[j].x + 1,
          top: sprayChunk[j].y + 1,
          originX: 'center',
          originY: 'center',
          fill: this.color
        });
        rects.push(rect);
      }
    }

    if (this.optimizeOverlapping) {
      rects = this._getOptimizedRects(rects);
    }

    var group = new fabric.Group(rects);
    this.shadow && group.set('shadow', new fabric.Shadow(this.shadow));
    this.canvas.fire('before:path:created', { path: group });
    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @private
   * @param {Array} rects
   */
  _getOptimizedRects: function(rects) {

    // avoid creating duplicate rects at the same coordinates
    var uniqueRects = { }, key, i, len;

    for (i = 0, len = rects.length; i < len; i++) {
      key = rects[i].left + '' + rects[i].top;
      if (!uniqueRects[key]) {
        uniqueRects[key] = rects[i];
      }
    }
    var uniqueRectsArray = [];
    for (key in uniqueRects) {
      uniqueRectsArray.push(uniqueRects[key]);
    }

    return uniqueRectsArray;
  },

  /**
   * Render new chunk of spray brush
   */
  render: function(sprayChunk) {
    var ctx = this.canvas.contextTop, i, len;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, len = sprayChunk.length; i < len; i++) {
      var point = sprayChunk[i];
      if (typeof point.opacity !== 'undefined') {
        ctx.globalAlpha = point.opacity;
      }
      ctx.fillRect(point.x, point.y, point.width, point.width);
    }
    ctx.restore();
  },

  /**
   * Render all spray chunks
   */
  _render: function() {
    var ctx = this.canvas.contextTop, i, ilen;
    ctx.fillStyle = this.color;

    this._saveAndTransform(ctx);

    for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      this.render(this.sprayChunks[i]);
    }
    ctx.restore();
  },

  /**
   * @param {Object} pointer
   */
  addSprayChunk: function(pointer) {
    this.sprayChunkPoints = [];

    var x, y, width, radius = this.width / 2, i;

    for (i = 0; i < this.density; i++) {

      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

      if (this.dotWidthVariance) {
        width = fabric.util.getRandomInt(
          // bottom clamp width to 1
          Math.max(1, this.dotWidth - this.dotWidthVariance),
          this.dotWidth + this.dotWidthVariance);
      }
      else {
        width = this.dotWidth;
      }

      var point = new fabric.Point(x, y);
      point.width = width;

      if (this.randomOpacity) {
        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
      }

      this.sprayChunkPoints.push(point);
    }

    this.sprayChunks.push(this.sprayChunkPoints);
  }
});


/**
 * PatternBrush class
 * @class fabric.PatternBrush
 * @extends fabric.BaseBrush
 */
fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

  getPatternSrc: function() {

    var dotWidth = 20,
        dotDistance = 5,
        patternCanvas = fabric.util.createCanvasElement(),
        patternCtx = patternCanvas.getContext('2d');

    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

    patternCtx.fillStyle = this.color;
    patternCtx.beginPath();
    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
    patternCtx.closePath();
    patternCtx.fill();

    return patternCanvas;
  },

  getPatternSrcFunction: function() {
    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
  },

  /**
   * Creates "pattern" instance property
   */
  getPattern: function() {
    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
  },

  /**
   * Sets brush styles
   */
  _setBrushStyles: function() {
    this.callSuper('_setBrushStyles');
    this.canvas.contextTop.strokeStyle = this.getPattern();
  },

  /**
   * Creates path
   */
  createPath: function(pathData) {
    var path = this.callSuper('createPath', pathData),
        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

    path.stroke = new fabric.Pattern({
      source: this.source || this.getPatternSrcFunction(),
      offsetX: -topLeft.x,
      offsetY: -topLeft.y
    });
    return path;
  }
});


(function() {

  var getPointer = fabric.util.getPointer,
      degreesToRadians = fabric.util.degreesToRadians,
      abs = Math.abs,
      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),
      isTouchEvent = fabric.util.isTouchEvent,
      STROKE_OFFSET = 0.5;

  /**
   * Canvas class
   * @class fabric.Canvas
   * @extends fabric.StaticCanvas
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
   * @see {@link fabric.Canvas#initialize} for constructor definition
   *
   * @fires object:modified at the end of a transform or any change when statefull is true
   * @fires object:rotating while an object is being rotated from the control
   * @fires object:scaling while an object is being scaled by controls
   * @fires object:moving while an object is being dragged
   * @fires object:skewing while an object is being skewed from the controls
   *
   * @fires before:transform before a transform is is started
   * @fires before:selection:cleared
   * @fires selection:cleared
   * @fires selection:updated
   * @fires selection:created
   *
   * @fires path:created after a drawing operation ends and the path is added
   * @fires mouse:down
   * @fires mouse:move
   * @fires mouse:up
   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs
   * @fires mouse:move:before on mouse move, before the inner fabric logic runs
   * @fires mouse:up:before on mouse up, before the inner fabric logic runs
   * @fires mouse:over
   * @fires mouse:out
   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop
   * @fires after:render at the end of the render process, receives the context in the callback
   * @fires before:render at start the render process, receives the context in the callback
   *
   * the following events are deprecated:
   * @fires object:rotated at the end of a rotation transform
   * @fires object:scaled at the end of a scale transform
   * @fires object:moved at the end of translation transform
   * @fires object:skewed at the end of a skew transform
   */
  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
      this._initInteractive();
      this._createCacheCanvas();
    },

    /**
     * When true, objects can be transformed by one side (unproportionally)
     * when dragged on the corners that normally would not do that.
     * @type Boolean
     * @default
     * @since fabric 4.0 // changed name and default value
     */
    uniformScaling:      true,

    /**
     * Indicates which key switches uniform scaling.
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled.
     * totally wrong named. this sounds like `uniform scaling`
     * if Canvas.uniformScaling is true, pressing this will set it to false
     * and viceversa.
     * @since 1.6.2
     * @type String
     * @default
     */
    uniScaleKey:           'shiftKey',

    /**
     * When true, objects use center point as the origin of scale transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:        false,

    /**
     * When true, objects use center point as the origin of rotate transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:       false,

    /**
     * Indicates which key enable centered Transform
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    centeredKey:           'altKey',

    /**
     * Indicates which key enable alternate action on corner
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    altActionKey:           'shiftKey',

    /**
     * Indicates that canvas is interactive. This property should not be changed.
     * @type Boolean
     * @default
     */
    interactive:            true,

    /**
     * Indicates whether group selection should be enabled
     * @type Boolean
     * @default
     */
    selection:              true,

    /**
     * Indicates which key or keys enable multiple click selection
     * Pass value as a string or array of strings
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or empty or containing any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.2
     * @type String|Array
     * @default
     */
    selectionKey:           'shiftKey',

    /**
     * Indicates which key enable alternative selection
     * in case of target overlapping with active object
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * For a series of reason that come from the general expectations on how
     * things should work, this feature works only for preserveObjectStacking true.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled.
     * @since 1.6.5
     * @type null|String
     * @default
     */
    altSelectionKey:           null,

    /**
     * Color of selection
     * @type String
     * @default
     */
    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

    /**
     * Default dash array pattern
     * If not empty the selection border is dashed
     * @type Array
     */
    selectionDashArray:     [],

    /**
     * Color of the border of selection (usually slightly darker than color of selection itself)
     * @type String
     * @default
     */
    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

    /**
     * Width of a line used in object/group selection
     * @type Number
     * @default
     */
    selectionLineWidth:     1,

    /**
     * Select only shapes that are fully contained in the dragged selection rectangle.
     * @type Boolean
     * @default
     */
    selectionFullyContained: false,

    /**
     * Default cursor value used when hovering over an object on canvas
     * @type String
     * @default
     */
    hoverCursor:            'move',

    /**
     * Default cursor value used when moving an object on canvas
     * @type String
     * @default
     */
    moveCursor:             'move',

    /**
     * Default cursor value used for the entire canvas
     * @type String
     * @default
     */
    defaultCursor:          'default',

    /**
     * Cursor value used during free drawing
     * @type String
     * @default
     */
    freeDrawingCursor:      'crosshair',

    /**
     * Cursor value used for rotation point
     * @type String
     * @default
     */
    rotationCursor:         'crosshair',

    /**
     * Cursor value used for disabled elements ( corners with disabled action )
     * @type String
     * @since 2.0.0
     * @default
     */
    notAllowedCursor:         'not-allowed',

    /**
     * Default element class that's given to wrapper (div) element of canvas
     * @type String
     * @default
     */
    containerClass:         'canvas-container',

    /**
     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:     false,

    /**
     * Number of pixels around target pixel to tolerate (consider active) during object detection
     * @type Number
     * @default
     */
    targetFindTolerance:    0,

    /**
     * When true, target detection is skipped. Target detection will return always undefined.
     * click selection won't work anymore, events will fire with no targets.
     * if something is selected before setting it to true, it will be deselected at the first click.
     * area selection will still work. check the `selection` property too.
     * if you deactivate both, you should look into staticCanvas.
     * @type Boolean
     * @default
     */
    skipTargetFind:         false,

    /**
     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
     * After mousedown, mousemove creates a shape,
     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
     * @type Boolean
     * @default
     */
    isDrawingMode:          false,

    /**
     * Indicates whether objects should remain in current stack position when selected.
     * When false objects are brought to top and rendered as part of the selection group
     * @type Boolean
     * @default
     */
    preserveObjectStacking: false,

    /**
     * Indicates the angle that an object will lock to while rotating.
     * @type Number
     * @since 1.6.7
     * @default
     */
    snapAngle: 0,

    /**
     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
     * When `null`, the snapThreshold will default to the snapAngle.
     * @type null|Number
     * @since 1.6.7
     * @default
     */
    snapThreshold: null,

    /**
     * Indicates if the right click on canvas can output the context menu or not
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    stopContextMenu: false,

    /**
     * Indicates if the canvas can fire right click events
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    fireRightClick: false,

    /**
     * Indicates if the canvas can fire middle click events
     * @type Boolean
     * @since 1.7.8
     * @default
     */
    fireMiddleClick: false,

    /**
     * Keep track of the subTargets for Mouse Events
     * @type fabric.Object[]
     */
    targets: [],

    /**
     * Keep track of the hovered target
     * @type fabric.Object
     * @private
     */
    _hoveredTarget: null,

    /**
     * hold the list of nested targets hovered
     * @type fabric.Object[]
     * @private
     */
    _hoveredTargets: [],

    /**
     * @private
     */
    _initInteractive: function() {
      this._currentTransform = null;
      this._groupSelector = null;
      this._initWrapperElement();
      this._createUpperCanvas();
      this._initEventListeners();

      this._initRetinaScaling();

      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

      this.calcOffset();
    },

    /**
     * Divides objects in two groups, one to render immediately
     * and one to render as activeGroup.
     * @return {Array} objects to render immediately and pushes the other in the activeGroup.
     */
    _chooseObjectsToRender: function() {
      var activeObjects = this.getActiveObjects(),
          object, objsToRender, activeGroupObjects;

      if (activeObjects.length > 0 && !this.preserveObjectStacking) {
        objsToRender = [];
        activeGroupObjects = [];
        for (var i = 0, length = this._objects.length; i < length; i++) {
          object = this._objects[i];
          if (activeObjects.indexOf(object) === -1 ) {
            objsToRender.push(object);
          }
          else {
            activeGroupObjects.push(object);
          }
        }
        if (activeObjects.length > 1) {
          this._activeObject._objects = activeGroupObjects;
        }
        objsToRender.push.apply(objsToRender, activeGroupObjects);
      }
      else {
        objsToRender = this._objects;
      }
      return objsToRender;
    },

    /**
     * Renders both the top canvas and the secondary container canvas.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
        this.clearContext(this.contextTop);
        this.contextTopDirty = false;
      }
      if (this.hasLostContext) {
        this.renderTopLayer(this.contextTop);
      }
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
      return this;
    },

    renderTopLayer: function(ctx) {
      ctx.save();
      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this.freeDrawingBrush && this.freeDrawingBrush._render();
        this.contextTopDirty = true;
      }
      // we render the top context - last object
      if (this.selection && this._groupSelector) {
        this._drawSelection(ctx);
        this.contextTopDirty = true;
      }
      ctx.restore();
    },

    /**
     * Method to render only the top canvas.
     * Also used to render the group selection box.
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    renderTop: function () {
      var ctx = this.contextTop;
      this.clearContext(ctx);
      this.renderTopLayer(ctx);
      this.fire('after:render');
      return this;
    },

    /**
     * @private
     */
    _normalizePointer: function (object, pointer) {
      var m = object.calcTransformMatrix(),
          invertedM = fabric.util.invertTransform(m),
          vptPointer = this.restorePointerVpt(pointer);
      return fabric.util.transformPoint(vptPointer, invertedM);
    },

    /**
     * Returns true if object is transparent at a certain location
     * @param {fabric.Object} target Object to check
     * @param {Number} x Left coordinate
     * @param {Number} y Top coordinate
     * @return {Boolean}
     */
    isTargetTransparent: function (target, x, y) {
      // in case the target is the activeObject, we cannot execute this optimization
      // because we need to draw controls too.
      if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {
        var normalizedPointer = this._normalizePointer(target, {x: x, y: y}),
            targetRelativeX = Math.max(target.cacheTranslationX + (normalizedPointer.x * target.zoomX), 0),
            targetRelativeY = Math.max(target.cacheTranslationY + (normalizedPointer.y * target.zoomY), 0);

        var isTransparent = fabric.util.isTransparent(
          target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);

        return isTransparent;
      }

      var ctx = this.contextCache,
          originalColor = target.selectionBackgroundColor, v = this.viewportTransform;

      target.selectionBackgroundColor = '';

      this.clearContext(ctx);

      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      target.render(ctx);
      ctx.restore();

      target === this._activeObject && target._renderControls(ctx, {
        hasBorders: false,
        transparentCorners: false
      }, {
        hasBorders: false,
      });

      target.selectionBackgroundColor = originalColor;

      var isTransparent = fabric.util.isTransparent(
        ctx, x, y, this.targetFindTolerance);

      return isTransparent;
    },

    /**
     * takes an event and determines if selection key has been pressed
     * @private
     * @param {Event} e Event object
     */
    _isSelectionKeyPressed: function(e) {
      var selectionKeyPressed = false;

      if (Object.prototype.toString.call(this.selectionKey) === '[object Array]') {
        selectionKeyPressed = !!this.selectionKey.find(function(key) { return e[key] === true; });
      }
      else {
        selectionKeyPressed = e[this.selectionKey];
      }

      return selectionKeyPressed;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _shouldClearSelection: function (e, target) {
      var activeObjects = this.getActiveObjects(),
          activeObject = this._activeObject;

      return (
        !target
        ||
        (target &&
          activeObject &&
          activeObjects.length > 1 &&
          activeObjects.indexOf(target) === -1 &&
          activeObject !== target &&
          !this._isSelectionKeyPressed(e))
        ||
        (target && !target.evented)
        ||
        (target &&
          !target.selectable &&
          activeObject &&
          activeObject !== target)
      );
    },

    /**
     * centeredScaling from object can't override centeredScaling from canvas.
     * this should be fixed, since object setting should take precedence over canvas.
     * also this should be something that will be migrated in the control properties.
     * as ability to define the origin of the transformation that the control provide.
     * @private
     * @param {fabric.Object} target
     * @param {String} action
     * @param {Boolean} altKey
     */
    _shouldCenterTransform: function (target, action, altKey) {
      if (!target) {
        return;
      }

      var centerTransform;

      if (action === 'scale' || action === 'scaleX' || action === 'scaleY' || action === 'resizing') {
        centerTransform = this.centeredScaling || target.centeredScaling;
      }
      else if (action === 'rotate') {
        centerTransform = this.centeredRotation || target.centeredRotation;
      }

      return centerTransform ? !altKey : altKey;
    },

    /**
     * should disappear before release 4.0
     * @private
     */
    _getOriginFromCorner: function(target, corner) {
      var origin = {
        x: target.originX,
        y: target.originY
      };

      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
        origin.x = 'right';
      }
      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
        origin.x = 'left';
      }

      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
        origin.y = 'bottom';
      }
      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
        origin.y = 'top';
      }
      return origin;
    },

    /**
     * @private
     * @param {Boolean} alreadySelected true if target is already selected
     * @param {String} corner a string representing the corner ml, mr, tl ...
     * @param {Event} e Event object
     * @param {fabric.Object} [target] inserted back to help overriding. Unused
     */
    _getActionFromCorner: function(alreadySelected, corner, e, target) {
      if (!corner || !alreadySelected) {
        return 'drag';
      }
      var control = target.controls[corner];
      return control.getActionName(e, control, target);
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _setupCurrentTransform: function (e, target, alreadySelected) {
      if (!target) {
        return;
      }

      var pointer = this.getPointer(e), corner = target.__corner,
          control = target.controls[corner],
          actionHandler = (alreadySelected && corner) ?
            control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler,
          action = this._getActionFromCorner(alreadySelected, corner, e, target),
          origin = this._getOriginFromCorner(target, corner),
          altKey = e[this.centeredKey],
          transform = {
            target: target,
            action: action,
            actionHandler: actionHandler,
            corner: corner,
            scaleX: target.scaleX,
            scaleY: target.scaleY,
            skewX: target.skewX,
            skewY: target.skewY,
            // used by transation
            offsetX: pointer.x - target.left,
            offsetY: pointer.y - target.top,
            originX: origin.x,
            originY: origin.y,
            ex: pointer.x,
            ey: pointer.y,
            lastX: pointer.x,
            lastY: pointer.y,
            // unsure they are useful anymore.
            // left: target.left,
            // top: target.top,
            theta: degreesToRadians(target.angle),
            // end of unsure
            width: target.width * target.scaleX,
            shiftKey: e.shiftKey,
            altKey: altKey,
            original: fabric.util.saveObjectTransform(target),
          };

      if (this._shouldCenterTransform(target, action, altKey)) {
        transform.originX = 'center';
        transform.originY = 'center';
      }
      transform.original.originX = origin.x;
      transform.original.originY = origin.y;
      this._currentTransform = transform;
      this._beforeTransform(e);
    },

    /**
     * Set the cursor type of the canvas element
     * @param {String} value Cursor type of the canvas element.
     * @see http://www.w3.org/TR/css3-ui/#cursor
     */
    setCursor: function (value) {
      this.upperCanvasEl.style.cursor = value;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx to draw the selection on
     */
    _drawSelection: function (ctx) {
      var groupSelector = this._groupSelector,
          left = groupSelector.left,
          top = groupSelector.top,
          aleft = abs(left),
          atop = abs(top);

      if (this.selectionColor) {
        ctx.fillStyle = this.selectionColor;

        ctx.fillRect(
          groupSelector.ex - ((left > 0) ? 0 : -left),
          groupSelector.ey - ((top > 0) ? 0 : -top),
          aleft,
          atop
        );
      }

      if (!this.selectionLineWidth || !this.selectionBorderColor) {
        return;
      }
      ctx.lineWidth = this.selectionLineWidth;
      ctx.strokeStyle = this.selectionBorderColor;

      // selection border
      if (this.selectionDashArray.length > 1 && !supportLineDash) {

        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);

        ctx.beginPath();

        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);

        ctx.closePath();
        ctx.stroke();
      }
      else {
        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
        ctx.strokeRect(
          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
          aleft,
          atop
        );
      }
    },

    /**
     * Method that determines what object we are clicking on
     * the skipGroup parameter is for internal use, is needed for shift+click action
     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target
     * or the outside part of the corner.
     * @param {Event} e mouse event
     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
     * @return {fabric.Object} the target found
     */
    findTarget: function (e, skipGroup) {
      if (this.skipTargetFind) {
        return;
      }

      var ignoreZoom = true,
          pointer = this.getPointer(e, ignoreZoom),
          activeObject = this._activeObject,
          aObjects = this.getActiveObjects(),
          activeTarget, activeTargetSubs,
          isTouch = isTouchEvent(e);

      // first check current group (if one exists)
      // active group does not check sub targets like normal groups.
      // if active group just exits.
      this.targets = [];

      if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        return activeObject;
      }
      // if we hit the corner of an activeObject, let's return that.
      if (aObjects.length === 1 && activeObject._findTargetCorner(pointer, isTouch)) {
        return activeObject;
      }
      if (aObjects.length === 1 &&
        activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        if (!this.preserveObjectStacking) {
          return activeObject;
        }
        else {
          activeTarget = activeObject;
          activeTargetSubs = this.targets;
          this.targets = [];
        }
      }
      var target = this._searchPossibleTargets(this._objects, pointer);
      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
        target = activeTarget;
        this.targets = activeTargetSubs;
      }
      return target;
    },

    /**
     * Checks point is inside the object.
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @param {fabric.Object} obj Object to test against
     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.
     * @return {Boolean} true if point is contained within an area of given object
     * @private
     */
    _checkTarget: function(pointer, obj, globalPointer) {
      if (obj &&
          obj.visible &&
          obj.evented &&
          // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
          // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
          (obj.containsPoint(pointer) || !!obj._findTargetCorner(pointer))
      ) {
        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
          var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);
          if (!isTransparent) {
            return true;
          }
        }
        else {
          return true;
        }
      }
    },

    /**
     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted
     * @param {Array} [objects] objects array to look into
     * @param {Object} [pointer] x,y object of point coordinates we want to check.
     * @return {fabric.Object} object that contains pointer
     * @private
     */
    _searchPossibleTargets: function(objects, pointer) {
      // Cache all targets where their bounding box contains point.
      var target, i = objects.length, subTarget;
      // Do not check for currently grouped objects, since we check the parent group itself.
      // until we call this function specifically to search inside the activeGroup
      while (i--) {
        var objToCheck = objects[i];
        var pointerToUse = objToCheck.group ?
          this._normalizePointer(objToCheck.group, pointer) : pointer;
        if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
          target = objects[i];
          if (target.subTargetCheck && target instanceof fabric.Group) {
            subTarget = this._searchPossibleTargets(target._objects, pointer);
            subTarget && this.targets.push(subTarget);
          }
          break;
        }
      }
      return target;
    },

    /**
     * Returns pointer coordinates without the effect of the viewport
     * @param {Object} pointer with "x" and "y" number values
     * @return {Object} object with "x" and "y" number values
     */
    restorePointerVpt: function(pointer) {
      return fabric.util.transformPoint(
        pointer,
        fabric.util.invertTransform(this.viewportTransform)
      );
    },

    /**
     * Returns pointer coordinates relative to canvas.
     * Can return coordinates with or without viewportTransform.
     * ignoreZoom false gives back coordinates that represent
     * the point clicked on canvas element.
     * ignoreZoom true gives back coordinates after being processed
     * by the viewportTransform ( sort of coordinates of what is displayed
     * on the canvas where you are clicking.
     * ignoreZoom true = HTMLElement coordinates relative to top,left
     * ignoreZoom false, default = fabric space coordinates, the same used for shape position
     * To interact with your shapes top and left you want to use ignoreZoom true
     * most of the time, while ignoreZoom false will give you coordinates
     * compatible with the object.oCoords system.
     * of the time.
     * @param {Event} e
     * @param {Boolean} ignoreZoom
     * @return {Object} object with "x" and "y" number values
     */
    getPointer: function (e, ignoreZoom) {
      // return cached values if we are in the event processing chain
      if (this._absolutePointer && !ignoreZoom) {
        return this._absolutePointer;
      }
      if (this._pointer && ignoreZoom) {
        return this._pointer;
      }

      var pointer = getPointer(e),
          upperCanvasEl = this.upperCanvasEl,
          bounds = upperCanvasEl.getBoundingClientRect(),
          boundsWidth = bounds.width || 0,
          boundsHeight = bounds.height || 0,
          cssScale;

      if (!boundsWidth || !boundsHeight ) {
        if ('top' in bounds && 'bottom' in bounds) {
          boundsHeight = Math.abs( bounds.top - bounds.bottom );
        }
        if ('right' in bounds && 'left' in bounds) {
          boundsWidth = Math.abs( bounds.right - bounds.left );
        }
      }

      this.calcOffset();
      pointer.x = pointer.x - this._offset.left;
      pointer.y = pointer.y - this._offset.top;
      if (!ignoreZoom) {
        pointer = this.restorePointerVpt(pointer);
      }

      var retinaScaling = this.getRetinaScaling();
      if (retinaScaling !== 1) {
        pointer.x /= retinaScaling;
        pointer.y /= retinaScaling;
      }

      if (boundsWidth === 0 || boundsHeight === 0) {
        // If bounds are not available (i.e. not visible), do not apply scale.
        cssScale = { width: 1, height: 1 };
      }
      else {
        cssScale = {
          width: upperCanvasEl.width / boundsWidth,
          height: upperCanvasEl.height / boundsHeight
        };
      }

      return {
        x: pointer.x * cssScale.width,
        y: pointer.y * cssScale.height
      };
    },

    /**
     * @private
     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
     */
    _createUpperCanvas: function () {
      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ''),
          lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;

      // there is no need to create a new upperCanvas element if we have already one.
      if (upperCanvasEl) {
        upperCanvasEl.className = '';
      }
      else {
        upperCanvasEl = this._createCanvasElement();
        this.upperCanvasEl = upperCanvasEl;
      }
      fabric.util.addClass(upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

      this.wrapperEl.appendChild(upperCanvasEl);

      this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);
      this._applyCanvasStyle(upperCanvasEl);
      this.contextTop = upperCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _createCacheCanvas: function () {
      this.cacheCanvasEl = this._createCanvasElement();
      this.cacheCanvasEl.setAttribute('width', this.width);
      this.cacheCanvasEl.setAttribute('height', this.height);
      this.contextCache = this.cacheCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _initWrapperElement: function () {
      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
        'class': this.containerClass
      });
      fabric.util.setStyle(this.wrapperEl, {
        width: this.width + 'px',
        height: this.height + 'px',
        position: 'relative'
      });
      fabric.util.makeElementUnselectable(this.wrapperEl);
    },

    /**
     * @private
     * @param {HTMLElement} element canvas element to apply styles on
     */
    _applyCanvasStyle: function (element) {
      var width = this.width || element.width,
          height = this.height || element.height;

      fabric.util.setStyle(element, {
        position: 'absolute',
        width: width + 'px',
        height: height + 'px',
        left: 0,
        top: 0,
        'touch-action': this.allowTouchScrolling ? 'manipulation' : 'none',
        '-ms-touch-action': this.allowTouchScrolling ? 'manipulation' : 'none'
      });
      element.width = width;
      element.height = height;
      fabric.util.makeElementUnselectable(element);
    },

    /**
     * Copy the entire inline style from one element (fromEl) to another (toEl)
     * @private
     * @param {Element} fromEl Element style is copied from
     * @param {Element} toEl Element copied style is applied to
     */
    _copyCanvasStyle: function (fromEl, toEl) {
      toEl.style.cssText = fromEl.style.cssText;
    },

    /**
     * Returns context of canvas where object selection is drawn
     * @return {CanvasRenderingContext2D}
     */
    getSelectionContext: function() {
      return this.contextTop;
    },

    /**
     * Returns &lt;canvas> element on which object selection is drawn
     * @return {HTMLCanvasElement}
     */
    getSelectionElement: function () {
      return this.upperCanvasEl;
    },

    /**
     * Returns currently active object
     * @return {fabric.Object} active object
     */
    getActiveObject: function () {
      return this._activeObject;
    },

    /**
     * Returns an array with the current selected objects
     * @return {fabric.Object} active object
     */
    getActiveObjects: function () {
      var active = this._activeObject;
      if (active) {
        if (active.type === 'activeSelection' && active._objects) {
          return active._objects.slice(0);
        }
        else {
          return [active];
        }
      }
      return [];
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      // removing active object should fire "selection:cleared" events
      if (obj === this._activeObject) {
        this.fire('before:selection:cleared', { target: obj });
        this._discardActiveObject();
        this.fire('selection:cleared', { target: obj });
        obj.fire('deselected');
      }
      if (obj === this._hoveredTarget){
        this._hoveredTarget = null;
        this._hoveredTargets = [];
      }
      this.callSuper('_onObjectRemoved', obj);
    },

    /**
     * @private
     * Compares the old activeObject with the current one and fires correct events
     * @param {fabric.Object} obj old activeObject
     */
    _fireSelectionEvents: function(oldObjects, e) {
      var somethingChanged = false, objects = this.getActiveObjects(),
          added = [], removed = [], opt = { e: e };
      oldObjects.forEach(function(oldObject) {
        if (objects.indexOf(oldObject) === -1) {
          somethingChanged = true;
          oldObject.fire('deselected', opt);
          removed.push(oldObject);
        }
      });
      objects.forEach(function(object) {
        if (oldObjects.indexOf(object) === -1) {
          somethingChanged = true;
          object.fire('selected', opt);
          added.push(object);
        }
      });
      if (oldObjects.length > 0 && objects.length > 0) {
        opt.selected = added;
        opt.deselected = removed;
        // added for backward compatibility
        opt.updated = added[0] || removed[0];
        opt.target = this._activeObject;
        somethingChanged && this.fire('selection:updated', opt);
      }
      else if (objects.length > 0) {
        opt.selected = added;
        // added for backward compatibility
        opt.target = this._activeObject;
        this.fire('selection:created', opt);
      }
      else if (oldObjects.length > 0) {
        opt.deselected = removed;
        this.fire('selection:cleared', opt);
      }
    },

    /**
     * Sets given object as the only active object on canvas
     * @param {fabric.Object} object Object to set as an active one
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setActiveObject: function (object, e) {
      var currentActives = this.getActiveObjects();
      this._setActiveObject(object, e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * @private
     * @param {Object} object to set as active
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {Boolean} true if the selection happened
     */
    _setActiveObject: function(object, e) {
      if (this._activeObject === object) {
        return false;
      }
      if (!this._discardActiveObject(e, object)) {
        return false;
      }
      if (object.onSelect({ e: e })) {
        return false;
      }
      this._activeObject = object;
      return true;
    },

    /**
     * @private
     */
    _discardActiveObject: function(e, object) {
      var obj = this._activeObject;
      if (obj) {
        // onDeselect return TRUE to cancel selection;
        if (obj.onDeselect({ e: e, object: object })) {
          return false;
        }
        this._activeObject = null;
      }
      return true;
    },

    /**
     * Discards currently active object and fire events. If the function is called by fabric
     * as a consequence of a mouse event, the event is passed as a parameter and
     * sent to the fire function for the custom events. When used as a method the
     * e param does not have any application.
     * @param {event} e
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    discardActiveObject: function (e) {
      var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();
      if (currentActives.length) {
        this.fire('before:selection:cleared', { target: activeObject, e: e });
      }
      this._discardActiveObject(e);
      this._fireSelectionEvents(currentActives, e);
      return this;
    },

    /**
     * Clears a canvas element and removes all event listeners
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      var wrapper = this.wrapperEl;
      this.removeListeners();
      wrapper.removeChild(this.upperCanvasEl);
      wrapper.removeChild(this.lowerCanvasEl);
      this.contextCache = null;
      this.contextTop = null;
      ['upperCanvasEl', 'cacheCanvasEl'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
      if (wrapper.parentNode) {
        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
      }
      delete this.wrapperEl;
      fabric.StaticCanvas.prototype.dispose.call(this);
      return this;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      // this.discardActiveGroup();
      this.discardActiveObject();
      this.clearContext(this.contextTop);
      return this.callSuper('clear');
    },

    /**
     * Draws objects' controls (borders/controls)
     * @param {CanvasRenderingContext2D} ctx Context to render controls on
     */
    drawControls: function(ctx) {
      var activeObject = this._activeObject;

      if (activeObject) {
        activeObject._renderControls(ctx);
      }
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      //If the object is part of the current selection group, it should
      //be transformed appropriately
      //i.e. it should be serialised as it would appear if the selection group
      //were to be destroyed.
      var originalProperties = this._realizeGroupTransformOnObject(instance),
          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
      //Undo the damage we did by changing all of its properties
      this._unwindGroupTransformOnObject(instance, originalProperties);
      return object;
    },

    /**
     * Realises an object's group transformation on it
     * @private
     * @param {fabric.Object} [instance] the object to transform (gets mutated)
     * @returns the original values of instance which were changed
     */
    _realizeGroupTransformOnObject: function(instance) {
      if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
        var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
        //Copy all the positionally relevant properties across now
        var originalValues = {};
        layoutProps.forEach(function(prop) {
          originalValues[prop] = instance[prop];
        });
        this._activeObject.realizeTransform(instance);
        return originalValues;
      }
      else {
        return null;
      }
    },

    /**
     * Restores the changed properties of instance
     * @private
     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
     */
    _unwindGroupTransformOnObject: function(instance, originalValues) {
      if (originalValues) {
        instance.set(originalValues);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      //If the object is in a selection group, simulate what would happen to that
      //object when the group is deselected
      var originalProperties = this._realizeGroupTransformOnObject(instance);
      this.callSuper('_setSVGObject', markup, instance, reviver);
      this._unwindGroupTransformOnObject(instance, originalProperties);
    },

    setViewportTransform: function (vpt) {
      if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
        this._activeObject.clearContextTop();
      }
      fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
    }
  });

  // copying static properties manually to work around Opera's bug,
  // where "prototype" property is enumerable and overrides existing prototype
  for (var prop in fabric.StaticCanvas) {
    if (prop !== 'prototype') {
      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
    }
  }
})();


(function() {

  var addListener = fabric.util.addListener,
      removeListener = fabric.util.removeListener,
      RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1,
      addEventOptions = { passive: false };

  function checkClick(e, value) {
    return e.button && (e.button === value - 1);
  }

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * Contains the id of the touch event that owns the fabric transform
     * @type Number
     * @private
     */
    mainTouchId: null,

    /**
     * Adds mouse listeners to canvas
     * @private
     */
    _initEventListeners: function () {
      // in case we initialized the class twice. This should not happen normally
      // but in some kind of applications where the canvas element may be changed
      // this is a workaround to having double listeners.
      this.removeListeners();
      this._bindEvents();
      this.addOrRemove(addListener, 'add');
    },

    /**
     * return an event prefix pointer or mouse.
     * @private
     */
    _getEventPrefix: function () {
      return this.enablePointerEvents ? 'pointer' : 'mouse';
    },

    addOrRemove: function(functor, eventjsFunctor) {
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      functor(fabric.window, 'resize', this._onResize);
      functor(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
      functor(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      functor(canvasElement, eventTypePrefix + 'out', this._onMouseOut);
      functor(canvasElement, eventTypePrefix + 'enter', this._onMouseEnter);
      functor(canvasElement, 'wheel', this._onMouseWheel);
      functor(canvasElement, 'contextmenu', this._onContextMenu);
      functor(canvasElement, 'dblclick', this._onDoubleClick);
      functor(canvasElement, 'dragover', this._onDragOver);
      functor(canvasElement, 'dragenter', this._onDragEnter);
      functor(canvasElement, 'dragleave', this._onDragLeave);
      functor(canvasElement, 'drop', this._onDrop);
      if (!this.enablePointerEvents) {
        functor(canvasElement, 'touchstart', this._onTouchStart, addEventOptions);
      }
      if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {
        eventjs[eventjsFunctor](canvasElement, 'gesture', this._onGesture);
        eventjs[eventjsFunctor](canvasElement, 'drag', this._onDrag);
        eventjs[eventjsFunctor](canvasElement, 'orientation', this._onOrientationChange);
        eventjs[eventjsFunctor](canvasElement, 'shake', this._onShake);
        eventjs[eventjsFunctor](canvasElement, 'longpress', this._onLongPress);
      }
    },

    /**
     * Removes all event listeners
     */
    removeListeners: function() {
      this.addOrRemove(removeListener, 'remove');
      // if you dispose on a mouseDown, before mouse up, you need to clean document to...
      var eventTypePrefix = this._getEventPrefix();
      removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
      removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
    },

    /**
     * @private
     */
    _bindEvents: function() {
      if (this.eventsBound) {
        // for any reason we pass here twice we do not want to bind events twice.
        return;
      }
      this._onMouseDown = this._onMouseDown.bind(this);
      this._onTouchStart = this._onTouchStart.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      this._onMouseUp = this._onMouseUp.bind(this);
      this._onTouchEnd = this._onTouchEnd.bind(this);
      this._onResize = this._onResize.bind(this);
      this._onGesture = this._onGesture.bind(this);
      this._onDrag = this._onDrag.bind(this);
      this._onShake = this._onShake.bind(this);
      this._onLongPress = this._onLongPress.bind(this);
      this._onOrientationChange = this._onOrientationChange.bind(this);
      this._onMouseWheel = this._onMouseWheel.bind(this);
      this._onMouseOut = this._onMouseOut.bind(this);
      this._onMouseEnter = this._onMouseEnter.bind(this);
      this._onContextMenu = this._onContextMenu.bind(this);
      this._onDoubleClick = this._onDoubleClick.bind(this);
      this._onDragOver = this._onDragOver.bind(this);
      this._onDragEnter = this._simpleEventHandler.bind(this, 'dragenter');
      this._onDragLeave = this._simpleEventHandler.bind(this, 'dragleave');
      this._onDrop = this._simpleEventHandler.bind(this, 'drop');
      this.eventsBound = true;
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js gesture
     * @param {Event} [self] Inner Event object
     */
    _onGesture: function(e, self) {
      this.__onTransformGesture && this.__onTransformGesture(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js drag
     * @param {Event} [self] Inner Event object
     */
    _onDrag: function(e, self) {
      this.__onDrag && this.__onDrag(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on wheel event
     */
    _onMouseWheel: function(e) {
      this.__onMouseWheel(e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseOut: function(e) {
      var target = this._hoveredTarget;
      this.fire('mouse:out', { target: target, e: e });
      this._hoveredTarget = null;
      target && target.fire('mouseout', { e: e });

      var _this = this;
      this._hoveredTargets.forEach(function(_target){
        _this.fire('mouse:out', { target: target, e: e });
        _target && target.fire('mouseout', { e: e });
      });
      this._hoveredTargets = [];

      if (this._iTextInstances) {
        this._iTextInstances.forEach(function(obj) {
          if (obj.isEditing) {
            obj.hiddenTextarea.focus();
          }
        });
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseenter
     */
    _onMouseEnter: function(e) {
      // This find target and consequent 'mouse:over' is used to
      // clear old instances on hovered target.
      // calling findTarget has the side effect of killing target.__corner.
      // as a short term fix we are not firing this if we are currently transforming.
      // as a long term fix we need to separate the action of finding a target with the
      // side effects we added to it.
      if (!this._currentTransform && !this.findTarget(e)) {
        this.fire('mouse:over', { target: null, e: e });
        this._hoveredTarget = null;
        this._hoveredTargets = [];
      }
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js orientation change
     * @param {Event} [self] Inner Event object
     */
    _onOrientationChange: function(e, self) {
      this.__onOrientationChange && this.__onOrientationChange(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onShake: function(e, self) {
      this.__onShake && this.__onShake(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onLongPress: function(e, self) {
      this.__onLongPress && this.__onLongPress(e, self);
    },

    /**
     * prevent default to allow drop event to be fired
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     */
    _onDragOver: function(e) {
      e.preventDefault();
      var target = this._simpleEventHandler('dragover', e);
      this._fireEnterLeaveEvents(target, e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onContextMenu: function (e) {
      if (this.stopContextMenu) {
        e.stopPropagation();
        e.preventDefault();
      }
      return false;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onDoubleClick: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'dblclick');
      this._resetTransformEventData(e);
    },

    /**
     * Return a the id of an event.
     * returns either the pointerId or the identifier or 0 for the mouse event
     * @private
     * @param {Event} evt Event object
     */
    getPointerId: function(evt) {
      var changedTouches = evt.changedTouches;

      if (changedTouches) {
        return changedTouches[0] && changedTouches[0].identifier;
      }

      if (this.enablePointerEvents) {
        return evt.pointerId;
      }

      return -1;
    },

    /**
     * Determines if an event has the id of the event that is considered main
     * @private
     * @param {evt} event Event object
     */
    _isMainEvent: function(evt) {
      if (evt.isPrimary === true) {
        return true;
      }
      if (evt.isPrimary === false) {
        return false;
      }
      if (evt.type === 'touchend' && evt.touches.length === 0) {
        return true;
      }
      if (evt.changedTouches) {
        return evt.changedTouches[0].identifier === this.mainTouchId;
      }
      return true;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onTouchStart: function(e) {
      e.preventDefault();
      if (this.mainTouchId === null) {
        this.mainTouchId = this.getPointerId(e);
      }
      this.__onMouseDown(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      addListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      addListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      // Unbind mousedown to prevent double triggers from touch devices
      removeListener(canvasElement, eventTypePrefix + 'down', this._onMouseDown);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDown: function (e) {
      this.__onMouseDown(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      removeListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      addListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
      addListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onTouchEnd: function(e) {
      if (e.touches.length > 0) {
        // if there are still touches stop here
        return;
      }
      this.__onMouseUp(e);
      this._resetTransformEventData();
      this.mainTouchId = null;
      var eventTypePrefix = this._getEventPrefix();
      removeListener(fabric.document, 'touchend', this._onTouchEnd, addEventOptions);
      removeListener(fabric.document, 'touchmove', this._onMouseMove, addEventOptions);
      var _this = this;
      if (this._willAddMouseDown) {
        clearTimeout(this._willAddMouseDown);
      }
      this._willAddMouseDown = setTimeout(function() {
        // Wait 400ms before rebinding mousedown to prevent double triggers
        // from touch devices
        addListener(_this.upperCanvasEl, eventTypePrefix + 'down', _this._onMouseDown);
        _this._willAddMouseDown = 0;
      }, 400);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUp: function (e) {
      this.__onMouseUp(e);
      this._resetTransformEventData();
      var canvasElement = this.upperCanvasEl,
          eventTypePrefix = this._getEventPrefix();
      if (this._isMainEvent(e)) {
        removeListener(fabric.document, eventTypePrefix + 'up', this._onMouseUp);
        removeListener(fabric.document, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
        addListener(canvasElement, eventTypePrefix + 'move', this._onMouseMove, addEventOptions);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMove: function (e) {
      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
      this.__onMouseMove(e);
    },

    /**
     * @private
     */
    _onResize: function () {
      this.calcOffset();
    },

    /**
     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
     * @private
     * @param {Object} target
     */
    _shouldRender: function(target) {
      var activeObject = this._activeObject;

      if (
        !!activeObject !== !!target ||
        (activeObject && target && (activeObject !== target))
      ) {
        // this covers: switch of target, from target to no target, selection of target
        // multiSelection with key and mouse
        return true;
      }
      else if (activeObject && activeObject.isEditing) {
        // if we mouse up/down over a editing textbox a cursor change,
        // there is no need to re render
        return false;
      }
      return false;
    },

    /**
     * Method that defines the actions when mouse is released on canvas.
     * The method resets the currentTransform parameters, store the image corner
     * position in the image object and render the canvas on top.
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseUp: function (e) {
      var target, transform = this._currentTransform,
          groupSelector = this._groupSelector, shouldRender = false,
          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));
      this._cacheTransformEventData(e);
      target = this._target;
      this._handleEvent(e, 'up:before');
      // if right/middle click just fire events and return
      // target undefined will make the _handleEvent search the target
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'up', RIGHT_CLICK, isClick);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'up', MIDDLE_CLICK, isClick);
        }
        this._resetTransformEventData();
        return;
      }

      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this._onMouseUpInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }
      if (transform) {
        this._finalizeCurrentTransform(e);
        shouldRender = transform.actionPerformed;
      }
      if (!isClick) {
        var targetWasActive = target === this._activeObject;
        this._maybeGroupObjects(e);
        if (!shouldRender) {
          shouldRender = (
            this._shouldRender(target) ||
            (!targetWasActive && target === this._activeObject)
          );
        }
      }
      if (target) {
        var corner = target._findTargetCorner(
          this.getPointer(e, true),
          fabric.util.isTouchEvent(e)
        );
        var control = target.controls[corner],
            mouseUpHandler = control && control.getMouseUpHandler(e, target, control);
        if (mouseUpHandler) {
          var pointer = this.getPointer(e);
          mouseUpHandler(e, transform, pointer.x, pointer.y);
        }
        target.isMoving = false;
      }
      this._setCursorFromEvent(e, target);
      this._handleEvent(e, 'up', LEFT_CLICK, isClick);
      this._groupSelector = null;
      this._currentTransform = null;
      // reset the target information about which corner is selected
      target && (target.__corner = 0);
      if (shouldRender) {
        this.requestRenderAll();
      }
      else if (!isClick) {
        this.renderTop();
      }
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @return {Fabric.Object} target return the the target found, for internal reasons.
     */
    _simpleEventHandler: function(eventType, e) {
      var target = this.findTarget(e),
          targets = this.targets,
          options = {
            e: e,
            target: target,
            subTargets: targets,
          };
      this.fire(eventType, options);
      target && target.fire(eventType, options);
      if (!targets) {
        return target;
      }
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire(eventType, options);
      }
      return target;
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @param {fabric.Object} targetObj receiving event
     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
     */
    _handleEvent: function(e, eventType, button, isClick) {
      var target = this._target,
          targets = this.targets || [],
          options = {
            e: e,
            target: target,
            subTargets: targets,
            button: button || LEFT_CLICK,
            isClick: isClick || false,
            pointer: this._pointer,
            absolutePointer: this._absolutePointer,
            transform: this._currentTransform
          };
      if (eventType === 'up') {
        options.currentTarget = this.findTarget(e);
        options.currentSubTargets = this.targets;
      }
      this.fire('mouse:' + eventType, options);
      target && target.fire('mouse' + eventType, options);
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire('mouse' + eventType, options);
      }
    },

    /**
     * @private
     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
     */
    _finalizeCurrentTransform: function(e) {

      var transform = this._currentTransform,
          target = transform.target,
          eventName,
          options = {
            e: e,
            target: target,
            transform: transform,
            action: transform.action,
          };

      if (target._scaling) {
        target._scaling = false;
      }

      target.setCoords();

      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
        if (transform.actionPerformed) {
          // this is not friendly to the new control api.
          // is deprecated.
          eventName = this._addEventOptions(options, transform);
          this._fire(eventName, options);
        }
        this._fire('modified', options);
      }
    },

    /**
     * Mutate option object in order to add by property and give back the event name.
     * @private
     * @deprecated since 4.2.0
     * @param {Object} options to mutate
     * @param {Object} transform to inspect action from
     */
    _addEventOptions: function(options, transform) {
      // we can probably add more details at low cost
      // scale change, rotation changes, translation changes
      var eventName, by;
      switch (transform.action) {
        case 'scaleX':
          eventName = 'scaled';
          by = 'x';
          break;
        case 'scaleY':
          eventName = 'scaled';
          by = 'y';
          break;
        case 'skewX':
          eventName = 'skewed';
          by = 'x';
          break;
        case 'skewY':
          eventName = 'skewed';
          by = 'y';
          break;
        case 'scale':
          eventName = 'scaled';
          by = 'equally';
          break;
        case 'rotate':
          eventName = 'rotated';
          break;
        case 'drag':
          eventName = 'moved';
          break;
      }
      options.by = by;
      return eventName;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDownInDrawingMode: function(e) {
      this._isCurrentlyDrawing = true;
      if (this.getActiveObject()) {
        this.discardActiveObject(e).requestRenderAll();
      }
      var pointer = this.getPointer(e);
      this.freeDrawingBrush.onMouseDown(pointer, { e: e, pointer: pointer });
      this._handleEvent(e, 'down');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMoveInDrawingMode: function(e) {
      if (this._isCurrentlyDrawing) {
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseMove(pointer, { e: e, pointer: pointer });
      }
      this.setCursor(this.freeDrawingCursor);
      this._handleEvent(e, 'move');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUpInDrawingMode: function(e) {
      var pointer = this.getPointer(e);
      this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: e, pointer: pointer });
      this._handleEvent(e, 'up');
    },

    /**
     * Method that defines the actions when mouse is clicked on canvas.
     * The method inits the currentTransform parameters and renders all the
     * canvas so the current image can be placed on the top canvas and the rest
     * in on the container one.
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    __onMouseDown: function (e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'down:before');
      var target = this._target;
      // if right click just fire events
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'down', RIGHT_CLICK);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'down', MIDDLE_CLICK);
        }
        return;
      }

      if (this.isDrawingMode) {
        this._onMouseDownInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }

      // ignore if some object is being transformed at this moment
      if (this._currentTransform) {
        return;
      }

      var pointer = this._pointer;
      // save pointer for check in __onMouseUp event
      this._previousPointer = pointer;
      var shouldRender = this._shouldRender(target),
          shouldGroup = this._shouldGroup(e, target);
      if (this._shouldClearSelection(e, target)) {
        this.discardActiveObject(e);
      }
      else if (shouldGroup) {
        this._handleGrouping(e, target);
        target = this._activeObject;
      }

      if (this.selection && (!target ||
        (!target.selectable && !target.isEditing && target !== this._activeObject))) {
        this._groupSelector = {
          ex: pointer.x,
          ey: pointer.y,
          top: 0,
          left: 0
        };
      }

      if (target) {
        var alreadySelected = target === this._activeObject;
        if (target.selectable) {
          this.setActiveObject(target, e);
        }
        var corner = target._findTargetCorner(
          this.getPointer(e, true),
          fabric.util.isTouchEvent(e)
        );
        target.__corner = corner;
        if (target === this._activeObject && (corner || !shouldGroup)) {
          this._setupCurrentTransform(e, target, alreadySelected);
          var control = target.controls[corner],
              pointer = this.getPointer(e),
              mouseDownHandler = control && control.getMouseDownHandler(e, target, control);
          if (mouseDownHandler) {
            mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);
          }
        }
      }
      this._handleEvent(e, 'down');
      // we must renderAll so that we update the visuals
      (shouldRender || shouldGroup) && this.requestRenderAll();
    },

    /**
     * reset cache form common information needed during event processing
     * @private
     */
    _resetTransformEventData: function() {
      this._target = null;
      this._pointer = null;
      this._absolutePointer = null;
    },

    /**
     * Cache common information needed during event processing
     * @private
     * @param {Event} e Event object fired on event
     */
    _cacheTransformEventData: function(e) {
      // reset in order to avoid stale caching
      this._resetTransformEventData();
      this._pointer = this.getPointer(e, true);
      this._absolutePointer = this.restorePointerVpt(this._pointer);
      this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;
    },

    /**
     * @private
     */
    _beforeTransform: function(e) {
      var t = this._currentTransform;
      this.stateful && t.target.saveState();
      this.fire('before:transform', {
        e: e,
        transform: t,
      });
    },

    /**
     * Method that defines the actions when mouse is hovering the canvas.
     * The currentTransform parameter will define whether the user is rotating/scaling/translating
     * an image or neither of them (only hovering). A group selection is also possible and would cancel
     * all any other type of action.
     * In case of an image transformation only the top canvas will be rendered.
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    __onMouseMove: function (e) {
      this._handleEvent(e, 'move:before');
      this._cacheTransformEventData(e);
      var target, pointer;

      if (this.isDrawingMode) {
        this._onMouseMoveInDrawingMode(e);
        return;
      }

      if (!this._isMainEvent(e)) {
        return;
      }

      var groupSelector = this._groupSelector;

      // We initially clicked in an empty area, so we draw a box for multiple selection
      if (groupSelector) {
        pointer = this._pointer;

        groupSelector.left = pointer.x - groupSelector.ex;
        groupSelector.top = pointer.y - groupSelector.ey;

        this.renderTop();
      }
      else if (!this._currentTransform) {
        target = this.findTarget(e) || null;
        this._setCursorFromEvent(e, target);
        this._fireOverOutEvents(target, e);
      }
      else {
        this._transformObject(e);
      }
      this._handleEvent(e, 'move');
      this._resetTransformEventData();
    },

    /**
     * Manage the mouseout, mouseover events for the fabric object on the canvas
     * @param {Fabric.Object} target the target where the target from the mousemove event
     * @param {Event} e Event object fired on mousemove
     * @private
     */
    _fireOverOutEvents: function(target, e) {
      var _hoveredTarget = this._hoveredTarget,
          _hoveredTargets = this._hoveredTargets, targets = this.targets,
          length = Math.max(_hoveredTargets.length, targets.length);

      this.fireSyntheticInOutEvents(target, e, {
        oldTarget: _hoveredTarget,
        evtOut: 'mouseout',
        canvasEvtOut: 'mouse:out',
        evtIn: 'mouseover',
        canvasEvtIn: 'mouse:over',
      });
      for (var i = 0; i < length; i++){
        this.fireSyntheticInOutEvents(targets[i], e, {
          oldTarget: _hoveredTargets[i],
          evtOut: 'mouseout',
          evtIn: 'mouseover',
        });
      }
      this._hoveredTarget = target;
      this._hoveredTargets = this.targets.concat();
    },

    /**
     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the onDrag event
     * @param {Event} e Event object fired on ondrag
     * @private
     */
    _fireEnterLeaveEvents: function(target, e) {
      var _draggedoverTarget = this._draggedoverTarget,
          _hoveredTargets = this._hoveredTargets, targets = this.targets,
          length = Math.max(_hoveredTargets.length, targets.length);

      this.fireSyntheticInOutEvents(target, e, {
        oldTarget: _draggedoverTarget,
        evtOut: 'dragleave',
        evtIn: 'dragenter',
      });
      for (var i = 0; i < length; i++) {
        this.fireSyntheticInOutEvents(targets[i], e, {
          oldTarget: _hoveredTargets[i],
          evtOut: 'dragleave',
          evtIn: 'dragenter',
        });
      }
      this._draggedoverTarget = target;
    },

    /**
     * Manage the synthetic in/out events for the fabric objects on the canvas
     * @param {Fabric.Object} target the target where the target from the supported events
     * @param {Event} e Event object fired
     * @param {Object} config configuration for the function to work
     * @param {String} config.targetName property on the canvas where the old target is stored
     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
     * @param {String} config.evtOut name of the event to fire for out
     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
     * @param {String} config.evtIn name of the event to fire for in
     * @private
     */
    fireSyntheticInOutEvents: function(target, e, config) {
      var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires,
          targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
      if (targetChanged) {
        inOpt = { e: e, target: target, previousTarget: oldTarget };
        outOpt = { e: e, target: oldTarget, nextTarget: target };
      }
      inFires = target && targetChanged;
      outFires = oldTarget && targetChanged;
      if (outFires) {
        canvasEvtOut && this.fire(canvasEvtOut, outOpt);
        oldTarget.fire(config.evtOut, outOpt);
      }
      if (inFires) {
        canvasEvtIn && this.fire(canvasEvtIn, inOpt);
        target.fire(config.evtIn, inOpt);
      }
    },

    /**
     * Method that defines actions when an Event Mouse Wheel
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseWheel: function(e) {
      this._cacheTransformEventData(e);
      this._handleEvent(e, 'wheel');
      this._resetTransformEventData();
    },

    /**
     * @private
     * @param {Event} e Event fired on mousemove
     */
    _transformObject: function(e) {
      var pointer = this.getPointer(e),
          transform = this._currentTransform;

      transform.reset = false;
      transform.target.isMoving = true;
      transform.shiftKey = e.shiftKey;
      transform.altKey = e[this.centeredKey];

      this._performTransformAction(e, transform, pointer);
      transform.actionPerformed && this.requestRenderAll();
    },

    /**
     * @private
     */
    _performTransformAction: function(e, transform, pointer) {
      var x = pointer.x,
          y = pointer.y,
          action = transform.action,
          actionPerformed = false,
          actionHandler = transform.actionHandler;
          // this object could be created from the function in the control handlers


      if (actionHandler) {
        actionPerformed = actionHandler(e, transform, x, y);
      }
      if (action === 'drag' && actionPerformed) {
        this.setCursor(transform.target.moveCursor || this.moveCursor);
      }
      transform.actionPerformed = transform.actionPerformed || actionPerformed;
    },

    /**
     * @private
     */
    _fire: fabric.controlsUtils.fireEvent,

    /**
     * Sets the cursor depending on where the canvas is being hovered.
     * Note: very buggy in Opera
     * @param {Event} e Event object
     * @param {Object} target Object that the mouse is hovering, if so.
     */
    _setCursorFromEvent: function (e, target) {
      if (!target) {
        this.setCursor(this.defaultCursor);
        return false;
      }
      var hoverCursor = target.hoverCursor || this.hoverCursor,
          activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
            this._activeObject : null,
          // only show proper corner when group selection is not active
          corner = (!activeSelection || !activeSelection.contains(target))
          // here we call findTargetCorner always with undefined for the touch parameter.
          // we assume that if you are using a cursor you do not need to interact with
          // the bigger touch area.
                    && target._findTargetCorner(this.getPointer(e, true));

      if (!corner) {
        if (target.subTargetCheck){
          // hoverCursor should come from top-most subTarget,
          // so we walk the array backwards
          this.targets.concat().reverse().map(function(_target){
            hoverCursor = _target.hoverCursor || hoverCursor;
          });
        }
        this.setCursor(hoverCursor);
      }
      else {
        this.setCursor(this.getCornerCursor(corner, target, e));
      }
    },

    /**
     * @private
     */
    getCornerCursor: function(corner, target, e) {
      var control = target.controls[corner];
      return control.cursorStyleHandler(e, control, target);
    }
  });
})();


(function() {

  var min = Math.min,
      max = Math.max;

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     * @return {Boolean}
     */
    _shouldGroup: function(e, target) {
      var activeObject = this._activeObject;
      return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection &&
            (activeObject !== target || activeObject.type === 'activeSelection') && !target.onSelect({ e: e });
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _handleGrouping: function (e, target) {
      var activeObject = this._activeObject;
      // avoid multi select when shift click on a corner
      if (activeObject.__corner) {
        return;
      }
      if (target === activeObject) {
        // if it's a group, find target again, using activeGroup objects
        target = this.findTarget(e, true);
        // if even object is not found or we are on activeObjectCorner, bail out
        if (!target || !target.selectable) {
          return;
        }
      }
      if (activeObject && activeObject.type === 'activeSelection') {
        this._updateActiveSelection(target, e);
      }
      else {
        this._createActiveSelection(target, e);
      }
    },

    /**
     * @private
     */
    _updateActiveSelection: function(target, e) {
      var activeSelection = this._activeObject,
          currentActiveObjects = activeSelection._objects.slice(0);
      if (activeSelection.contains(target)) {
        activeSelection.removeWithUpdate(target);
        this._hoveredTarget = target;
        this._hoveredTargets = this.targets.concat();
        if (activeSelection.size() === 1) {
          // activate last remaining object
          this._setActiveObject(activeSelection.item(0), e);
        }
      }
      else {
        activeSelection.addWithUpdate(target);
        this._hoveredTarget = activeSelection;
        this._hoveredTargets = this.targets.concat();
      }
      this._fireSelectionEvents(currentActiveObjects, e);
    },

    /**
     * @private
     */
    _createActiveSelection: function(target, e) {
      var currentActives = this.getActiveObjects(), group = this._createGroup(target);
      this._hoveredTarget = group;
      // ISSUE 4115: should we consider subTargets here?
      // this._hoveredTargets = [];
      // this._hoveredTargets = this.targets.concat();
      this._setActiveObject(group, e);
      this._fireSelectionEvents(currentActives, e);
    },

    /**
     * @private
     * @param {Object} target
     */
    _createGroup: function(target) {
      var objects = this._objects,
          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
          groupObjects = isActiveLower
            ? [this._activeObject, target]
            : [target, this._activeObject];
      this._activeObject.isEditing && this._activeObject.exitEditing();
      return new fabric.ActiveSelection(groupObjects, {
        canvas: this
      });
    },

    /**
     * @private
     * @param {Event} e mouse event
     */
    _groupSelectedObjects: function (e) {

      var group = this._collectObjects(e),
          aGroup;

      // do not create group for 1 element only
      if (group.length === 1) {
        this.setActiveObject(group[0], e);
      }
      else if (group.length > 1) {
        aGroup = new fabric.ActiveSelection(group.reverse(), {
          canvas: this
        });
        this.setActiveObject(aGroup, e);
      }
    },

    /**
     * @private
     */
    _collectObjects: function(e) {
      var group = [],
          currentObject,
          x1 = this._groupSelector.ex,
          y1 = this._groupSelector.ey,
          x2 = x1 + this._groupSelector.left,
          y2 = y1 + this._groupSelector.top,
          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
          allowIntersect = !this.selectionFullyContained,
          isClick = x1 === x2 && y1 === y2;
      // we iterate reverse order to collect top first in case of click.
      for (var i = this._objects.length; i--; ) {
        currentObject = this._objects[i];

        if (!currentObject || !currentObject.selectable || !currentObject.visible) {
          continue;
        }

        if ((allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2)) ||
            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
            (allowIntersect && currentObject.containsPoint(selectionX1Y1)) ||
            (allowIntersect && currentObject.containsPoint(selectionX2Y2))
        ) {
          group.push(currentObject);
          // only add one object if it's a click
          if (isClick) {
            break;
          }
        }
      }

      if (group.length > 1) {
        group = group.filter(function(object) {
          return !object.onSelect({ e: e });
        });
      }

      return group;
    },

    /**
     * @private
     */
    _maybeGroupObjects: function(e) {
      if (this.selection && this._groupSelector) {
        this._groupSelectedObjects(e);
      }
      this.setCursor(this.defaultCursor);
      // clear selection and current transformation
      this._groupSelector = null;
    }
  });

})();


(function () {
  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
     * @param {Object} [options] Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
     * @example <caption>Generate jpeg dataURL with lower quality</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'jpeg',
     *   quality: 0.8
     * });
     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   left: 100,
     *   top: 100,
     *   width: 200,
     *   height: 200
     * });
     * @example <caption>Generate double scaled png dataURL</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   multiplier: 2
     * });
     */
    toDataURL: function (options) {
      options || (options = { });

      var format = options.format || 'png',
          quality = options.quality || 1,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1),
          canvasEl = this.toCanvasElement(multiplier, options);
      return fabric.util.toDataURL(canvasEl, format, quality);
    },

    /**
     * Create a new HTMLCanvas element painted with the current canvas content.
     * No need to resize the actual one or repaint it.
     * Will transfer object ownership to a new canvas, paint it, and set everything back.
     * This is an intermediary step used to get to a dataUrl but also it is useful to
     * create quick image copies of a canvas without passing for the dataUrl string
     * @param {Number} [multiplier] a zoom factor.
     * @param {Object} [cropping] Cropping informations
     * @param {Number} [cropping.left] Cropping left offset.
     * @param {Number} [cropping.top] Cropping top offset.
     * @param {Number} [cropping.width] Cropping width.
     * @param {Number} [cropping.height] Cropping height.
     */
    toCanvasElement: function(multiplier, cropping) {
      multiplier = multiplier || 1;
      cropping = cropping || { };
      var scaledWidth = (cropping.width || this.width) * multiplier,
          scaledHeight = (cropping.height || this.height) * multiplier,
          zoom = this.getZoom(),
          originalWidth = this.width,
          originalHeight = this.height,
          newZoom = zoom * multiplier,
          vp = this.viewportTransform,
          translateX = (vp[4] - (cropping.left || 0)) * multiplier,
          translateY = (vp[5] - (cropping.top || 0)) * multiplier,
          originalInteractive = this.interactive,
          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
          originalRetina = this.enableRetinaScaling,
          canvasEl = fabric.util.createCanvasElement(),
          originalContextTop = this.contextTop;
      canvasEl.width = scaledWidth;
      canvasEl.height = scaledHeight;
      this.contextTop = null;
      this.enableRetinaScaling = false;
      this.interactive = false;
      this.viewportTransform = newVp;
      this.width = scaledWidth;
      this.height = scaledHeight;
      this.calcViewportBoundaries();
      this.renderCanvas(canvasEl.getContext('2d'), this._objects);
      this.viewportTransform = vp;
      this.width = originalWidth;
      this.height = originalHeight;
      this.calcViewportBoundaries();
      this.interactive = originalInteractive;
      this.enableRetinaScaling = originalRetina;
      this.contextTop = originalContextTop;
      return canvasEl;
    },
  });

})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
  /**
   * Populates canvas with data from the specified JSON.
   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
   * @param {String|Object} json JSON string or object
   * @param {Function} callback Callback, invoked when json is parsed
   *                            and corresponding objects (e.g: {@link fabric.Image})
   *                            are initialized
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
   * @return {fabric.Canvas} instance
   * @chainable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
   * @example <caption>loadFromJSON</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
   * @example <caption>loadFromJSON with reviver</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
   *   // `o` = json object
   *   // `object` = fabric.Object instance
   *   // ... do some stuff ...
   * });
   */
  loadFromJSON: function (json, callback, reviver) {
    if (!json) {
      return;
    }

    // serialize if it wasn't already
    var serialized = (typeof json === 'string')
      ? JSON.parse(json)
      : fabric.util.object.clone(json);

    var _this = this,
        clipPath = serialized.clipPath,
        renderOnAddRemove = this.renderOnAddRemove;

    this.renderOnAddRemove = false;

    delete serialized.clipPath;

    this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
      _this.clear();
      _this._setBgOverlay(serialized, function () {
        if (clipPath) {
          _this._enlivenObjects([clipPath], function (enlivenedCanvasClip) {
            _this.clipPath = enlivenedCanvasClip[0];
            _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
          });
        }
        else {
          _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
        }
      });
    }, reviver);
    return this;
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Array} restored canvas objects
   * @param {Function} cached renderOnAddRemove callback
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {
    var _this = this;
    enlivenedObjects.forEach(function(obj, index) {
      // we splice the array just in case some custom classes restored from JSON
      // will add more object to canvas at canvas init.
      _this.insertAt(obj, index);
    });
    this.renderOnAddRemove = renderOnAddRemove;
    // remove parts i cannot set as options
    delete serialized.objects;
    delete serialized.backgroundImage;
    delete serialized.overlayImage;
    delete serialized.background;
    delete serialized.overlay;
    // this._initOptions does too many things to just
    // call it. Normally loading an Object from JSON
    // create the Object instance. Here the Canvas is
    // already an instance and we are just loading things over it
    this._setOptions(serialized);
    this.renderAll();
    callback && callback();
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  _setBgOverlay: function(serialized, callback) {
    var loaded = {
      backgroundColor: false,
      overlayColor: false,
      backgroundImage: false,
      overlayImage: false
    };

    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
      callback && callback();
      return;
    }

    var cbIfLoaded = function () {
      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
        callback && callback();
      }
    };

    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
  },

  /**
   * @private
   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
   * @param {(Object|String)} value Value to set
   * @param {Object} loaded Set loaded property to true if property is set
   * @param {Object} callback Callback function to invoke after property is set
   */
  __setBgOverlay: function(property, value, loaded, callback) {
    var _this = this;

    if (!value) {
      loaded[property] = true;
      callback && callback();
      return;
    }

    if (property === 'backgroundImage' || property === 'overlayImage') {
      fabric.util.enlivenObjects([value], function(enlivedObject){
        _this[property] = enlivedObject[0];
        loaded[property] = true;
        callback && callback();
      });
    }
    else {
      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
        loaded[property] = true;
        callback && callback();
      });
    }
  },

  /**
   * @private
   * @param {Array} objects
   * @param {Function} callback
   * @param {Function} [reviver]
   */
  _enlivenObjects: function (objects, callback, reviver) {
    if (!objects || objects.length === 0) {
      callback && callback([]);
      return;
    }

    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
      callback && callback(enlivenedObjects);
    }, null, reviver);
  },

  /**
   * @private
   * @param {String} format
   * @param {Function} callback
   */
  _toDataURL: function (format, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURL(format));
    });
  },

  /**
   * @private
   * @param {String} format
   * @param {Number} multiplier
   * @param {Function} callback
   */
  _toDataURLWithMultiplier: function (format, multiplier, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURLWithMultiplier(format, multiplier));
    });
  },

  /**
   * Clones canvas instance
   * @param {Object} [callback] Receives cloned instance as a first argument
   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
   */
  clone: function (callback, properties) {
    var data = JSON.stringify(this.toJSON(properties));
    this.cloneWithoutData(function(clone) {
      clone.loadFromJSON(data, function() {
        callback && callback(clone);
      });
    });
  },

  /**
   * Clones canvas instance without cloning existing data.
   * This essentially copies canvas dimensions, clipping properties, etc.
   * but leaves data empty (so that you can populate it with your own)
   * @param {Object} [callback] Receives cloned instance as a first argument
   */
  cloneWithoutData: function(callback) {
    var el = fabric.util.createCanvasElement();

    el.width = this.width;
    el.height = this.height;

    var clone = new fabric.Canvas(el);
    if (this.backgroundImage) {
      clone.setBackgroundImage(this.backgroundImage.src, function() {
        clone.renderAll();
        callback && callback(clone);
      });
      clone.backgroundImageOpacity = this.backgroundImageOpacity;
      clone.backgroundImageStretch = this.backgroundImageStretch;
    }
    else {
      callback && callback(clone);
    }
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      capitalize = fabric.util.string.capitalize,
      degreesToRadians = fabric.util.degreesToRadians,
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
      objectCaching = !fabric.isLikelyNode,
      ALIASING_LIMIT = 2;

  if (fabric.Object) {
    return;
  }

  /**
   * Root object class from which all 2d shape classes inherit from
   * @class fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
   * @see {@link fabric.Object#initialize} for constructor definition
   *
   * @fires added
   * @fires removed
   *
   * @fires selected
   * @fires deselected
   * @fires modified
   * @fires modified
   * @fires moved
   * @fires scaled
   * @fires rotated
   * @fires skewed
   *
   * @fires rotating
   * @fires scaling
   * @fires moving
   * @fires skewing
   *
   * @fires mousedown
   * @fires mouseup
   * @fires mouseover
   * @fires mouseout
   * @fires mousewheel
   * @fires mousedblclick
   *
   * @fires dragover
   * @fires dragenter
   * @fires dragleave
   * @fires drop
   */
  fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

    /**
     * Type of an object (rect, circle, path, etc.).
     * Note that this property is meant to be read-only and not meant to be modified.
     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
     * @type String
     * @default
     */
    type:                     'object',

    /**
     * Horizontal origin of transformation of an object (one of "left", "right", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originX:                  'left',

    /**
     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originY:                  'top',

    /**
     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
     * @type Number
     * @default
     */
    top:                      0,

    /**
     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
     * @type Number
     * @default
     */
    left:                     0,

    /**
     * Object width
     * @type Number
     * @default
     */
    width:                    0,

    /**
     * Object height
     * @type Number
     * @default
     */
    height:                   0,

    /**
     * Object scale factor (horizontal)
     * @type Number
     * @default
     */
    scaleX:                   1,

    /**
     * Object scale factor (vertical)
     * @type Number
     * @default
     */
    scaleY:                   1,

    /**
     * When true, an object is rendered as flipped horizontally
     * @type Boolean
     * @default
     */
    flipX:                    false,

    /**
     * When true, an object is rendered as flipped vertically
     * @type Boolean
     * @default
     */
    flipY:                    false,

    /**
     * Opacity of an object
     * @type Number
     * @default
     */
    opacity:                  1,

    /**
     * Angle of rotation of an object (in degrees)
     * @type Number
     * @default
     */
    angle:                    0,

    /**
     * Angle of skew on x axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewX:                    0,

    /**
     * Angle of skew on y axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewY:                    0,

    /**
     * Size of object's controlling corners (in pixels)
     * @type Number
     * @default
     */
    cornerSize:               13,

    /**
     * Size of object's controlling corners when touch interaction is detected
     * @type Number
     * @default
     */
    touchCornerSize:               24,

    /**
     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
     * @type Boolean
     * @default
     */
    transparentCorners:       true,

    /**
     * Default cursor value used when hovering over this object on canvas
     * @type String
     * @default
     */
    hoverCursor:              null,

    /**
     * Default cursor value used when moving this object on canvas
     * @type String
     * @default
     */
    moveCursor:               null,

    /**
     * Padding between object and its controlling borders (in pixels)
     * @type Number
     * @default
     */
    padding:                  0,

    /**
     * Color of controlling borders of an object (when it's active)
     * @type String
     * @default
     */
    borderColor:              'rgb(178,204,255)',

    /**
     * Array specifying dash pattern of an object's borders (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    borderDashArray:          null,

    /**
     * Color of controlling corners of an object (when it's active)
     * @type String
     * @default
     */
    cornerColor:              'rgb(178,204,255)',

    /**
     * Color of controlling corners of an object (when it's active and transparentCorners false)
     * @since 1.6.2
     * @type String
     * @default
     */
    cornerStrokeColor:        null,

    /**
     * Specify style of control, 'rect' or 'circle'
     * @since 1.6.2
     * @type String
     */
    cornerStyle:          'rect',

    /**
     * Array specifying dash pattern of an object's control (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    cornerDashArray:          null,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being scaled via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:          false,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being rotated via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:         true,

    /**
     * Color of object's fill
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    fill:                     'rgb(0,0,0)',

    /**
     * Fill rule used to fill an object
     * accepted values are nonzero, evenodd
     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
     * @type String
     * @default
     */
    fillRule:                 'nonzero',

    /**
     * Composite rule used for canvas globalCompositeOperation
     * @type String
     * @default
     */
    globalCompositeOperation: 'source-over',

    /**
     * Background color of an object.
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    backgroundColor:          '',

    /**
     * Selection Background color of an object. colored layer behind the object when it is active.
     * does not mix good with globalCompositeOperation methods.
     * @type String
     * @default
     */
    selectionBackgroundColor:          '',

    /**
     * When defined, an object is rendered via stroke and this property specifies its color
     * takes css colors https://www.w3.org/TR/css-color-3/
     * @type String
     * @default
     */
    stroke:                   null,

    /**
     * Width of a stroke used to render this object
     * @type Number
     * @default
     */
    strokeWidth:              1,

    /**
     * Array specifying dash pattern of an object's stroke (stroke must be defined)
     * @type Array
     */
    strokeDashArray:          null,

    /**
     * Line offset of an object's stroke
     * @type Number
     * @default
     */
    strokeDashOffset: 0,

    /**
     * Line endings style of an object's stroke (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap:            'butt',

    /**
     * Corner style of an object's stroke (one of "bevel", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin:           'miter',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
     * @type Number
     * @default
     */
    strokeMiterLimit:         4,

    /**
     * Shadow object representing shadow of this shape
     * @type fabric.Shadow
     * @default
     */
    shadow:                   null,

    /**
     * Opacity of object's controlling borders when object is active and moving
     * @type Number
     * @default
     */
    borderOpacityWhenMoving:  0.4,

    /**
     * Scale factor of object's controlling borders
     * bigger number will make a thicker border
     * border is 1, so this is basically a border thickness
     * since there is no way to change the border itself.
     * @type Number
     * @default
     */
    borderScaleFactor:        1,

    /**
     * Minimum allowed scale value of an object
     * @type Number
     * @default
     */
    minScaleLimit:            0,

    /**
     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
     * But events still fire on it.
     * @type Boolean
     * @default
     */
    selectable:               true,

    /**
     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
     * @type Boolean
     * @default
     */
    evented:                  true,

    /**
     * When set to `false`, an object is not rendered on canvas
     * @type Boolean
     * @default
     */
    visible:                  true,

    /**
     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
     * @type Boolean
     * @default
     */
    hasControls:              true,

    /**
     * When set to `false`, object's controlling borders are not rendered
     * @type Boolean
     * @default
     */
    hasBorders:               true,

    /**
     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:       false,

    /**
     * When `false`, default object's values are not included in its serialization
     * @type Boolean
     * @default
     */
    includeDefaultValues:     true,

    /**
     * When `true`, object horizontal movement is locked
     * @type Boolean
     * @default
     */
    lockMovementX:            false,

    /**
     * When `true`, object vertical movement is locked
     * @type Boolean
     * @default
     */
    lockMovementY:            false,

    /**
     * When `true`, object rotation is locked
     * @type Boolean
     * @default
     */
    lockRotation:             false,

    /**
     * When `true`, object horizontal scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingX:             false,

    /**
     * When `true`, object vertical scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingY:             false,

    /**
     * When `true`, object horizontal skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingX:             false,

    /**
     * When `true`, object vertical skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingY:             false,

    /**
     * When `true`, object cannot be flipped by scaling into negative values
     * @type Boolean
     * @default
     */
    lockScalingFlip:          false,

    /**
     * When `true`, object is not exported in OBJECT/JSON
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    excludeFromExport:        false,

    /**
     * When `true`, object is cached on an additional canvas.
     * When `false`, object is not cached unless necessary ( clipPath )
     * default to true
     * @since 1.7.0
     * @type Boolean
     * @default true
     */
    objectCaching:            objectCaching,

    /**
     * When `true`, object properties are checked for cache invalidation. In some particular
     * situation you may want this to be disabled ( spray brush, very big, groups)
     * or if your application does not allow you to modify properties for groups child you want
     * to disable it for groups.
     * default to false
     * since 1.7.0
     * @type Boolean
     * @default false
     */
    statefullCache:            false,

    /**
     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
     * too much and will be redrawn with correct details at the end of scaling.
     * this setting is performance and application dependant.
     * default to true
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    noScaleCache:              true,

    /**
     * When `false`, the stoke width will scale with the object.
     * When `true`, the stroke will always match the exact pixel size entered for stroke width.
     * default to false
     * @since 2.6.0
     * @type Boolean
     * @default false
     * @type Boolean
     * @default false
     */
    strokeUniform:              false,

    /**
     * When set to `true`, object's cache will be rerendered next render call.
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    dirty:                true,

    /**
     * keeps the value of the last hovered corner during mouse move.
     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
     * It should be private, but there is no harm in using it as
     * a read-only property.
     * @type number|string|any
     * @default 0
     */
    __corner: 0,

    /**
     * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
     * @type String
     * @default
     */
    paintFirst:           'fill',

    /**
     * List of properties to consider when checking if state
     * of an object is changed (fabric.Object#hasStateChanged)
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: (
      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
      'stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit ' +
      'angle opacity fill globalCompositeOperation shadow visible backgroundColor ' +
      'skewX skewY fillRule paintFirst clipPath strokeUniform'
    ).split(' '),

    /**
     * List of properties to consider when checking if cache needs refresh
     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
     * and refreshed at the next render
     * @type Array
     */
    cacheProperties: (
      'fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform' +
      ' strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath'
    ).split(' '),

    /**
     * List of properties to consider for animating colors.
     * @type Array
     */
    colorProperties: (
      'fill stroke backgroundColor'
    ).split(' '),

    /**
     * a fabricObject that, without stroke define a clipping area with their shape. filled in black
     * the clipPath object gets used when the object has rendered, and the context is placed in the center
     * of the object cacheCanvas.
     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
     * @type fabric.Object
     */
    clipPath: undefined,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will make the object clip to the outside of the clipPath
     * since 2.4.0
     * @type boolean
     * @default false
     */
    inverted: false,

    /**
     * Meaningful ONLY when the object is used as clipPath.
     * if true, the clipPath will have its top and left relative to canvas, and will
     * not be influenced by the object transform. This will make the clipPath relative
     * to the canvas, but clipping just a particular object.
     * WARNING this is beta, this feature may change or be renamed.
     * since 2.4.0
     * @type boolean
     * @default false
     */
    absolutePositioned: false,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Create a the canvas used to keep the cached copy of the object
     * @private
     */
    _createCacheCanvas: function() {
      this._cacheProperties = {};
      this._cacheCanvas = fabric.util.createCanvasElement();
      this._cacheContext = this._cacheCanvas.getContext('2d');
      this._updateCacheCanvas();
      // if canvas gets created, is empty, so dirty.
      this.dirty = true;
    },

    /**
     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
     * and each side do not cross fabric.cacheSideLimit
     * those numbers are configurable so that you can get as much detail as you want
     * making bargain with performances.
     * @param {Object} dims
     * @param {Object} dims.width width of canvas
     * @param {Object} dims.height height of canvas
     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _limitCacheSize: function(dims) {
      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
          width = dims.width, height = dims.height,
          max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;
      if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
        if (width < min) {
          dims.width = min;
        }
        if (height < min) {
          dims.height = min;
        }
        return dims;
      }
      var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal),
          capValue = fabric.util.capValue,
          x = capValue(min, limitedDims.x, max),
          y = capValue(min, limitedDims.y, max);
      if (width > x) {
        dims.zoomX /= width / x;
        dims.width = x;
        dims.capped = true;
      }
      if (height > y) {
        dims.zoomY /= height / y;
        dims.height = y;
        dims.capped = true;
      }
      return dims;
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @return {Object}.x width of object to be cached
     * @return {Object}.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var objectScale = this.getTotalObjectScaling(),
          // caculate dimensions without skewing
          dim = this._getTransformedDimensions(0, 0),
          neededX = dim.x * objectScale.scaleX / this.scaleX,
          neededY = dim.y * objectScale.scaleY / this.scaleY;
      return {
        // for sure this ALIASING_LIMIT is slightly creating problem
        // in situation in which the cache canvas gets an upper limit
        // also objectScale contains already scaleX and scaleY
        width: neededX + ALIASING_LIMIT,
        height: neededY + ALIASING_LIMIT,
        zoomX: objectScale.scaleX,
        zoomY: objectScale.scaleY,
        x: neededX,
        y: neededY
      };
    },

    /**
     * Update width and height of the canvas for cache
     * returns true or false if canvas needed resize.
     * @private
     * @return {Boolean} true if the canvas has been resized
     */
    _updateCacheCanvas: function() {
      var targetCanvas = this.canvas;
      if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
        var target = targetCanvas._currentTransform.target,
            action = targetCanvas._currentTransform.action;
        if (this === target && action.slice && action.slice(0, 5) === 'scale') {
          return false;
        }
      }
      var canvas = this._cacheCanvas,
          dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          minCacheSize = fabric.minCacheSideLimit,
          width = dims.width, height = dims.height, drawingWidth, drawingHeight,
          zoomX = dims.zoomX, zoomY = dims.zoomY,
          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
          shouldRedraw = dimensionsChanged || zoomChanged,
          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
      if (dimensionsChanged) {
        var canvasWidth = this._cacheCanvas.width,
            canvasHeight = this._cacheCanvas.height,
            sizeGrowing = width > canvasWidth || height > canvasHeight,
            sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
              canvasWidth > minCacheSize && canvasHeight > minCacheSize;
        shouldResizeCanvas = sizeGrowing || sizeShrinking;
        if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
          additionalWidth = width * 0.1;
          additionalHeight = height * 0.1;
        }
      }
      if (shouldRedraw) {
        if (shouldResizeCanvas) {
          canvas.width = Math.ceil(width + additionalWidth);
          canvas.height = Math.ceil(height + additionalHeight);
        }
        else {
          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
          this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
        }
        drawingWidth = dims.x / 2;
        drawingHeight = dims.y / 2;
        this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
        this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
        this.cacheWidth = width;
        this.cacheHeight = height;
        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
        this._cacheContext.scale(zoomX, zoomY);
        this.zoomX = zoomX;
        this.zoomY = zoomY;
        return true;
      }
      return false;
    },

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      this._setOptions(options);
      this._initGradient(options.fill, 'fill');
      this._initGradient(options.stroke, 'stroke');
      this._initPattern(options.fill, 'fill');
      this._initPattern(options.stroke, 'stroke');
    },

    /**
     * Transforms context when rendering an object
     * @param {CanvasRenderingContext2D} ctx Context
     */
    transform: function(ctx) {
      var needFullTransform = (this.group && !this.group._transformDone) ||
         (this.group && this.canvas && ctx === this.canvas.contextTop);
      var m = this.calcTransformMatrix(!needFullTransform);
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    },

    /**
     * Returns an object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

          object = {
            type:                     this.type,
            version:                  fabric.version,
            originX:                  this.originX,
            originY:                  this.originY,
            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
            strokeLineCap:            this.strokeLineCap,
            strokeDashOffset:         this.strokeDashOffset,
            strokeLineJoin:           this.strokeLineJoin,
            strokeUniform:            this.strokeUniform,
            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
            flipX:                    this.flipX,
            flipY:                    this.flipY,
            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
            visible:                  this.visible,
            backgroundColor:          this.backgroundColor,
            fillRule:                 this.fillRule,
            paintFirst:               this.paintFirst,
            globalCompositeOperation: this.globalCompositeOperation,
            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS),
          };

      if (this.clipPath) {
        object.clipPath = this.clipPath.toObject(propertiesToInclude);
        object.clipPath.inverted = this.clipPath.inverted;
        object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
      }

      fabric.util.populateWithProperties(this, object, propertiesToInclude);
      if (!this.includeDefaultValues) {
        object = this._removeDefaultValues(object);
      }

      return object;
    },

    /**
     * Returns (dataless) object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      // will be overwritten by subclasses
      return this.toObject(propertiesToInclude);
    },

    /**
     * @private
     * @param {Object} object
     */
    _removeDefaultValues: function(object) {
      var prototype = fabric.util.getKlass(object.type).prototype,
          stateProperties = prototype.stateProperties;
      stateProperties.forEach(function(prop) {
        if (prop === 'left' || prop === 'top') {
          return;
        }
        if (object[prop] === prototype[prop]) {
          delete object[prop];
        }
        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';

        // basically a check for [] === []
        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
          delete object[prop];
        }
      });

      return object;
    },

    /**
     * Returns a string representation of an instance
     * @return {String}
     */
    toString: function() {
      return '#<fabric.' + capitalize(this.type) + '>';
    },

    /**
     * Return the object scale factor counting also the group scaling
     * @return {Object} object with scaleX and scaleY properties
     */
    getObjectScaling: function() {
      var options = fabric.util.qrDecompose(this.calcTransformMatrix());
      return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
    },

    /**
     * Return the object scale factor counting also the group scaling, zoom and retina
     * @return {Object} object with scaleX and scaleY properties
     */
    getTotalObjectScaling: function() {
      var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
      if (this.canvas) {
        var zoom = this.canvas.getZoom();
        var retina = this.canvas.getRetinaScaling();
        scaleX *= zoom * retina;
        scaleY *= zoom * retina;
      }
      return { scaleX: scaleX, scaleY: scaleY };
    },

    /**
     * Return the object opacity counting also the group property
     * @return {Number}
     */
    getObjectOpacity: function() {
      var opacity = this.opacity;
      if (this.group) {
        opacity *= this.group.getObjectOpacity();
      }
      return opacity;
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Object} thisArg
     */
    _set: function(key, value) {
      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY'),
          isChanged = this[key] !== value, groupNeedsUpdate = false;

      if (shouldConstrainValue) {
        value = this._constrainScale(value);
      }
      if (key === 'scaleX' && value < 0) {
        this.flipX = !this.flipX;
        value *= -1;
      }
      else if (key === 'scaleY' && value < 0) {
        this.flipY = !this.flipY;
        value *= -1;
      }
      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
        value = new fabric.Shadow(value);
      }
      else if (key === 'dirty' && this.group) {
        this.group.set('dirty', value);
      }

      this[key] = value;

      if (isChanged) {
        groupNeedsUpdate = this.group && this.group.isOnACache();
        if (this.cacheProperties.indexOf(key) > -1) {
          this.dirty = true;
          groupNeedsUpdate && this.group.set('dirty', true);
        }
        else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
          this.group.set('dirty', true);
        }
      }
      return this;
    },

    /**
     * This callback function is called by the parent group of an object every
     * time a non-delegated property changes on the group. It is passed the key
     * and value as parameters. Not adding in this function's signature to avoid
     * Travis build error about unused variables.
     */
    setOnGroup: function() {
      // implemented by sub-classes, as needed.
    },

    /**
     * Retrieves viewportTransform from Object's canvas if possible
     * @method getViewportTransform
     * @memberOf fabric.Object.prototype
     * @return {Array}
     */
    getViewportTransform: function() {
      if (this.canvas && this.canvas.viewportTransform) {
        return this.canvas.viewportTransform;
      }
      return fabric.iMatrix.concat();
    },

    /*
     * @private
     * return if the object would be visible in rendering
     * @memberOf fabric.Object.prototype
     * @return {Boolean}
     */
    isNotVisible: function() {
      return this.opacity === 0 ||
        (!this.width && !this.height && this.strokeWidth === 0) ||
        !this.visible;
    },

    /**
     * Renders an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if width/height are zeros or object is not visible
      if (this.isNotVisible()) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      ctx.save();
      this._setupCompositeOperation(ctx);
      this.drawSelectionBackground(ctx);
      this.transform(ctx);
      this._setOpacity(ctx);
      this._setShadow(ctx, this);
      if (this.shouldCache()) {
        this.renderCache();
        this.drawCacheOnCanvas(ctx);
      }
      else {
        this._removeCacheCanvas();
        this.dirty = false;
        this.drawObject(ctx);
        if (this.objectCaching && this.statefullCache) {
          this.saveState({ propertySet: 'cacheProperties' });
        }
      }
      ctx.restore();
    },

    renderCache: function(options) {
      options = options || {};
      if (!this._cacheCanvas) {
        this._createCacheCanvas();
      }
      if (this.isCacheDirty()) {
        this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
        this.drawObject(this._cacheContext, options.forClipping);
        this.dirty = false;
      }
    },

    /**
     * Remove cacheCanvas and its dimensions from the objects
     */
    _removeCacheCanvas: function() {
      this._cacheCanvas = null;
      this.cacheWidth = 0;
      this.cacheHeight = 0;
    },

    /**
     * return true if the object will draw a stroke
     * Does not consider text styles. This is just a shortcut used at rendering time
     * We want it to be an approximation and be fast.
     * wrote to avoid extra caching, it has to return true when stroke happens,
     * can guess when it will not happen at 100% chance, does not matter if it misses
     * some use case where the stroke is invisible.
     * @since 3.0.0
     * @returns Boolean
     */
    hasStroke: function() {
      return this.stroke && this.stroke !== 'transparent' && this.strokeWidth !== 0;
    },

    /**
     * return true if the object will draw a fill
     * Does not consider text styles. This is just a shortcut used at rendering time
     * We want it to be an approximation and be fast.
     * wrote to avoid extra caching, it has to return true when fill happens,
     * can guess when it will not happen at 100% chance, does not matter if it misses
     * some use case where the fill is invisible.
     * @since 3.0.0
     * @returns Boolean
     */
    hasFill: function() {
      return this.fill && this.fill !== 'transparent';
    },

    /**
     * When set to `true`, force the object to have its own cache, even if it is inside a group
     * it may be needed when your object behave in a particular way on the cache and always needs
     * its own isolated canvas to render correctly.
     * Created to be overridden
     * since 1.7.12
     * @returns Boolean
     */
    needsItsOwnCache: function() {
      if (this.paintFirst === 'stroke' &&
        this.hasFill() && this.hasStroke() && typeof this.shadow === 'object') {
        return true;
      }
      if (this.clipPath) {
        return true;
      }
      return false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
     * @return {Boolean}
     */
    shouldCache: function() {
      this.ownCaching = this.needsItsOwnCache() || (
        this.objectCaching &&
        (!this.group || !this.group.isOnACache())
      );
      return this.ownCaching;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * used by Group.shouldCache to know if child has a shadow recursively
     * @return {Boolean}
     */
    willDrawShadow: function() {
      return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
    },

    /**
     * Execute the drawing operation for an object clipPath
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawClipPathOnCache: function(ctx) {
      var path = this.clipPath;
      ctx.save();
      // DEBUG: uncomment this line, comment the following
      // ctx.globalAlpha = 0.4
      if (path.inverted) {
        ctx.globalCompositeOperation = 'destination-out';
      }
      else {
        ctx.globalCompositeOperation = 'destination-in';
      }
      //ctx.scale(1 / 2, 1 / 2);
      if (path.absolutePositioned) {
        var m = fabric.util.invertTransform(this.calcTransformMatrix());
        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }
      path.transform(ctx);
      ctx.scale(1 / path.zoomX, 1 / path.zoomY);
      ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
      ctx.restore();
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx, forClipping) {
      var originalFill = this.fill, originalStroke = this.stroke;
      if (forClipping) {
        this.fill = 'black';
        this.stroke = '';
        this._setClippingProperties(ctx);
      }
      else {
        this._renderBackground(ctx);
      }
      this._render(ctx);
      this._drawClipPath(ctx);
      this.fill = originalFill;
      this.stroke = originalStroke;
    },

    _drawClipPath: function(ctx) {
      var path = this.clipPath;
      if (!path) { return; }
      // needed to setup a couple of variables
      // path canvas gets overridden with this one.
      // TODO find a better solution?
      path.canvas = this.canvas;
      path.shouldCache();
      path._transformDone = true;
      path.renderCache({ forClipping: true });
      this.drawClipPathOnCache(ctx);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
    },

    /**
     * Check if cache is dirty
     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
     * on parent canvas.
     */
    isCacheDirty: function(skipCanvas) {
      if (this.isNotVisible()) {
        return false;
      }
      if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
        // in this case the context is already cleared.
        return true;
      }
      else {
        if (this.dirty ||
          (this.clipPath && this.clipPath.absolutePositioned) ||
          (this.statefullCache && this.hasStateChanged('cacheProperties'))
        ) {
          if (this._cacheCanvas && !skipCanvas) {
            var width = this.cacheWidth / this.zoomX;
            var height = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Draws a background for the object big as its untransformed dimensions
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      if (!this.backgroundColor) {
        return;
      }
      var dim = this._getNonTransformedDimensions();
      ctx.fillStyle = this.backgroundColor;

      ctx.fillRect(
        -dim.x / 2,
        -dim.y / 2,
        dim.x,
        dim.y
      );
      // if there is background color no other shadows
      // should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setOpacity: function(ctx) {
      if (this.group && !this.group._transformDone) {
        ctx.globalAlpha = this.getObjectOpacity();
      }
      else {
        ctx.globalAlpha *= this.opacity;
      }
    },

    _setStrokeStyles: function(ctx, decl) {
      var stroke = decl.stroke;
      if (stroke) {
        ctx.lineWidth = decl.strokeWidth;
        ctx.lineCap = decl.strokeLineCap;
        ctx.lineDashOffset = decl.strokeDashOffset;
        ctx.lineJoin = decl.strokeLineJoin;
        ctx.miterLimit = decl.strokeMiterLimit;
        if (stroke.toLive) {
          if (stroke.gradientUnits === 'percentage' || stroke.gradientTrasnform || stroke.patternTransform) {
            // need to transform gradient in a pattern.
            // this is a slow process. If you are hitting this codepath, and the object
            // is not using caching, you should consider switching it on.
            // we need a canvas as big as the current object caching canvas.
            this._applyPatternForTransformedGradient(ctx, stroke);
          }
          else {
            // is a simple gradient or pattern
            ctx.strokeStyle = stroke.toLive(ctx, this);
            this._applyPatternGradientTransform(ctx, stroke);
          }
        }
        else {
          // is a color
          ctx.strokeStyle = decl.stroke;
        }
      }
    },

    _setFillStyles: function(ctx, decl) {
      var fill = decl.fill;
      if (fill) {
        if (fill.toLive) {
          ctx.fillStyle = fill.toLive(ctx, this);
          this._applyPatternGradientTransform(ctx, decl.fill);
        }
        else {
          ctx.fillStyle = fill;
        }
      }
    },

    _setClippingProperties: function(ctx) {
      ctx.globalAlpha = 1;
      ctx.strokeStyle = 'transparent';
      ctx.fillStyle = '#000000';
    },

    /**
     * @private
     * Sets line dash
     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
     * @param {Array} dashArray array representing dashes
     * @param {Function} alternative function to call if browser does not support lineDash
     */
    _setLineDash: function(ctx, dashArray, alternative) {
      if (!dashArray || dashArray.length === 0) {
        return;
      }
      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
      if (1 & dashArray.length) {
        dashArray.push.apply(dashArray, dashArray);
      }
      if (supportsLineDash) {
        ctx.setLineDash(dashArray);
      }
      else {
        alternative && alternative(ctx);
      }
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     */
    _renderControls: function(ctx, styleOverride) {
      var vpt = this.getViewportTransform(),
          matrix = this.calcTransformMatrix(),
          options, drawBorders, drawControls;
      styleOverride = styleOverride || { };
      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
      options = fabric.util.qrDecompose(matrix);
      ctx.save();
      ctx.translate(options.translateX, options.translateY);
      ctx.lineWidth = 1 * this.borderScaleFactor;
      if (!this.group) {
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      }
      if (styleOverride.forActiveSelection) {
        ctx.rotate(degreesToRadians(options.angle));
        drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
      }
      else {
        ctx.rotate(degreesToRadians(this.angle));
        drawBorders && this.drawBorders(ctx, styleOverride);
      }
      drawControls && this.drawControls(ctx, styleOverride);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      var shadow = this.shadow, canvas = this.canvas, scaling,
          multX = (canvas && canvas.viewportTransform[0]) || 1,
          multY = (canvas && canvas.viewportTransform[3]) || 1;
      if (shadow.nonScaling) {
        scaling = { scaleX: 1, scaleY: 1 };
      }
      else {
        scaling = this.getObjectScaling();
      }
      if (canvas && canvas._isRetinaScaling()) {
        multX *= fabric.devicePixelRatio;
        multY *= fabric.devicePixelRatio;
      }
      ctx.shadowColor = shadow.color;
      ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant *
        (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
      ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
      ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _removeShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} filler fabric.Pattern or fabric.Gradient
     * @return {Object} offset.offsetX offset for text rendering
     * @return {Object} offset.offsetY offset for text rendering
     */
    _applyPatternGradientTransform: function(ctx, filler) {
      if (!filler || !filler.toLive) {
        return { offsetX: 0, offsetY: 0 };
      }
      var t = filler.gradientTransform || filler.patternTransform;
      var offsetX = -this.width / 2 + filler.offsetX || 0,
          offsetY = -this.height / 2 + filler.offsetY || 0;

      if (filler.gradientUnits === 'percentage') {
        ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
      }
      else {
        ctx.transform(1, 0, 0, 1, offsetX, offsetY);
      }
      if (t) {
        ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
      }
      return { offsetX: offsetX, offsetY: offsetY };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderPaintInOrder: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderStroke(ctx);
        this._renderFill(ctx);
      }
      else {
        this._renderFill(ctx);
        this._renderStroke(ctx);
      }
    },

    /**
     * @private
     * function that actually render something on the context.
     * empty here to allow Obects to work on tests to benchmark fabric functionalites
     * not related to rendering
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(/* ctx */) {

    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderFill: function(ctx) {
      if (!this.fill) {
        return;
      }

      ctx.save();
      this._setFillStyles(ctx, this);
      if (this.fillRule === 'evenodd') {
        ctx.fill('evenodd');
      }
      else {
        ctx.fill();
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderStroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      if (this.strokeUniform && this.group) {
        var scaling = this.getObjectScaling();
        ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
      }
      else if (this.strokeUniform) {
        ctx.scale(1 / this.scaleX, 1 / this.scaleY);
      }
      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
      this._setStrokeStyles(ctx, this);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * This function try to patch the missing gradientTransform on canvas gradients.
     * transforming a context to transform the gradient, is going to transform the stroke too.
     * we want to transform the gradient but not the stroke operation, so we create
     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
     * is limited.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {fabric.Gradient} filler a fabric gradient instance
     */
    _applyPatternForTransformedGradient: function(ctx, filler) {
      var dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(),
          width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
      pCanvas.width = width;
      pCanvas.height = height;
      pCtx = pCanvas.getContext('2d');
      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
      pCtx.lineTo(0, height); pCtx.closePath();
      pCtx.translate(width / 2, height / 2);
      pCtx.scale(
        dims.zoomX / this.scaleX / retinaScaling,
        dims.zoomY / this.scaleY / retinaScaling
      );
      this._applyPatternGradientTransform(pCtx, filler);
      pCtx.fillStyle = filler.toLive(ctx);
      pCtx.fill();
      ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
      ctx.scale(
        retinaScaling * this.scaleX / dims.zoomX,
        retinaScaling * this.scaleY / dims.zoomY
      );
      ctx.strokeStyle = pCtx.createPattern(pCanvas, 'no-repeat');
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
    },

    /**
     * This function is an helper for svg import. it decompose the transformMatrix
     * and assign properties to object.
     * untransformed coordinates
     * @private
     * @chainable
     */
    _assignTransformMatrixProps: function() {
      if (this.transformMatrix) {
        var options = fabric.util.qrDecompose(this.transformMatrix);
        this.flipX = false;
        this.flipY = false;
        this.set('scaleX', options.scaleX);
        this.set('scaleY', options.scaleY);
        this.angle = options.angle;
        this.skewX = options.skewX;
        this.skewY = 0;
      }
    },

    /**
     * This function is an helper for svg import. it removes the transform matrix
     * and set to object properties that fabricjs can handle
     * @private
     * @param {Object} preserveAspectRatioOptions
     * @return {thisArg}
     */
    _removeTransformMatrix: function(preserveAspectRatioOptions) {
      var center = this._findCenterFromElement();
      if (this.transformMatrix) {
        this._assignTransformMatrixProps();
        center = fabric.util.transformPoint(center, this.transformMatrix);
      }
      this.transformMatrix = null;
      if (preserveAspectRatioOptions) {
        this.scaleX *= preserveAspectRatioOptions.scaleX;
        this.scaleY *= preserveAspectRatioOptions.scaleY;
        this.cropX = preserveAspectRatioOptions.cropX;
        this.cropY = preserveAspectRatioOptions.cropY;
        center.x += preserveAspectRatioOptions.offsetLeft;
        center.y += preserveAspectRatioOptions.offsetTop;
        this.width = preserveAspectRatioOptions.width;
        this.height = preserveAspectRatioOptions.height;
      }
      this.setPositionByOrigin(center, 'center', 'center');
    },

    /**
     * Clones an instance, using a callback method will work for every object.
     * @param {Function} callback Callback is invoked with a clone as a first argument
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     */
    clone: function(callback, propertiesToInclude) {
      var objectForm = this.toObject(propertiesToInclude);
      if (this.constructor.fromObject) {
        this.constructor.fromObject(objectForm, callback);
      }
      else {
        fabric.Object._fromObject('Object', objectForm, callback);
      }
    },

    /**
     * Creates an instance of fabric.Image out of an object
     * makes use of toCanvasElement.
     * Once this method was based on toDataUrl and loadImage, so it also had a quality
     * and format option. toCanvasElement is faster and produce no loss of quality.
     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.
     * toCanvasElement and then toBlob from the obtained canvas is also a good option.
     * This method is sync now, but still support the callback because we did not want to break.
     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.
     * @param {Function} callback callback, invoked with an instance as a first argument
     * @param {Object} [options] for clone as image, passed to toDataURL
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {fabric.Object} thisArg
     */
    cloneAsImage: function(callback, options) {
      var canvasEl = this.toCanvasElement(options);
      if (callback) {
        callback(new fabric.Image(canvasEl));
      }
      return this;
    },

    /**
     * Converts an object into a HTMLCanvas element
     * @param {Object} options Options object
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
     */
    toCanvasElement: function(options) {
      options || (options = { });

      var utils = fabric.util, origParams = utils.saveObjectTransform(this),
          originalGroup = this.group,
          originalShadow = this.shadow, abs = Math.abs,
          multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);
      delete this.group;
      if (options.withoutTransform) {
        utils.resetObjectTransform(this);
      }
      if (options.withoutShadow) {
        this.shadow = null;
      }

      var el = fabric.util.createCanvasElement(),
          // skip canvas zoom and calculate with setCoords now.
          boundingRect = this.getBoundingRect(true, true),
          shadow = this.shadow, scaling,
          shadowOffset = { x: 0, y: 0 }, shadowBlur,
          width, height;

      if (shadow) {
        shadowBlur = shadow.blur;
        if (shadow.nonScaling) {
          scaling = { scaleX: 1, scaleY: 1 };
        }
        else {
          scaling = this.getObjectScaling();
        }
        // consider non scaling shadow.
        shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * (abs(scaling.scaleX));
        shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * (abs(scaling.scaleY));
      }
      width = boundingRect.width + shadowOffset.x;
      height = boundingRect.height + shadowOffset.y;
      // if the current width/height is not an integer
      // we need to make it so.
      el.width = Math.ceil(width);
      el.height = Math.ceil(height);
      var canvas = new fabric.StaticCanvas(el, {
        enableRetinaScaling: false,
        renderOnAddRemove: false,
        skipOffscreen: false,
      });
      if (options.format === 'jpeg') {
        canvas.backgroundColor = '#fff';
      }
      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

      var originalCanvas = this.canvas;
      canvas.add(this);
      var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
      this.shadow = originalShadow;
      this.set('canvas', originalCanvas);
      if (originalGroup) {
        this.group = originalGroup;
      }
      this.set(origParams).setCoords();
      // canvas.dispose will call image.dispose that will nullify the elements
      // since this canvas is a simple element for the process, we remove references
      // to objects in this way in order to avoid object trashing.
      canvas._objects = [];
      canvas.dispose();
      canvas = null;

      return canvasEl;
    },

    /**
     * Converts an object into a data-url-like string
     * @param {Object} options Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     */
    toDataURL: function(options) {
      options || (options = { });
      return fabric.util.toDataURL(this.toCanvasElement(options), options.format || 'png', options.quality || 1);
    },

    /**
     * Returns true if specified type is identical to the type of an instance
     * @param {String} type Type to check against
     * @return {Boolean}
     */
    isType: function(type) {
      return this.type === type;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance (is 1 unless subclassed)
     */
    complexity: function() {
      return 1;
    },

    /**
     * Returns a JSON representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} JSON
     */
    toJSON: function(propertiesToInclude) {
      // delegate, not alias
      return this.toObject(propertiesToInclude);
    },

    /**
     * Sets "angle" of an instance with centered rotation
     * @param {Number} angle Angle value (in degrees)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    rotate: function(angle) {
      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

      if (shouldCenterOrigin) {
        this._setOriginToCenter();
      }

      this.set('angle', angle);

      if (shouldCenterOrigin) {
        this._resetOrigin();
      }

      return this;
    },

    /**
     * Centers object horizontally on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerH: function () {
      this.canvas && this.canvas.centerObjectH(this);
      return this;
    },

    /**
     * Centers object horizontally on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterH: function () {
      this.canvas && this.canvas.viewportCenterObjectH(this);
      return this;
    },

    /**
     * Centers object vertically on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerV: function () {
      this.canvas && this.canvas.centerObjectV(this);
      return this;
    },

    /**
     * Centers object vertically on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterV: function () {
      this.canvas && this.canvas.viewportCenterObjectV(this);
      return this;
    },

    /**
     * Centers object vertically and horizontally on canvas to which is was added last
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    center: function () {
      this.canvas && this.canvas.centerObject(this);
      return this;
    },

    /**
     * Centers object on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenter: function () {
      this.canvas && this.canvas.viewportCenterObject(this);
      return this;
    },

    /**
     * Returns coordinates of a pointer relative to an object
     * @param {Event} e Event to operate upon
     * @param {Object} [pointer] Pointer to operate upon (instead of event)
     * @return {Object} Coordinates of a pointer (x, y)
     */
    getLocalPointer: function(e, pointer) {
      pointer = pointer || this.canvas.getPointer(e);
      var pClicked = new fabric.Point(pointer.x, pointer.y),
          objectLeftTop = this._getLeftTopCoords();
      if (this.angle) {
        pClicked = fabric.util.rotatePoint(
          pClicked, objectLeftTop, degreesToRadians(-this.angle));
      }
      return {
        x: pClicked.x - objectLeftTop.x,
        y: pClicked.y - objectLeftTop.y
      };
    },

    /**
     * Sets canvas globalCompositeOperation for specific object
     * custom composition operation for the particular object can be specified using globalCompositeOperation property
     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
     */
    _setupCompositeOperation: function (ctx) {
      if (this.globalCompositeOperation) {
        ctx.globalCompositeOperation = this.globalCompositeOperation;
      }
    }
  });

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

  extend(fabric.Object.prototype, fabric.Observable);

  /**
   * Defines the number of fraction digits to use when serializing object values.
   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
   * @static
   * @memberOf fabric.Object
   * @constant
   * @type Number
   */
  fabric.Object.NUM_FRACTION_DIGITS = 2;

  fabric.Object._fromObject = function(className, object, callback, extraParam) {
    var klass = fabric[className];
    object = clone(object, true);
    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
      if (typeof patterns[0] !== 'undefined') {
        object.fill = patterns[0];
      }
      if (typeof patterns[1] !== 'undefined') {
        object.stroke = patterns[1];
      }
      fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
        object.clipPath = enlivedProps[0];
        var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
        callback && callback(instance);
      });
    });
  };

  /**
   * Unique id used internally when creating SVG elements
   * @static
   * @memberOf fabric.Object
   * @type Number
   */
  fabric.Object.__uid = 0;
})( true ? exports : 0);


(function() {

  var degreesToRadians = fabric.util.degreesToRadians,
      originXOffset = {
        left: -0.5,
        center: 0,
        right: 0.5
      },
      originYOffset = {
        top: -0.5,
        center: 0,
        bottom: 0.5
      };

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Translates the coordinates from a set of origin to another (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
      var x = point.x,
          y = point.y,
          offsetX, offsetY, dim;

      if (typeof fromOriginX === 'string') {
        fromOriginX = originXOffset[fromOriginX];
      }
      else {
        fromOriginX -= 0.5;
      }

      if (typeof toOriginX === 'string') {
        toOriginX = originXOffset[toOriginX];
      }
      else {
        toOriginX -= 0.5;
      }

      offsetX = toOriginX - fromOriginX;

      if (typeof fromOriginY === 'string') {
        fromOriginY = originYOffset[fromOriginY];
      }
      else {
        fromOriginY -= 0.5;
      }

      if (typeof toOriginY === 'string') {
        toOriginY = originYOffset[toOriginY];
      }
      else {
        toOriginY -= 0.5;
      }

      offsetY = toOriginY - fromOriginY;

      if (offsetX || offsetY) {
        dim = this._getTransformedDimensions();
        x = point.x + offsetX * dim.x;
        y = point.y + offsetY * dim.y;
      }

      return new fabric.Point(x, y);
    },

    /**
     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToCenterPoint: function(point, originX, originY) {
      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
      if (this.angle) {
        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
     * @param {fabric.Point} center The point which corresponds to center of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToOriginPoint: function(center, originX, originY) {
      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      if (this.angle) {
        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Returns the real center coordinates of the object
     * @return {fabric.Point}
     */
    getCenterPoint: function() {
      var leftTop = new fabric.Point(this.left, this.top);
      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
    },

    /**
     * Returns the coordinates of the object based on center coordinates
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @return {fabric.Point}
     */
    // getOriginPoint: function(center) {
    //   return this.translateToOriginPoint(center, this.originX, this.originY);
    // },

    /**
     * Returns the coordinates of the object as if it has a different origin
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    getPointByOrigin: function(originX, originY) {
      var center = this.getCenterPoint();
      return this.translateToOriginPoint(center, originX, originY);
    },

    /**
     * Returns the point in local coordinates
     * @param {fabric.Point} point The point relative to the global coordinate system
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    toLocalPoint: function(point, originX, originY) {
      var center = this.getCenterPoint(),
          p, p2;

      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      }
      else {
        p = new fabric.Point(this.left, this.top);
      }

      p2 = new fabric.Point(point.x, point.y);
      if (this.angle) {
        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
      }
      return p2.subtractEquals(p);
    },

    /**
     * Returns the point in global coordinates
     * @param {fabric.Point} The point relative to the local coordinate system
     * @return {fabric.Point}
     */
    // toGlobalPoint: function(point) {
    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
    // },

    /**
     * Sets the position of the object taking into consideration the object's origin
     * @param {fabric.Point} pos The new position of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {void}
     */
    setPositionByOrigin: function(pos, originX, originY) {
      var center = this.translateToCenterPoint(pos, originX, originY),
          position = this.translateToOriginPoint(center, this.originX, this.originY);
      this.set('left', position.x);
      this.set('top', position.y);
    },

    /**
     * @param {String} to One of 'left', 'center', 'right'
     */
    adjustPosition: function(to) {
      var angle = degreesToRadians(this.angle),
          hypotFull = this.getScaledWidth(),
          xFull = fabric.util.cos(angle) * hypotFull,
          yFull = fabric.util.sin(angle) * hypotFull,
          offsetFrom, offsetTo;

      //TODO: this function does not consider mixed situation like top, center.
      if (typeof this.originX === 'string') {
        offsetFrom = originXOffset[this.originX];
      }
      else {
        offsetFrom = this.originX - 0.5;
      }
      if (typeof to === 'string') {
        offsetTo = originXOffset[to];
      }
      else {
        offsetTo = to - 0.5;
      }
      this.left += xFull * (offsetTo - offsetFrom);
      this.top += yFull * (offsetTo - offsetFrom);
      this.setCoords();
      this.originX = to;
    },

    /**
     * Sets the origin/position of the object to it's center point
     * @private
     * @return {void}
     */
    _setOriginToCenter: function() {
      this._originalOriginX = this.originX;
      this._originalOriginY = this.originY;

      var center = this.getCenterPoint();

      this.originX = 'center';
      this.originY = 'center';

      this.left = center.x;
      this.top = center.y;
    },

    /**
     * Resets the origin/position of the object to it's original origin
     * @private
     * @return {void}
     */
    _resetOrigin: function() {
      var originPoint = this.translateToOriginPoint(
        this.getCenterPoint(),
        this._originalOriginX,
        this._originalOriginY);

      this.originX = this._originalOriginX;
      this.originY = this._originalOriginY;

      this.left = originPoint.x;
      this.top = originPoint.y;

      this._originalOriginX = null;
      this._originalOriginY = null;
    },

    /**
     * @private
     */
    _getLeftTopCoords: function() {
      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
    },
  });

})();


(function() {

  function arrayFromCoords(coords) {
    return [
      new fabric.Point(coords.tl.x, coords.tl.y),
      new fabric.Point(coords.tr.x, coords.tr.y),
      new fabric.Point(coords.br.x, coords.br.y),
      new fabric.Point(coords.bl.x, coords.bl.y)
    ];
  }

  var util = fabric.util,
      degreesToRadians = util.degreesToRadians,
      multiplyMatrices = util.multiplyTransformMatrices,
      transformPoint = util.transformPoint;

  util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Describe object's corner position in canvas element coordinates.
     * properties are depending on control keys and padding the main controls.
     * each property is an object with x, y and corner.
     * The `corner` property contains in a similar manner the 4 points of the
     * interactive area of the corner.
     * The coordinates depends from the controls positionHandler and are used
     * to draw and locate controls
     * @memberOf fabric.Object.prototype
     */
    oCoords: null,

    /**
     * Describe object's corner position in canvas object absolute coordinates
     * properties are tl,tr,bl,br and describe the four main corner.
     * each property is an object with x, y, instance of Fabric.Point.
     * The coordinates depends from this properties: width, height, scaleX, scaleY
     * skewX, skewY, angle, strokeWidth, top, left.
     * Those coordinates are useful to understand where an object is. They get updated
     * with oCoords but they do not need to be updated when zoom or panning change.
     * The coordinates get updated with @method setCoords.
     * You can calculate them without updating with @method calcACoords();
     * @memberOf fabric.Object.prototype
     */
    aCoords: null,

    /**
     * Describe object's corner position in canvas element coordinates.
     * includes padding. Used of object detection.
     * set and refreshed with setCoords and calcCoords.
     * @memberOf fabric.Object.prototype
     */
    lineCoords: null,

    /**
     * storage for object transform matrix
     */
    ownMatrixCache: null,

    /**
     * storage for object full transform matrix
     */
    matrixCache: null,

    /**
     * custom controls interface
     * controls are added by default_controls.js
     */
    controls: { },

    /**
     * return correct set of coordinates for intersection
     * this will return either aCoords or lineCoords.
     * @param {Boolean} absolute will return aCoords if true or lineCoords
     * @return {Object} {tl, tr, br, bl} points
     */
    _getCoords: function(absolute, calculate) {
      if (calculate) {
        return (absolute ? this.calcACoords() : this.calcLineCoords());
      }
      if (!this.aCoords || !this.lineCoords) {
        this.setCoords(true);
      }
      return (absolute ? this.aCoords : this.lineCoords);
    },

    /**
     * return correct set of coordinates for intersection
     * this will return either aCoords or lineCoords.
     * The coords are returned in an array.
     * @return {Array} [tl, tr, br, bl] of points
     */
    getCoords: function(absolute, calculate) {
      return arrayFromCoords(this._getCoords(absolute, calculate));
    },

    /**
     * Checks if object intersects with an area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with an area formed by 2 points
     */
    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
      var coords = this.getCoords(absolute, calculate),
          intersection = fabric.Intersection.intersectPolygonRectangle(
            coords,
            pointTL,
            pointBR
          );
      return intersection.status === 'Intersection';
    },

    /**
     * Checks if object intersects with another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with another object
     */
    intersectsWithObject: function(other, absolute, calculate) {
      var intersection = fabric.Intersection.intersectPolygonPolygon(
        this.getCoords(absolute, calculate),
        other.getCoords(absolute, calculate)
      );

      return intersection.status === 'Intersection'
        || other.isContainedWithinObject(this, absolute, calculate)
        || this.isContainedWithinObject(other, absolute, calculate);
    },

    /**
     * Checks if object is fully contained within area of another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area of another object
     */
    isContainedWithinObject: function(other, absolute, calculate) {
      var points = this.getCoords(absolute, calculate),
          otherCoords = absolute ? other.aCoords : other.lineCoords,
          i = 0, lines = other._getImageLines(otherCoords);
      for (; i < 4; i++) {
        if (!other.containsPoint(points[i], lines)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Checks if object is fully contained within area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area formed by 2 points
     */
    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
      var boundingRect = this.getBoundingRect(absolute, calculate);

      return (
        boundingRect.left >= pointTL.x &&
        boundingRect.left + boundingRect.width <= pointBR.x &&
        boundingRect.top >= pointTL.y &&
        boundingRect.top + boundingRect.height <= pointBR.y
      );
    },

    /**
     * Checks if point is inside the object
     * @param {fabric.Point} point Point to check against
     * @param {Object} [lines] object returned from @method _getImageLines
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if point is inside the object
     */
    containsPoint: function(point, lines, absolute, calculate) {
      var coords = this._getCoords(absolute, calculate),
          lines = lines || this._getImageLines(coords),
          xPoints = this._findCrossPoints(point, lines);
      // if xPoints is odd then point is inside the object
      return (xPoints !== 0 && xPoints % 2 === 1);
    },

    /**
     * Checks if object is contained within the canvas with current viewportTransform
     * the check is done stopping at first point that appears on screen
     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
     * @return {Boolean} true if object is fully or partially contained within canvas
     */
    isOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      var points = this.getCoords(true, calculate);
      // if some point is on screen, the object is on screen.
      if (points.some(function(point) {
        return point.x <= pointBR.x && point.x >= pointTL.x &&
        point.y <= pointBR.y && point.y >= pointTL.y;
      })) {
        return true;
      }
      // no points on screen, check intersection with absolute coordinates
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Checks if the object contains the midpoint between canvas extremities
     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
     * @private
     * @param {Fabric.Point} pointTL Top Left point
     * @param {Fabric.Point} pointBR Top Right point
     * @param {Boolean} calculate use coordinates of current position instead of .oCoords
     * @return {Boolean} true if the object contains the point
     */
    _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
      // worst case scenario the object is so big that contains the screen
      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
      if (this.containsPoint(centerPoint, null, true, calculate)) {
        return true;
      }
      return false;
    },

    /**
     * Checks if object is partially contained within the canvas with current viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is partially contained within canvas
     */
    isPartiallyOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
        return true;
      }
      var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {
        return (point.x >= pointBR.x || point.x <= pointTL.x) &&
        (point.y >= pointBR.y || point.y <= pointTL.y);
      });
      return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);
    },

    /**
     * Method that returns an object with the object edges in it, given the coordinates of the corners
     * @private
     * @param {Object} oCoords Coordinates of the object corners
     */
    _getImageLines: function(oCoords) {

      var lines = {
        topline: {
          o: oCoords.tl,
          d: oCoords.tr
        },
        rightline: {
          o: oCoords.tr,
          d: oCoords.br
        },
        bottomline: {
          o: oCoords.br,
          d: oCoords.bl
        },
        leftline: {
          o: oCoords.bl,
          d: oCoords.tl
        }
      };

      // // debugging
      // if (this.canvas.contextTop) {
      //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
      //
      //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
      //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
      // }

      return lines;
    },

    /**
     * Helper method to determine how many cross points are between the 4 object edges
     * and the horizontal line determined by a point on canvas
     * @private
     * @param {fabric.Point} point Point to check
     * @param {Object} lines Coordinates of the object being evaluated
     */
    // remove yi, not used but left code here just in case.
    _findCrossPoints: function(point, lines) {
      var b1, b2, a1, a2, xi, // yi,
          xcount = 0,
          iLine;

      for (var lineKey in lines) {
        iLine = lines[lineKey];
        // optimisation 1: line below point. no cross
        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
          continue;
        }
        // optimisation 2: line above point. no cross
        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
          continue;
        }
        // optimisation 3: vertical line case
        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
          xi = iLine.o.x;
          // yi = point.y;
        }
        // calculate the intersection point
        else {
          b1 = 0;
          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
          a1 = point.y - b1 * point.x;
          a2 = iLine.o.y - b2 * iLine.o.x;

          xi = -(a1 - a2) / (b1 - b2);
          // yi = a1 + b1 * xi;
        }
        // dont count xi < point.x cases
        if (xi >= point.x) {
          xcount += 1;
        }
        // optimisation 4: specific for square images
        if (xcount === 2) {
          break;
        }
      }
      return xcount;
    },

    /**
     * Returns coordinates of object's bounding rectangle (left, top, width, height)
     * the box is intended as aligned to axis of canvas.
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
     * @return {Object} Object with left, top, width, height properties
     */
    getBoundingRect: function(absolute, calculate) {
      var coords = this.getCoords(absolute, calculate);
      return util.makeBoundingBoxFromPoints(coords);
    },

    /**
     * Returns width of an object's bounding box counting transformations
     * before 2.0 it was named getWidth();
     * @return {Number} width value
     */
    getScaledWidth: function() {
      return this._getTransformedDimensions().x;
    },

    /**
     * Returns height of an object bounding box counting transformations
     * before 2.0 it was named getHeight();
     * @return {Number} height value
     */
    getScaledHeight: function() {
      return this._getTransformedDimensions().y;
    },

    /**
     * Makes sure the scale is valid and modifies it if necessary
     * @private
     * @param {Number} value
     * @return {Number}
     */
    _constrainScale: function(value) {
      if (Math.abs(value) < this.minScaleLimit) {
        if (value < 0) {
          return -this.minScaleLimit;
        }
        else {
          return this.minScaleLimit;
        }
      }
      else if (value === 0) {
        return 0.0001;
      }
      return value;
    },

    /**
     * Scales an object (equally by x and y)
     * @param {Number} value Scale factor
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scale: function(value) {
      this._set('scaleX', value);
      this._set('scaleY', value);
      return this.setCoords();
    },

    /**
     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New width value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToWidth: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
      return this.scale(value / this.width / boundingRectFactor);
    },

    /**
     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New height value
     * @param {Boolean} absolute ignore viewport
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToHeight: function(value, absolute) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
      return this.scale(value / this.height / boundingRectFactor);
    },

    /**
     * Calculates and returns the .coords of an object.
     * unused by the library, only for the end dev.
     * @return {Object} Object with tl, tr, br, bl ....
     * @chainable
     * @deprecated
     */
    calcCoords: function(absolute) {
      // this is a compatibility function to avoid removing calcCoords now.
      if (absolute) {
        return this.calcACoords();
      }
      return this.calcOCoords();
    },

    calcLineCoords: function() {
      var vpt = this.getViewportTransform(),
          padding = this.padding, angle = degreesToRadians(this.angle),
          cos = util.cos(angle), sin = util.sin(angle),
          cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP,
          cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();

      var lineCoords = {
        tl: transformPoint(aCoords.tl, vpt),
        tr: transformPoint(aCoords.tr, vpt),
        bl: transformPoint(aCoords.bl, vpt),
        br: transformPoint(aCoords.br, vpt),
      };

      if (padding) {
        lineCoords.tl.x -= cosPMinusSinP;
        lineCoords.tl.y -= cosPSinP;
        lineCoords.tr.x += cosPSinP;
        lineCoords.tr.y -= cosPMinusSinP;
        lineCoords.bl.x -= cosPSinP;
        lineCoords.bl.y += cosPMinusSinP;
        lineCoords.br.x += cosPMinusSinP;
        lineCoords.br.y += cosPSinP;
      }

      return lineCoords;
    },

    calcOCoords: function() {
      var rotateMatrix = this._calcRotateMatrix(),
          translateMatrix = this._calcTranslateMatrix(),
          vpt = this.getViewportTransform(),
          startMatrix = multiplyMatrices(vpt, translateMatrix),
          finalMatrix = multiplyMatrices(startMatrix, rotateMatrix),
          finalMatrix = multiplyMatrices(finalMatrix, [1 / vpt[0], 0, 0, 1 / vpt[3], 0, 0]),
          dim = this._calculateCurrentDimensions(),
          coords = {};
      this.forEachControl(function(control, key, fabricObject) {
        coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);
      });

      // debug code
      // var canvas = this.canvas;
      // setTimeout(function() {
      //   canvas.contextTop.clearRect(0, 0, 700, 700);
      //   canvas.contextTop.fillStyle = 'green';
      //   Object.keys(coords).forEach(function(key) {
      //     var control = coords[key];
      //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);
      //   });
      // }, 50);
      return coords;
    },

    calcACoords: function() {
      var rotateMatrix = this._calcRotateMatrix(),
          translateMatrix = this._calcTranslateMatrix(),
          finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix),
          dim = this._getTransformedDimensions(),
          w = dim.x / 2, h = dim.y / 2;
      return {
        // corners
        tl: transformPoint({ x: -w, y: -h }, finalMatrix),
        tr: transformPoint({ x: w, y: -h }, finalMatrix),
        bl: transformPoint({ x: -w, y: h }, finalMatrix),
        br: transformPoint({ x: w, y: h }, finalMatrix)
      };
    },

    /**
     * Sets corner and controls position coordinates based on current angle, width and height, left and top.
     * oCoords are used to find the corners
     * aCoords are used to quickly find an object on the canvas
     * lineCoords are used to quickly find object during pointer events.
     * See {@link https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords|When-to-call-setCoords}
     * @param {Boolean} [skipCorners] skip calculation of oCoords.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setCoords: function(skipCorners) {
      this.aCoords = this.calcACoords();
      // in case we are in a group, for how the inner group target check works,
      // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.
      this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();
      if (skipCorners) {
        return this;
      }
      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
      this.oCoords = this.calcOCoords();
      this._setCornerCoords && this._setCornerCoords();
      return this;
    },

    /**
     * calculate rotation matrix of an object
     * @return {Array} rotation matrix for the object
     */
    _calcRotateMatrix: function() {
      return util.calcRotateMatrix(this);
    },

    /**
     * calculate the translation matrix for an object transform
     * @return {Array} rotation matrix for the object
     */
    _calcTranslateMatrix: function() {
      var center = this.getCenterPoint();
      return [1, 0, 0, 1, center.x, center.y];
    },

    transformMatrixKey: function(skipGroup) {
      var sep = '_', prefix = '';
      if (!skipGroup && this.group) {
        prefix = this.group.transformMatrixKey(skipGroup) + sep;
      };
      return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY +
        sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY +
        sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
    },

    /**
     * calculate transform matrix that represents the current transformations from the
     * object's properties.
     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
     * There are some situation in which this is useful to avoid the fake rotation.
     * @return {Array} transform matrix for the object
     */
    calcTransformMatrix: function(skipGroup) {
      var matrix = this.calcOwnMatrix();
      if (skipGroup || !this.group) {
        return matrix;
      }
      var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      if (this.group) {
        matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);
      }
      cache.key = key;
      cache.value = matrix;
      return matrix;
    },

    /**
     * calculate transform matrix that represents the current transformations from the
     * object's properties, this matrix does not include the group transformation
     * @return {Array} transform matrix for the object
     */
    calcOwnMatrix: function() {
      var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
      if (cache.key === key) {
        return cache.value;
      }
      var tMatrix = this._calcTranslateMatrix(),
          options = {
            angle: this.angle,
            translateX: tMatrix[4],
            translateY: tMatrix[5],
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: this.skewX,
            skewY: this.skewY,
            flipX: this.flipX,
            flipY: this.flipY,
          };
      cache.key = key;
      cache.value = util.composeMatrix(options);
      return cache.value;
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     * @deprecated since 3.4.0, please use fabric.util._calcDimensionsTransformMatrix
     * not including or including flipX, flipY to emulate the flipping boolean
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
      return util.calcDimensionsMatrix({
        skewX: skewX,
        skewY: skewY,
        scaleX: this.scaleX * (flipping && this.flipX ? -1 : 1),
        scaleY: this.scaleY * (flipping && this.flipY ? -1 : 1)
      });
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getNonTransformedDimensions: function() {
      var strokeWidth = this.strokeWidth,
          w = this.width + strokeWidth,
          h = this.height + strokeWidth;
      return { x: w, y: h };
    },

    /*
     * Calculate object bounding box dimensions from its properties scale, skew.
     * @param {Number} skewX, a value to override current skewX
     * @param {Number} skewY, a value to override current skewY
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getTransformedDimensions: function(skewX, skewY) {
      if (typeof skewX === 'undefined') {
        skewX = this.skewX;
      }
      if (typeof skewY === 'undefined') {
        skewY = this.skewY;
      }
      var dimensions = this._getNonTransformedDimensions(), dimX, dimY,
          noSkew = skewX === 0 && skewY === 0;

      if (this.strokeUniform) {
        dimX = this.width;
        dimY = this.height;
      }
      else {
        dimX = dimensions.x;
        dimY = dimensions.y;
      }
      if (noSkew) {
        return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
      }
      var bbox = util.sizeAfterTransform(dimX, dimY, {
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        skewX: skewX,
        skewY: skewY,
      });
      return this._finalizeDimensions(bbox.x, bbox.y);
    },

    /*
     * Calculate object bounding box dimensions from its properties scale, skew.
     * @param Number width width of the bbox
     * @param Number height height of the bbox
     * @private
     * @return {Object} .x finalized width dimension
     * @return {Object} .y finalized height dimension
     */
    _finalizeDimensions: function(width, height) {
      return this.strokeUniform ?
        { x: width + this.strokeWidth, y: height + this.strokeWidth }
        :
        { x: width, y: height };
    },

    /*
     * Calculate object dimensions for controls box, including padding and canvas zoom.
     * and active selection
     * private
     */
    _calculateCurrentDimensions: function()  {
      var vpt = this.getViewportTransform(),
          dim = this._getTransformedDimensions(),
          p = transformPoint(dim, vpt, true);
      return p.scalarAdd(2 * this.padding);
    },
  });
})();


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * Moves an object to the bottom of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendToBack: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
    }
    else if (this.canvas) {
      this.canvas.sendToBack(this);
    }
    return this;
  },

  /**
   * Moves an object to the top of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringToFront: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
    }
    else if (this.canvas) {
      this.canvas.bringToFront(this);
    }
    return this;
  },

  /**
   * Moves an object down in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendBackwards: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
    }
    else if (this.canvas) {
      this.canvas.sendBackwards(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object up in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringForward: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
    }
    else if (this.canvas) {
      this.canvas.bringForward(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object to specified level in stack of drawn objects
   * @param {Number} index New position of object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  moveTo: function(index) {
    if (this.group && this.group.type !== 'activeSelection') {
      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
    }
    else if (this.canvas) {
      this.canvas.moveTo(this, index);
    }
    return this;
  }
});


/* _TO_SVG_START_ */
(function() {
  function getSvgColorString(prop, value) {
    if (!value) {
      return prop + ': none; ';
    }
    else if (value.toLive) {
      return prop + ': url(#SVGID_' + value.id + '); ';
    }
    else {
      var color = new fabric.Color(value),
          str = prop + ': ' + color.toRgb() + '; ',
          opacity = color.getAlpha();
      if (opacity !== 1) {
        //change the color in rgb + opacity
        str += prop + '-opacity: ' + opacity.toString() + '; ';
      }
      return str;
    }
  }

  var toFixed = fabric.util.toFixed;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {

      var fillRule = this.fillRule ? this.fillRule : 'nonzero',
          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
          strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : '0',
          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
          visibility = this.visible ? '' : ' visibility: hidden;',
          filter = skipShadow ? '' : this.getSvgFilter(),
          fill = getSvgColorString('fill', this.fill),
          stroke = getSvgColorString('stroke', this.stroke);

      return [
        stroke,
        'stroke-width: ', strokeWidth, '; ',
        'stroke-dasharray: ', strokeDashArray, '; ',
        'stroke-linecap: ', strokeLineCap, '; ',
        'stroke-dashoffset: ', strokeDashOffset, '; ',
        'stroke-linejoin: ', strokeLineJoin, '; ',
        'stroke-miterlimit: ', strokeMiterLimit, '; ',
        fill,
        'fill-rule: ', fillRule, '; ',
        'opacity: ', opacity, ';',
        filter,
        visibility
      ].join('');
    },

    /**
     * Returns styles-string for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
     * @return {String}
     */
    getSvgSpanStyles: function(style, useWhiteSpace) {
      var term = '; ';
      var fontFamily = style.fontFamily ?
        'font-family: ' + (((style.fontFamily.indexOf('\'') === -1 && style.fontFamily.indexOf('"') === -1) ?
          '\'' + style.fontFamily  + '\'' : style.fontFamily)) + term : '';
      var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + term : '',
          fontFamily = fontFamily,
          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + 'px' + term : '',
          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + term : '',
          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + term : '',
          fill = style.fill ? getSvgColorString('fill', style.fill) : '',
          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
          textDecoration = this.getSvgTextDecoration(style),
          deltaY = style.deltaY ? 'baseline-shift: ' + (-style.deltaY) + '; ' : '';
      if (textDecoration) {
        textDecoration = 'text-decoration: ' + textDecoration + term;
      }

      return [
        stroke,
        strokeWidth,
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight,
        textDecoration,
        fill,
        deltaY,
        useWhiteSpace ? 'white-space: pre; ' : ''
      ].join('');
    },

    /**
     * Returns text-decoration property for svg-export
     * @param {Object} style the object from which to retrieve style properties
     * @return {String}
     */
    getSvgTextDecoration: function(style) {
      return ['overline', 'underline', 'line-through'].filter(function(decoration) {
        return style[decoration.replace('-', '')];
      }).join(' ');
    },

    /**
     * Returns filter for svg shadow
     * @return {String}
     */
    getSvgFilter: function() {
      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
    },

    /**
     * Returns id attribute for svg output
     * @return {String}
     */
    getSvgCommons: function() {
      return [
        this.id ? 'id="' + this.id + '" ' : '',
        this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : '',
      ].join('');
    },

    /**
     * Returns transform-string for svg-export
     * @param {Boolean} use the full transform or the single object one.
     * @return {String}
     */
    getSvgTransform: function(full, additionalTransform) {
      var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(),
          svgTransform = 'transform="' + fabric.util.matrixToSVG(transform);
      return svgTransform +
        (additionalTransform || '') + '" ';
    },

    _setSVGBg: function(textBgRects) {
      if (this.backgroundColor) {
        var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
        textBgRects.push(
          '\t\t<rect ',
          this._getFillAttributes(this.backgroundColor),
          ' x="',
          toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(this.width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(this.height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      }
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver: reviver });
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      return '\t' + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver: reviver });
    },

    /**
     * @private
     */
    _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var reviver = options.reviver,
          additionalTransform = options.additionalTransform || '',
          commonPieces = [
            this.getSvgTransform(true, additionalTransform),
            this.getSvgCommons(),
          ].join(''),
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS');
      objectMarkup[index] = commonPieces;
      return reviver ? reviver(objectMarkup.join('')) : objectMarkup.join('');
    },

    /**
     * @private
     */
    _createBaseSVGMarkup: function(objectMarkup, options) {
      options = options || {};
      var noStyle = options.noStyle,
          reviver = options.reviver,
          styleInfo = noStyle ? '' : 'style="' + this.getSvgStyles() + '" ',
          shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : '',
          clipPath = this.clipPath,
          vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : '',
          absoluteClipPath = clipPath && clipPath.absolutePositioned,
          stroke = this.stroke, fill = this.fill, shadow = this.shadow,
          commonPieces, markup = [], clipPathMarkup,
          // insert commons in the markup, style and svgCommons
          index = objectMarkup.indexOf('COMMON_PARTS'),
          additionalTransform = options.additionalTransform;
      if (clipPath) {
        clipPath.clipPathId = 'CLIPPATH_' + fabric.Object.__uid++;
        clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' +
          clipPath.toClipPathSVG(reviver) +
          '</clipPath>\n';
      }
      if (absoluteClipPath) {
        markup.push(
          '<g ', shadowInfo, this.getSvgCommons(), ' >\n'
        );
      }
      markup.push(
        '<g ',
        this.getSvgTransform(false),
        !absoluteClipPath ? shadowInfo + this.getSvgCommons() : '',
        ' >\n'
      );
      commonPieces = [
        styleInfo,
        vectorEffect,
        noStyle ? '' : this.addPaintOrder(), ' ',
        additionalTransform ? 'transform="' + additionalTransform + '" ' : '',
      ].join('');
      objectMarkup[index] = commonPieces;
      if (fill && fill.toLive) {
        markup.push(fill.toSVG(this));
      }
      if (stroke && stroke.toLive) {
        markup.push(stroke.toSVG(this));
      }
      if (shadow) {
        markup.push(shadow.toSVG(this));
      }
      if (clipPath) {
        markup.push(clipPathMarkup);
      }
      markup.push(objectMarkup.join(''));
      markup.push('</g>\n');
      absoluteClipPath && markup.push('</g>\n');
      return reviver ? reviver(markup.join('')) : markup.join('');
    },

    addPaintOrder: function() {
      return this.paintFirst !== 'fill' ? ' paint-order="' + this.paintFirst + '" ' : '';
    }
  });
})();
/* _TO_SVG_END_ */


(function() {

  var extend = fabric.util.object.extend,
      originalSet = 'stateProperties';

  /*
    Depends on `stateProperties`
  */
  function saveProps(origin, destination, props) {
    var tmpObj = { }, deep = true;
    props.forEach(function(prop) {
      tmpObj[prop] = origin[prop];
    });

    extend(origin[destination], tmpObj, deep);
  }

  function _isEqual(origValue, currentValue, firstPass) {
    if (origValue === currentValue) {
      // if the objects are identical, return
      return true;
    }
    else if (Array.isArray(origValue)) {
      if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
        return false;
      }
      for (var i = 0, len = origValue.length; i < len; i++) {
        if (!_isEqual(origValue[i], currentValue[i])) {
          return false;
        }
      }
      return true;
    }
    else if (origValue && typeof origValue === 'object') {
      var keys = Object.keys(origValue), key;
      if (!currentValue ||
          typeof currentValue !== 'object' ||
          (!firstPass && keys.length !== Object.keys(currentValue).length)
      ) {
        return false;
      }
      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        // since clipPath is in the statefull cache list and the clipPath objects
        // would be iterated as an object, this would lead to possible infinite recursion
        // we do not want to compare those.
        if (key === 'canvas' || key === 'group') {
          continue;
        }
        if (!_isEqual(origValue[key], currentValue[key])) {
          return false;
        }
      }
      return true;
    }
  }


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Returns true if object state (one of its state properties) was changed
     * @param {String} [propertySet] optional name for the set of property we want to save
     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
     */
    hasStateChanged: function(propertySet) {
      propertySet = propertySet || originalSet;
      var dashedPropertySet = '_' + propertySet;
      if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
        return true;
      }
      return !_isEqual(this[dashedPropertySet], this, true);
    },

    /**
     * Saves state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    saveState: function(options) {
      var propertySet = options && options.propertySet || originalSet,
          destination = '_' + propertySet;
      if (!this[destination]) {
        return this.setupState(options);
      }
      saveProps(this, destination, this[propertySet]);
      if (options && options.stateProperties) {
        saveProps(this, destination, options.stateProperties);
      }
      return this;
    },

    /**
     * Setups state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    setupState: function(options) {
      options = options || { };
      var propertySet = options.propertySet || originalSet;
      options.propertySet = propertySet;
      this['_' + propertySet] = { };
      this.saveState(options);
      return this;
    }
  });
})();


(function() {

  var degreesToRadians = fabric.util.degreesToRadians;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Determines which corner has been clicked
     * @private
     * @param {Object} pointer The pointer indicating the mouse position
     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
     */
    _findTargetCorner: function(pointer, forTouch) {
      // objects in group, anykind, are not self modificable,
      // must not return an hovered corner.
      if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
        return false;
      }

      var ex = pointer.x,
          ey = pointer.y,
          xPoints,
          lines, keys = Object.keys(this.oCoords),
          j = keys.length - 1, i;
      this.__corner = 0;

      // cycle in reverse order so we pick first the one on top
      for (; j >= 0; j--) {
        i = keys[j];
        if (!this.isControlVisible(i)) {
          continue;
        }

        lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);
        // // debugging
        //
        // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
        //
        // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
        // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
        if (xPoints !== 0 && xPoints % 2 === 1) {
          this.__corner = i;
          return i;
        }
      }
      return false;
    },

    /**
     * Calls a function for each control. The function gets called,
     * with the control, the object that is calling the iterator and the control's key
     * @param {Function} fn function to iterate over the controls over
     */
    forEachControl: function(fn) {
      for (var i in this.controls) {
        fn(this.controls[i], i, this);
      };
    },

    /**
     * Sets the coordinates of the draggable boxes in the corners of
     * the image used to scale/rotate it.
     * note: if we would switch to ROUND corner area, all of this would disappear.
     * everything would resolve to a single point and a pythagorean theorem for the distance
     * @private
     */
    _setCornerCoords: function() {
      var coords = this.oCoords;

      for (var control in coords) {
        var controlObject = this.controls[control];
        coords[control].corner = controlObject.calcCornerCoords(
          this.angle, this.cornerSize, coords[control].x, coords[control].y, false);
        coords[control].touchCorner = controlObject.calcCornerCoords(
          this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);
      }
    },

    /**
     * Draws a colored layer behind the object, inside its selection borders.
     * Requires public options: padding, selectionBackgroundColor
     * this function is called when the context is transformed
     * has checks to be skipped when the object is on a staticCanvas
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawSelectionBackground: function(ctx) {
      if (!this.selectionBackgroundColor ||
        (this.canvas && !this.canvas.interactive) ||
        (this.canvas && this.canvas._activeObject !== this)
      ) {
        return this;
      }
      ctx.save();
      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
          vpt = this.canvas.viewportTransform;
      ctx.translate(center.x, center.y);
      ctx.scale(1 / vpt[0], 1 / vpt[3]);
      ctx.rotate(degreesToRadians(this.angle));
      ctx.fillStyle = this.selectionBackgroundColor;
      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBorders: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      var wh = this._calculateCurrentDimensions(),
          strokeWidth = this.borderScaleFactor,
          width = wh.x + strokeWidth,
          height = wh.y + strokeWidth,
          hasControls = typeof styleOverride.hasControls !== 'undefined' ?
            styleOverride.hasControls : this.hasControls,
          shouldStroke = false;

      ctx.save();
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);

      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      if (hasControls) {
        ctx.beginPath();
        this.forEachControl(function(control, key, fabricObject) {
          // in this moment, the ctx is centered on the object.
          // width and height of the above function are the size of the bbox.
          if (control.withConnection && control.getVisibility(fabricObject, key)) {
            // reset movement for each control
            shouldStroke = true;
            ctx.moveTo(control.x * width, control.y * height);
            ctx.lineTo(
              control.x * width + control.offsetX,
              control.y * height + control.offsetY
            );
          }
        });
        if (shouldStroke) {
          ctx.stroke();
        }
      }
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box when it is inside a group.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {object} options object representing current object parameters
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBordersInGroup: function(ctx, options, styleOverride) {
      styleOverride = styleOverride || {};
      var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options),
          strokeWidth = this.strokeWidth,
          strokeUniform = this.strokeUniform,
          borderScaleFactor = this.borderScaleFactor,
          width =
            bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor,
          height =
            bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
      ctx.save();
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      ctx.restore();
      return this;
    },

    /**
     * Draws corners of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: cornerSize, padding
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawControls: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      ctx.save();
      ctx.setTransform(this.canvas.getRetinaScaling(), 0, 0, this.canvas.getRetinaScaling(), 0, 0);
      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
      if (!this.transparentCorners) {
        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
      }
      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);
      this.setCoords();
      this.forEachControl(function(control, key, fabricObject) {
        if (control.getVisibility(fabricObject, key)) {
          control.render(ctx,
            fabricObject.oCoords[key].x,
            fabricObject.oCoords[key].y, styleOverride, fabricObject);
        }
      });
      ctx.restore();

      return this;
    },

    /**
     * Returns true if the specified control is visible, false otherwise.
     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @returns {Boolean} true if the specified control is visible, false otherwise
     */
    isControlVisible: function(controlKey) {
      return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);
    },

    /**
     * Sets the visibility of the specified control.
     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @param {Boolean} visible true to set the specified control visible, false otherwise
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlVisible: function(controlKey, visible) {
      if (!this._controlsVisibility) {
        this._controlsVisibility = {};
      }
      this._controlsVisibility[controlKey] = visible;
      return this;
    },

    /**
     * Sets the visibility state of object controls.
     * @param {Object} [options] Options object
     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlsVisibility: function(options) {
      options || (options = { });

      for (var p in options) {
        this.setControlVisible(p, options[p]);
      }
      return this;
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to deselect this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onDeselect: function() {
      // implemented by sub-classes, as needed.
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to select this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onSelect: function() {
      // implemented by sub-classes, as needed.
    }
  });
})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Animation duration (in ms) for fx* methods
   * @type Number
   * @default
   */
  FX_DURATION: 500,

  /**
   * Centers object horizontally with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectH: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.left,
      endValue: this.getCenter().left,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('left', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Centers object vertically with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectV: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.top,
      endValue: this.getCenter().top,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('top', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Same as `fabric.Canvas#remove` but animated
   * @param {fabric.Object} object Object to remove
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxRemove: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.opacity,
      endValue: 0,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('opacity', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function () {
        _this.remove(object);
        onComplete();
      }
    });

    return this;
  }
});

fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
  /**
   * Animates object's properties
   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
   * @return {fabric.Object} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
   * @chainable
   *
   * As object — multiple properties
   *
   * object.animate({ left: ..., top: ... });
   * object.animate({ left: ..., top: ... }, { duration: ... });
   *
   * As string — one property
   *
   * object.animate('left', ...);
   * object.animate('left', { duration: ... });
   *
   */
  animate: function() {
    if (arguments[0] && typeof arguments[0] === 'object') {
      var propsToAnimate = [], prop, skipCallbacks;
      for (prop in arguments[0]) {
        propsToAnimate.push(prop);
      }
      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
        prop = propsToAnimate[i];
        skipCallbacks = i !== len - 1;
        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
      }
    }
    else {
      this._animate.apply(this, arguments);
    }
    return this;
  },

  /**
   * @private
   * @param {String} property Property to animate
   * @param {String} to Value to animate to
   * @param {Object} [options] Options object
   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
   */
  _animate: function(property, to, options, skipCallbacks) {
    var _this = this, propPair;

    to = to.toString();

    if (!options) {
      options = { };
    }
    else {
      options = fabric.util.object.clone(options);
    }

    if (~property.indexOf('.')) {
      propPair = property.split('.');
    }

    var propIsColor =
      _this.colorProperties.indexOf(property) > -1 ||
      (propPair && _this.colorProperties.indexOf(propPair[1]) > -1);

    var currentValue = propPair
      ? this.get(propPair[0])[propPair[1]]
      : this.get(property);

    if (!('from' in options)) {
      options.from = currentValue;
    }

    if (!propIsColor) {
      if (~to.indexOf('=')) {
        to = currentValue + parseFloat(to.replace('=', ''));
      }
      else {
        to = parseFloat(to);
      }
    }

    var _options = {
      startValue: options.from,
      endValue: to,
      byValue: options.by,
      easing: options.easing,
      duration: options.duration,
      abort: options.abort && function () {
        return options.abort.call(_this);
      },
      onChange: function (value, valueProgress, timeProgress) {
        if (propPair) {
          _this[propPair[0]][propPair[1]] = value;
        }
        else {
          _this.set(property, value);
        }
        if (skipCallbacks) {
          return;
        }
        options.onChange && options.onChange(value, valueProgress, timeProgress);
      },
      onComplete: function (value, valueProgress, timeProgress) {
        if (skipCallbacks) {
          return;
        }

        _this.setCoords();
        options.onComplete && options.onComplete(value, valueProgress, timeProgress);
      }
    };

    if (propIsColor) {
      fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);
    }
    else {
      fabric.util.animate(_options);
    }
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');

  if (fabric.Line) {
    fabric.warn('fabric.Line is already defined');
    return;
  }

  /**
   * Line class
   * @class fabric.Line
   * @extends fabric.Object
   * @see {@link fabric.Line#initialize} for constructor definition
   */
  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'line',

    /**
     * x value or first line edge
     * @type Number
     * @default
     */
    x1: 0,

    /**
     * y value or first line edge
     * @type Number
     * @default
     */
    y1: 0,

    /**
     * x value or second line edge
     * @type Number
     * @default
     */
    x2: 0,

    /**
     * y value or second line edge
     * @type Number
     * @default
     */
    y2: 0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('x1', 'x2', 'y1', 'y2'),

    /**
     * Constructor
     * @param {Array} [points] Array of points
     * @param {Object} [options] Options object
     * @return {fabric.Line} thisArg
     */
    initialize: function(points, options) {
      if (!points) {
        points = [0, 0, 0, 0];
      }

      this.callSuper('initialize', options);

      this.set('x1', points[0]);
      this.set('y1', points[1]);
      this.set('x2', points[2]);
      this.set('y2', points[3]);

      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Object} [options] Options
     */
    _setWidthHeight: function(options) {
      options || (options = { });

      this.width = Math.abs(this.x2 - this.x1);
      this.height = Math.abs(this.y2 - this.y1);

      this.left = 'left' in options
        ? options.left
        : this._getLeftToOriginX();

      this.top = 'top' in options
        ? options.top
        : this._getTopToOriginY();
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      if (typeof coordProps[key] !== 'undefined') {
        this._setWidthHeight();
      }
      return this;
    },

    /**
     * @private
     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
     */
    _getLeftToOriginX: makeEdgeToOriginGetter(
      { // property names
        origin: 'originX',
        axis1: 'x1',
        axis2: 'x2',
        dimension: 'width'
      },
      { // possible values of origin
        nearest: 'left',
        center: 'center',
        farthest: 'right'
      }
    ),

    /**
     * @private
     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
     */
    _getTopToOriginY: makeEdgeToOriginGetter(
      { // property names
        origin: 'originY',
        axis1: 'y1',
        axis2: 'y2',
        dimension: 'height'
      },
      { // possible values of origin
        nearest: 'top',
        center: 'center',
        farthest: 'bottom'
      }
    ),

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();

      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
        // move from center (of virtual box) to its left/top corner
        // we can't assume x1, y1 is top left and x2, y2 is bottom right
        var p = this.calcLinePoints();
        ctx.moveTo(p.x1, p.y1);
        ctx.lineTo(p.x2, p.y2);
      }

      ctx.lineWidth = this.strokeWidth;

      // TODO: test this
      // make sure setting "fill" changes color of a line
      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
      var origStrokeStyle = ctx.strokeStyle;
      ctx.strokeStyle = this.stroke || ctx.fillStyle;
      this.stroke && this._renderStroke(ctx);
      ctx.strokeStyle = origStrokeStyle;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p = this.calcLinePoints();

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return {
        x: (this.x1 + this.x2) / 2,
        y: (this.y1 + this.y2) / 2,
      };
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     */
    _getNonTransformedDimensions: function() {
      var dim = this.callSuper('_getNonTransformedDimensions');
      if (this.strokeLineCap === 'butt') {
        if (this.width === 0) {
          dim.y -= this.strokeWidth;
        }
        if (this.height === 0) {
          dim.x -= this.strokeWidth;
        }
      }
      return dim;
    },

    /**
     * Recalculates line points given width and height
     * @private
     */
    calcLinePoints: function() {
      var xMult = this.x1 <= this.x2 ? -1 : 1,
          yMult = this.y1 <= this.y2 ? -1 : 1,
          x1 = (xMult * this.width * 0.5),
          y1 = (yMult * this.height * 0.5),
          x2 = (xMult * this.width * -0.5),
          y2 = (yMult * this.height * -0.5);

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2
      };
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var p = this.calcLinePoints();
      return [
        '<line ', 'COMMON_PARTS',
        'x1="', p.x1,
        '" y1="', p.y1,
        '" x2="', p.x2,
        '" y2="', p.y2,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
   * @static
   * @memberOf fabric.Line
   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
   */
  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

  /**
   * Returns fabric.Line instance from an SVG element
   * @static
   * @memberOf fabric.Line
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} [callback] callback function invoked after parsing
   */
  fabric.Line.fromElement = function(element, callback, options) {
    options = options || { };
    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
        points = [
          parsedAttributes.x1 || 0,
          parsedAttributes.y1 || 0,
          parsedAttributes.x2 || 0,
          parsedAttributes.y2 || 0
        ];
    callback(new fabric.Line(points, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Line instance from an object representation
   * @static
   * @memberOf fabric.Line
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Line.fromObject = function(object, callback) {
    function _callback(instance) {
      delete instance.points;
      callback && callback(instance);
    };
    var options = clone(object, true);
    options.points = [object.x1, object.y1, object.x2, object.y2];
    fabric.Object._fromObject('Line', options, _callback, 'points');
  };

  /**
   * Produces a function that calculates distance from canvas edge to Line origin.
   */
  function makeEdgeToOriginGetter(propertyNames, originValues) {
    var origin = propertyNames.origin,
        axis1 = propertyNames.axis1,
        axis2 = propertyNames.axis2,
        dimension = propertyNames.dimension,
        nearest = originValues.nearest,
        center = originValues.center,
        farthest = originValues.farthest;

    return function() {
      switch (this.get(origin)) {
        case nearest:
          return Math.min(this.get(axis1), this.get(axis2));
        case center:
          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
        case farthest:
          return Math.max(this.get(axis1), this.get(axis2));
      }
    };

  }

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      pi = Math.PI;

  if (fabric.Circle) {
    fabric.warn('fabric.Circle is already defined.');
    return;
  }

  /**
   * Circle class
   * @class fabric.Circle
   * @extends fabric.Object
   * @see {@link fabric.Circle#initialize} for constructor definition
   */
  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'circle',

    /**
     * Radius of this circle
     * @type Number
     * @default
     */
    radius: 0,

    /**
     * Start angle of the circle, moving clockwise
     * deprecated type, this should be in degree, this was an oversight.
     * probably will change to degrees in next major version
     * @type Number
     * @default 0
     */
    startAngle: 0,

    /**
     * End angle of the circle
     * deprecated type, this should be in degree, this was an oversight.
     * probably will change to degrees in next major version
     * @type Number
     * @default 2Pi
     */
    endAngle: pi * 2,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('radius', 'startAngle', 'endAngle'),

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Circle} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);

      if (key === 'radius') {
        this.setRadius(value);
      }

      return this;
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */

    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString, x = 0, y = 0,
          angle = (this.endAngle - this.startAngle) % ( 2 * pi);

      if (angle === 0) {
        svgString = [
          '<circle ', 'COMMON_PARTS',
          'cx="' + x + '" cy="' + y + '" ',
          'r="', this.radius,
          '" />\n'
        ];
      }
      else {
        var startX = fabric.util.cos(this.startAngle) * this.radius,
            startY = fabric.util.sin(this.startAngle) * this.radius,
            endX = fabric.util.cos(this.endAngle) * this.radius,
            endY = fabric.util.sin(this.endAngle) * this.radius,
            largeFlag = angle > pi ? '1' : '0';
        svgString = [
          '<path d="M ' + startX + ' ' + startY,
          ' A ' + this.radius + ' ' + this.radius,
          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
          '" ', 'COMMON_PARTS', ' />\n'
        ];
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.arc(
        0,
        0,
        this.radius,
        this.startAngle,
        this.endAngle, false);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusX: function() {
      return this.get('radius') * this.get('scaleX');
    },

    /**
     * Returns vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusY: function() {
      return this.get('radius') * this.get('scaleY');
    },

    /**
     * Sets radius of an object (and updates width accordingly)
     * @return {fabric.Circle} thisArg
     */
    setRadius: function(value) {
      this.radius = value;
      return this.set('width', value * 2).set('height', value * 2);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
   * @static
   * @memberOf fabric.Circle
   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
   */
  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

  /**
   * Returns {@link fabric.Circle} instance from an SVG element
   * @static
   * @memberOf fabric.Circle
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @param {Object} [options] Options object
   * @throws {Error} If value of `r` attribute is missing or invalid
   */
  fabric.Circle.fromElement = function(element, callback) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

    if (!isValidRadius(parsedAttributes)) {
      throw new Error('value of `r` attribute is required and can not be negative');
    }

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
    callback(new fabric.Circle(parsedAttributes));
  };

  /**
   * @private
   */
  function isValidRadius(attributes) {
    return (('radius' in attributes) && (attributes.radius >= 0));
  }
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Circle} instance from an object representation
   * @static
   * @memberOf fabric.Circle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {Object} Instance of fabric.Circle
   */
  fabric.Circle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Circle', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Triangle) {
    fabric.warn('fabric.Triangle is already defined');
    return;
  }

  /**
   * Triangle class
   * @class fabric.Triangle
   * @extends fabric.Object
   * @return {fabric.Triangle} thisArg
   * @see {@link fabric.Triangle#initialize} for constructor definition
   */
  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'triangle',

    /**
     * Width is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    width: 100,

    /**
     * Height is set to 100 to compensate the old initialize code that was setting it to 100
     * @type Number
     * @default
     */
    height: 100,

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      ctx.moveTo(-widthBy2, heightBy2);
      ctx.lineTo(0, -heightBy2);
      ctx.lineTo(widthBy2, heightBy2);
      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
      ctx.closePath();
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2,
          points = [
            -widthBy2 + ' ' + heightBy2,
            '0 ' + -heightBy2,
            widthBy2 + ' ' + heightBy2
          ].join(',');
      return [
        '<polygon ', 'COMMON_PARTS',
        'points="', points,
        '" />'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Triangle} instance from an object representation
   * @static
   * @memberOf fabric.Triangle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Triangle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Triangle', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      piBy2   = Math.PI * 2;

  if (fabric.Ellipse) {
    fabric.warn('fabric.Ellipse is already defined.');
    return;
  }

  /**
   * Ellipse class
   * @class fabric.Ellipse
   * @extends fabric.Object
   * @return {fabric.Ellipse} thisArg
   * @see {@link fabric.Ellipse#initialize} for constructor definition
   */
  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'ellipse',

    /**
     * Horizontal radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {fabric.Ellipse} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this.set('rx', options && options.rx || 0);
      this.set('ry', options && options.ry || 0);
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Ellipse} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      switch (key) {

        case 'rx':
          this.rx = value;
          this.set('width', value * 2);
          break;

        case 'ry':
          this.ry = value;
          this.set('height', value * 2);
          break;

      }
      return this;
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRx: function() {
      return this.get('rx') * this.get('scaleX');
    },

    /**
     * Returns Vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRy: function() {
      return this.get('ry') * this.get('scaleY');
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      return [
        '<ellipse ', 'COMMON_PARTS',
        'cx="0" cy="0" ',
        'rx="', this.rx,
        '" ry="', this.ry,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.save();
      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
      ctx.arc(
        0,
        0,
        this.rx,
        0,
        piBy2,
        false);
      ctx.restore();
      this._renderPaintInOrder(ctx);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
   * @static
   * @memberOf fabric.Ellipse
   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
   */
  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

  /**
   * Returns {@link fabric.Ellipse} instance from an SVG element
   * @static
   * @memberOf fabric.Ellipse
   * @param {SVGElement} element Element to parse
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromElement = function(element, callback) {

    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
    callback(new fabric.Ellipse(parsedAttributes));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Ellipse} instance from an object representation
   * @static
   * @memberOf fabric.Ellipse
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Ellipse', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend;

  if (fabric.Rect) {
    fabric.warn('fabric.Rect is already defined');
    return;
  }

  /**
   * Rectangle class
   * @class fabric.Rect
   * @extends fabric.Object
   * @return {fabric.Rect} thisArg
   * @see {@link fabric.Rect#initialize} for constructor definition
   */
  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

    /**
     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('rx', 'ry'),

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'rect',

    /**
     * Horizontal border radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical border radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('rx', 'ry'),

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this._initRxRy();
    },

    /**
     * Initializes rx/ry attributes
     * @private
     */
    _initRxRy: function() {
      if (this.rx && !this.ry) {
        this.ry = this.rx;
      }
      else if (this.ry && !this.rx) {
        this.rx = this.ry;
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {

      // 1x1 case (used in spray brush) optimization was removed because
      // with caching and higher zoom level this makes more damage than help

      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
          w = this.width,
          h = this.height,
          x = -this.width / 2,
          y = -this.height / 2,
          isRounded = rx !== 0 || ry !== 0,
          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
          k = 1 - 0.5522847498;
      ctx.beginPath();

      ctx.moveTo(x + rx, y);

      ctx.lineTo(x + w - rx, y);
      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

      ctx.lineTo(x + w, y + h - ry);
      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

      ctx.lineTo(x + rx, y + h);
      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

      ctx.lineTo(x, y + ry);
      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

      ctx.closePath();

      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var x = -this.width / 2, y = -this.height / 2;
      return [
        '<rect ', 'COMMON_PARTS',
        'x="', x, '" y="', y,
        '" rx="', this.rx, '" ry="', this.ry,
        '" width="', this.width, '" height="', this.height,
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
   * @static
   * @memberOf fabric.Rect
   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
   */
  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

  /**
   * Returns {@link fabric.Rect} instance from an SVG element
   * @static
   * @memberOf fabric.Rect
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Rect.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }
    options = options || { };

    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
    parsedAttributes.left = parsedAttributes.left || 0;
    parsedAttributes.top  = parsedAttributes.top  || 0;
    parsedAttributes.height  = parsedAttributes.height || 0;
    parsedAttributes.width  = parsedAttributes.width || 0;
    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
    callback(rect);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Rect} instance from an object representation
   * @static
   * @memberOf fabric.Rect
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
   */
  fabric.Rect.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Rect', object, callback);
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      toFixed = fabric.util.toFixed;

  if (fabric.Polyline) {
    fabric.warn('fabric.Polyline is already defined');
    return;
  }

  /**
   * Polyline class
   * @class fabric.Polyline
   * @extends fabric.Object
   * @see {@link fabric.Polyline#initialize} for constructor definition
   */
  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polyline',

    /**
     * Points array
     * @type Array
     * @default
     */
    points: null,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('points'),

    /**
     * Constructor
     * @param {Array} points Array of points (where each point is an object with x and y)
     * @param {Object} [options] Options object
     * @return {fabric.Polyline} thisArg
     * @example
     * var poly = new fabric.Polyline([
     *     { x: 10, y: 10 },
     *     { x: 50, y: 30 },
     *     { x: 40, y: 70 },
     *     { x: 60, y: 50 },
     *     { x: 100, y: 150 },
     *     { x: 40, y: 100 }
     *   ], {
     *   stroke: 'red',
     *   left: 100,
     *   top: 100
     * });
     */
    initialize: function(points, options) {
      options = options || {};
      this.points = points || [];
      this.callSuper('initialize', options);
      this._setPositionDimensions(options);
    },

    _setPositionDimensions: function(options) {
      var calcDim = this._calcDimensions(options), correctLeftTop;
      this.width = calcDim.width;
      this.height = calcDim.height;
      if (!options.fromSVG) {
        correctLeftTop = this.translateToGivenOrigin(
          { x: calcDim.left - this.strokeWidth / 2, y: calcDim.top - this.strokeWidth / 2 },
          'left',
          'top',
          this.originX,
          this.originY
        );
      }
      if (typeof options.left === 'undefined') {
        this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
      }
      if (typeof options.top === 'undefined') {
        this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
      }
      this.pathOffset = {
        x: calcDim.left + this.width / 2,
        y: calcDim.top + this.height / 2
      };
    },

    /**
     * Calculate the polygon min and max point from points array,
     * returning an object with left, top, width, height to measure the
     * polygon size
     * @return {Object} object.left X coordinate of the polygon leftmost point
     * @return {Object} object.top Y coordinate of the polygon topmost point
     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
     * @private
     */
    _calcDimensions: function() {

      var points = this.points,
          minX = min(points, 'x') || 0,
          minY = min(points, 'y') || 0,
          maxX = max(points, 'x') || 0,
          maxY = max(points, 'y') || 0,
          width = (maxX - minX),
          height = (maxY - minY);

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        points: this.points.concat()
      });
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      for (var i = 0, len = this.points.length; i < len; i++) {
        points.push(
          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
        );
      }
      return [
        '<' + this.type + ' ', 'COMMON_PARTS',
        'points="', points.join(''),
        '" />\n'
      ];
    },
    /* _TO_SVG_END_ */


    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    commonRender: function(ctx) {
      var point, len = this.points.length,
          x = this.pathOffset.x,
          y = this.pathOffset.y;

      if (!len || isNaN(this.points[len - 1].y)) {
        // do not draw if no points or odd points
        // NaN comes from parseFloat of a empty string in parser
        return false;
      }
      ctx.beginPath();
      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
      for (var i = 0; i < len; i++) {
        point = this.points[i];
        ctx.lineTo(point.x - x, point.y - y);
      }
      return true;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p1, p2;

      ctx.beginPath();
      for (var i = 0, len = this.points.length; i < len; i++) {
        p1 = this.points[i];
        p2 = this.points[i + 1] || p1;
        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
      }
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.get('points').length;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
   * @static
   * @memberOf fabric.Polyline
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
   */
  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns fabric.Polyline instance from an SVG element
   * @static
   * @memberOf fabric.Polyline
   * @param {SVGElement} element Element to parser
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polyline.fromElementGenerator = function(_class) {
    return function(element, callback, options) {
      if (!element) {
        return callback(null);
      }
      options || (options = { });

      var points = fabric.parsePointsAttribute(element.getAttribute('points')),
          parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);
      parsedAttributes.fromSVG = true;
      callback(new fabric[_class](points, extend(parsedAttributes, options)));
    };
  };

  fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator('Polyline');

  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polyline instance from an object representation
   * @static
   * @memberOf fabric.Polyline
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polyline.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polyline', object, callback, 'points');
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Polygon) {
    fabric.warn('fabric.Polygon is already defined');
    return;
  }

  /**
   * Polygon class
   * @class fabric.Polygon
   * @extends fabric.Polyline
   * @see {@link fabric.Polygon#initialize} for constructor definition
   */
  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polygon',

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      this.callSuper('_renderDashedStroke', ctx);
      ctx.closePath();
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
   * @static
   * @memberOf fabric.Polygon
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
   */
  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns {@link fabric.Polygon} instance from an SVG element
   * @static
   * @memberOf fabric.Polygon
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator('Polygon');
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polygon instance from an object representation
   * @static
   * @memberOf fabric.Polygon
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polygon.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polygon', object, callback, 'points');
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      extend = fabric.util.object.extend,
      _toString = Object.prototype.toString,
      toFixed = fabric.util.toFixed;

  if (fabric.Path) {
    fabric.warn('fabric.Path is already defined');
    return;
  }

  /**
   * Path class
   * @class fabric.Path
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
   * @see {@link fabric.Path#initialize} for constructor definition
   */
  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'path',

    /**
     * Array of path points
     * @type Array
     * @default
     */
    path: null,

    cacheProperties: fabric.Object.prototype.cacheProperties.concat('path', 'fillRule'),

    stateProperties: fabric.Object.prototype.stateProperties.concat('path'),

    /**
     * Constructor
     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
     * @param {Object} [options] Options object
     * @return {fabric.Path} thisArg
     */
    initialize: function(path, options) {
      options = options || { };
      this.callSuper('initialize', options);
      if (!path) {
        path = [];
      }

      var fromArray = _toString.call(path) === '[object Array]';

      this.path = fromArray
        ? fabric.util.makePathSimpler(path)

        : fabric.util.makePathSimpler(
          fabric.util.parsePath(path)
        );

      if (!this.path) {
        return;
      }
      fabric.Polyline.prototype._setPositionDimensions.call(this, options);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _renderPathCommands: function(ctx) {
      var current, // current instruction
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          controlX = 0, // current control point x
          controlY = 0, // current control point y
          l = -this.pathOffset.x,
          t = -this.pathOffset.y;

      ctx.beginPath();

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            ctx.lineTo(x + l, y + t);
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            ctx.moveTo(x + l, y + t);
            break;

          case 'C': // bezierCurveTo, absolute
            x = current[5];
            y = current[6];
            controlX = current[3];
            controlY = current[4];
            ctx.bezierCurveTo(
              current[1] + l,
              current[2] + t,
              controlX + l,
              controlY + t,
              x + l,
              y + t
            );
            break;

          case 'Q': // quadraticCurveTo, absolute
            ctx.quadraticCurveTo(
              current[1] + l,
              current[2] + t,
              current[3] + l,
              current[4] + t
            );
            x = current[3];
            y = current[4];
            controlX = current[1];
            controlY = current[2];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            ctx.closePath();
            break;
        }
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _render: function(ctx) {
      this._renderPathCommands(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Returns string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function() {
      return '#<fabric.Path (' + this.complexity() +
        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        path: this.path.map(function(item) { return item.slice(); }),
      });
    },

    /**
     * Returns dataless object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
      if (o.sourcePath) {
        delete o.path;
      }
      return o;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var path = this.path.map(function(path) {
        return path.join(' ');
      }).join(' ');
      return [
        '<path ', 'COMMON_PARTS',
        'd="', path,
        '" stroke-linecap="round" ',
        '/>\n'
      ];
    },

    _getOffsetTransform: function() {
      var digits = fabric.Object.NUM_FRACTION_DIGITS;
      return ' translate(' + toFixed(-this.pathOffset.x, digits) + ', ' +
          toFixed(-this.pathOffset.y, digits) + ')';
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return '\t' + this._createBaseClipPathSVGMarkup(
        this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform }
      );
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var additionalTransform = this._getOffsetTransform();
      return this._createBaseSVGMarkup(this._toSVG(), { reviver: reviver, additionalTransform: additionalTransform  });
    },
    /* _TO_SVG_END_ */

    /**
     * Returns number representation of an instance complexity
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.path.length;
    },

    /**
     * @private
     */
    _calcDimensions: function() {

      var aX = [],
          aY = [],
          current, // current instruction
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          bounds;

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            bounds = [];
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            bounds = [];
            break;

          case 'C': // bezierCurveTo, absolute
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6]
            );
            x = current[5];
            y = current[6];
            break;

          case 'Q': // quadraticCurveTo, absolute
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              current[1],
              current[2],
              current[3],
              current[4]
            );
            x = current[3];
            y = current[4];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            break;
        }
        bounds.forEach(function (point) {
          aX.push(point.x);
          aY.push(point.y);
        });
        aX.push(x);
        aY.push(y);
      }

      var minX = min(aX) || 0,
          minY = min(aY) || 0,
          maxX = max(aX) || 0,
          maxY = max(aY) || 0,
          deltaX = maxX - minX,
          deltaY = maxY - minY;

      return {
        left: minX,
        top: minY,
        width: deltaX,
        height: deltaY
      };
    }
  });

  /**
   * Creates an instance of fabric.Path from an object
   * @static
   * @memberOf fabric.Path
   * @param {Object} object
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Path.fromObject = function(object, callback) {
    if (typeof object.sourcePath === 'string') {
      var pathUrl = object.sourcePath;
      fabric.loadSVGFromURL(pathUrl, function (elements) {
        var path = elements[0];
        path.setOptions(object);
        callback && callback(path);
      });
    }
    else {
      fabric.Object._fromObject('Path', object, callback, 'path');
    }
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
   * @static
   * @memberOf fabric.Path
   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
   */
  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

  /**
   * Creates an instance of fabric.Path from an SVG <path> element
   * @static
   * @memberOf fabric.Path
   * @param {SVGElement} element to parse
   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
   * @param {Object} [options] Options object
   * @param {Function} [callback] Options callback invoked after parsing is finished
   */
  fabric.Path.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
    parsedAttributes.fromSVG = true;
    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max;

  if (fabric.Group) {
    return;
  }

  /**
   * Group class
   * @class fabric.Group
   * @extends fabric.Object
   * @mixes fabric.Collection
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.Group#initialize} for constructor definition
   */
  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'group',

    /**
     * Width of stroke
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
     * @type Boolean
     * @default
     */
    subTargetCheck: false,

    /**
     * Groups are container, do not render anything on theyr own, ence no cache properties
     * @type Array
     * @default
     */
    cacheProperties: [],

    /**
     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
     * available setting this boolean to true.
     * @type Boolean
     * @since 2.0.0
     * @default
     */
    useSetOnGroup: false,

    /**
     * Constructor
     * @param {Object} objects Group objects
     * @param {Object} [options] Options object
     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
     * @return {Object} thisArg
     */
    initialize: function(objects, options, isAlreadyGrouped) {
      options = options || {};
      this._objects = [];
      // if objects enclosed in a group have been grouped already,
      // we cannot change properties of objects.
      // Thus we need to set options to group without objects,
      isAlreadyGrouped && this.callSuper('initialize', options);
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (!isAlreadyGrouped) {
        var center = options && options.centerPoint;
        // we want to set origins before calculating the bounding box.
        // so that the topleft can be set with that in mind.
        // if specific top and left are passed, are overwritten later
        // with the callSuper('initialize', options)
        if (options.originX !== undefined) {
          this.originX = options.originX;
        }
        if (options.originY !== undefined) {
          this.originY = options.originY;
        }
        // if coming from svg i do not want to calc bounds.
        // i assume width and height are passed along options
        center || this._calcBounds();
        this._updateObjectsCoords(center);
        delete options.centerPoint;
        this.callSuper('initialize', options);
      }
      else {
        this._updateObjectsACoords();
      }

      this.setCoords();
    },

    /**
     * @private
     */
    _updateObjectsACoords: function() {
      var skipControls = true;
      for (var i = this._objects.length; i--; ){
        this._objects[i].setCoords(skipControls);
      }
    },

    /**
     * @private
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
     */
    _updateObjectsCoords: function(center) {
      var center = center || this.getCenterPoint();
      for (var i = this._objects.length; i--; ){
        this._updateObjectCoords(this._objects[i], center);
      }
    },

    /**
     * @private
     * @param {Object} object
     * @param {fabric.Point} center, current center of group.
     */
    _updateObjectCoords: function(object, center) {
      var objectLeft = object.left,
          objectTop = object.top,
          skipControls = true;

      object.set({
        left: objectLeft - center.x,
        top: objectTop - center.y
      });
      object.group = this;
      object.setCoords(skipControls);
    },

    /**
     * Returns string represenation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.Group: (' + this.complexity() + ')>';
    },

    /**
     * Adds an object to a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    addWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);
      if (object) {
        this._objects.push(object);
        object.group = this;
        object._set('canvas', this.canvas);
      }
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * Removes an object from a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    removeWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);

      this.remove(object);
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * @private
     */
    _onObjectAdded: function(object) {
      this.dirty = true;
      object.group = this;
      object._set('canvas', this.canvas);
    },

    /**
     * @private
     */
    _onObjectRemoved: function(object) {
      this.dirty = true;
      delete object.group;
    },

    /**
     * @private
     */
    _set: function(key, value) {
      var i = this._objects.length;
      if (this.useSetOnGroup) {
        while (i--) {
          this._objects[i].setOnGroup(key, value);
        }
      }
      if (key === 'canvas') {
        while (i--) {
          this._objects[i]._set(key, value);
        }
      }
      fabric.Object.prototype._set.call(this, key, value);
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var _includeDefaultValues = this.includeDefaultValues;
      var objsToObject = this._objects.map(function(obj) {
        var originalDefaults = obj.includeDefaultValues;
        obj.includeDefaultValues = _includeDefaultValues;
        var _obj = obj.toObject(propertiesToInclude);
        obj.includeDefaultValues = originalDefaults;
        return _obj;
      });
      var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Returns object representation of an instance, in dataless mode.
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var objsToObject, sourcePath = this.sourcePath;
      if (sourcePath) {
        objsToObject = sourcePath;
      }
      else {
        var _includeDefaultValues = this.includeDefaultValues;
        objsToObject = this._objects.map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = _includeDefaultValues;
          var _obj = obj.toDatalessObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
      }
      var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
      obj.objects = objsToObject;
      return obj;
    },

    /**
     * Renders instance on a given context
     * @param {CanvasRenderingContext2D} ctx context to render instance on
     */
    render: function(ctx) {
      this._transformDone = true;
      this.callSuper('render', ctx);
      this._transformDone = false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group is already cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      var ownCache = fabric.Object.prototype.shouldCache.call(this);
      if (ownCache) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            this.ownCaching = false;
            return false;
          }
        }
      }
      return ownCache;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * @return {Boolean}
     */
    willDrawShadow: function() {
      if (fabric.Object.prototype.willDrawShadow.call(this)) {
        return true;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].willDrawShadow()) {
          return true;
        }
      }
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return this.ownCaching || (this.group && this.group.isOnACache());
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx) {
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i].render(ctx);
      }
      this._drawClipPath(ctx);
    },

    /**
     * Check if cache is dirty
     */
    isCacheDirty: function(skipCanvas) {
      if (this.callSuper('isCacheDirty', skipCanvas)) {
        return true;
      }
      if (!this.statefullCache) {
        return false;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].isCacheDirty(true)) {
          if (this._cacheCanvas) {
            // if this group has not a cache canvas there is nothing to clean
            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Restores original state of each of group objects (original state is that which was before group was created).
     * @private
     * @return {fabric.Group} thisArg
     * @chainable
     */
    _restoreObjectsState: function() {
      this._objects.forEach(this._restoreObjectState, this);
      return this;
    },

    /**
     * Realises the transform from this group onto the supplied object
     * i.e. it tells you what would happen if the supplied object was in
     * the group, and then the group was destroyed. It mutates the supplied
     * object.
     * @param {fabric.Object} object
     * @return {fabric.Object} transformedObject
     */
    realizeTransform: function(object) {
      var matrix = object.calcTransformMatrix(),
          options = fabric.util.qrDecompose(matrix),
          center = new fabric.Point(options.translateX, options.translateY);
      object.flipX = false;
      object.flipY = false;
      object.set('scaleX', options.scaleX);
      object.set('scaleY', options.scaleY);
      object.skewX = options.skewX;
      object.skewY = options.skewY;
      object.angle = options.angle;
      object.setPositionByOrigin(center, 'center', 'center');
      return object;
    },

    /**
     * Restores original state of a specified object in group
     * @private
     * @param {fabric.Object} object
     * @return {fabric.Group} thisArg
     */
    _restoreObjectState: function(object) {
      this.realizeTransform(object);
      delete object.group;
      object.setCoords();
      return this;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    destroy: function() {
      // when group is destroyed objects needs to get a repaint to be eventually
      // displayed on canvas.
      this._objects.forEach(function(object) {
        object.set('dirty', true);
      });
      return this._restoreObjectsState();
    },

    /**
     * make a group an active selection, remove the group from canvas
     * the group has to be on canvas for this to work.
     * @return {fabric.ActiveSelection} thisArg
     * @chainable
     */
    toActiveSelection: function() {
      if (!this.canvas) {
        return;
      }
      var objects = this._objects, canvas = this.canvas;
      this._objects = [];
      var options = this.toObject();
      delete options.objects;
      var activeSelection = new fabric.ActiveSelection([]);
      activeSelection.set(options);
      activeSelection.type = 'activeSelection';
      canvas.remove(this);
      objects.forEach(function(object) {
        object.group = activeSelection;
        object.dirty = true;
        canvas.add(object);
      });
      activeSelection.canvas = canvas;
      activeSelection._objects = objects;
      canvas._activeObject = activeSelection;
      activeSelection.setCoords();
      return activeSelection;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    ungroupOnCanvas: function() {
      return this._restoreObjectsState();
    },

    /**
     * Sets coordinates of all objects inside group
     * @return {fabric.Group} thisArg
     * @chainable
     */
    setObjectsCoords: function() {
      var skipControls = true;
      this.forEachObject(function(object) {
        object.setCoords(skipControls);
      });
      return this;
    },

    /**
     * @private
     */
    _calcBounds: function(onlyWidthHeight) {
      var aX = [],
          aY = [],
          o, prop,
          props = ['tr', 'br', 'bl', 'tl'],
          i = 0, iLen = this._objects.length,
          j, jLen = props.length;

      for ( ; i < iLen; ++i) {
        o = this._objects[i];
        o.aCoords = o.calcACoords();
        for (j = 0; j < jLen; j++) {
          prop = props[j];
          aX.push(o.aCoords[prop].x);
          aY.push(o.aCoords[prop].y);
        }
      }

      this._getBounds(aX, aY, onlyWidthHeight);
    },

    /**
     * @private
     */
    _getBounds: function(aX, aY, onlyWidthHeight) {
      var minXY = new fabric.Point(min(aX), min(aY)),
          maxXY = new fabric.Point(max(aX), max(aY)),
          top = minXY.y || 0, left = minXY.x || 0,
          width = (maxXY.x - minXY.x) || 0,
          height = (maxXY.y - minXY.y) || 0;
      this.width = width;
      this.height = height;
      if (!onlyWidthHeight) {
        // the bounding box always finds the topleft most corner.
        // whatever is the group origin, we set up here the left/top position.
        this.setPositionByOrigin({ x: left, y: top }, 'left', 'top');
      }
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    _toSVG: function(reviver) {
      var svgString = ['<g ', 'COMMON_PARTS', ' >\n'];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t\t', this._objects[i].toSVG(reviver));
      }
      svgString.push('</g>\n');
      return svgString;
    },

    /**
     * Returns styles-string for svg-export, specific version for group
     * @return {String}
     */
    getSvgStyles: function() {
      var opacity = typeof this.opacity !== 'undefined' && this.opacity !== 1 ?
            'opacity: ' + this.opacity + ';' : '',
          visibility = this.visible ? '' : ' visibility: hidden;';
      return [
        opacity,
        this.getSvgFilter(),
        visibility
      ].join('');
    },

    /**
     * Returns svg clipPath representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toClipPathSVG: function(reviver) {
      var svgString = [];

      for (var i = 0, len = this._objects.length; i < len; i++) {
        svgString.push('\t', this._objects[i].toClipPathSVG(reviver));
      }

      return this._createBaseClipPathSVGMarkup(svgString, { reviver: reviver });
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Group} instance from an object representation
   * @static
   * @memberOf fabric.Group
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an group instance is created
   */
  fabric.Group.fromObject = function(object, callback) {
    var objects = object.objects,
        options = fabric.util.object.clone(object, true);
    delete options.objects;
    if (typeof objects === 'string') {
      // it has to be an url or something went wrong.
      fabric.loadSVGFromURL(objects, function (elements) {
        var group = fabric.util.groupSVGElements(elements, object, objects);
        group.set(options);
        callback && callback(group);
      });
      return;
    }
    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
      fabric.util.enlivenObjects([object.clipPath], function(enlivedClipPath) {
        var options = fabric.util.object.clone(object, true);
        options.clipPath = enlivedClipPath[0];
        delete options.objects;
        callback && callback(new fabric.Group(enlivenedObjects, options, true));
      });
    });
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.ActiveSelection) {
    return;
  }

  /**
   * Group class
   * @class fabric.ActiveSelection
   * @extends fabric.Group
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.ActiveSelection#initialize} for constructor definition
   */
  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'activeSelection',

    /**
     * Constructor
     * @param {Object} objects ActiveSelection objects
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(objects, options) {
      options = options || {};
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (options.originX) {
        this.originX = options.originX;
      }
      if (options.originY) {
        this.originY = options.originY;
      }
      this._calcBounds();
      this._updateObjectsCoords();
      fabric.Object.prototype.initialize.call(this, options);
      this.setCoords();
    },

    /**
     * Change te activeSelection to a normal group,
     * High level function that automatically adds it to canvas as
     * active object. no events fired.
     * @since 2.0.0
     * @return {fabric.Group}
     */
    toGroup: function() {
      var objects = this._objects.concat();
      this._objects = [];
      var options = fabric.Object.prototype.toObject.call(this);
      var newGroup = new fabric.Group([]);
      delete options.type;
      newGroup.set(options);
      objects.forEach(function(object) {
        object.canvas.remove(object);
        object.group = newGroup;
      });
      newGroup._objects = objects;
      if (!this.canvas) {
        return newGroup;
      }
      var canvas = this.canvas;
      canvas.add(newGroup);
      canvas._activeObject = newGroup;
      newGroup.setCoords();
      return newGroup;
    },

    /**
     * If returns true, deselection is cancelled.
     * @since 2.0.0
     * @return {Boolean} [cancel]
     */
    onDeselect: function() {
      this.destroy();
      return false;
    },

    /**
     * Returns string representation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return false;
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     * @param {Object} [childrenOverride] properties to override the children overrides
     */
    _renderControls: function(ctx, styleOverride, childrenOverride) {
      ctx.save();
      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      this.callSuper('_renderControls', ctx, styleOverride);
      childrenOverride = childrenOverride || { };
      if (typeof childrenOverride.hasControls === 'undefined') {
        childrenOverride.hasControls = false;
      }
      childrenOverride.forActiveSelection = true;
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i]._renderControls(ctx, childrenOverride);
      }
      ctx.restore();
    },
  });

  /**
   * Returns {@link fabric.ActiveSelection} instance from an object representation
   * @static
   * @memberOf fabric.ActiveSelection
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
   */
  fabric.ActiveSelection.fromObject = function(object, callback) {
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
      delete object.objects;
      callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
    });
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var extend = fabric.util.object.extend;

  if (!global.fabric) {
    global.fabric = { };
  }

  if (global.fabric.Image) {
    fabric.warn('fabric.Image is already defined.');
    return;
  }

  /**
   * Image class
   * @class fabric.Image
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
   * @see {@link fabric.Image#initialize} for constructor definition
   */
  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'image',

    /**
     * Width of a stroke.
     * For image quality a stroke multiple of 2 gives better results.
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.
     * This allows for relative urls as image src.
     * @since 2.7.0
     * @type Boolean
     * @default
     */
    srcFromAttribute: false,

    /**
     * private
     * contains last value of scaleX to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleX: 1,

    /**
     * private
     * contains last value of scaleY to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleY: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingX: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingY: 1,

    /**
     * minimum scale factor under which any resizeFilter is triggered to resize the image
     * 0 will disable the automatic resize. 1 will trigger automatically always.
     * number bigger than 1 are not implemented yet.
     * @type Number
     */
    minimumScaleTrigger: 0.5,

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat('cropX', 'cropY'),

    /**
     * key used to retrieve the texture representing this image
     * @since 2.0.0
     * @type String
     * @default
     */
    cacheKey: '',

    /**
     * Image crop in pixels from original image size.
     * @since 2.0.0
     * @type Number
     * @default
     */
    cropX: 0,

    /**
     * Image crop in pixels from original image size.
     * @since 2.0.0
     * @type Number
     * @default
     */
    cropY: 0,

    /**
     * Indicates whether this canvas will use image smoothing when painting this image.
     * Also influence if the cacheCanvas for this image uses imageSmoothing
     * @since 4.0.0-beta.11
     * @type Boolean
     * @default
     */
    imageSmoothing: true,

    /**
     * Constructor
     * @param {HTMLImageElement | String} element Image element
     * @param {Object} [options] Options object
     * @param {function} [callback] callback function to call after eventual filters applied.
     * @return {fabric.Image} thisArg
     */
    initialize: function(element, options) {
      options || (options = { });
      this.filters = [];
      this.cacheKey = 'texture' + fabric.Object.__uid++;
      this.callSuper('initialize', options);
      this._initElement(element, options);
    },

    /**
     * Returns image element which this instance if based on
     * @return {HTMLImageElement} Image element
     */
    getElement: function() {
      return this._element || {};
    },

    /**
     * Sets image element for this instance to a specified one.
     * If filters defined they are applied to new image.
     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
     * @param {HTMLImageElement} element
     * @param {Object} [options] Options object
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setElement: function(element, options) {
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._element = element;
      this._originalElement = element;
      this._initConfig(options);
      if (this.filters.length !== 0) {
        this.applyFilters();
      }
      // resizeFilters work on the already filtered copy.
      // we need to apply resizeFilters AFTER normal filters.
      // applyResizeFilters is run more often than normal filters
      // and is triggered by user interactions rather than dev code
      if (this.resizeFilter) {
        this.applyResizeFilters();
      }
      return this;
    },

    /**
     * Delete a single texture if in webgl mode
     */
    removeTexture: function(key) {
      var backend = fabric.filterBackend;
      if (backend && backend.evictCachesForKey) {
        backend.evictCachesForKey(key);
      }
    },

    /**
     * Delete textures, reference to elements and eventually JSDOM cleanup
     */
    dispose: function() {
      this.removeTexture(this.cacheKey);
      this.removeTexture(this.cacheKey + '_filtered');
      this._cacheContext = undefined;
      ['_originalElement', '_element', '_filteredEl', '_cacheCanvas'].forEach((function(element) {
        fabric.util.cleanUpJsdomNode(this[element]);
        this[element] = undefined;
      }).bind(this));
    },

    /**
     * Get the crossOrigin value (of the corresponding image element)
     */
    getCrossOrigin: function() {
      return this._originalElement && (this._originalElement.crossOrigin || null);
    },

    /**
     * Returns original size of an image
     * @return {Object} Object with "width" and "height" properties
     */
    getOriginalSize: function() {
      var element = this.getElement();
      return {
        width: element.naturalWidth || element.width,
        height: element.naturalHeight || element.height
      };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _stroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }
      var w = this.width / 2, h = this.height / 2;
      ctx.beginPath();
      ctx.moveTo(-w, -h);
      ctx.lineTo(w, -h);
      ctx.lineTo(w, h);
      ctx.lineTo(-w, h);
      ctx.lineTo(-w, -h);
      ctx.closePath();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.save();
      this._setStrokeStyles(ctx, this);

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
      ctx.restore();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var filters = [];

      this.filters.forEach(function(filterObj) {
        if (filterObj) {
          filters.push(filterObj.toObject());
        }
      });
      var object = extend(
        this.callSuper(
          'toObject',
          ['cropX', 'cropY'].concat(propertiesToInclude)
        ), {
          src: this.getSrc(),
          crossOrigin: this.getCrossOrigin(),
          filters: filters,
        });
      if (this.resizeFilter) {
        object.resizeFilter = this.resizeFilter.toObject();
      }
      return object;
    },

    /**
     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.
     * @return {Boolean}
     */
    hasCrop: function() {
      return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @return {Array} an array of strings with the specific svg representation
     * of the instance
     */
    _toSVG: function() {
      var svgString = [], imageMarkup = [], strokeSvg, element = this._element,
          x = -this.width / 2, y = -this.height / 2, clipPath = '', imageRendering = '';
      if (!element) {
        return [];
      }
      if (this.hasCrop()) {
        var clipPathId = fabric.Object.__uid++;
        svgString.push(
          '<clipPath id="imageCrop_' + clipPathId + '">\n',
          '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
          '</clipPath>\n'
        );
        clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
      }
      if (!this.imageSmoothing) {
        imageRendering = '" image-rendering="optimizeSpeed';
      }
      imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(true),
        '" x="', x - this.cropX, '" y="', y - this.cropY,
        // we're essentially moving origin of transformation from top/left corner to the center of the shape
        // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
        // so that object's center aligns with container's left/top
        '" width="', element.width || element.naturalWidth,
        '" height="', element.height || element.height,
        imageRendering,
        '"', clipPath,
        '></image>\n');

      if (this.stroke || this.strokeDashArray) {
        var origFill = this.fill;
        this.fill = null;
        strokeSvg = [
          '\t<rect ',
          'x="', x, '" y="', y,
          '" width="', this.width, '" height="', this.height,
          '" style="', this.getSvgStyles(),
          '"/>\n'
        ];
        this.fill = origFill;
      }
      if (this.paintFirst !== 'fill') {
        svgString = svgString.concat(strokeSvg, imageMarkup);
      }
      else {
        svgString = svgString.concat(imageMarkup, strokeSvg);
      }
      return svgString;
    },
    /* _TO_SVG_END_ */

    /**
     * Returns source of an image
     * @param {Boolean} filtered indicates if the src is needed for svg
     * @return {String} Source of an image
     */
    getSrc: function(filtered) {
      var element = filtered ? this._element : this._originalElement;
      if (element) {
        if (element.toDataURL) {
          return element.toDataURL();
        }

        if (this.srcFromAttribute) {
          return element.getAttribute('src');
        }
        else {
          return element.src;
        }
      }
      else {
        return this.src || '';
      }
    },

    /**
     * Sets source of an image
     * @param {String} src Source string (URL)
     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
     * @param {Object} [options] Options object
     * @param {String} [options.crossOrigin] crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setSrc: function(src, callback, options) {
      fabric.util.loadImage(src, function(img, isError) {
        this.setElement(img, options);
        this._setWidthHeight();
        callback && callback(this, isError);
      }, this, options && options.crossOrigin);
      return this;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of an instance
     */
    toString: function() {
      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
    },

    applyResizeFilters: function() {
      var filter = this.resizeFilter,
          minimumScale = this.minimumScaleTrigger,
          objectScale = this.getTotalObjectScaling(),
          scaleX = objectScale.scaleX,
          scaleY = objectScale.scaleY,
          elementToFilter = this._filteredEl || this._originalElement;
      if (this.group) {
        this.set('dirty', true);
      }
      if (!filter || (scaleX > minimumScale && scaleY > minimumScale)) {
        this._element = elementToFilter;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        this._lastScaleX = scaleX;
        this._lastScaleY = scaleY;
        return;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      var canvasEl = fabric.util.createCanvasElement(),
          cacheKey = this._filteredEl ? (this.cacheKey + '_filtered') : this.cacheKey,
          sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
      canvasEl.width = sourceWidth;
      canvasEl.height = sourceHeight;
      this._element = canvasEl;
      this._lastScaleX = filter.scaleX = scaleX;
      this._lastScaleY = filter.scaleY = scaleY;
      fabric.filterBackend.applyFilters(
        [filter], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);
      this._filterScalingX = canvasEl.width / this._originalElement.width;
      this._filterScalingY = canvasEl.height / this._originalElement.height;
    },

    /**
     * Applies filters assigned to this image (from "filters" array) or from filter param
     * @method applyFilters
     * @param {Array} filters to be applied
     * @param {Boolean} forResizing specify if the filter operation is a resize operation
     * @return {thisArg} return the fabric.Image object
     * @chainable
     */
    applyFilters: function(filters) {

      filters = filters || this.filters || [];
      filters = filters.filter(function(filter) { return filter && !filter.isNeutralState(); });
      this.set('dirty', true);

      // needs to clear out or WEBGL will not resize correctly
      this.removeTexture(this.cacheKey + '_filtered');

      if (filters.length === 0) {
        this._element = this._originalElement;
        this._filteredEl = null;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        return this;
      }

      var imgElement = this._originalElement,
          sourceWidth = imgElement.naturalWidth || imgElement.width,
          sourceHeight = imgElement.naturalHeight || imgElement.height;

      if (this._element === this._originalElement) {
        // if the element is the same we need to create a new element
        var canvasEl = fabric.util.createCanvasElement();
        canvasEl.width = sourceWidth;
        canvasEl.height = sourceHeight;
        this._element = canvasEl;
        this._filteredEl = canvasEl;
      }
      else {
        // clear the existing element to get new filter data
        // also dereference the eventual resized _element
        this._element = this._filteredEl;
        this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
        // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y
        this._lastScaleX = 1;
        this._lastScaleY = 1;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      fabric.filterBackend.applyFilters(
        filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
      if (this._originalElement.width !== this._element.width ||
        this._originalElement.height !== this._element.height) {
        this._filterScalingX = this._element.width / this._originalElement.width;
        this._filterScalingY = this._element.height / this._originalElement.height;
      }
      return this;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
      if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
        this.applyResizeFilters();
      }
      this._stroke(ctx);
      this._renderPaintInOrder(ctx);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * it will set the imageSmoothing for the draw operation
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
      fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * This is the special image version where we would like to avoid caching where possible.
     * Essentially images do not benefit from caching. They may require caching, and in that
     * case we do it. Also caching an image usually ends in a loss of details.
     * A full performance audit should be done.
     * @return {Boolean}
     */
    shouldCache: function() {
      return this.needsItsOwnCache();
    },

    _renderFill: function(ctx) {
      var elementToDraw = this._element;
      if (!elementToDraw) {
        return;
      }
      var scaleX = this._filterScalingX, scaleY = this._filterScalingY,
          w = this.width, h = this.height, min = Math.min, max = Math.max,
          // crop values cannot be lesser than 0.
          cropX = max(this.cropX, 0), cropY = max(this.cropY, 0),
          elWidth = elementToDraw.naturalWidth || elementToDraw.width,
          elHeight = elementToDraw.naturalHeight || elementToDraw.height,
          sX = cropX * scaleX,
          sY = cropY * scaleY,
          // the width height cannot exceed element width/height, starting from the crop offset.
          sW = min(w * scaleX, elWidth - sX),
          sH = min(h * scaleY, elHeight - sY),
          x = -w / 2, y = -h / 2,
          maxDestW = min(w, elWidth / scaleX - cropX),
          maxDestH = min(h, elHeight / scaleX - cropY);

      elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);
    },

    /**
     * needed to check if image needs resize
     * @private
     */
    _needsResize: function() {
      var scale = this.getTotalObjectScaling();
      return (scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY);
    },

    /**
     * @private
     */
    _resetWidthHeight: function() {
      this.set(this.getOriginalSize());
    },

    /**
     * The Image class's initialization method. This method is automatically
     * called by the constructor.
     * @private
     * @param {HTMLImageElement|String} element The element representing the image
     * @param {Object} [options] Options object
     */
    _initElement: function(element, options) {
      this.setElement(fabric.util.getById(element), options);
      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initConfig: function(options) {
      options || (options = { });
      this.setOptions(options);
      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Array} filters to be initialized
     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
     */
    _initFilters: function(filters, callback) {
      if (filters && filters.length) {
        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
          callback && callback(enlivenedObjects);
        }, 'fabric.Image.filters');
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * Set the width and the height of the image object, using the element or the
     * options.
     * @param {Object} [options] Object with width/height properties
     */
    _setWidthHeight: function(options) {
      options || (options = { });
      var el = this.getElement();
      this.width = options.width || el.naturalWidth || el.width || 0;
      this.height = options.height || el.naturalHeight || el.height || 0;
    },

    /**
     * Calculate offset for center and scale factor for the image in order to respect
     * the preserveAspectRatio attribute
     * @private
     * @return {Object}
     */
    parsePreserveAspectRatioAttribute: function() {
      var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ''),
          rWidth = this._element.width, rHeight = this._element.height,
          scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0,
          offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
      if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
        if (pAR.meetOrSlice === 'meet') {
          scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
          offset = (pWidth - rWidth * scaleX) / 2;
          if (pAR.alignX === 'Min') {
            offsetLeft = -offset;
          }
          if (pAR.alignX === 'Max') {
            offsetLeft = offset;
          }
          offset = (pHeight - rHeight * scaleY) / 2;
          if (pAR.alignY === 'Min') {
            offsetTop = -offset;
          }
          if (pAR.alignY === 'Max') {
            offsetTop = offset;
          }
        }
        if (pAR.meetOrSlice === 'slice') {
          scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
          offset = rWidth - pWidth / scaleX;
          if (pAR.alignX === 'Mid') {
            cropX = offset / 2;
          }
          if (pAR.alignX === 'Max') {
            cropX = offset;
          }
          offset = rHeight - pHeight / scaleY;
          if (pAR.alignY === 'Mid') {
            cropY = offset / 2;
          }
          if (pAR.alignY === 'Max') {
            cropY = offset;
          }
          rWidth = pWidth / scaleX;
          rHeight = pHeight / scaleY;
        }
      }
      else {
        scaleX = pWidth / rWidth;
        scaleY = pHeight / rHeight;
      }
      return {
        width: rWidth,
        height: rHeight,
        scaleX: scaleX,
        scaleY: scaleY,
        offsetLeft: offsetLeft,
        offsetTop: offsetTop,
        cropX: cropX,
        cropY: cropY
      };
    }
  });

  /**
   * Default CSS class name for canvas
   * @static
   * @type String
   * @default
   */
  fabric.Image.CSS_CANVAS = 'canvas-img';

  /**
   * Alias for getSrc
   * @static
   */
  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

  /**
   * Creates an instance of fabric.Image from its object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} callback Callback to invoke when an image instance is created
   */
  fabric.Image.fromObject = function(_object, callback) {
    var object = fabric.util.object.clone(_object);
    fabric.util.loadImage(object.src, function(img, isError) {
      if (isError) {
        callback && callback(null, true);
        return;
      }
      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
        object.filters = filters || [];
        fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
          object.resizeFilter = resizeFilters[0];
          fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
            object.clipPath = enlivedProps[0];
            var image = new fabric.Image(img, object);
            callback(image, false);
          });
        });
      });
    }, null, object.crossOrigin);
  };

  /**
   * Creates an instance of fabric.Image from an URL string
   * @static
   * @param {String} url URL to create an image from
   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.
   * @param {Object} [imgOptions] Options object
   */
  fabric.Image.fromURL = function(url, callback, imgOptions) {
    fabric.util.loadImage(url, function(img, isError) {
      callback && callback(new fabric.Image(img, imgOptions), isError);
    }, null, imgOptions && imgOptions.crossOrigin);
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
   * @static
   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
   */
  fabric.Image.ATTRIBUTE_NAMES =
    fabric.SHARED_ATTRIBUTES.concat(
      'x y width height preserveAspectRatio xlink:href crossOrigin image-rendering'.split(' ')
    );

  /**
   * Returns {@link fabric.Image} instance from an SVG element
   * @static
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} callback Callback to execute when fabric.Image object is created
   * @return {fabric.Image} Instance of fabric.Image
   */
  fabric.Image.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : 0);


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * @private
   * @return {Number} angle value
   */
  _getAngleValueForStraighten: function() {
    var angle = this.angle % 360;
    if (angle > 0) {
      return Math.round((angle - 1) / 90) * 90;
    }
    return Math.round(angle / 90) * 90;
  },

  /**
   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  straighten: function() {
    this.rotate(this._getAngleValueForStraighten());
    return this;
  },

  /**
   * Same as {@link fabric.Object.prototype.straighten} but with animation
   * @param {Object} callbacks Object with callback functions
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Object} thisArg
   * @chainable
   */
  fxStraighten: function(callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: this.get('angle'),
      endValue: this._getAngleValueForStraighten(),
      duration: this.FX_DURATION,
      onChange: function(value) {
        _this.rotate(value);
        onChange();
      },
      onComplete: function() {
        _this.setCoords();
        onComplete();
      },
    });

    return this;
  }
});

fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Straightens object, then rerenders canvas
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  straightenObject: function (object) {
    object.straighten();
    this.requestRenderAll();
    return this;
  },

  /**
   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxStraightenObject: function (object) {
    object.fxStraighten({
      onChange: this.requestRenderAllBound
    });
    return this;
  }
});


(function() {

  'use strict';

  /**
   * Tests if webgl supports certain precision
   * @param {WebGL} Canvas WebGL context to test on
   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'
   * @returns {Boolean} Whether the user's browser WebGL supports given precision.
   */
  function testPrecision(gl, precision){
    var fragmentSource = 'precision ' + precision + ' float;\nvoid main(){}';
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    return true;
  }

  /**
   * Indicate whether this filtering backend is supported by the user's browser.
   * @param {Number} tileSize check if the tileSize is supported
   * @returns {Boolean} Whether the user's browser supports WebGL.
   */
  fabric.isWebglSupported = function(tileSize) {
    if (fabric.isLikelyNode) {
      return false;
    }
    tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    var isSupported = false;
    // eslint-disable-next-line
    if (gl) {
      fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      isSupported = fabric.maxTextureSize >= tileSize;
      var precisions = ['highp', 'mediump', 'lowp'];
      for (var i = 0; i < 3; i++){
        if (testPrecision(gl, precisions[i])){
          fabric.webGlPrecision = precisions[i];
          break;
        };
      }
    }
    this.isSupported = isSupported;
    return isSupported;
  };

  fabric.WebglFilterBackend = WebglFilterBackend;

  /**
   * WebGL filter backend.
   */
  function WebglFilterBackend(options) {
    if (options && options.tileSize) {
      this.tileSize = options.tileSize;
    }
    this.setupGLContext(this.tileSize, this.tileSize);
    this.captureGPUInfo();
  };

  WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

    tileSize: 2048,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
     */
    setupGLContext: function(width, height) {
      this.dispose();
      this.createWebGLCanvas(width, height);
      // eslint-disable-next-line
      this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
      this.chooseFastestCopyGLTo2DMethod(width, height);
    },

    /**
     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
     * putImageData is faster than drawImage for that specific operation.
     */
    chooseFastestCopyGLTo2DMethod: function(width, height) {
      var canMeasurePerf = typeof window.performance !== 'undefined', canUseImageData;
      try {
        new ImageData(1, 1);
        canUseImageData = true;
      }
      catch (e) {
        canUseImageData = false;
      }
      // eslint-disable-next-line no-undef
      var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
      // eslint-disable-next-line no-undef
      var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

      if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
        return;
      }

      var targetCanvas = fabric.util.createCanvasElement();
      // eslint-disable-next-line no-undef
      var imageBuffer = new ArrayBuffer(width * height * 4);
      if (fabric.forceGLPutImageData) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
        return;
      }
      var testContext = {
        imageBuffer: imageBuffer,
        destinationWidth: width,
        destinationHeight: height,
        targetCanvas: targetCanvas
      };
      var startTime, drawImageTime, putImageDataTime;
      targetCanvas.width = width;
      targetCanvas.height = height;

      startTime = window.performance.now();
      copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
      drawImageTime = window.performance.now() - startTime;

      startTime = window.performance.now();
      copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
      putImageDataTime = window.performance.now() - startTime;

      if (drawImageTime > putImageDataTime) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
      }
      else {
        this.copyGLTo2D = copyGLTo2DDrawImage;
      }
    },

    /**
     * Create a canvas element and associated WebGL context and attaches them as
     * class properties to the GLFilterBackend class.
     */
    createWebGLCanvas: function(width, height) {
      var canvas = fabric.util.createCanvasElement();
      canvas.width = width;
      canvas.height = height;
      var glOptions = {
            alpha: true,
            premultipliedAlpha: false,
            depth: false,
            stencil: false,
            antialias: false
          },
          gl = canvas.getContext('webgl', glOptions);
      if (!gl) {
        gl = canvas.getContext('experimental-webgl', glOptions);
      }
      if (!gl) {
        return;
      }
      gl.clearColor(0, 0, 0, 0);
      // this canvas can fire webglcontextlost and webglcontextrestored
      this.canvas = canvas;
      this.gl = gl;
    },

    /**
     * Attempts to apply the requested filters to the source provided, drawing the filtered output
     * to the provided target canvas.
     *
     * @param {Array} filters The filters to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
     * @param {Number} width The width of the source input.
     * @param {Number} height The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
     * omitted, caching will be skipped.
     */
    applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
      var gl = this.gl;
      var cachedTexture;
      if (cacheKey) {
        cachedTexture = this.getCachedTexture(cacheKey, source);
      }
      var pipelineState = {
        originalWidth: source.width || source.originalWidth,
        originalHeight: source.height || source.originalHeight,
        sourceWidth: width,
        sourceHeight: height,
        destinationWidth: width,
        destinationHeight: height,
        context: gl,
        sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
        targetTexture: this.createTexture(gl, width, height),
        originalTexture: cachedTexture ||
          this.createTexture(gl, width, height, !cachedTexture && source),
        passes: filters.length,
        webgl: true,
        aPosition: this.aPosition,
        programCache: this.programCache,
        pass: 0,
        filterBackend: this,
        targetCanvas: targetCanvas
      };
      var tempFbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
      filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
      resizeCanvasIfNeeded(pipelineState);
      this.copyGLTo2D(gl, pipelineState);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.deleteTexture(pipelineState.sourceTexture);
      gl.deleteTexture(pipelineState.targetTexture);
      gl.deleteFramebuffer(tempFbo);
      targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
      return pipelineState;
    },

    /**
     * Detach event listeners, remove references, and clean up caches.
     */
    dispose: function() {
      if (this.canvas) {
        this.canvas = null;
        this.gl = null;
      }
      this.clearWebGLCaches();
    },

    /**
     * Wipe out WebGL-related caches.
     */
    clearWebGLCaches: function() {
      this.programCache = {};
      this.textureCache = {};
    },

    /**
     * Create a WebGL texture object.
     *
     * Accepts specific dimensions to initialize the texture to or a source image.
     *
     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
     * @param {Number} width The width to initialize the texture at.
     * @param {Number} height The height to initialize the texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
     * @returns {WebGLTexture}
     */
    createTexture: function(gl, width, height, textureImageSource) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (textureImageSource) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
      }
      else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      return texture;
    },

    /**
     * Can be optionally used to get a texture from the cache array
     *
     * If an existing texture is not found, a new texture is created and cached.
     *
     * @param {String} uniqueId A cache key to use to find an existing texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
     * texture cache entry if one does not already exist.
     */
    getCachedTexture: function(uniqueId, textureImageSource) {
      if (this.textureCache[uniqueId]) {
        return this.textureCache[uniqueId];
      }
      else {
        var texture = this.createTexture(
          this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
        this.textureCache[uniqueId] = texture;
        return texture;
      }
    },

    /**
     * Clear out cached resources related to a source image that has been
     * filtered previously.
     *
     * @param {String} cacheKey The cache key provided when the source image was filtered.
     */
    evictCachesForKey: function(cacheKey) {
      if (this.textureCache[cacheKey]) {
        this.gl.deleteTexture(this.textureCache[cacheKey]);
        delete this.textureCache[cacheKey];
      }
    },

    copyGLTo2D: copyGLTo2DDrawImage,

    /**
     * Attempt to extract GPU information strings from a WebGL context.
     *
     * Useful information when debugging or blacklisting specific GPUs.
     *
     * @returns {Object} A GPU info object with renderer and vendor strings.
     */
    captureGPUInfo: function() {
      if (this.gpuInfo) {
        return this.gpuInfo;
      }
      var gl = this.gl, gpuInfo = { renderer: '', vendor: '' };
      if (!gl) {
        return gpuInfo;
      }
      var ext = gl.getExtension('WEBGL_debug_renderer_info');
      if (ext) {
        var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
        var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
        if (renderer) {
          gpuInfo.renderer = renderer.toLowerCase();
        }
        if (vendor) {
          gpuInfo.vendor = vendor.toLowerCase();
        }
      }
      this.gpuInfo = gpuInfo;
      return gpuInfo;
    },
  };
})();

function resizeCanvasIfNeeded(pipelineState) {
  var targetCanvas = pipelineState.targetCanvas,
      width = targetCanvas.width, height = targetCanvas.height,
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight;

  if (width !== dWidth || height !== dHeight) {
    targetCanvas.width = dWidth;
    targetCanvas.height = dHeight;
  }
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas.
 *
 * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
 * desired output image appearing in the bottom-left corner of the WebGL canvas.
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DDrawImage(gl, pipelineState) {
  var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas,
      ctx = targetCanvas.getContext('2d');
  ctx.translate(0, targetCanvas.height); // move it down again
  ctx.scale(1, -1); // vertical flip
  // where is my image on the big glcanvas?
  var sourceY = glCanvas.height - targetCanvas.height;
  ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
    targetCanvas.width, targetCanvas.height);
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
 * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 * @param {Object} pipelineState The 2D target canvas to copy on to.
 */
function copyGLTo2DPutImageData(gl, pipelineState) {
  var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext('2d'),
      dWidth = pipelineState.destinationWidth,
      dHeight = pipelineState.destinationHeight,
      numBytes = dWidth * dHeight * 4;

  // eslint-disable-next-line no-undef
  var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
  // eslint-disable-next-line no-undef
  var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);

  gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
  var imgData = new ImageData(u8Clamped, dWidth, dHeight);
  ctx.putImageData(imgData, 0, 0);
}


(function() {

  'use strict';

  var noop = function() {};

  fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

  /**
   * Canvas 2D filter backend.
   */
  function Canvas2dFilterBackend() {};

  Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
    evictCachesForKey: noop,
    dispose: noop,
    clearWebGLCaches: noop,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Apply a set of filters against a source image and draw the filtered output
     * to the provided destination canvas.
     *
     * @param {EnhancedFilter} filters The filter to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
     * @param {Number} sourceWidth The width of the source input.
     * @param {Number} sourceHeight The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     */
    applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
      var ctx = targetCanvas.getContext('2d');
      ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
      var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var pipelineState = {
        sourceWidth: sourceWidth,
        sourceHeight: sourceHeight,
        imageData: imageData,
        originalEl: sourceElement,
        originalImageData: originalImageData,
        canvasEl: targetCanvas,
        ctx: ctx,
        filterBackend: this,
      };
      filters.forEach(function(filter) { filter.applyTo(pipelineState); });
      if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
        targetCanvas.width = pipelineState.imageData.width;
        targetCanvas.height = pipelineState.imageData.height;
      }
      ctx.putImageData(pipelineState.imageData, 0, 0);
      return pipelineState;
    },

  };
})();


/**
 * @namespace fabric.Image.filters
 * @memberOf fabric.Image
 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
 */
fabric.Image = fabric.Image || { };
fabric.Image.filters = fabric.Image.filters || { };

/**
 * Root filter class from which all filter classes inherit from
 * @class fabric.Image.filters.BaseFilter
 * @memberOf fabric.Image.filters
 */
fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

  /**
   * Filter type
   * @param {String} type
   * @default
   */
  type: 'BaseFilter',

  /**
   * Array of attributes to send with buffers. do not modify
   * @private
   */

  vertexSource: 'attribute vec2 aPosition;\n' +
    'varying vec2 vTexCoord;\n' +
    'void main() {\n' +
      'vTexCoord = aPosition;\n' +
      'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
    '}',

  fragmentSource: 'precision highp float;\n' +
    'varying vec2 vTexCoord;\n' +
    'uniform sampler2D uTexture;\n' +
    'void main() {\n' +
      'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
    '}',

  /**
   * Constructor
   * @param {Object} [options] Options object
   */
  initialize: function(options) {
    if (options) {
      this.setOptions(options);
    }
  },

  /**
   * Sets filter's properties from options
   * @param {Object} [options] Options object
   */
  setOptions: function(options) {
    for (var prop in options) {
      this[prop] = options[prop];
    }
  },

  /**
   * Compile this filter's shader program.
   *
   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
   * @param {String} fragmentSource fragmentShader source for compilation
   * @param {String} vertexSource vertexShader source for compilation
   */
  createProgram: function(gl, fragmentSource, vertexSource) {
    fragmentSource = fragmentSource || this.fragmentSource;
    vertexSource = vertexSource || this.vertexSource;
    if (fabric.webGlPrecision !== 'highp'){
      fragmentSource = fragmentSource.replace(
        /precision highp float/g,
        'precision ' + fabric.webGlPrecision + ' float'
      );
    }
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Vertex shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(vertexShader)
      );
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Fragment shader compile error for ' + this.type + ': ' +
        gl.getShaderInfoLog(fragmentShader)
      );
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Shader link error for "${this.type}" ' +
        gl.getProgramInfoLog(program)
      );
    }

    var attributeLocations = this.getAttributeLocations(gl, program);
    var uniformLocations = this.getUniformLocations(gl, program) || { };
    uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
    uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
    return {
      program: program,
      attributeLocations: attributeLocations,
      uniformLocations: uniformLocations
    };
  },

  /**
   * Return a map of attribute names to WebGLAttributeLocation objects.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
   * @returns {Object} A map of attribute names to attribute locations.
   */
  getAttributeLocations: function(gl, program) {
    return {
      aPosition: gl.getAttribLocation(program, 'aPosition'),
    };
  },

  /**
   * Return a map of uniform names to WebGLUniformLocation objects.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
   * @returns {Object} A map of uniform names to uniform locations.
   */
  getUniformLocations: function (/* gl, program */) {
    // in case i do not need any special uniform i need to return an empty object
    return { };
  },

  /**
   * Send attribute data from this filter to its shader program on the GPU.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} attributeLocations A map of shader attribute names to their locations.
   */
  sendAttributeData: function(gl, attributeLocations, aPositionData) {
    var attributeLocation = attributeLocations.aPosition;
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(attributeLocation);
    gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
  },

  _setupFrameBuffer: function(options) {
    var gl = options.context, width, height;
    if (options.passes > 1) {
      width = options.destinationWidth;
      height = options.destinationHeight;
      if (options.sourceWidth !== width || options.sourceHeight !== height) {
        gl.deleteTexture(options.targetTexture);
        options.targetTexture = options.filterBackend.createTexture(gl, width, height);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        options.targetTexture, 0);
    }
    else {
      // draw last filter on canvas and not to framebuffer.
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.finish();
    }
  },

  _swapTextures: function(options) {
    options.passes--;
    options.pass++;
    var temp = options.targetTexture;
    options.targetTexture = options.sourceTexture;
    options.sourceTexture = temp;
  },

  /**
   * Generic isNeutral implementation for one parameter based filters.
   * Used only in image applyFilters to discard filters that will not have an effect
   * on the image
   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )
   * @param {Object} options
   **/
  isNeutralState: function(/* options */) {
    var main = this.mainParameter,
        _class = fabric.Image.filters[this.type].prototype;
    if (main) {
      if (Array.isArray(_class[main])) {
        for (var i = _class[main].length; i--;) {
          if (this[main][i] !== _class[main][i]) {
            return false;
          }
        }
        return true;
      }
      else {
        return _class[main] === this[main];
      }
    }
    else {
      return false;
    }
  },

  /**
   * Apply this filter to the input image data provided.
   *
   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyTo: function(options) {
    if (options.webgl) {
      this._setupFrameBuffer(options);
      this.applyToWebGL(options);
      this._swapTextures(options);
    }
    else {
      this.applyTo2d(options);
    }
  },

  /**
   * Retrieves the cached shader.
   * @param {Object} options
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  retrieveShader: function(options) {
    if (!options.programCache.hasOwnProperty(this.type)) {
      options.programCache[this.type] = this.createProgram(options.context);
    }
    return options.programCache[this.type];
  },

  /**
   * Apply this filter using webgl.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.originalTexture The texture of the original input image.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyToWebGL: function(options) {
    var gl = options.context;
    var shader = this.retrieveShader(options);
    if (options.pass === 0 && options.originalTexture) {
      gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
    }
    else {
      gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
    }
    gl.useProgram(shader.program);
    this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);

    gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
    gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

    this.sendUniformData(gl, shader.uniformLocations);
    gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  },

  bindAdditionalTexture: function(gl, texture, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // reset active texture to 0 as usual
    gl.activeTexture(gl.TEXTURE0);
  },

  unbindAdditionalTexture: function(gl, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.activeTexture(gl.TEXTURE0);
  },

  getMainParameter: function() {
    return this[this.mainParameter];
  },

  setMainParameter: function(value) {
    this[this.mainParameter] = value;
  },

  /**
   * Send uniform data from this filter to its shader program on the GPU.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} uniformLocations A map of shader uniform names to their locations.
   */
  sendUniformData: function(/* gl, uniformLocations */) {
    // Intentionally left blank.  Override me in subclasses.
  },

  /**
   * If needed by a 2d filter, this functions can create an helper canvas to be used
   * remember that options.targetCanvas is available for use till end of chain.
   */
  createHelpLayer: function(options) {
    if (!options.helpLayer) {
      var helpLayer = document.createElement('canvas');
      helpLayer.width = options.sourceWidth;
      helpLayer.height = options.sourceHeight;
      options.helpLayer = helpLayer;
    }
  },

  /**
   * Returns object representation of an instance
   * @return {Object} Object representation of an instance
   */
  toObject: function() {
    var object = { type: this.type }, mainP = this.mainParameter;
    if (mainP) {
      object[mainP] = this[mainP];
    }
    return object;
  },

  /**
   * Returns a JSON representation of an instance
   * @return {Object} JSON
   */
  toJSON: function() {
    // delegate, not alias
    return this.toObject();
  }
});

fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
  var filter = new fabric.Image.filters[object.type](object);
  callback && callback(filter);
  return filter;
};


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Matrix filter class
   * @class fabric.Image.filters.ColorMatrix
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
   * @example <caption>Kodachrome filter</caption>
   * var filter = new fabric.Image.filters.ColorMatrix({
   *  matrix: [
       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
       0, 0, 0, 1, 0
      ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'ColorMatrix',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform mat4 uColorMatrix;\n' +
      'uniform vec4 uConstants;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color *= uColorMatrix;\n' +
        'color += uConstants;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Colormatrix for pixels.
     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
     * outside the -1, 1 range.
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Array} matrix array of 20 numbers.
     * @default
     */
    matrix: [
      1, 0, 0, 0, 0,
      0, 1, 0, 0, 0,
      0, 0, 1, 0, 0,
      0, 0, 0, 1, 0
    ],

    mainParameter: 'matrix',

    /**
     * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario
     * to save some calculation
     */
    colorsOnly: true,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.matrix = this.matrix.slice(0);
    },

    /**
     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = data.length,
          m = this.matrix,
          r, g, b, a, i, colorsOnly = this.colorsOnly;

      for (i = 0; i < iLen; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        if (colorsOnly) {
          data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
        }
        else {
          a = data[i + 3];
          data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
          data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
        uConstants: gl.getUniformLocation(program, 'uConstants'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var m = this.matrix,
          matrix = [
            m[0], m[1], m[2], m[3],
            m[5], m[6], m[7], m[8],
            m[10], m[11], m[12], m[13],
            m[15], m[16], m[17], m[18]
          ],
          constants = [m[4], m[9], m[14], m[19]];
      gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
      gl.uniform4fv(uniformLocations.uConstants, constants);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] function to invoke after filter creation
   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
   */
  fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Brightness filter class
   * @class fabric.Image.filters.Brightness
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Brightness({
   *   brightness: 0.05
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Brightness',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBrightness;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += uBrightness;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Brightness value, from -1 to 1.
     * translated to -255 to 255 for 2d
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Number} brightness
     * @default
     */
    brightness: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'brightness',

    /**
    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
    *
    * @param {Object} options
    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
    */
    applyTo2d: function(options) {
      if (this.brightness === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          brightness = Math.round(this.brightness * 255);
      for (i = 0; i < len; i += 4) {
        data[i] = data[i] + brightness;
        data[i + 1] = data[i + 1] + brightness;
        data[i + 2] = data[i + 2] + brightness;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBrightness: gl.getUniformLocation(program, 'uBrightness'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBrightness, this.brightness);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
   */
  fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
   * @class fabric.Image.filters.Convolute
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example <caption>Sharpen filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 0, -1,  0,
   *            -1,  5, -1,
   *             0, -1,  0 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Blur filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter with opaqueness</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   opaque: true,
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Convolute',

    /*
     * Opaque value (true/false)
     */
    opaque: false,

    /*
     * matrix for the filter, max 9x9
     */
    matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: {
      Convolute_3_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_3_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_5_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_5_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_7_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_7_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_9_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_9_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
    },

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Convolute.prototype
     * @param {Object} [options] Options object
     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
     * @param {Array} [options.matrix] Filter matrix
     */


    /**
    * Retrieves the cached shader.
    * @param {Object} options
    * @param {WebGLRenderingContext} options.context The GL context used for rendering.
    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
    */
    retrieveShader: function(options) {
      var size = Math.sqrt(this.matrix.length);
      var cacheKey = this.type + '_' + size + '_' + (this.opaque ? 1 : 0);
      var shaderSource = this.fragmentSource[cacheKey];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          weights = this.matrix,
          side = Math.round(Math.sqrt(weights.length)),
          halfSide = Math.floor(side / 2),
          sw = imageData.width,
          sh = imageData.height,
          output = options.ctx.createImageData(sw, sh),
          dst = output.data,
          // go through the destination image pixels
          alphaFac = this.opaque ? 1 : 0,
          r, g, b, a, dstOff,
          scx, scy, srcOff, wt,
          x, y, cx, cy;

      for (y = 0; y < sh; y++) {
        for (x = 0; x < sw; x++) {
          dstOff = (y * sw + x) * 4;
          // calculate the weighed sum of the source image pixels that
          // fall under the convolution matrix
          r = 0; g = 0; b = 0; a = 0;

          for (cy = 0; cy < side; cy++) {
            for (cx = 0; cx < side; cx++) {
              scy = y + cy - halfSide;
              scx = x + cx - halfSide;

              // eslint-disable-next-line max-depth
              if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {
                continue;
              }

              srcOff = (scy * sw + scx) * 4;
              wt = weights[cy * side + cx];

              r += data[srcOff] * wt;
              g += data[srcOff + 1] * wt;
              b += data[srcOff + 2] * wt;
              // eslint-disable-next-line max-depth
              if (!alphaFac) {
                a += data[srcOff + 3] * wt;
              }
            }
          }
          dst[dstOff] = r;
          dst[dstOff + 1] = g;
          dst[dstOff + 2] = b;
          if (!alphaFac) {
            dst[dstOff + 3] = a;
          }
          else {
            dst[dstOff + 3] = data[dstOff + 3];
          }
        }
      }
      options.imageData = output;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMatrix: gl.getUniformLocation(program, 'uMatrix'),
        uOpaque: gl.getUniformLocation(program, 'uOpaque'),
        uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
        uSize: gl.getUniformLocation(program, 'uSize'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        opaque: this.opaque,
        matrix: this.matrix
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
   */
  fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Grayscale image filter class
   * @class fabric.Image.filters.Grayscale
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Grayscale();
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Grayscale',

    fragmentSource: {
      average: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float average = (color.r + color.b + color.g) / 3.0;\n' +
          'gl_FragColor = vec4(average, average, average, color.a);\n' +
        '}',
      lightness: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
      luminosity: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
    },


    /**
     * Grayscale mode, between 'average', 'lightness', 'luminosity'
     * @param {String} type
     * @default
     */
    mode: 'average',

    mainParameter: 'mode',

    /**
     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length, value,
          mode = this.mode;
      for (i = 0; i < len; i += 4) {
        if (mode === 'average') {
          value = (data[i] + data[i + 1] + data[i + 2]) / 3;
        }
        else if (mode === 'lightness') {
          value = (Math.min(data[i], data[i + 1], data[i + 2]) +
            Math.max(data[i], data[i + 1], data[i + 2])) / 2;
        }
        else if (mode === 'luminosity') {
          value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
        }
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var shaderSource = this.fragmentSource[this.mode];
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMode: gl.getUniformLocation(program, 'uMode'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      // default average mode.
      var mode = 1;
      gl.uniform1i(uniformLocations.uMode, mode);
    },

    /**
     * Grayscale filter isNeutralState implementation
     * The filter is never neutral
     * on the image
     **/
    isNeutralState: function() {
      return false;
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
   */
  fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Invert filter class
   * @class fabric.Image.filters.Invert
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Invert();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Invert',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform int uInvert;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'if (uInvert == 1) {\n' +
          'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
        '} else {\n' +
          'gl_FragColor = color;\n' +
        '}\n' +
      '}',

    /**
     * Filter invert. if false, does nothing
     * @param {Boolean} invert
     * @default
     */
    invert: true,

    mainParameter: 'invert',

    /**
     * Apply the Invert operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length;
      for (i = 0; i < len; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
      }
    },

    /**
     * Invert filter isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function() {
      return !this.invert;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uInvert: gl.getUniformLocation(program, 'uInvert'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1i(uniformLocations.uInvert, this.invert);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
   */
  fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Noise filter class
   * @class fabric.Image.filters.Noise
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Noise({
   *   noise: 700
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Noise',

    /**
     * Fragment source for the noise program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uStepH;\n' +
      'uniform float uNoise;\n' +
      'uniform float uSeed;\n' +
      'varying vec2 vTexCoord;\n' +
      'float rand(vec2 co, float seed, float vScale) {\n' +
        'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'noise',

    /**
     * Noise value, from
     * @param {Number} noise
     * @default
     */
    noise: 0,

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.noise === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          noise = this.noise, rand;

      for (i = 0, len = data.length; i < len; i += 4) {

        rand = (0.5 - Math.random()) * noise;

        data[i] += rand;
        data[i + 1] += rand;
        data[i + 2] += rand;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uNoise: gl.getUniformLocation(program, 'uNoise'),
        uSeed: gl.getUniformLocation(program, 'uSeed'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
      gl.uniform1f(uniformLocations.uSeed, Math.random());
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        noise: this.noise
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
   */
  fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Pixelate filter class
   * @class fabric.Image.filters.Pixelate
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Pixelate({
   *   blocksize: 8
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Pixelate',

    blocksize: 4,

    mainParameter: 'blocksize',

    /**
     * Fragment source for the Pixelate program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBlocksize;\n' +
      'uniform float uStepW;\n' +
      'uniform float uStepH;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'float blockW = uBlocksize * uStepW;\n' +
        'float blockH = uBlocksize * uStepW;\n' +
        'int posX = int(vTexCoord.x / blockW);\n' +
        'int posY = int(vTexCoord.y / blockH);\n' +
        'float fposX = float(posX);\n' +
        'float fposY = float(posY);\n' +
        'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
        'vec4 color = texture2D(uTexture, squareCoords);\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = imageData.height,
          jLen = imageData.width,
          index, i, j, r, g, b, a,
          _i, _j, _iLen, _jLen;

      for (i = 0; i < iLen; i += this.blocksize) {
        for (j = 0; j < jLen; j += this.blocksize) {

          index = (i * 4) * jLen + (j * 4);

          r = data[index];
          g = data[index + 1];
          b = data[index + 2];
          a = data[index + 3];

          _iLen = Math.min(i + this.blocksize, iLen);
          _jLen = Math.min(j + this.blocksize, jLen);
          for (_i = i; _i < _iLen; _i++) {
            for (_j = j; _j < _jLen; _j++) {
              index = (_i * 4) * jLen + (_j * 4);
              data[index] = r;
              data[index + 1] = g;
              data[index + 2] = b;
              data[index + 3] = a;
            }
          }
        }
      }
    },

    /**
     * Indicate when the filter is not gonna apply changes to the image
     **/
    isNeutralState: function() {
      return this.blocksize === 1;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
        uStepW: gl.getUniformLocation(program, 'uStepW'),
        uStepH: gl.getUniformLocation(program, 'uStepH'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
   */
  fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Remove white filter class
   * @class fabric.Image.filters.RemoveColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.RemoveColor({
   *   threshold: 0.2,
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'RemoveColor',

    /**
     * Color to remove, in any format understood by fabric.Color.
     * @param {String} type
     * @default
     */
    color: '#FFFFFF',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec4 uLow;\n' +
      'uniform vec4 uHigh;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
        'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
          'gl_FragColor.a = 0.0;\n' +
        '}\n' +
      '}',

    /**
     * distance to actual color, as value up or down from each r,g,b
     * between 0 and 1
     **/
    distance: 0.02,

    /**
     * For color to remove inside distance, use alpha channel for a smoother deletion
     * NOT IMPLEMENTED YET
     **/
    useAlpha: false,

    /**
     * Constructor
     * @memberOf fabric.Image.filters.RemoveWhite.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.color=#RRGGBB] Threshold value
     * @param {Number} [options.distance=10] Distance value
     */

    /**
     * Applies filter to canvas element
     * @param {Object} canvasEl Canvas element to apply filter to
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          distance = this.distance * 255,
          r, g, b,
          source = new fabric.Color(this.color).getSource(),
          lowC = [
            source[0] - distance,
            source[1] - distance,
            source[2] - distance,
          ],
          highC = [
            source[0] + distance,
            source[1] + distance,
            source[2] + distance,
          ];


      for (i = 0; i < data.length; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        if (r > lowC[0] &&
            g > lowC[1] &&
            b > lowC[2] &&
            r < highC[0] &&
            g < highC[1] &&
            b < highC[2]) {
          data[i + 3] = 0;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uLow: gl.getUniformLocation(program, 'uLow'),
        uHigh: gl.getUniformLocation(program, 'uHigh'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource(),
          distance = parseFloat(this.distance),
          lowC = [
            0 + source[0] / 255 - distance,
            0 + source[1] / 255 - distance,
            0 + source[2] / 255 - distance,
            1
          ],
          highC = [
            source[0] / 255 + distance,
            source[1] / 255 + distance,
            source[2] / 255 + distance,
            1
          ];
      gl.uniform4fv(uniformLocations.uLow, lowC);
      gl.uniform4fv(uniformLocations.uHigh, highC);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        color: this.color,
        distance: this.distance
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
   */
  fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  var matrices = {
    Brownie: [
      0.59970,0.34553,-0.27082,0,0.186,
      -0.03770,0.86095,0.15059,0,-0.1449,
      0.24113,-0.07441,0.44972,0,-0.02965,
      0,0,0,1,0
    ],
    Vintage: [
      0.62793,0.32021,-0.03965,0,0.03784,
      0.02578,0.64411,0.03259,0,0.02926,
      0.04660,-0.08512,0.52416,0,0.02023,
      0,0,0,1,0
    ],
    Kodachrome: [
      1.12855,-0.39673,-0.03992,0,0.24991,
      -0.16404,1.08352,-0.05498,0,0.09698,
      -0.16786,-0.56034,1.60148,0,0.13972,
      0,0,0,1,0
    ],
    Technicolor: [
      1.91252,-0.85453,-0.09155,0,0.04624,
      -0.30878,1.76589,-0.10601,0,-0.27589,
      -0.23110,-0.75018,1.84759,0,0.12137,
      0,0,0,1,0
    ],
    Polaroid: [
      1.438,-0.062,-0.062,0,0,
      -0.122,1.378,-0.122,0,0,
      -0.016,-0.016,1.483,0,0,
      0,0,0,1,0
    ],
    Sepia: [
      0.393, 0.769, 0.189, 0, 0,
      0.349, 0.686, 0.168, 0, 0,
      0.272, 0.534, 0.131, 0, 0,
      0, 0, 0, 1, 0
    ],
    BlackWhite: [
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      0, 0, 0, 1, 0,
    ]
  };

  for (var key in matrices) {
    filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: key,

      /**
       * Colormatrix for the effect
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: matrices[key],

      /**
       * Lock the matrix export for this kind of static, parameter less filters.
       */
      mainParameter: false,
      /**
       * Lock the colormatrix on the color part, skipping alpha
       */
      colorsOnly: true,

    });
    fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
  }
})( true ? exports : 0);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Blend filter class
   * @class fabric.Image.filter.BlendColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
    type: 'BlendColor',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    color: '#F95C63',

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend color operation.
     **/
    alpha: 1,

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'gl_FragColor.rgb *= uColor.rgb;\n',
      screen: 'gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n',
      add: 'gl_FragColor.rgb += uColor.rgb;\n',
      diff: 'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n',
      subtract: 'gl_FragColor.rgb -= uColor.rgb;\n',
      lighten: 'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n',
      darken: 'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n',
      exclusion: 'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n',
      overlay: 'if (uColor.r < 0.5) {\n' +
          'gl_FragColor.r *= 2.0 * uColor.r;\n' +
        '} else {\n' +
          'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
        '}\n' +
        'if (uColor.g < 0.5) {\n' +
          'gl_FragColor.g *= 2.0 * uColor.g;\n' +
        '} else {\n' +
          'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
        '}\n' +
        'if (uColor.b < 0.5) {\n' +
          'gl_FragColor.b *= 2.0 * uColor.b;\n' +
        '} else {\n' +
          'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
        '}\n',
      tint: 'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
        'gl_FragColor.rgb += uColor.rgb;\n',
    },

    /**
     * build the fragment source for the filters, joining the common part with
     * the specific one.
     * @param {String} mode the mode of the filter, a key of this.fragmentSource
     * @return {String} the source to be compiled
     * @private
     */
    buildSource: function(mode) {
      return 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor = color;\n' +
          'if (color.a > 0.0) {\n' +
            this.fragmentSource[mode] +
          '}\n' +
        '}';
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode, shaderSource;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        shaderSource = this.buildSource(this.mode);
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, iLen = data.length,
          tr, tg, tb,
          r, g, b,
          source, alpha1 = 1 - this.alpha;

      source = new fabric.Color(this.color).getSource();
      tr = source[0] * this.alpha;
      tg = source[1] * this.alpha;
      tb = source[2] * this.alpha;

      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            break;
          case 'screen':
            data[i] = 255 - (255 - r) * (255 - tr) / 255;
            data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
            data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
            break;
          case 'add':
            data[i] = r + tr;
            data[i + 1] = g + tg;
            data[i + 2] = b + tb;
            break;
          case 'diff':
          case 'difference':
            data[i] = Math.abs(r - tr);
            data[i + 1] = Math.abs(g - tg);
            data[i + 2] = Math.abs(b - tb);
            break;
          case 'subtract':
            data[i] = r - tr;
            data[i + 1] = g - tg;
            data[i + 2] = b - tb;
            break;
          case 'darken':
            data[i] = Math.min(r, tr);
            data[i + 1] = Math.min(g, tg);
            data[i + 2] = Math.min(b, tb);
            break;
          case 'lighten':
            data[i] = Math.max(r, tr);
            data[i + 1] = Math.max(g, tg);
            data[i + 2] = Math.max(b, tb);
            break;
          case 'overlay':
            data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
            data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
            data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
            break;
          case 'exclusion':
            data[i] = tr + r - ((2 * tr * r) / 255);
            data[i + 1] = tg + g - ((2 * tg * g) / 255);
            data[i + 2] = tb + b - ((2 * tb * b) / 255);
            break;
          case 'tint':
            data[i] = tr + r * alpha1;
            data[i + 1] = tg + g * alpha1;
            data[i + 2] = tb + b * alpha1;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColor: gl.getUniformLocation(program, 'uColor'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource();
      source[0] = this.alpha * source[0] / 255;
      source[1] = this.alpha * source[1] / 255;
      source[2] = this.alpha * source[2] / 255;
      source[3] = this.alpha;
      gl.uniform4fv(uniformLocations.uColor, source);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        color: this.color,
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
   */
  fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Image Blend filter class
   * @class fabric.Image.filter.BlendImage
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
    type: 'BlendImage',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    image: null,

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend image operation.
     * not implemented.
     **/
    alpha: 1,

    vertexSource: 'attribute vec2 aPosition;\n' +
      'varying vec2 vTexCoord;\n' +
      'varying vec2 vTexCoord2;\n' +
      'uniform mat3 uTransformMatrix;\n' +
      'void main() {\n' +
        'vTexCoord = aPosition;\n' +
        'vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.rgba *= color2.rgba;\n' +
          'gl_FragColor = color;\n' +
        '}',
      mask: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.a = color2.a;\n' +
          'gl_FragColor = color;\n' +
        '}',
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      var shaderSource = this.fragmentSource[this.mode];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    applyToWebGL: function(options) {
      // load texture to blend.
      var gl = options.context,
          texture = this.createTexture(options.filterBackend, this.image);
      this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
      this.callSuper('applyToWebGL', options);
      this.unbindAdditionalTexture(gl, gl.TEXTURE1);
    },

    createTexture: function(backend, image) {
      return backend.getCachedTexture(image.cacheKey, image._element);
    },

    /**
     * Calculate a transformMatrix to adapt the image to blend over
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    calculateMatrix: function() {
      var image = this.image,
          width = image._element.width,
          height = image._element.height;
      return [
        1 / image.scaleX, 0, 0,
        0, 1 / image.scaleY, 0,
        -image.left / width, -image.top / height, 1
      ];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          resources = options.filterBackend.resources,
          data = imageData.data, iLen = data.length,
          width = imageData.width,
          height = imageData.height,
          tr, tg, tb, ta,
          r, g, b, a,
          canvas1, context, image = this.image, blendData;

      if (!resources.blendImage) {
        resources.blendImage = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blendImage;
      context = canvas1.getContext('2d');
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas1.width = width;
        canvas1.height = height;
      }
      else {
        context.clearRect(0, 0, width, height);
      }
      context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
      context.drawImage(image._element, 0, 0, width, height);
      blendData = context.getImageData(0, 0, width, height).data;
      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];

        tr = blendData[i];
        tg = blendData[i + 1];
        tb = blendData[i + 2];
        ta = blendData[i + 3];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            data[i + 3] = a * ta / 255;
            break;
          case 'mask':
            data[i + 3] = ta;
            break;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
        uImage: gl.getUniformLocation(program, 'uImage'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var matrix = this.calculateMatrix();
      gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
      gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        image: this.image && this.image.toObject(),
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} callback to be invoked after filter creation
   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
   */
  fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
    fabric.Image.fromObject(object.image, function(image) {
      var options = fabric.util.object.clone(object);
      options.image = image;
      callback(new fabric.Image.filters.BlendImage(options));
    });
  };

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
      sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
      ceil = Math.ceil,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Resize image filter class
   * @class fabric.Image.filters.Resize
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Resize();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Resize',

    /**
     * Resize type
     * for webgl resizeType is just lanczos, for canvas2d can be:
     * bilinear, hermite, sliceHack, lanczos.
     * @param {String} resizeType
     * @default
     */
    resizeType: 'hermite',

    /**
     * Scale factor for resizing, x axis
     * @param {Number} scaleX
     * @default
     */
    scaleX: 1,

    /**
     * Scale factor for resizing, y axis
     * @param {Number} scaleY
     * @default
     */
    scaleY: 1,

    /**
     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos
     * @param {Number} lanczosLobes
     * @default
     */
    lanczosLobes: 3,


    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uDelta: gl.getUniformLocation(program, 'uDelta'),
        uTaps: gl.getUniformLocation(program, 'uTaps'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
      gl.uniform1fv(uniformLocations.uTaps, this.taps);
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var filterWindow = this.getFilterWindow(), cacheKey = this.type + '_' + filterWindow;
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        var fragmentShader = this.generateShader(filterWindow);
        options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
      }
      return options.programCache[cacheKey];
    },

    getFilterWindow: function() {
      var scale = this.tempScale;
      return Math.ceil(this.lanczosLobes / scale);
    },

    getTaps: function() {
      var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale,
          filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
      for (var i = 1; i <= filterWindow; i++) {
        taps[i - 1] = lobeFunction(i * scale);
      }
      return taps;
    },

    /**
     * Generate vertex and shader sources from the necessary steps numbers
     * @param {Number} filterWindow
     */
    generateShader: function(filterWindow) {
      var offsets = new Array(filterWindow),
          fragmentShader = this.fragmentSourceTOP, filterWindow;

      for (var i = 1; i <= filterWindow; i++) {
        offsets[i - 1] = i + '.0 * uDelta';
      }

      fragmentShader += 'uniform float uTaps[' + filterWindow + '];\n';
      fragmentShader += 'void main() {\n';
      fragmentShader += '  vec4 color = texture2D(uTexture, vTexCoord);\n';
      fragmentShader += '  float sum = 1.0;\n';

      offsets.forEach(function(offset, i) {
        fragmentShader += '  color += texture2D(uTexture, vTexCoord + ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  color += texture2D(uTexture, vTexCoord - ' + offset + ') * uTaps[' + i + '];\n';
        fragmentShader += '  sum += 2.0 * uTaps[' + i + '];\n';
      });
      fragmentShader += '  gl_FragColor = color / sum;\n';
      fragmentShader += '}';
      return fragmentShader;
    },

    fragmentSourceTOP: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n',

    /**
     * Apply the resize filter to the image
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      if (options.webgl) {
        options.passes++;
        this.width = options.sourceWidth;
        this.horizontal = true;
        this.dW = Math.round(this.width * this.scaleX);
        this.dH = options.sourceHeight;
        this.tempScale = this.dW / this.width;
        this.taps = this.getTaps();
        options.destinationWidth = this.dW;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceWidth = options.destinationWidth;

        this.height = options.sourceHeight;
        this.horizontal = false;
        this.dH = Math.round(this.height * this.scaleY);
        this.tempScale = this.dH / this.height;
        this.taps = this.getTaps();
        options.destinationHeight = this.dH;
        this._setupFrameBuffer(options);
        this.applyToWebGL(options);
        this._swapTextures(options);
        options.sourceHeight = options.destinationHeight;
      }
      else {
        this.applyTo2d(options);
      }
    },

    isNeutralState: function() {
      return this.scaleX === 1 && this.scaleY === 1;
    },

    lanczosCreate: function(lobes) {
      return function(x) {
        if (x >= lobes || x <= -lobes) {
          return 0.0;
        }
        if (x < 1.19209290E-07 && x > -1.19209290E-07) {
          return 1.0;
        }
        x *= Math.PI;
        var xx = x / lobes;
        return (sin(x) / x) * sin(xx) / xx;
      };
    },

    /**
     * Applies filter to canvas element
     * @memberOf fabric.Image.filters.Resize.prototype
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} scaleX
     * @param {Number} scaleY
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          scaleX = this.scaleX,
          scaleY = this.scaleY;

      this.rcpScaleX = 1 / scaleX;
      this.rcpScaleY = 1 / scaleY;

      var oW = imageData.width, oH = imageData.height,
          dW = round(oW * scaleX), dH = round(oH * scaleY),
          newData;

      if (this.resizeType === 'sliceHack') {
        newData = this.sliceByTwo(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'hermite') {
        newData = this.hermiteFastResize(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'bilinear') {
        newData = this.bilinearFiltering(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'lanczos') {
        newData = this.lanczosResize(options, oW, oH, dW, dH);
      }
      options.imageData = newData;
    },

    /**
     * Filter sliceByTwo
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    sliceByTwo: function(options, oW, oH, dW, dH) {
      var imageData = options.imageData,
          mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
          stepH = oH * mult, resources = fabric.filterBackend.resources,
          tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
      if (!resources.sliceByTwo) {
        resources.sliceByTwo = document.createElement('canvas');
      }
      tmpCanvas = resources.sliceByTwo;
      if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
        tmpCanvas.width = oW * 1.5;
        tmpCanvas.height = oH;
      }
      ctx = tmpCanvas.getContext('2d');
      ctx.clearRect(0, 0, oW * 1.5, oH);
      ctx.putImageData(imageData, 0, 0);

      dW = floor(dW);
      dH = floor(dH);

      while (!doneW || !doneH) {
        oW = stepW;
        oH = stepH;
        if (dW < floor(stepW * mult)) {
          stepW = floor(stepW * mult);
        }
        else {
          stepW = dW;
          doneW = true;
        }
        if (dH < floor(stepH * mult)) {
          stepH = floor(stepH * mult);
        }
        else {
          stepH = dH;
          doneH = true;
        }
        ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
        sX = dX;
        sY = dY;
        dY += stepH;
      }
      return ctx.getImageData(sX, sY, dW, dH);
    },

    /**
     * Filter lanczosResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    lanczosResize: function(options, oW, oH, dW, dH) {

      function process(u) {
        var v, i, weight, idx, a, red, green,
            blue, alpha, fX, fY;
        center.x = (u + 0.5) * ratioX;
        icenter.x = floor(center.x);
        for (v = 0; v < dH; v++) {
          center.y = (v + 0.5) * ratioY;
          icenter.y = floor(center.y);
          a = 0; red = 0; green = 0; blue = 0; alpha = 0;
          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
            if (i < 0 || i >= oW) {
              continue;
            }
            fX = floor(1000 * abs(i - center.x));
            if (!cacheLanc[fX]) {
              cacheLanc[fX] = { };
            }
            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
              if (j < 0 || j >= oH) {
                continue;
              }
              fY = floor(1000 * abs(j - center.y));
              if (!cacheLanc[fX][fY]) {
                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
              }
              weight = cacheLanc[fX][fY];
              if (weight > 0) {
                idx = (j * oW + i) * 4;
                a += weight;
                red += weight * srcData[idx];
                green += weight * srcData[idx + 1];
                blue += weight * srcData[idx + 2];
                alpha += weight * srcData[idx + 3];
              }
            }
          }
          idx = (v * dW + u) * 4;
          destData[idx] = red / a;
          destData[idx + 1] = green / a;
          destData[idx + 2] = blue / a;
          destData[idx + 3] = alpha / a;
        }

        if (++u < dW) {
          return process(u);
        }
        else {
          return destImg;
        }
      }

      var srcData = options.imageData.data,
          destImg = options.ctx.createImageData(dW, dH),
          destData = destImg.data,
          lanczos = this.lanczosCreate(this.lanczosLobes),
          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
          range2X = ceil(ratioX * this.lanczosLobes / 2),
          range2Y = ceil(ratioY * this.lanczosLobes / 2),
          cacheLanc = { }, center = { }, icenter = { };

      return process(0);
    },

    /**
     * bilinearFiltering
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    bilinearFiltering: function(options, oW, oH, dW, dH) {
      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
          color, offset = 0, origPix, ratioX = this.rcpScaleX,
          ratioY = this.rcpScaleY,
          w4 = 4 * (oW - 1), img = options.imageData,
          pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
          destPixels = destImage.data;
      for (i = 0; i < dH; i++) {
        for (j = 0; j < dW; j++) {
          x = floor(ratioX * j);
          y = floor(ratioY * i);
          xDiff = ratioX * j - x;
          yDiff = ratioY * i - y;
          origPix = 4 * (y * oW + x);

          for (chnl = 0; chnl < 4; chnl++) {
            a = pixels[origPix + chnl];
            b = pixels[origPix + 4 + chnl];
            c = pixels[origPix + w4 + chnl];
            d = pixels[origPix + w4 + 4 + chnl];
            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
            destPixels[offset++] = color;
          }
        }
      }
      return destImage;
    },

    /**
     * hermiteFastResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    hermiteFastResize: function(options, oW, oH, dW, dH) {
      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
          ratioWHalf = ceil(ratioW / 2),
          ratioHHalf = ceil(ratioH / 2),
          img = options.imageData, data = img.data,
          img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
      for (var j = 0; j < dH; j++) {
        for (var i = 0; i < dW; i++) {
          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                  w = sqrt(w0 + dx * dx);
              /* eslint-disable max-depth */
              if (w > 1 && w < -1) {
                continue;
              }
              //hermite filter
              weight = 2 * w * w * w - 3 * w * w + 1;
              if (weight > 0) {
                dx = 4 * (xx + yy * oW);
                //alpha
                gxA += weight * data[dx + 3];
                weightsAlpha += weight;
                //colors
                if (data[dx + 3] < 255) {
                  weight = weight * data[dx + 3] / 250;
                }
                gxR += weight * data[dx];
                gxG += weight * data[dx + 1];
                gxB += weight * data[dx + 2];
                weights += weight;
              }
              /* eslint-enable max-depth */
            }
          }
          data2[x2] = gxR / weights;
          data2[x2 + 1] = gxG / weights;
          data2[x2 + 2] = gxB / weights;
          data2[x2 + 3] = gxA / weightsAlpha;
        }
      }
      return img2;
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        resizeType: this.resizeType,
        lanczosLobes: this.lanczosLobes
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
   */
  fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Contrast filter class
   * @class fabric.Image.filters.Contrast
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Contrast({
   *   contrast: 0.25
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Contrast',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uContrast;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
        'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * contrast value, range from -1 to 1.
     * @param {Number} contrast
     * @default 0
     */
    contrast: 0,

    mainParameter: 'contrast',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Contrast.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
     */

    /**
      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8Array to be filtered.
      */
    applyTo2d: function(options) {
      if (this.contrast === 0) {
        return;
      }
      var imageData = options.imageData, i, len,
          data = imageData.data, len = data.length,
          contrast = Math.floor(this.contrast * 255),
          contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

      for (i = 0; i < len; i += 4) {
        data[i] = contrastF * (data[i] - 128) + 128;
        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uContrast: gl.getUniformLocation(program, 'uContrast'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uContrast, this.contrast);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
   */
  fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Saturate filter class
   * @class fabric.Image.filters.Saturation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Saturation({
   *   saturation: 100
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Saturation',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uSaturation;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float rgMax = max(color.r, color.g);\n' +
        'float rgbMax = max(rgMax, color.b);\n' +
        'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
        'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
        'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
        'gl_FragColor = color;\n' +
      '}',

    saturation: 0,

    mainParameter: 'saturation',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Saturate.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
     */

    /**
     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.saturation === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, len = data.length,
          adjust = -this.saturation, i, max;

      for (i = 0; i < len; i += 4) {
        max = Math.max(data[i], data[i + 1], data[i + 2]);
        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uSaturation: gl.getUniformLocation(program, 'uSaturation'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
   */
  fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Blur filter class
   * @class fabric.Image.filters.Blur
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Blur({
   *   blur: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

    type: 'Blur',

    /*
'gl_FragColor = vec4(0.0);',
'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
*/

    /* eslint-disable max-len */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n' +
      'const float nSamples = 15.0;\n' +
      'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
      'float random(vec3 scale) {\n' +
        /* use the fragment position for a different seed per-pixel */
        'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = vec4(0.0);\n' +
        'float total = 0.0;\n' +
        'float offset = random(v3offset);\n' +
        'for (float t = -nSamples; t <= nSamples; t++) {\n' +
          'float percent = (t + offset - 0.5) / nSamples;\n' +
          'float weight = 1.0 - abs(percent);\n' +
          'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
          'total += weight;\n' +
        '}\n' +
        'gl_FragColor = color / total;\n' +
      '}',
    /* eslint-enable max-len */

    /**
     * blur value, in percentage of image dimensions.
     * specific to keep the image blur constant at different resolutions
     * range between 0 and 1.
     */
    blur: 0,

    mainParameter: 'blur',

    applyTo: function(options) {
      if (options.webgl) {
        // this aspectRatio is used to give the same blur to vertical and horizontal
        this.aspectRatio = options.sourceWidth / options.sourceHeight;
        options.passes++;
        this._setupFrameBuffer(options);
        this.horizontal = true;
        this.applyToWebGL(options);
        this._swapTextures(options);
        this._setupFrameBuffer(options);
        this.horizontal = false;
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else {
        this.applyTo2d(options);
      }
    },

    applyTo2d: function(options) {
      // paint canvasEl with current image data.
      //options.ctx.putImageData(options.imageData, 0, 0);
      options.imageData = this.simpleBlur(options);
    },

    simpleBlur: function(options) {
      var resources = options.filterBackend.resources, canvas1, canvas2,
          width = options.imageData.width,
          height = options.imageData.height;

      if (!resources.blurLayer1) {
        resources.blurLayer1 = fabric.util.createCanvasElement();
        resources.blurLayer2 = fabric.util.createCanvasElement();
      }
      canvas1 = resources.blurLayer1;
      canvas2 = resources.blurLayer2;
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas2.width = canvas1.width = width;
        canvas2.height = canvas1.height = height;
      }
      var ctx1 = canvas1.getContext('2d'),
          ctx2 = canvas2.getContext('2d'),
          nSamples = 15,
          random, percent, j, i,
          blur = this.blur * 0.06 * 0.5;

      // load first canvas
      ctx1.putImageData(options.imageData, 0, 0);
      ctx2.clearRect(0, 0, width, height);

      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * width + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, j, random);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * height + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, random, j);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      options.ctx.drawImage(canvas1, 0, 0);
      var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
      ctx1.globalAlpha = 1;
      ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
      return newImageData;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        delta: gl.getUniformLocation(program, 'uDelta'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var delta = this.chooseRightDelta();
      gl.uniform2fv(uniformLocations.delta, delta);
    },

    /**
     * choose right value of image percentage to blur with
     * @returns {Array} a numeric array with delta values
     */
    chooseRightDelta: function() {
      var blurScale = 1, delta = [0, 0], blur;
      if (this.horizontal) {
        if (this.aspectRatio > 1) {
          // image is wide, i want to shrink radius horizontal
          blurScale = 1 / this.aspectRatio;
        }
      }
      else {
        if (this.aspectRatio < 1) {
          // image is tall, i want to shrink radius vertical
          blurScale = this.aspectRatio;
        }
      }
      blur = blurScale * this.blur * 0.12;
      if (this.horizontal) {
        delta[0] = blur;
      }
      else {
        delta[1] = blur;
      }
      return delta;
    },
  });

  /**
   * Deserialize a JSON definition of a BlurFilter into a concrete instance.
   */
  filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Gamma filter class
   * @class fabric.Image.filters.Gamma
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Gamma({
   *   gamma: [1, 0.5, 2.1]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Gamma',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec3 uGamma;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'vec3 correction = (1.0 / uGamma);\n' +
        'color.r = pow(color.r, correction.r);\n' +
        'color.g = pow(color.g, correction.g);\n' +
        'color.b = pow(color.b, correction.b);\n' +
        'gl_FragColor = color;\n' +
        'gl_FragColor.rgb *= color.a;\n' +
      '}',

    /**
     * Gamma array value, from 0.01 to 2.2.
     * @param {Array} gamma
     * @default
     */
    gamma: [1, 1, 1],

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'gamma',

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.gamma = [1, 1, 1];
      filters.BaseFilter.prototype.initialize.call(this, options);
    },

    /**
     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData, data = imageData.data,
          gamma = this.gamma, len = data.length,
          rInv = 1 / gamma[0], gInv = 1 / gamma[1],
          bInv = 1 / gamma[2], i;

      if (!this.rVals) {
        // eslint-disable-next-line
        this.rVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.gVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.bVals = new Uint8Array(256);
      }

      // This is an optimization - pre-compute a look-up table for each color channel
      // instead of performing these pow calls for each pixel in the image.
      for (i = 0, len = 256; i < len; i++) {
        this.rVals[i] = Math.pow(i / 255, rInv) * 255;
        this.gVals[i] = Math.pow(i / 255, gInv) * 255;
        this.bVals[i] = Math.pow(i / 255, bInv) * 255;
      }
      for (i = 0, len = data.length; i < len; i += 4) {
        data[i] = this.rVals[data[i]];
        data[i + 1] = this.gVals[data[i + 1]];
        data[i + 2] = this.bVals[data[i + 2]];
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uGamma: gl.getUniformLocation(program, 'uGamma'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform3fv(uniformLocations.uGamma, this.gamma);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
   */
  fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * A container class that knows how to apply a sequence of filters to an input image.
   */
  filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

    type: 'Composed',

    /**
     * A non sparse array of filters to apply
     */
    subFilters: [],

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.subFilters = this.subFilters.slice(0);
    },

    /**
     * Apply this container's filters to the input image provided.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be applied.
     */
    applyTo: function(options) {
      options.passes += this.subFilters.length - 1;
      this.subFilters.forEach(function(filter) {
        filter.applyTo(options);
      });
    },

    /**
     * Serialize this filter into JSON.
     *
     * @returns {Object} A JSON representation of this filter.
     */
    toObject: function() {
      return fabric.util.object.extend(this.callSuper('toObject'), {
        subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
      });
    },

    isNeutralState: function() {
      return !this.subFilters.some(function(filter) { return !filter.isNeutralState(); });
    }
  });

  /**
   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
   */
  fabric.Image.filters.Composed.fromObject = function(object, callback) {
    var filters = object.subFilters || [],
        subFilters = filters.map(function(filter) {
          return new fabric.Image.filters[filter.type](filter);
        }),
        instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
    callback && callback(instance);
    return instance;
  };
})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * HueRotation filter class
   * @class fabric.Image.filters.HueRotation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.HueRotation({
   *   rotation: -0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'HueRotation',

    /**
     * HueRotation value, from -1 to 1.
     * the unit is radians
     * @param {Number} myParameter
     * @default
     */
    rotation: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'rotation',

    calculateMatrix: function() {
      var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad),
          aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
      this.matrix = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ];
      this.matrix[0] = cos + OneMinusCos / 3;
      this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[6] = cos + aThird * OneMinusCos;
      this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[12] = cos + aThird * OneMinusCos;
    },

    /**
     * HueRotation isNeutralState implementation
     * Used only in image applyFilters to discard filters that will not have an effect
     * on the image
     * @param {Object} options
     **/
    isNeutralState: function(options) {
      this.calculateMatrix();
      return filters.BaseFilter.prototype.isNeutralState.call(this, options);
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      this.calculateMatrix();
      filters.BaseFilter.prototype.applyTo.call(this, options);
    },

  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
   */
  fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : 0);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      clone = fabric.util.object.clone;

  if (fabric.Text) {
    fabric.warn('fabric.Text is already defined');
    return;
  }

  var additionalProps =
    ('fontFamily fontWeight fontSize text underline overline linethrough' +
    ' textAlign fontStyle lineHeight textBackgroundColor charSpacing styles path').split(' ');

  /**
   * Text class
   * @class fabric.Text
   * @extends fabric.Object
   * @return {fabric.Text} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
   * @see {@link fabric.Text#initialize} for constructor definition
   */
  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

    /**
     * Properties which when set cause object to change dimensions
     * @type Array
     * @private
     */
    _dimensionAffectingProps: [
      'fontSize',
      'fontWeight',
      'fontFamily',
      'fontStyle',
      'lineHeight',
      'text',
      'charSpacing',
      'textAlign',
      'styles',
      'path'
    ],

    /**
     * @private
     */
    _reNewline: /\r?\n/,

    /**
     * Use this regular expression to filter for whitespaces that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpacesAndTabs: /[ \t\r]/g,

    /**
     * Use this regular expression to filter for whitespace that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpaceAndTab: /[ \t\r]/,

    /**
     * Use this regular expression to filter consecutive groups of non spaces.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reWords: /\S+/g,

    /**
     * Type of an object
     * @type String
     * @default
     */
    type:                 'text',

    /**
     * Font size (in pixels)
     * @type Number
     * @default
     */
    fontSize:             40,

    /**
     * Font weight (e.g. bold, normal, 400, 600, 800)
     * @type {(Number|String)}
     * @default
     */
    fontWeight:           'normal',

    /**
     * Font family
     * @type String
     * @default
     */
    fontFamily:           'Times New Roman',

    /**
     * Text decoration underline.
     * @type Boolean
     * @default
     */
    underline:       false,

    /**
     * Text decoration overline.
     * @type Boolean
     * @default
     */
    overline:       false,

    /**
     * Text decoration linethrough.
     * @type Boolean
     * @default
     */
    linethrough:       false,

    /**
     * Text alignment. Possible values: "left", "center", "right", "justify",
     * "justify-left", "justify-center" or "justify-right".
     * @type String
     * @default
     */
    textAlign:            'left',

    /**
     * Font style . Possible values: "", "normal", "italic" or "oblique".
     * @type String
     * @default
     */
    fontStyle:            'normal',

    /**
     * Line height
     * @type Number
     * @default
     */
    lineHeight:           1.16,

    /**
     * Superscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    superscript: {
      size:      0.60, // fontSize factor
      baseline: -0.35  // baseline-shift factor (upwards)
    },

    /**
     * Subscript schema object (minimum overlap)
     * @type {Object}
     * @default
     */
    subscript: {
      size:      0.60, // fontSize factor
      baseline:  0.11  // baseline-shift factor (downwards)
    },

    /**
     * Background color of text lines
     * @type String
     * @default
     */
    textBackgroundColor:  '',

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),

    /**
     * List of properties to consider when checking if cache needs refresh
     * @type Array
     */
    cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),

    /**
     * When defined, an object is rendered via stroke and this property specifies its color.
     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
     * @type String
     * @default
     */
    stroke:               null,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
     * @type fabric.Shadow
     * @default
     */
    shadow:               null,

    /**
     * @private
     */
    _fontSizeFraction: 0.222,

    /**
     * @private
     */
    offsets: {
      underline: 0.10,
      linethrough: -0.315,
      overline: -0.88
    },

    /**
     * Text Line proportion to font Size (in pixels)
     * @type Number
     * @default
     */
    _fontSizeMult:             1.13,

    /**
     * additional space between characters
     * expressed in thousands of em unit
     * @type Number
     * @default
     */
    charSpacing:             0,

    /**
     * Object containing character styles - top-level properties -> line numbers,
     * 2nd-level properties - character numbers
     * @type Object
     * @default
     */
    styles: null,

    /**
     * Reference to a context to measure text char or couple of chars
     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every
     * text object created.
     * @type {CanvasRenderingContext2D}
     * @default
     */
    _measuringContext: null,

    /**
     * Baseline shift, styles only, keep at 0 for the main text object
     * @type {Number}
     * @default
     */
    deltaY: 0,

    /**
     * Array of properties that define a style unit (of 'styles').
     * @type {Array}
     * @default
     */
    _styleProperties: [
      'stroke',
      'strokeWidth',
      'fill',
      'fontFamily',
      'fontSize',
      'fontWeight',
      'fontStyle',
      'underline',
      'overline',
      'linethrough',
      'deltaY',
      'textBackgroundColor',
    ],

    /**
     * contains characters bounding boxes
     */
    __charBounds: [],

    /**
     * use this size when measuring text. To avoid IE11 rounding errors
     * @type {Number}
     * @default
     * @readonly
     * @private
     */
    CACHE_FONT_SIZE: 400,

    /**
     * contains the min text width to avoid getting 0
     * @type {Number}
     * @default
     */
    MIN_TEXT_WIDTH: 2,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    initialize: function(text, options) {
      this.styles = options ? (options.styles || { }) : { };
      this.text = text;
      this.__skipDimension = true;
      this.callSuper('initialize', options);
      if (this.path) {
        this.setPathInfo();
      }
      this.__skipDimension = false;
      this.initDimensions();
      this.setCoords();
      this.setupState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * If text has a path, it will add the extra information needed
     * for path and text calculations
     * @return {fabric.Text} thisArg
     */
    setPathInfo: function() {
      var path = this.path;
      if (path) {
        path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);
      }
    },

    /**
     * Return a context for measurement of text string.
     * if created it gets stored for reuse
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    getMeasuringContext: function() {
      // if we did not return we have to measure something.
      if (!fabric._measuringContext) {
        fabric._measuringContext = this.canvas && this.canvas.contextCache ||
          fabric.util.createCanvasElement().getContext('2d');
      }
      return fabric._measuringContext;
    },

    /**
     * @private
     * Divides text into lines of text and lines of graphemes.
     */
    _splitText: function() {
      var newLines = this._splitTextIntoLines(this.text);
      this.textLines = newLines.lines;
      this._textLines = newLines.graphemeLines;
      this._unwrappedTextLines = newLines._unwrappedLines;
      this._text = newLines.graphemeText;
      return newLines;
    },

    /**
     * Initialize or update text dimensions.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this._splitText();
      this._clearCache();
      if (this.path) {
        this.width = this.path.width;
        this.height = this.path.height;
      }
      else {
        this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
        this.height = this.calcTextHeight();
      }
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Enlarge space boxes and shift the others
     */
    enlargeSpaces: function() {
      var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        if (this.textAlign !== 'justify' && (i === len - 1 || this.isEndOfWrapping(i))) {
          continue;
        }
        accumulatedSpace = 0;
        line = this._textLines[i];
        currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
          numberOfSpaces = spaces.length;
          diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
          for (var j = 0, jlen = line.length; j <= jlen; j++) {
            charBound = this.__charBounds[i][j];
            if (this._reSpaceAndTab.test(line[j])) {
              charBound.width += diffSpace;
              charBound.kernedWidth += diffSpace;
              charBound.left += accumulatedSpace;
              accumulatedSpace += diffSpace;
            }
            else {
              charBound.left += accumulatedSpace;
            }
          }
        }
      }
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      return lineIndex === this._textLines.length - 1;
    },

    /**
     * Detect if a line has a linebreak and so we need to account for it when moving
     * and counting style.
     * It return always for text and Itext.
     * @return Number
     */
    missingNewlineOffset: function() {
      return 1;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of text object
     */
    toString: function() {
      return '#<fabric.Text (' + this.complexity() +
        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @param {Object} dim.x width of object to be cached
     * @param {Object} dim.y height of object to be cached
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var dims = this.callSuper('_getCacheCanvasDimensions');
      var fontSize = this.fontSize;
      dims.width += fontSize * dims.zoomX;
      dims.height += fontSize * dims.zoomY;
      return dims;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this._setTextStyles(ctx);
      this._renderTextLinesBackground(ctx);
      this._renderTextDecoration(ctx, 'underline');
      this._renderText(ctx);
      this._renderTextDecoration(ctx, 'overline');
      this._renderTextDecoration(ctx, 'linethrough');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderText: function(ctx) {
      if (this.paintFirst === 'stroke') {
        this._renderTextStroke(ctx);
        this._renderTextFill(ctx);
      }
      else {
        this._renderTextFill(ctx);
        this._renderTextStroke(ctx);
      }
    },

    /**
     * Set the font parameter of the context with the object properties or with charStyle
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [charStyle] object with font style properties
     * @param {String} [charStyle.fontFamily] Font Family
     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
     * @param {String} [charStyle.fontWeight] Font weight
     * @param {String} [charStyle.fontStyle] Font style (italic|normal)
     */
    _setTextStyles: function(ctx, charStyle, forMeasuring) {
      ctx.textBaseline = 'alphabetic';
      ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
    },

    /**
     * calculate and return the text Width measuring each line.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {Number} Maximum width of fabric.Text object
     */
    calcTextWidth: function() {
      var maxWidth = this.getLineWidth(0);

      for (var i = 1, len = this._textLines.length; i < len; i++) {
        var currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth > maxWidth) {
          maxWidth = currentLineWidth;
        }
      }
      return maxWidth;
    },

    /**
     * @private
     * @param {String} method Method name ("fillText" or "strokeText")
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} line Text to render
     * @param {Number} left Left position of text
     * @param {Number} top Top position of text
     * @param {Number} lineIndex Index of a line in a text
     */
    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
      this._renderChars(method, ctx, line, left, top, lineIndex);
    },

    /**
     * Renders the text background for lines, taking care of style
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextLinesBackground: function(ctx) {
      if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
        return;
      }
      var heightOfLine,
          lineLeftOffset, originalFill = ctx.fillStyle,
          line, lastColor,
          leftOffset = this._getLeftOffset(),
          lineTopOffset = this._getTopOffset(),
          boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
          lineTopOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        lineLeftOffset = this._getLineLeftOffset(i);
        boxWidth = 0;
        boxStart = 0;
        lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (path) {
            ctx.save();
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            ctx.fillStyle = currentColor;
            currentColor && ctx.fillRect(
              -charBox.width / 2,
              -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction),
              charBox.width,
              heightOfLine / this.lineHeight
            );
            ctx.restore();
          }
          else if (currentColor !== lastColor) {
            ctx.fillStyle = lastColor;
            lastColor && ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        if (currentColor && !path) {
          ctx.fillStyle = currentColor;
          ctx.fillRect(
            leftOffset + lineLeftOffset + boxStart,
            lineTopOffset,
            boxWidth,
            heightOfLine / this.lineHeight
          );
        }
        lineTopOffset += heightOfLine;
      }
      ctx.fillStyle = originalFill;
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {Object} decl style declaration for cache
     * @param {String} decl.fontFamily fontFamily
     * @param {String} decl.fontStyle fontStyle
     * @param {String} decl.fontWeight fontWeight
     * @return {Object} reference to cache
     */
    getFontCache: function(decl) {
      var fontFamily = decl.fontFamily.toLowerCase();
      if (!fabric.charWidthsCache[fontFamily]) {
        fabric.charWidthsCache[fontFamily] = { };
      }
      var cache = fabric.charWidthsCache[fontFamily],
          cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
      if (!cache[cacheProp]) {
        cache[cacheProp] = { };
      }
      return cache[cacheProp];
    },

    /**
     * measure and return the width of a single character.
     * possibly overridden to accommodate different measure logic or
     * to hook some external lib for character measurement
     * @private
     * @param {String} _char, char to be measured
     * @param {Object} charStyle style of char to be measured
     * @param {String} [previousChar] previous char
     * @param {Object} [prevCharStyle] style of previous char
     */
    _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
      // first i try to return from cache
      var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
          previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
          stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
          fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;

      if (previousChar && fontCache[previousChar] !== undefined) {
        previousWidth = fontCache[previousChar];
      }
      if (fontCache[_char] !== undefined) {
        kernedWidth = width = fontCache[_char];
      }
      if (stylesAreEqual && fontCache[couple] !== undefined) {
        coupleWidth = fontCache[couple];
        kernedWidth = coupleWidth - previousWidth;
      }
      if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {
        var ctx = this.getMeasuringContext();
        // send a TRUE to specify measuring font size CACHE_FONT_SIZE
        this._setTextStyles(ctx, charStyle, true);
      }
      if (width === undefined) {
        kernedWidth = width = ctx.measureText(_char).width;
        fontCache[_char] = width;
      }
      if (previousWidth === undefined && stylesAreEqual && previousChar) {
        previousWidth = ctx.measureText(previousChar).width;
        fontCache[previousChar] = previousWidth;
      }
      if (stylesAreEqual && coupleWidth === undefined) {
        // we can measure the kerning couple and subtract the width of the previous character
        coupleWidth = ctx.measureText(couple).width;
        fontCache[couple] = coupleWidth;
        kernedWidth = coupleWidth - previousWidth;
      }
      return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
    },

    /**
     * Computes height of character at given position
     * @param {Number} line the line index number
     * @param {Number} _char the character index number
     * @return {Number} fontSize of the character
     */
    getHeightOfChar: function(line, _char) {
      return this.getValueOfPropertyAt(line, _char, 'fontSize');
    },

    /**
     * measure a text line measuring all characters.
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    measureLine: function(lineIndex) {
      var lineInfo = this._measureLine(lineIndex);
      if (this.charSpacing !== 0) {
        lineInfo.width -= this._getWidthOfCharSpacing();
      }
      if (lineInfo.width < 0) {
        lineInfo.width = 0;
      }
      return lineInfo;
    },

    /**
     * measure every grapheme of a line, populating __charBounds
     * @param {Number} lineIndex
     * @return {Object} object.width total width of characters
     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
     */
    _measureLine: function(lineIndex) {
      var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
          graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length),
          positionInPath = 0, startingPoint, totalPathLength, path = this.path;

      this.__charBounds[lineIndex] = lineBounds;
      if (path) {
        startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);
        totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;
        startingPoint.x += path.pathOffset.x;
        startingPoint.y += path.pathOffset.y;
      }
      for (i = 0; i < line.length; i++) {
        grapheme = line[i];
        graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
        if (path) {
          if (positionInPath > totalPathLength) {
            positionInPath %= totalPathLength;
          }
          // it would probably much fater to send all the grapheme position for a line
          // and calculate path position/angle at once.
          this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);
        }
        lineBounds[i] = graphemeInfo;
        width += graphemeInfo.kernedWidth;
        positionInPath += graphemeInfo.kernedWidth;
        prevGrapheme = grapheme;
      }
      // this latest bound box represent the last character of the line
      // to simplify cursor handling in interactive mode.
      lineBounds[i] = {
        left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
        width: 0,
        kernedWidth: 0,
        height: this.fontSize
      };
      return { width: width, numOfSpaces: numOfSpaces };
    },

    /**
     * Calculate the angle  and the left,top position of the char that follow a path.
     * It appends it to graphemeInfo to be reused later at rendering
     * @private
     * @param {Number} positionInPath to be measured
     * @param {Object} graphemeInfo current grapheme box information
     * @param {Object} startingPoint position of the point
     */
    _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {
      var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2,
          path = this.path;

      // we are at currentPositionOnPath. we want to know what point on the path is.
      var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);
      graphemeInfo.renderLeft = info.x - startingPoint.x;
      graphemeInfo.renderTop = info.y - startingPoint.y;
      graphemeInfo.angle = info.angle;
    },

    /**
     * Measure and return the info of a single grapheme.
     * needs the the info of previous graphemes already filled
     * @private
     * @param {String} grapheme to be measured
     * @param {Number} lineIndex index of the line where the char is
     * @param {Number} charIndex position in the line
     * @param {String} [prevGrapheme] character preceding the one to be measured
     */
    _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
      var style = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
          info = this._measureChar(grapheme, style, prevGrapheme, prevStyle),
          kernedWidth = info.kernedWidth,
          width = info.width, charSpacing;

      if (this.charSpacing !== 0) {
        charSpacing = this._getWidthOfCharSpacing();
        width += charSpacing;
        kernedWidth += charSpacing;
      }

      var box = {
        width: width,
        left: 0,
        height: style.fontSize,
        kernedWidth: kernedWidth,
        deltaY: style.deltaY,
      };
      if (charIndex > 0 && !skipLeft) {
        var previousBox = this.__charBounds[lineIndex][charIndex - 1];
        box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
      }
      return box;
    },

    /**
     * Calculate height of line at 'lineIndex'
     * @param {Number} lineIndex index of line to calculate
     * @return {Number}
     */
    getHeightOfLine: function(lineIndex) {
      if (this.__lineHeights[lineIndex]) {
        return this.__lineHeights[lineIndex];
      }

      var line = this._textLines[lineIndex],
          // char 0 is measured before the line cycle because it nneds to char
          // emptylines
          maxHeight = this.getHeightOfChar(lineIndex, 0);
      for (var i = 1, len = line.length; i < len; i++) {
        maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
      }

      return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
    },

    /**
     * Calculate text box height
     */
    calcTextHeight: function() {
      var lineHeight, height = 0;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineHeight = this.getHeightOfLine(i);
        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
      }
      return height;
    },

    /**
     * @private
     * @return {Number} Left offset
     */
    _getLeftOffset: function() {
      return -this.width / 2;
    },

    /**
     * @private
     * @return {Number} Top offset
     */
    _getTopOffset: function() {
      return -this.height / 2;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} method Method name ("fillText" or "strokeText")
     */
    _renderTextCommon: function(ctx, method) {
      ctx.save();
      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        var heightOfLine = this.getHeightOfLine(i),
            maxHeight = heightOfLine / this.lineHeight,
            leftOffset = this._getLineLeftOffset(i);
        this._renderTextLine(
          method,
          ctx,
          this._textLines[i],
          left + leftOffset,
          top + lineHeights + maxHeight,
          i
        );
        lineHeights += heightOfLine;
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextFill: function(ctx) {
      if (!this.fill && !this.styleHas('fill')) {
        return;
      }

      this._renderTextCommon(ctx, 'fillText');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextStroke: function(ctx) {
      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      this._setLineDash(ctx, this.strokeDashArray);
      ctx.beginPath();
      this._renderTextCommon(ctx, 'strokeText');
      ctx.closePath();
      ctx.restore();
    },

    /**
     * @private
     * @param {String} method fillText or strokeText.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} line Content of the line, splitted in an array by grapheme
     * @param {Number} left
     * @param {Number} top
     * @param {Number} lineIndex
     */
    _renderChars: function(method, ctx, line, left, top, lineIndex) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox,
          boxWidth = 0,
          timeToRender,
          path = this.path,
          shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path;

      ctx.save();
      top -= lineHeight * this._fontSizeFraction / this.lineHeight;
      if (shortCut) {
        // render all the line in one pass without checking
        this._renderChar(method, ctx, lineIndex, 0, line.join(''), left, top, lineHeight);
        ctx.restore();
        return;
      }
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing || path;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          left += charBox.kernedWidth - charBox.width;
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
        }
        if (timeToRender) {
          if (path) {
            ctx.save();
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);
            ctx.restore();
          }
          else {
            this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);
          }
          charsToRender = '';
          actualStyle = nextStyle;
          left += boxWidth;
          boxWidth = 0;
        }
      }
      ctx.restore();
    },

    /**
     * This function try to patch the missing gradientTransform on canvas gradients.
     * transforming a context to transform the gradient, is going to transform the stroke too.
     * we want to transform the gradient but not the stroke operation, so we create
     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size
     * is limited.
     * @private
     * @param {fabric.Gradient} filler a fabric gradient instance
     * @return {CanvasPattern} a pattern to use as fill/stroke style
     */
    _applyPatternGradientTransformText: function(filler) {
      var pCanvas = fabric.util.createCanvasElement(), pCtx,
          // TODO: verify compatibility with strokeUniform
          width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;
      pCanvas.width = width;
      pCanvas.height = height;
      pCtx = pCanvas.getContext('2d');
      pCtx.beginPath(); pCtx.moveTo(0, 0); pCtx.lineTo(width, 0); pCtx.lineTo(width, height);
      pCtx.lineTo(0, height); pCtx.closePath();
      pCtx.translate(width / 2, height / 2);
      pCtx.fillStyle = filler.toLive(pCtx);
      this._applyPatternGradientTransform(pCtx, filler);
      pCtx.fill();
      return pCtx.createPattern(pCanvas, 'no-repeat');
    },

    handleFiller: function(ctx, property, filler) {
      var offsetX, offsetY;
      if (filler.toLive) {
        if (filler.gradientUnits === 'percentage' || filler.gradientTrasnform || filler.patternTransform) {
          // need to transform gradient in a pattern.
          // this is a slow process. If you are hitting this codepath, and the object
          // is not using caching, you should consider switching it on.
          // we need a canvas as big as the current object caching canvas.
          offsetX = -this.width / 2;
          offsetY = -this.height / 2;
          ctx.translate(offsetX, offsetY);
          ctx[property] = this._applyPatternGradientTransformText(filler);
          return { offsetX: offsetX, offsetY: offsetY };
        }
        else {
          // is a simple gradient or pattern
          ctx[property] = filler.toLive(ctx, this);
          return this._applyPatternGradientTransform(ctx, filler);
        }
      }
      else {
        // is a color
        ctx[property] = filler;
      }
      return { offsetX: 0, offsetY: 0 };
    },

    _setStrokeStyles: function(ctx, decl) {
      ctx.lineWidth = decl.strokeWidth;
      ctx.lineCap = this.strokeLineCap;
      ctx.lineDashOffset = this.strokeDashOffset;
      ctx.lineJoin = this.strokeLineJoin;
      ctx.miterLimit = this.strokeMiterLimit;
      return this.handleFiller(ctx, 'strokeStyle', decl.stroke);
    },

    _setFillStyles: function(ctx, decl) {
      return this.handleFiller(ctx, 'fillStyle', decl.fill);
    },

    /**
     * @private
     * @param {String} method
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {String} _char
     * @param {Number} left Left coordinate
     * @param {Number} top Top coordinate
     * @param {Number} lineHeight Height of the line
     */
    _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
      var decl = this._getStyleDeclaration(lineIndex, charIndex),
          fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          shouldFill = method === 'fillText' && fullDecl.fill,
          shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth,
          fillOffsets, strokeOffsets;

      if (!shouldStroke && !shouldFill) {
        return;
      }
      ctx.save();

      shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));
      shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));

      ctx.font = this._getFontDeclaration(fullDecl);


      if (decl && decl.textBackgroundColor) {
        this._removeShadow(ctx);
      }
      if (decl && decl.deltaY) {
        top += decl.deltaY;
      }
      shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);
      shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);
      ctx.restore();
    },

    /**
     * Turns the character into a 'superior figure' (i.e. 'superscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSuperscript: function(start, end) {
      return this._setScript(start, end, this.superscript);
    },

    /**
     * Turns the character into an 'inferior figure' (i.e. 'subscript')
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    setSubscript: function(start, end) {
      return this._setScript(start, end, this.subscript);
    },

    /**
     * Applies 'schema' at given position
     * @private
     * @param {Number} start selection start
     * @param {Number} end selection end
     * @param {Number} schema
     * @returns {fabric.Text} thisArg
     * @chainable
     */
    _setScript: function(start, end, schema) {
      var loc = this.get2DCursorLocation(start, true),
          fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'fontSize'),
          dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, 'deltaY'),
          style = { fontSize: fontSize * schema.size, deltaY: dy + fontSize * schema.baseline };
      this.setSelectionStyles(style, start, end);
      return this;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChanged: function(prevStyle, thisStyle) {
      return prevStyle.fill !== thisStyle.fill ||
              prevStyle.stroke !== thisStyle.stroke ||
              prevStyle.strokeWidth !== thisStyle.strokeWidth ||
              prevStyle.fontSize !== thisStyle.fontSize ||
              prevStyle.fontFamily !== thisStyle.fontFamily ||
              prevStyle.fontWeight !== thisStyle.fontWeight ||
              prevStyle.fontStyle !== thisStyle.fontStyle ||
              prevStyle.deltaY !== thisStyle.deltaY;
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
      return this._hasStyleChanged(prevStyle, thisStyle) ||
        prevStyle.overline !== thisStyle.overline ||
        prevStyle.underline !== thisStyle.underline ||
        prevStyle.linethrough !== thisStyle.linethrough;
    },

    /**
     * @private
     * @param {Number} lineIndex index text line
     * @return {Number} Line left offset
     */
    _getLineLeftOffset: function(lineIndex) {
      var lineWidth = this.getLineWidth(lineIndex);
      if (this.textAlign === 'center') {
        return (this.width - lineWidth) / 2;
      }
      if (this.textAlign === 'right') {
        return this.width - lineWidth;
      }
      if (this.textAlign === 'justify-center' && this.isEndOfWrapping(lineIndex)) {
        return (this.width - lineWidth) / 2;
      }
      if (this.textAlign === 'justify-right' && this.isEndOfWrapping(lineIndex)) {
        return this.width - lineWidth;
      }
      return 0;
    },

    /**
     * @private
     */
    _clearCache: function() {
      this.__lineWidths = [];
      this.__lineHeights = [];
      this.__charBounds = [];
    },

    /**
     * @private
     */
    _shouldClearDimensionCache: function() {
      var shouldClear = this._forceClearCache;
      shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
      if (shouldClear) {
        this.dirty = true;
        this._forceClearCache = false;
      }
      return shouldClear;
    },

    /**
     * Measure a single line given its index. Used to calculate the initial
     * text bounding box. The values are calculated and stored in __lineWidths cache.
     * @private
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    getLineWidth: function(lineIndex) {
      if (this.__lineWidths[lineIndex]) {
        return this.__lineWidths[lineIndex];
      }

      var width, line = this._textLines[lineIndex], lineInfo;

      if (line === '') {
        width = 0;
      }
      else {
        lineInfo = this.measureLine(lineIndex);
        width = lineInfo.width;
      }
      this.__lineWidths[lineIndex] = width;
      return width;
    },

    _getWidthOfCharSpacing: function() {
      if (this.charSpacing !== 0) {
        return this.fontSize * this.charSpacing / 1000;
      }
      return 0;
    },

    /**
     * Retrieves the value of property at given character position
     * @param {Number} lineIndex the line number
     * @param {Number} charIndex the character number
     * @param {String} property the property name
     * @returns the value of 'property'
     */
    getValueOfPropertyAt: function(lineIndex, charIndex, property) {
      var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
      if (charStyle && typeof charStyle[property] !== 'undefined') {
        return charStyle[property];
      }
      return this[property];
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextDecoration: function(ctx, type) {
      if (!this[type] && !this.styleHas(type)) {
        return;
      }
      var heightOfLine, size, _size,
          lineLeftOffset, dy, _dy,
          line, lastDecoration,
          leftOffset = this._getLeftOffset(),
          topOffset = this._getTopOffset(), top,
          boxStart, boxWidth, charBox, currentDecoration,
          maxHeight, currentFill, lastFill, path = this.path,
          charSpacing = this._getWidthOfCharSpacing();

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this[type] && !this.styleHas(type, i)) {
          topOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        maxHeight = heightOfLine / this.lineHeight;
        lineLeftOffset = this._getLineLeftOffset(i);
        boxStart = 0;
        boxWidth = 0;
        lastDecoration = this.getValueOfPropertyAt(i, 0, type);
        lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
        top = topOffset + maxHeight * (1 - this._fontSizeFraction);
        size = this.getHeightOfChar(i, 0);
        dy = this.getValueOfPropertyAt(i, 0, 'deltaY');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentDecoration = this.getValueOfPropertyAt(i, j, type);
          currentFill = this.getValueOfPropertyAt(i, j, 'fill');
          _size = this.getHeightOfChar(i, j);
          _dy = this.getValueOfPropertyAt(i, j, 'deltaY');
          if (path && currentDecoration && currentFill) {
            ctx.save();
            ctx.fillStyle = lastFill;
            ctx.translate(charBox.renderLeft, charBox.renderTop);
            ctx.rotate(charBox.angle);
            ctx.fillRect(
              -charBox.kernedWidth / 2,
              this.offsets[type] * _size + _dy,
              charBox.kernedWidth,
              this.fontSize / 15
            );
            ctx.restore();
          }
          else if (
            (currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy)
            && boxWidth > 0
          ) {
            lastDecoration && lastFill &&
              ctx.fillRect(
                leftOffset + lineLeftOffset + boxStart,
                top + this.offsets[type] * size + dy,
                boxWidth,
                this.fontSize / 15
              );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastDecoration = currentDecoration;
            lastFill = currentFill;
            size = _size;
            dy = _dy;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        ctx.fillStyle = currentFill;
        currentDecoration && currentFill && ctx.fillRect(
          leftOffset + lineLeftOffset + boxStart,
          top + this.offsets[type] * size + dy,
          boxWidth - charSpacing,
          this.fontSize / 15
        );
        topOffset += heightOfLine;
      }
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * return font declaration string for canvas context
     * @param {Object} [styleObject] object
     * @returns {String} font declaration formatted for canvas context.
     */
    _getFontDeclaration: function(styleObject, forMeasuring) {
      var style = styleObject || this, family = this.fontFamily,
          fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
      var fontFamily = family === undefined ||
      family.indexOf('\'') > -1 || family.indexOf(',') > -1 ||
      family.indexOf('"') > -1 || fontIsGeneric
        ? style.fontFamily : '"' + style.fontFamily + '"';
      return [
        // node-canvas needs "weight style", while browsers need "style weight"
        // verify if this can be fixed in JSDOM
        (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
        (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
        forMeasuring ? this.CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
        fontFamily
      ].join(' ');
    },

    /**
     * Renders text instance on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if object is not visible
      if (!this.visible) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
      }
      this.callSuper('render', ctx);
    },

    /**
     * Returns the text as an array of lines.
     * @param {String} text text to split
     * @returns {Array} Lines in the text
     */
    _splitTextIntoLines: function(text) {
      var lines = text.split(this._reNewline),
          newLines = new Array(lines.length),
          newLine = ['\n'],
          newText = [];
      for (var i = 0; i < lines.length; i++) {
        newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
        newText = newText.concat(newLines[i], newLine);
      }
      newText.pop();
      return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var additionalProperties = [
        'text',
        'fontSize',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'lineHeight',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'textBackgroundColor',
        'charSpacing',
      ].concat(propertiesToInclude);
      var obj = this.callSuper('toObject', additionalProperties);
      obj.styles = clone(this.styles, true);
      return obj;
    },

    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(key, value) {
      this.callSuper('set', key, value);
      var needsDims = false;
      var isAddingPath = false;
      if (typeof key === 'object') {
        for (var _key in key) {
          if (_key === 'path') {
            this.setPathInfo();
          }
          needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
          isAddingPath = isAddingPath || _key === 'path';
        }
      }
      else {
        needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
        isAddingPath = key === 'path';
      }
      if (isAddingPath) {
        this.setPathInfo();
      }
      if (needsDims) {
        this.initDimensions();
        this.setCoords();
      }
      return this;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity
     */
    complexity: function() {
      return 1;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
   * @static
   * @memberOf fabric.Text
   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
   */
  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
    'x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor'.split(' '));

  /**
   * Default SVG font size
   * @static
   * @memberOf fabric.Text
   */
  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

  /**
   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
   * @static
   * @memberOf fabric.Text
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Text.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }

    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
        parsedAnchor = parsedAttributes.textAnchor || 'left';
    options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

    options.top = options.top || 0;
    options.left = options.left || 0;
    if (parsedAttributes.textDecoration) {
      var textDecoration = parsedAttributes.textDecoration;
      if (textDecoration.indexOf('underline') !== -1) {
        options.underline = true;
      }
      if (textDecoration.indexOf('overline') !== -1) {
        options.overline = true;
      }
      if (textDecoration.indexOf('line-through') !== -1) {
        options.linethrough = true;
      }
      delete options.textDecoration;
    }
    if ('dx' in parsedAttributes) {
      options.left += parsedAttributes.dx;
    }
    if ('dy' in parsedAttributes) {
      options.top += parsedAttributes.dy;
    }
    if (!('fontSize' in options)) {
      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
    }

    var textContent = '';

    // The XML is not properly parsed in IE9 so a workaround to get
    // textContent is through firstChild.data. Another workaround would be
    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
    if (!('textContent' in element)) {
      if ('firstChild' in element && element.firstChild !== null) {
        if ('data' in element.firstChild && element.firstChild.data !== null) {
          textContent = element.firstChild.data;
        }
      }
    }
    else {
      textContent = element.textContent;
    }

    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');
    var originalStrokeWidth = options.strokeWidth;
    options.strokeWidth = 0;

    var text = new fabric.Text(textContent, options),
        textHeightScaleFactor = text.getScaledHeight() / text.height,
        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
        scaledDiff = lineHeightDiff * textHeightScaleFactor,
        textHeight = text.getScaledHeight() + scaledDiff,
        offX = 0;
    /*
      Adjust positioning:
        x/y attributes in SVG correspond to the bottom-left corner of text bounding box
        fabric output by default at top, left.
    */
    if (parsedAnchor === 'center') {
      offX = text.getScaledWidth() / 2;
    }
    if (parsedAnchor === 'right') {
      offX = text.getScaledWidth();
    }
    text.set({
      left: text.left - offX,
      top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
      strokeWidth: typeof originalStrokeWidth !== 'undefined' ? originalStrokeWidth : 1,
    });
    callback(text);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Text instance from an object representation
   * @static
   * @memberOf fabric.Text
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
   */
  fabric.Text.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Text', object, callback, 'text');
  };

  fabric.Text.genericFonts = ['sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'];

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

})( true ? exports : 0);


(function() {
  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {
    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return true;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          // eslint-disable-next-line no-unused-vars
          for (var p3 in obj[p1][p2]) {
            return false;
          }
        }
      }
      return true;
    },

    /**
     * Returns true if object has a style property or has it ina specified line
     * This function is used to detect if a text will use a particular property or not.
     * @param {String} property to check for
     * @param {Number} lineIndex to check the style on
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return false;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { 0: this.styles[lineIndex] };
      // eslint-disable-next-line
      for (var p1 in obj) {
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          if (typeof obj[p1][p2][property] !== 'undefined') {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Check if characters in a text have a value for a property
     * whose value matches the textbox's value for that property.  If so,
     * the character-level property is deleted.  If the character
     * has no other properties, then it is also deleted.  Finally,
     * if the line containing that character has no other characters
     * then it also is deleted.
     *
     * @param {string} property The property to compare between characters and text.
     */
    cleanStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue,
          allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
      // eslint-disable-next-line
      for (var p1 in obj) {
        letterCount = 0;
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          var styleObject = obj[p1][p2],
              stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);

          stylesCount++;

          if (stylePropertyHasBeenSet) {
            if (!stylePropertyValue) {
              stylePropertyValue = styleObject[property];
            }
            else if (styleObject[property] !== stylePropertyValue) {
              allStyleObjectPropertiesMatch = false;
            }

            if (styleObject[property] === this[property]) {
              delete styleObject[property];
            }
          }
          else {
            allStyleObjectPropertiesMatch = false;
          }

          if (Object.keys(styleObject).length !== 0) {
            letterCount++;
          }
          else {
            delete obj[p1][p2];
          }
        }

        if (letterCount === 0) {
          delete obj[p1];
        }
      }
      // if every grapheme has the same style set then
      // delete those styles and set it on the parent
      for (var i = 0; i < this._textLines.length; i++) {
        graphemeCount += this._textLines[i].length;
      }
      if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
        this[property] = stylePropertyValue;
        this.removeStyle(property);
      }
    },

    /**
     * Remove a style property or properties from all individual character styles
     * in a text object.  Deletes the character style object if it contains no other style
     * props.  Deletes a line style object if it contains no other character styles.
     *
     * @param {String} props The property to remove from character styles.
     */
    removeStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return;
      }
      var obj = this.styles, line, lineNum, charNum;
      for (lineNum in obj) {
        line = obj[lineNum];
        for (charNum in line) {
          delete line[charNum][property];
          if (Object.keys(line[charNum]).length === 0) {
            delete line[charNum];
          }
        }
        if (Object.keys(line).length === 0) {
          delete obj[lineNum];
        }
      }
    },

    /**
     * @private
     */
    _extendStyles: function(index, styles) {
      var loc = this.get2DCursorLocation(index);

      if (!this._getLineStyle(loc.lineIndex)) {
        this._setLineStyle(loc.lineIndex);
      }

      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
      }

      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
    },

    /**
     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.
     */
    get2DCursorLocation: function(selectionStart, skipWrapping) {
      if (typeof selectionStart === 'undefined') {
        selectionStart = this.selectionStart;
      }
      var lines = skipWrapping ? this._unwrappedTextLines : this._textLines,
          len = lines.length;
      for (var i = 0; i < len; i++) {
        if (selectionStart <= lines[i].length) {
          return {
            lineIndex: i,
            charIndex: selectionStart
          };
        }
        selectionStart -= lines[i].length + this.missingNewlineOffset(i);
      }
      return {
        lineIndex: i - 1,
        charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
      };
    },

    /**
     * Gets style of a current selection/cursor (at the start position)
     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @param {Boolean} [complete] get full style or not
     * @return {Array} styles an array with one, zero or more Style objects
     */
    getSelectionStyles: function(startIndex, endIndex, complete) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      var styles = [];
      for (var i = startIndex; i < endIndex; i++) {
        styles.push(this.getStyleAtPosition(i, complete));
      }
      return styles;
    },

    /**
     * Gets style of a current selection/cursor position
     * @param {Number} position  to get styles at
     * @param {Boolean} [complete] full style if true
     * @return {Object} style Style object at a specified index
     * @private
     */
    getStyleAtPosition: function(position, complete) {
      var loc = this.get2DCursorLocation(position),
          style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
            this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
      return style || {};
    },

    /**
     * Sets style of a current selection, if no selection exist, do not set anything.
     * @param {Object} [styles] Styles object
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
     * @return {fabric.IText} thisArg
     * @chainable
     */
    setSelectionStyles: function(styles, startIndex, endIndex) {
      if (typeof startIndex === 'undefined') {
        startIndex = this.selectionStart || 0;
      }
      if (typeof endIndex === 'undefined') {
        endIndex = this.selectionEnd || startIndex;
      }
      for (var i = startIndex; i < endIndex; i++) {
        this._extendStyles(i, styles);
      }
      /* not included in _extendStyles to avoid clearing cache more than once */
      this._forceClearCache = true;
      return this;
    },

    /**
     * get the reference, not a clone, of the style object for a given character
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Object} style object
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      var lineStyle = this.styles && this.styles[lineIndex];
      if (!lineStyle) {
        return null;
      }
      return lineStyle[charIndex];
    },

    /**
     * return a new object that contains all the style property for a character
     * the object returned is newly created
     * @param {Number} lineIndex of the line where the character is
     * @param {Number} charIndex position of the character on the line
     * @return {Object} style object
     */
    getCompleteStyleDeclaration: function(lineIndex, charIndex) {
      var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
          styleObject = { }, prop;
      for (var i = 0; i < this._styleProperties.length; i++) {
        prop = this._styleProperties[i];
        styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
      }
      return styleObject;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      this.styles[lineIndex][charIndex] = style;
    },

    /**
     *
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * @param {Number} lineIndex
     * @return {Boolean} if the line exists or not
     * @private
     */
    _getLineStyle: function(lineIndex) {
      return !!this.styles[lineIndex];
    },

    /**
     * Set the line style to an empty object so that is initialized
     * @param {Number} lineIndex
     * @private
     */
    _setLineStyle: function(lineIndex) {
      this.styles[lineIndex] = {};
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _deleteLineStyle: function(lineIndex) {
      delete this.styles[lineIndex];
    }
  });
})();


(function() {

  function parseDecoration(object) {
    if (object.textDecoration) {
      object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
      object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
      object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
      delete object.textDecoration;
    }
  }

  /**
   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
   * prefix when observing canvas.
   * @class fabric.IText
   * @extends fabric.Text
   * @mixes fabric.Observable
   *
   * @fires changed
   * @fires selection:changed
   * @fires editing:entered
   * @fires editing:exited
   *
   * @return {fabric.IText} thisArg
   * @see {@link fabric.IText#initialize} for constructor definition
   *
   * <p>Supported key combinations:</p>
   * <pre>
   *   Move cursor:                    left, right, up, down
   *   Select character:               shift + left, shift + right
   *   Select text vertically:         shift + up, shift + down
   *   Move cursor by word:            alt + left, alt + right
   *   Select words:                   shift + alt + left, shift + alt + right
   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
   *   Jump to start/end of text:      cmd + up, cmd + down
   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
   *   Delete character:               backspace
   *   Delete word:                    alt + backspace
   *   Delete line:                    cmd + backspace
   *   Forward delete:                 delete
   *   Copy text:                      ctrl/cmd + c
   *   Paste text:                     ctrl/cmd + v
   *   Cut text:                       ctrl/cmd + x
   *   Select entire text:             ctrl/cmd + a
   *   Quit editing                    tab or esc
   * </pre>
   *
   * <p>Supported mouse/touch combination</p>
   * <pre>
   *   Position cursor:                click/touch
   *   Create selection:               click/touch & drag
   *   Create selection:               click & shift + click
   *   Select word:                    double click
   *   Select line:                    triple click
   * </pre>
   */
  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'i-text',

    /**
     * Index where text selection starts (or where cursor is when there is no selection)
     * @type Number
     * @default
     */
    selectionStart: 0,

    /**
     * Index where text selection ends
     * @type Number
     * @default
     */
    selectionEnd: 0,

    /**
     * Color of text selection
     * @type String
     * @default
     */
    selectionColor: 'rgba(17,119,255,0.3)',

    /**
     * Indicates whether text is in editing mode
     * @type Boolean
     * @default
     */
    isEditing: false,

    /**
     * Indicates whether a text can be edited
     * @type Boolean
     * @default
     */
    editable: true,

    /**
     * Border color of text object while it's in editing mode
     * @type String
     * @default
     */
    editingBorderColor: 'rgba(102,153,255,0.25)',

    /**
     * Width of cursor (in px)
     * @type Number
     * @default
     */
    cursorWidth: 2,

    /**
     * Color of text cursor color in editing mode.
     * if not set (default) will take color from the text.
     * if set to a color value that fabric can understand, it will
     * be used instead of the color of the text at the current position.
     * @type String
     * @default
     */
    cursorColor: '',

    /**
     * Delay between cursor blink (in ms)
     * @type Number
     * @default
     */
    cursorDelay: 1000,

    /**
     * Duration of cursor fadein (in ms)
     * @type Number
     * @default
     */
    cursorDuration: 600,

    /**
     * Indicates whether internal text char widths can be cached
     * @type Boolean
     * @default
     */
    caching: true,

    /**
     * @private
     */
    _reSpace: /\s|\n/,

    /**
     * @private
     */
    _currentCursorOpacity: 0,

    /**
     * @private
     */
    _selectionDirection: null,

    /**
     * @private
     */
    _abortCursorAnimation: false,

    /**
     * @private
     */
    __widthOfSpace: [],

    /**
     * Helps determining when the text is in composition, so that the cursor
     * rendering is altered.
     */
    inCompositionMode: false,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.IText} thisArg
     */
    initialize: function(text, options) {
      this.callSuper('initialize', text, options);
      this.initBehavior();
    },

    /**
     * Sets selection start (left boundary of a selection)
     * @param {Number} index Index to set selection start to
     */
    setSelectionStart: function(index) {
      index = Math.max(index, 0);
      this._updateAndFire('selectionStart', index);
    },

    /**
     * Sets selection end (right boundary of a selection)
     * @param {Number} index Index to set selection end to
     */
    setSelectionEnd: function(index) {
      index = Math.min(index, this.text.length);
      this._updateAndFire('selectionEnd', index);
    },

    /**
     * @private
     * @param {String} property 'selectionStart' or 'selectionEnd'
     * @param {Number} index new position of property
     */
    _updateAndFire: function(property, index) {
      if (this[property] !== index) {
        this._fireSelectionChanged();
        this[property] = index;
      }
      this._updateTextarea();
    },

    /**
     * Fires the even of selection changed
     * @private
     */
    _fireSelectionChanged: function() {
      this.fire('selection:changed');
      this.canvas && this.canvas.fire('text:selection:changed', { target: this });
    },

    /**
     * Initialize text dimensions. Render all text on given context
     * or on a offscreen canvas to get the text width with measureText.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     * @private
     */
    initDimensions: function() {
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this.callSuper('initDimensions');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      this.clearContextTop();
      this.callSuper('render', ctx);
      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
      // the correct position but not at every cursor animation.
      this.cursorOffsetCache = { };
      this.renderCursorOrSelection();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this.callSuper('_render', ctx);
    },

    /**
     * Prepare and clean the contextTop
     */
    clearContextTop: function(skipRestore) {
      if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
        return;
      }
      var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      this.transform(ctx);
      this._clearTextArea(ctx);
      skipRestore || ctx.restore();
    },
    /**
     * Renders cursor or selection (depending on what exists)
     * it does on the contextTop. If contextTop is not available, do nothing.
     */
    renderCursorOrSelection: function() {
      if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
        return;
      }
      var boundaries = this._getCursorBoundaries(),
          ctx = this.canvas.contextTop;
      this.clearContextTop(true);
      if (this.selectionStart === this.selectionEnd) {
        this.renderCursor(boundaries, ctx);
      }
      else {
        this.renderSelection(boundaries, ctx);
      }
      ctx.restore();
    },

    _clearTextArea: function(ctx) {
      // we add 4 pixel, to be sure to do not leave any pixel out
      var width = this.width + 4, height = this.height + 4;
      ctx.clearRect(-width / 2, -height / 2, width, height);
    },

    /**
     * Returns cursor boundaries (left, top, leftOffset, topOffset)
     * @private
     * @param {Array} chars Array of characters
     * @param {String} typeOfBoundaries
     */
    _getCursorBoundaries: function(position) {

      // left/top are left/top of entire text box
      // leftOffset/topOffset are offset from that left/top point of a text box

      if (typeof position === 'undefined') {
        position = this.selectionStart;
      }

      var left = this._getLeftOffset(),
          top = this._getTopOffset(),
          offsets = this._getCursorBoundariesOffsets(position);

      return {
        left: left,
        top: top,
        leftOffset: offsets.left,
        topOffset: offsets.top
      };
    },

    /**
     * @private
     */
    _getCursorBoundariesOffsets: function(position) {
      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
        return this.cursorOffsetCache;
      }
      var lineLeftOffset,
          lineIndex,
          charIndex,
          topOffset = 0,
          leftOffset = 0,
          boundaries,
          cursorPosition = this.get2DCursorLocation(position);
      charIndex = cursorPosition.charIndex;
      lineIndex = cursorPosition.lineIndex;
      for (var i = 0; i < lineIndex; i++) {
        topOffset += this.getHeightOfLine(i);
      }
      lineLeftOffset = this._getLineLeftOffset(lineIndex);
      var bound = this.__charBounds[lineIndex][charIndex];
      bound && (leftOffset = bound.left);
      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
        leftOffset -= this._getWidthOfCharSpacing();
      }
      boundaries = {
        top: topOffset,
        left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
      };
      this.cursorOffsetCache = boundaries;
      return this.cursorOffsetCache;
    },

    /**
     * Renders cursor
     * @param {Object} boundaries
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderCursor: function(boundaries, ctx) {
      var cursorLocation = this.get2DCursorLocation(),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
          multiplier = this.scaleX * this.canvas.getZoom(),
          cursorWidth = this.cursorWidth / multiplier,
          topOffset = boundaries.topOffset,
          dy = this.getValueOfPropertyAt(lineIndex, charIndex, 'deltaY');

      topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
        - charHeight * (1 - this._fontSizeFraction);

      if (this.inCompositionMode) {
        this.renderSelection(boundaries, ctx);
      }

      ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
      ctx.fillRect(
        boundaries.left + boundaries.leftOffset - cursorWidth / 2,
        topOffset + boundaries.top + dy,
        cursorWidth,
        charHeight);
    },

    /**
     * Renders text selection
     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderSelection: function(boundaries, ctx) {

      var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
          selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
          isJustify = this.textAlign.indexOf('justify') !== -1,
          start = this.get2DCursorLocation(selectionStart),
          end = this.get2DCursorLocation(selectionEnd),
          startLine = start.lineIndex,
          endLine = end.lineIndex,
          startChar = start.charIndex < 0 ? 0 : start.charIndex,
          endChar = end.charIndex < 0 ? 0 : end.charIndex;

      for (var i = startLine; i <= endLine; i++) {
        var lineOffset = this._getLineLeftOffset(i) || 0,
            lineHeight = this.getHeightOfLine(i),
            realLineHeight = 0, boxStart = 0, boxEnd = 0;

        if (i === startLine) {
          boxStart = this.__charBounds[startLine][startChar].left;
        }
        if (i >= startLine && i < endLine) {
          boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?
        }
        else if (i === endLine) {
          if (endChar === 0) {
            boxEnd = this.__charBounds[endLine][endChar].left;
          }
          else {
            var charSpacing = this._getWidthOfCharSpacing();
            boxEnd = this.__charBounds[endLine][endChar - 1].left
              + this.__charBounds[endLine][endChar - 1].width - charSpacing;
          }
        }
        realLineHeight = lineHeight;
        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
          lineHeight /= this.lineHeight;
        }
        if (this.inCompositionMode) {
          ctx.fillStyle = this.compositionColor || 'black';
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset + lineHeight,
            boxEnd - boxStart,
            1);
        }
        else {
          ctx.fillStyle = this.selectionColor;
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset,
            boxEnd - boxStart,
            lineHeight);
        }


        boundaries.topOffset += realLineHeight;
      }
    },

    /**
     * High level function to know the height of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns fontSize of char at the current cursor
     * Unused from the library, is for the end user
     * @return {Number} Character font size
     */
    getCurrentCharFontSize: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
    },

    /**
     * High level function to know the color of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns color (fill) of char at the current cursor
     * Unused from the library, is for the end user
     * @return {String} Character color (fill)
     */
    getCurrentCharColor: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
    },

    /**
     * Returns the cursor position for the getCurrent.. functions
     * @private
     */
    _getCurrentCharIndex: function() {
      var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
          charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
      return { l: cursorPosition.lineIndex, c: charIndex };
    }
  });

  /**
   * Returns fabric.IText instance from an object representation
   * @static
   * @memberOf fabric.IText
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as argument
   */
  fabric.IText.fromObject = function(object, callback) {
    parseDecoration(object);
    if (object.styles) {
      for (var i in object.styles) {
        for (var j in object.styles[i]) {
          parseDecoration(object.styles[i][j]);
        }
      }
    }
    fabric.Object._fromObject('IText', object, callback, 'text');
  };
})();


(function() {

  var clone = fabric.util.object.clone;

  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes all the interactive behavior of IText
     */
    initBehavior: function() {
      this.initAddedHandler();
      this.initRemovedHandler();
      this.initCursorSelectionHandlers();
      this.initDoubleClickSimulation();
      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
    },

    onDeselect: function() {
      this.isEditing && this.exitEditing();
      this.selected = false;
    },

    /**
     * Initializes "added" event handler
     */
    initAddedHandler: function() {
      var _this = this;
      this.on('added', function() {
        var canvas = _this.canvas;
        if (canvas) {
          if (!canvas._hasITextHandlers) {
            canvas._hasITextHandlers = true;
            _this._initCanvasHandlers(canvas);
          }
          canvas._iTextInstances = canvas._iTextInstances || [];
          canvas._iTextInstances.push(_this);
        }
      });
    },

    initRemovedHandler: function() {
      var _this = this;
      this.on('removed', function() {
        var canvas = _this.canvas;
        if (canvas) {
          canvas._iTextInstances = canvas._iTextInstances || [];
          fabric.util.removeFromArray(canvas._iTextInstances, _this);
          if (canvas._iTextInstances.length === 0) {
            canvas._hasITextHandlers = false;
            _this._removeCanvasHandlers(canvas);
          }
        }
      });
    },

    /**
     * register canvas event to manage exiting on other instances
     * @private
     */
    _initCanvasHandlers: function(canvas) {
      canvas._mouseUpITextHandler = function() {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.__isMousedown = false;
          });
        }
      };
      canvas.on('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * remove canvas event to manage exiting on other instances
     * @private
     */
    _removeCanvasHandlers: function(canvas) {
      canvas.off('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * @private
     */
    _tick: function() {
      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
    },

    /**
     * @private
     */
    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

      var tickState;

      tickState = {
        isAborted: false,
        abort: function() {
          this.isAborted = true;
        },
      };

      obj.animate('_currentCursorOpacity', targetOpacity, {
        duration: duration,
        onComplete: function() {
          if (!tickState.isAborted) {
            obj[completeMethod]();
          }
        },
        onChange: function() {
          // we do not want to animate a selection, only cursor
          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
            obj.renderCursorOrSelection();
          }
        },
        abort: function() {
          return tickState.isAborted;
        }
      });
      return tickState;
    },

    /**
     * @private
     */
    _onTickComplete: function() {

      var _this = this;

      if (this._cursorTimeout1) {
        clearTimeout(this._cursorTimeout1);
      }
      this._cursorTimeout1 = setTimeout(function() {
        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
      }, 100);
    },

    /**
     * Initializes delayed cursor
     */
    initDelayedCursor: function(restart) {
      var _this = this,
          delay = restart ? 0 : this.cursorDelay;

      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this._cursorTimeout2 = setTimeout(function() {
        _this._tick();
      }, delay);
    },

    /**
     * Aborts cursor animation and clears all timeouts
     */
    abortCursorAnimation: function() {
      var shouldClear = this._currentTickState || this._currentTickCompleteState,
          canvas = this.canvas;
      this._currentTickState && this._currentTickState.abort();
      this._currentTickCompleteState && this._currentTickCompleteState.abort();

      clearTimeout(this._cursorTimeout1);
      clearTimeout(this._cursorTimeout2);

      this._currentCursorOpacity = 0;
      // to clear just itext area we need to transform the context
      // it may not be worth it
      if (shouldClear && canvas) {
        canvas.clearContext(canvas.contextTop || canvas.contextContainer);
      }

    },

    /**
     * Selects entire text
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectAll: function() {
      this.selectionStart = 0;
      this.selectionEnd = this._text.length;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Returns selected text
     * @return {String}
     */
    getSelectedText: function() {
      return this._text.slice(this.selectionStart, this.selectionEnd).join('');
    },

    /**
     * Find new selection index representing start of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      // remove space before cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index--;
        }
      }
      while (/\S/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      // remove space after cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index++;
        }
      }
      while (/\S/.test(this._text[index]) && index < this._text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Find new selection index representing start of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      while (!/\n/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      while (!/\n/.test(this._text[index]) && index < this._text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Finds index corresponding to beginning or end of a word
     * @param {Number} selectionStart Index of a character
     * @param {Number} direction 1 or -1
     * @return {Number} Index of the beginning or end of a word
     */
    searchWordBoundary: function(selectionStart, direction) {
      var text = this._text,
          index     = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart,
          _char     = text[index],
          // wrong
          reNonWord = fabric.reNonWord;

      while (!reNonWord.test(_char) && index > 0 && index < text.length) {
        index += direction;
        _char = text[index];
      }
      if (reNonWord.test(_char)) {
        index += direction === 1 ? 0 : 1;
      }
      return index;
    },

    /**
     * Selects a word based on the index
     * @param {Number} selectionStart Index of a character
     */
    selectWord: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      this.renderCursorOrSelection();
    },

    /**
     * Selects a line based on the index
     * @param {Number} selectionStart Index of a character
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectLine: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
          newSelectionEnd = this.findLineBoundaryRight(selectionStart);

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Enters editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    enterEditing: function(e) {
      if (this.isEditing || !this.editable) {
        return;
      }

      if (this.canvas) {
        this.canvas.calcOffset();
        this.exitEditingOnOthers(this.canvas);
      }

      this.isEditing = true;

      this.initHiddenTextarea(e);
      this.hiddenTextarea.focus();
      this.hiddenTextarea.value = this.text;
      this._updateTextarea();
      this._saveEditingProps();
      this._setEditingProps();
      this._textBeforeEdit = this.text;

      this._tick();
      this.fire('editing:entered');
      this._fireSelectionChanged();
      if (!this.canvas) {
        return this;
      }
      this.canvas.fire('text:editing:entered', { target: this });
      this.initMouseMoveHandler();
      this.canvas.requestRenderAll();
      return this;
    },

    exitEditingOnOthers: function(canvas) {
      if (canvas._iTextInstances) {
        canvas._iTextInstances.forEach(function(obj) {
          obj.selected = false;
          if (obj.isEditing) {
            obj.exitEditing();
          }
        });
      }
    },

    /**
     * Initializes "mousemove" event handler
     */
    initMouseMoveHandler: function() {
      this.canvas.on('mouse:move', this.mouseMoveHandler);
    },

    /**
     * @private
     */
    mouseMoveHandler: function(options) {
      if (!this.__isMousedown || !this.isEditing) {
        return;
      }

      var newSelectionStart = this.getSelectionStartFromPointer(options.e),
          currentStart = this.selectionStart,
          currentEnd = this.selectionEnd;
      if (
        (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
        &&
        (currentStart === newSelectionStart || currentEnd === newSelectionStart)
      ) {
        return;
      }
      if (newSelectionStart > this.__selectionStartOnMouseDown) {
        this.selectionStart = this.__selectionStartOnMouseDown;
        this.selectionEnd = newSelectionStart;
      }
      else {
        this.selectionStart = newSelectionStart;
        this.selectionEnd = this.__selectionStartOnMouseDown;
      }
      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
        this.restartCursorIfNeeded();
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      }
    },

    /**
     * @private
     */
    _setEditingProps: function() {
      this.hoverCursor = 'text';

      if (this.canvas) {
        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
      }

      this.borderColor = this.editingBorderColor;
      this.hasControls = this.selectable = false;
      this.lockMovementX = this.lockMovementY = true;
    },

    /**
     * convert from textarea to grapheme indexes
     */
    fromStringToGraphemeSelection: function(start, end, text) {
      var smallerTextStart = text.slice(0, start),
          graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = text.slice(start, end),
          graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * convert from fabric to textarea values
     */
    fromGraphemeToStringSelection: function(start, end, _text) {
      var smallerTextStart = _text.slice(0, start),
          graphemeStart = smallerTextStart.join('').length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = _text.slice(start, end),
          graphemeEnd = smallerTextEnd.join('').length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * @private
     */
    _updateTextarea: function() {
      this.cursorOffsetCache = { };
      if (!this.hiddenTextarea) {
        return;
      }
      if (!this.inCompositionMode) {
        var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = newSelection.selectionStart;
        this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateFromTextArea: function() {
      if (!this.hiddenTextarea) {
        return;
      }
      this.cursorOffsetCache = { };
      this.text = this.hiddenTextarea.value;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      var newSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
      this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
      if (!this.inCompositionMode) {
        this.selectionStart = newSelection.selectionStart;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateTextareaPosition: function() {
      if (this.selectionStart === this.selectionEnd) {
        var style = this._calcTextareaPosition();
        this.hiddenTextarea.style.left = style.left;
        this.hiddenTextarea.style.top = style.top;
      }
    },

    /**
     * @private
     * @return {Object} style contains style for hiddenTextarea
     */
    _calcTextareaPosition: function() {
      if (!this.canvas) {
        return { x: 1, y: 1 };
      }
      var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart,
          boundaries = this._getCursorBoundaries(desiredPosition),
          cursorLocation = this.get2DCursorLocation(desiredPosition),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
          leftOffset = boundaries.leftOffset,
          m = this.calcTransformMatrix(),
          p = {
            x: boundaries.left + leftOffset,
            y: boundaries.top + boundaries.topOffset + charHeight
          },
          retinaScaling = this.canvas.getRetinaScaling(),
          upperCanvas = this.canvas.upperCanvasEl,
          upperCanvasWidth = upperCanvas.width / retinaScaling,
          upperCanvasHeight = upperCanvas.height / retinaScaling,
          maxWidth = upperCanvasWidth - charHeight,
          maxHeight = upperCanvasHeight - charHeight,
          scaleX = upperCanvas.clientWidth / upperCanvasWidth,
          scaleY = upperCanvas.clientHeight / upperCanvasHeight;

      p = fabric.util.transformPoint(p, m);
      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
      p.x *= scaleX;
      p.y *= scaleY;
      if (p.x < 0) {
        p.x = 0;
      }
      if (p.x > maxWidth) {
        p.x = maxWidth;
      }
      if (p.y < 0) {
        p.y = 0;
      }
      if (p.y > maxHeight) {
        p.y = maxHeight;
      }

      // add canvas offset on document
      p.x += this.canvas._offset.left;
      p.y += this.canvas._offset.top;

      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
    },

    /**
     * @private
     */
    _saveEditingProps: function() {
      this._savedProps = {
        hasControls: this.hasControls,
        borderColor: this.borderColor,
        lockMovementX: this.lockMovementX,
        lockMovementY: this.lockMovementY,
        hoverCursor: this.hoverCursor,
        selectable: this.selectable,
        defaultCursor: this.canvas && this.canvas.defaultCursor,
        moveCursor: this.canvas && this.canvas.moveCursor
      };
    },

    /**
     * @private
     */
    _restoreEditingProps: function() {
      if (!this._savedProps) {
        return;
      }

      this.hoverCursor = this._savedProps.hoverCursor;
      this.hasControls = this._savedProps.hasControls;
      this.borderColor = this._savedProps.borderColor;
      this.selectable = this._savedProps.selectable;
      this.lockMovementX = this._savedProps.lockMovementX;
      this.lockMovementY = this._savedProps.lockMovementY;

      if (this.canvas) {
        this.canvas.defaultCursor = this._savedProps.defaultCursor;
        this.canvas.moveCursor = this._savedProps.moveCursor;
      }
    },

    /**
     * Exits from editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    exitEditing: function() {
      var isTextChanged = (this._textBeforeEdit !== this.text);
      var hiddenTextarea = this.hiddenTextarea;
      this.selected = false;
      this.isEditing = false;

      this.selectionEnd = this.selectionStart;

      if (hiddenTextarea) {
        hiddenTextarea.blur && hiddenTextarea.blur();
        hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
      }
      this.hiddenTextarea = null;
      this.abortCursorAnimation();
      this._restoreEditingProps();
      this._currentCursorOpacity = 0;
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
        this.setCoords();
      }
      this.fire('editing:exited');
      isTextChanged && this.fire('modified');
      if (this.canvas) {
        this.canvas.off('mouse:move', this.mouseMoveHandler);
        this.canvas.fire('text:editing:exited', { target: this });
        isTextChanged && this.canvas.fire('object:modified', { target: this });
      }
      return this;
    },

    /**
     * @private
     */
    _removeExtraneousStyles: function() {
      for (var prop in this.styles) {
        if (!this._textLines[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * remove and reflow a style block from start to end.
     * @param {Number} start linear start position for removal (included in removal)
     * @param {Number} end linear end position for removal ( excluded from removal )
     */
    removeStyleFromTo: function(start, end) {
      var cursorStart = this.get2DCursorLocation(start, true),
          cursorEnd = this.get2DCursorLocation(end, true),
          lineStart = cursorStart.lineIndex,
          charStart = cursorStart.charIndex,
          lineEnd = cursorEnd.lineIndex,
          charEnd = cursorEnd.charIndex,
          i, styleObj;
      if (lineStart !== lineEnd) {
        // step1 remove the trailing of lineStart
        if (this.styles[lineStart]) {
          for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
            delete this.styles[lineStart][i];
          }
        }
        // step2 move the trailing of lineEnd to lineStart if needed
        if (this.styles[lineEnd]) {
          for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
            styleObj = this.styles[lineEnd][i];
            if (styleObj) {
              this.styles[lineStart] || (this.styles[lineStart] = { });
              this.styles[lineStart][charStart + i - charEnd] = styleObj;
            }
          }
        }
        // step3 detects lines will be completely removed.
        for (i = lineStart + 1; i <= lineEnd; i++) {
          delete this.styles[i];
        }
        // step4 shift remaining lines.
        this.shiftLineStyles(lineEnd, lineStart - lineEnd);
      }
      else {
        // remove and shift left on the same line
        if (this.styles[lineStart]) {
          styleObj = this.styles[lineStart];
          var diff = charEnd - charStart, numericChar, _char;
          for (i = charStart; i < charEnd; i++) {
            delete styleObj[i];
          }
          for (_char in this.styles[lineStart]) {
            numericChar = parseInt(_char, 10);
            if (numericChar >= charEnd) {
              styleObj[numericChar - diff] = styleObj[_char];
              delete styleObj[_char];
            }
          }
        }
      }
    },

    /**
     * Shifts line styles up or down
     * @param {Number} lineIndex Index of a line
     * @param {Number} offset Can any number?
     */
    shiftLineStyles: function(lineIndex, offset) {
      // shift all line styles by offset upward or downward
      // do not clone deep. we need new array, not new style objects
      var clonedStyles = clone(this.styles);
      for (var line in this.styles) {
        var numericLine = parseInt(line, 10);
        if (numericLine > lineIndex) {
          this.styles[numericLine + offset] = clonedStyles[numericLine];
          if (!clonedStyles[numericLine - offset]) {
            delete this.styles[numericLine];
          }
        }
      }
    },

    restartCursorIfNeeded: function() {
      if (!this._currentTickState || this._currentTickState.isAborted
        || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
      ) {
        this.initDelayedCursor();
      }
    },

    /**
     * Handle insertion of more consecutive style lines for when one or more
     * newlines gets added to the text. Since current style needs to be shifted
     * first we shift the current style of the number lines needed, then we add
     * new lines from the last to the first.
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} qty number of lines to add
     * @param {Array} copiedStyle Array of objects styles
     */
    insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
      var currentCharStyle,
          newLineStyles = {},
          somethingAdded = false,
          isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;

      qty || (qty = 1);
      this.shiftLineStyles(lineIndex, qty);
      if (this.styles[lineIndex]) {
        currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
      }
      // we clone styles of all chars
      // after cursor onto the current line
      for (var index in this.styles[lineIndex]) {
        var numIndex = parseInt(index, 10);
        if (numIndex >= charIndex) {
          somethingAdded = true;
          newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
          // remove lines from the previous line since they're on a new line now
          if (!(isEndOfLine && charIndex === 0)) {
            delete this.styles[lineIndex][index];
          }
        }
      }
      var styleCarriedOver = false;
      if (somethingAdded && !isEndOfLine) {
        // if is end of line, the extra style we copied
        // is probably not something we want
        this.styles[lineIndex + qty] = newLineStyles;
        styleCarriedOver = true;
      }
      if (styleCarriedOver) {
        // skip the last line of since we already prepared it.
        qty--;
      }
      // for the all the lines or all the other lines
      // we clone current char style onto the next (otherwise empty) line
      while (qty > 0) {
        if (copiedStyle && copiedStyle[qty - 1]) {
          this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty - 1]) };
        }
        else if (currentCharStyle) {
          this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
        }
        else {
          delete this.styles[lineIndex + qty];
        }
        qty--;
      }
      this._forceClearCache = true;
    },

    /**
     * Inserts style object for a given line/char index
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} quantity number Style object to insert, if given
     * @param {Array} copiedStyle array of style objects
     */
    insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
      if (!this.styles) {
        this.styles = {};
      }
      var currentLineStyles       = this.styles[lineIndex],
          currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

      quantity || (quantity = 1);
      // shift all char styles by quantity forward
      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
      for (var index in currentLineStylesCloned) {
        var numericIndex = parseInt(index, 10);
        if (numericIndex >= charIndex) {
          currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
          // only delete the style if there was nothing moved there
          if (!currentLineStylesCloned[numericIndex - quantity]) {
            delete currentLineStyles[numericIndex];
          }
        }
      }
      this._forceClearCache = true;
      if (copiedStyle) {
        while (quantity--) {
          if (!Object.keys(copiedStyle[quantity]).length) {
            continue;
          }
          if (!this.styles[lineIndex]) {
            this.styles[lineIndex] = {};
          }
          this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
        }
        return;
      }
      if (!currentLineStyles) {
        return;
      }
      var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
      while (newStyle && quantity--) {
        this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
      }
    },

    /**
     * Inserts style object(s)
     * @param {Array} insertedText Characters at the location where style is inserted
     * @param {Number} start cursor index for inserting style
     * @param {Array} [copiedStyle] array of style objects to insert.
     */
    insertNewStyleBlock: function(insertedText, start, copiedStyle) {
      var cursorLoc = this.get2DCursorLocation(start, true),
          addedLines = [0], linesLength = 0;
      // get an array of how many char per lines are being added.
      for (var i = 0; i < insertedText.length; i++) {
        if (insertedText[i] === '\n') {
          linesLength++;
          addedLines[linesLength] = 0;
        }
        else {
          addedLines[linesLength]++;
        }
      }
      // for the first line copy the style from the current char position.
      if (addedLines[0] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
      }
      linesLength && this.insertNewlineStyleObject(
        cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);
      for (var i = 1; i < linesLength; i++) {
        if (addedLines[i] > 0) {
          this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        }
        else if (copiedStyle) {
          this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
        }
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
      }
      // we use i outside the loop to get it like linesLength
      if (addedLines[i] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
      }
    },

    /**
     * Set the selectionStart and selectionEnd according to the new position of cursor
     * mimic the key - mouse navigation when shift is pressed.
     */
    setSelectionStartEndWithShift: function(start, end, newSelection) {
      if (newSelection <= start) {
        if (end === start) {
          this._selectionDirection = 'left';
        }
        else if (this._selectionDirection === 'right') {
          this._selectionDirection = 'left';
          this.selectionEnd = start;
        }
        this.selectionStart = newSelection;
      }
      else if (newSelection > start && newSelection < end) {
        if (this._selectionDirection === 'right') {
          this.selectionEnd = newSelection;
        }
        else {
          this.selectionStart = newSelection;
        }
      }
      else {
        // newSelection is > selection start and end
        if (end === start) {
          this._selectionDirection = 'right';
        }
        else if (this._selectionDirection === 'left') {
          this._selectionDirection = 'right';
          this.selectionStart = end;
        }
        this.selectionEnd = newSelection;
      }
    },

    setSelectionInBoundaries: function() {
      var length = this.text.length;
      if (this.selectionStart > length) {
        this.selectionStart = length;
      }
      else if (this.selectionStart < 0) {
        this.selectionStart = 0;
      }
      if (this.selectionEnd > length) {
        this.selectionEnd = length;
      }
      else if (this.selectionEnd < 0) {
        this.selectionEnd = 0;
      }
    }
  });
})();


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
  /**
   * Initializes "dbclick" event handler
   */
  initDoubleClickSimulation: function() {

    // for double click
    this.__lastClickTime = +new Date();

    // for triple click
    this.__lastLastClickTime = +new Date();

    this.__lastPointer = { };

    this.on('mousedown', this.onMouseDown);
  },

  /**
   * Default event handler to simulate triple click
   * @private
   */
  onMouseDown: function(options) {
    if (!this.canvas) {
      return;
    }
    this.__newClickTime = +new Date();
    var newPointer = options.pointer;
    if (this.isTripleClick(newPointer)) {
      this.fire('tripleclick', options);
      this._stopEvent(options.e);
    }
    this.__lastLastClickTime = this.__lastClickTime;
    this.__lastClickTime = this.__newClickTime;
    this.__lastPointer = newPointer;
    this.__lastIsEditing = this.isEditing;
    this.__lastSelected = this.selected;
  },

  isTripleClick: function(newPointer) {
    return this.__newClickTime - this.__lastClickTime < 500 &&
        this.__lastClickTime - this.__lastLastClickTime < 500 &&
        this.__lastPointer.x === newPointer.x &&
        this.__lastPointer.y === newPointer.y;
  },

  /**
   * @private
   */
  _stopEvent: function(e) {
    e.preventDefault && e.preventDefault();
    e.stopPropagation && e.stopPropagation();
  },

  /**
   * Initializes event handlers related to cursor or selection
   */
  initCursorSelectionHandlers: function() {
    this.initMousedownHandler();
    this.initMouseupHandler();
    this.initClicks();
  },

  /**
   * Default handler for double click, select a word
   */
  doubleClickHandler: function(options) {
    if (!this.isEditing) {
      return;
    }
    this.selectWord(this.getSelectionStartFromPointer(options.e));
  },

  /**
   * Default handler for triple click, select a line
   */
  tripleClickHandler: function(options) {
    if (!this.isEditing) {
      return;
    }
    this.selectLine(this.getSelectionStartFromPointer(options.e));
  },

  /**
   * Initializes double and triple click event handlers
   */
  initClicks: function() {
    this.on('mousedblclick', this.doubleClickHandler);
    this.on('tripleclick', this.tripleClickHandler);
  },

  /**
   * Default event handler for the basic functionalities needed on _mouseDown
   * can be overridden to do something different.
   * Scope of this implementation is: find the click position, set selectionStart
   * find selectionEnd, initialize the drawing of either cursor or selection area
   * initializing a mousedDown on a text area will cancel fabricjs knowledge of
   * current compositionMode. It will be set to false.
   */
  _mouseDownHandler: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }

    this.__isMousedown = true;

    if (this.selected) {
      this.inCompositionMode = false;
      this.setCursorByClick(options.e);
    }

    if (this.isEditing) {
      this.__selectionStartOnMouseDown = this.selectionStart;
      if (this.selectionStart === this.selectionEnd) {
        this.abortCursorAnimation();
      }
      this.renderCursorOrSelection();
    }
  },

  /**
   * Default event handler for the basic functionalities needed on mousedown:before
   * can be overridden to do something different.
   * Scope of this implementation is: verify the object is already selected when mousing down
   */
  _mouseDownHandlerBefore: function(options) {
    if (!this.canvas || !this.editable || (options.e.button && options.e.button !== 1)) {
      return;
    }
    // we want to avoid that an object that was selected and then becomes unselectable,
    // may trigger editing mode in some way.
    this.selected = this === this.canvas._activeObject;
  },

  /**
   * Initializes "mousedown" event handler
   */
  initMousedownHandler: function() {
    this.on('mousedown', this._mouseDownHandler);
    this.on('mousedown:before', this._mouseDownHandlerBefore);
  },

  /**
   * Initializes "mouseup" event handler
   */
  initMouseupHandler: function() {
    this.on('mouseup', this.mouseUpHandler);
  },

  /**
   * standard handler for mouse up, overridable
   * @private
   */
  mouseUpHandler: function(options) {
    this.__isMousedown = false;
    if (!this.editable || this.group ||
      (options.transform && options.transform.actionPerformed) ||
      (options.e.button && options.e.button !== 1)) {
      return;
    }

    if (this.canvas) {
      var currentActive = this.canvas._activeObject;
      if (currentActive && currentActive !== this) {
        // avoid running this logic when there is an active object
        // this because is possible with shift click and fast clicks,
        // to rapidly deselect and reselect this object and trigger an enterEdit
        return;
      }
    }

    if (this.__lastSelected && !this.__corner) {
      this.selected = false;
      this.__lastSelected = false;
      this.enterEditing(options.e);
      if (this.selectionStart === this.selectionEnd) {
        this.initDelayedCursor(true);
      }
      else {
        this.renderCursorOrSelection();
      }
    }
    else {
      this.selected = true;
    }
  },

  /**
   * Changes cursor location in a text depending on passed pointer (x/y) object
   * @param {Event} e Event object
   */
  setCursorByClick: function(e) {
    var newSelection = this.getSelectionStartFromPointer(e),
        start = this.selectionStart, end = this.selectionEnd;
    if (e.shiftKey) {
      this.setSelectionStartEndWithShift(start, end, newSelection);
    }
    else {
      this.selectionStart = newSelection;
      this.selectionEnd = newSelection;
    }
    if (this.isEditing) {
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Returns index of a character corresponding to where an object was clicked
   * @param {Event} e Event object
   * @return {Number} Index of a character
   */
  getSelectionStartFromPointer: function(e) {
    var mouseOffset = this.getLocalPointer(e),
        prevWidth = 0,
        width = 0,
        height = 0,
        charIndex = 0,
        lineIndex = 0,
        lineLeftOffset,
        line;

    for (var i = 0, len = this._textLines.length; i < len; i++) {
      if (height <= mouseOffset.y) {
        height += this.getHeightOfLine(i) * this.scaleY;
        lineIndex = i;
        if (i > 0) {
          charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);
        }
      }
      else {
        break;
      }
    }
    lineLeftOffset = this._getLineLeftOffset(lineIndex);
    width = lineLeftOffset * this.scaleX;
    line = this._textLines[lineIndex];
    for (var j = 0, jlen = line.length; j < jlen; j++) {
      prevWidth = width;
      // i removed something about flipX here, check.
      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
      if (width <= mouseOffset.x) {
        charIndex++;
      }
      else {
        break;
      }
    }
    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
  },

  /**
   * @private
   */
  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
    // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0
    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
        distanceBtwNextCharAndCursor = width - mouseOffset.x,
        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ||
          distanceBtwNextCharAndCursor < 0 ? 0 : 1,
        newSelectionStart = index + offset;
    // if object is horizontally flipped, mirror cursor location from the end
    if (this.flipX) {
      newSelectionStart = jlen - newSelectionStart;
    }

    if (newSelectionStart > this._text.length) {
      newSelectionStart = this._text.length;
    }

    return newSelectionStart;
  }
});


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

  /**
   * Initializes hidden textarea (needed to bring up keyboard in iOS)
   */
  initHiddenTextarea: function() {
    this.hiddenTextarea = fabric.document.createElement('textarea');
    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
    this.hiddenTextarea.setAttribute('autocorrect', 'off');
    this.hiddenTextarea.setAttribute('autocomplete', 'off');
    this.hiddenTextarea.setAttribute('spellcheck', 'false');
    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
    this.hiddenTextarea.setAttribute('wrap', 'off');
    var style = this._calcTextareaPosition();
    // line-height: 1px; was removed from the style to fix this:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=870966
    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
    ' paddingｰtop: ' + style.fontSize + ';';
    fabric.document.body.appendChild(this.hiddenTextarea);

    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

    if (!this._clickHandlerInitialized && this.canvas) {
      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
      this._clickHandlerInitialized = true;
    }
  },

  /**
   * For functionalities on keyDown
   * Map a special key to a function of the instance/prototype
   * If you need different behaviour for ESC or TAB or arrows, you have to change
   * this map setting the name of a function that you build on the fabric.Itext or
   * your prototype.
   * the map change will affect all Instances unless you need for only some text Instances
   * in that case you have to clone this object and assign your Instance.
   * this.keysMap = fabric.util.object.clone(this.keysMap);
   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
   */
  keysMap: {
    9:  'exitEditing',
    27: 'exitEditing',
    33: 'moveCursorUp',
    34: 'moveCursorDown',
    35: 'moveCursorRight',
    36: 'moveCursorLeft',
    37: 'moveCursorLeft',
    38: 'moveCursorUp',
    39: 'moveCursorRight',
    40: 'moveCursorDown',
  },

  /**
   * For functionalities on keyUp + ctrl || cmd
   */
  ctrlKeysMapUp: {
    67: 'copy',
    88: 'cut'
  },

  /**
   * For functionalities on keyDown + ctrl || cmd
   */
  ctrlKeysMapDown: {
    65: 'selectAll'
  },

  onClick: function() {
    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
    this.hiddenTextarea && this.hiddenTextarea.focus();
  },

  /**
   * Handles keydown event
   * only used for arrows and combination of modifier keys.
   * @param {Event} e Event object
   */
  onKeyDown: function(e) {
    if (!this.isEditing) {
      return;
    }
    if (e.keyCode in this.keysMap) {
      this[this.keysMap[e.keyCode]](e);
    }
    else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    if (e.keyCode >= 33 && e.keyCode <= 40) {
      // if i press an arrow key just update selection
      this.inCompositionMode = false;
      this.clearContextTop();
      this.renderCursorOrSelection();
    }
    else {
      this.canvas && this.canvas.requestRenderAll();
    }
  },

  /**
   * Handles keyup event
   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
   * if a copy/cut event fired, keyup is dismissed
   * @param {Event} e Event object
   */
  onKeyUp: function(e) {
    if (!this.isEditing || this._copyDone || this.inCompositionMode) {
      this._copyDone = false;
      return;
    }
    if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapUp[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.canvas && this.canvas.requestRenderAll();
  },

  /**
   * Handles onInput event
   * @param {Event} e Event object
   */
  onInput: function(e) {
    var fromPaste = this.fromPaste;
    this.fromPaste = false;
    e && e.stopPropagation();
    if (!this.isEditing) {
      return;
    }
    // decisions about style changes.
    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
        charCount = this._text.length,
        nextCharCount = nextText.length,
        removedText, insertedText,
        charDiff = nextCharCount - charCount,
        selectionStart = this.selectionStart, selectionEnd = this.selectionEnd,
        selection = selectionStart !== selectionEnd,
        copiedStyle, removeFrom, removeTo;
    if (this.hiddenTextarea.value === '') {
      this.styles = { };
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
      return;
    }

    var textareaSelection = this.fromStringToGraphemeSelection(
      this.hiddenTextarea.selectionStart,
      this.hiddenTextarea.selectionEnd,
      this.hiddenTextarea.value
    );
    var backDelete = selectionStart > textareaSelection.selectionStart;

    if (selection) {
      removedText = this._text.slice(selectionStart, selectionEnd);
      charDiff += selectionEnd - selectionStart;
    }
    else if (nextCharCount < charCount) {
      if (backDelete) {
        removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);
      }
      else {
        removedText = this._text.slice(selectionStart, selectionStart - charDiff);
      }
    }
    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
    if (removedText && removedText.length) {
      if (insertedText.length) {
        // let's copy some style before deleting.
        // we want to copy the style before the cursor OR the style at the cursor if selection
        // is bigger than 0.
        copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);
        // now duplicate the style one for each inserted text.
        copiedStyle = insertedText.map(function() {
          // this return an array of references, but that is fine since we are
          // copying the style later.
          return copiedStyle[0];
        });
      }
      if (selection) {
        removeFrom = selectionStart;
        removeTo = selectionEnd;
      }
      else if (backDelete) {
        // detect differences between forwardDelete and backDelete
        removeFrom = selectionEnd - removedText.length;
        removeTo = selectionEnd;
      }
      else {
        removeFrom = selectionEnd;
        removeTo = selectionEnd + removedText.length;
      }
      this.removeStyleFromTo(removeFrom, removeTo);
    }
    if (insertedText.length) {
      if (fromPaste && insertedText.join('') === fabric.copiedText && !fabric.disableStyleCopyPaste) {
        copiedStyle = fabric.copiedTextStyle;
      }
      this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);
    }
    this.updateFromTextArea();
    this.fire('changed');
    if (this.canvas) {
      this.canvas.fire('text:changed', { target: this });
      this.canvas.requestRenderAll();
    }
  },
  /**
   * Composition start
   */
  onCompositionStart: function() {
    this.inCompositionMode = true;
  },

  /**
   * Composition end
   */
  onCompositionEnd: function() {
    this.inCompositionMode = false;
  },

  // /**
  //  * Composition update
  //  */
  onCompositionUpdate: function(e) {
    this.compositionStart = e.target.selectionStart;
    this.compositionEnd = e.target.selectionEnd;
    this.updateTextareaPosition();
  },

  /**
   * Copies selected text
   * @param {Event} e Event object
   */
  copy: function() {
    if (this.selectionStart === this.selectionEnd) {
      //do not cut-copy if no selection
      return;
    }

    fabric.copiedText = this.getSelectedText();
    if (!fabric.disableStyleCopyPaste) {
      fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
    }
    else {
      fabric.copiedTextStyle = null;
    }
    this._copyDone = true;
  },

  /**
   * Pastes text
   * @param {Event} e Event object
   */
  paste: function() {
    this.fromPaste = true;
  },

  /**
   * @private
   * @param {Event} e Event object
   * @return {Object} Clipboard data object
   */
  _getClipboardData: function(e) {
    return (e && e.clipboardData) || fabric.window.clipboardData;
  },

  /**
   * Finds the width in pixels before the cursor on the same line
   * @private
   * @param {Number} lineIndex
   * @param {Number} charIndex
   * @return {Number} widthBeforeCursor width before cursor
   */
  _getWidthBeforeCursor: function(lineIndex, charIndex) {
    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

    if (charIndex > 0) {
      bound = this.__charBounds[lineIndex][charIndex - 1];
      widthBeforeCursor += bound.left + bound.width;
    }
    return widthBeforeCursor;
  },

  /**
   * Gets start offset of a selection
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getDownCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    // if on last line, down cursor goes to end of line
    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
      // move to the end of a text
      return this._text.length - selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
    return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
  },

  /**
   * private
   * Helps finding if the offset should be counted from Start or End
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  _getSelectionForOffset: function(e, isRight) {
    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
      return this.selectionEnd;
    }
    else {
      return this.selectionStart;
    }
  },

  /**
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getUpCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
      // if on first line, up cursor goes to start of line
      return -selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),
        missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
    // return a negative offset
    return -this._textLines[lineIndex - 1].length
     + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
  },

  /**
   * for a given width it founds the matching character.
   * @private
   */
  _getIndexOnLine: function(lineIndex, width) {

    var line = this._textLines[lineIndex],
        lineLeftOffset = this._getLineLeftOffset(lineIndex),
        widthOfCharsOnLine = lineLeftOffset,
        indexOnLine = 0, charWidth, foundMatch;

    for (var j = 0, jlen = line.length; j < jlen; j++) {
      charWidth = this.__charBounds[lineIndex][j].width;
      widthOfCharsOnLine += charWidth;
      if (widthOfCharsOnLine > width) {
        foundMatch = true;
        var leftEdge = widthOfCharsOnLine - charWidth,
            rightEdge = widthOfCharsOnLine,
            offsetFromLeftEdge = Math.abs(leftEdge - width),
            offsetFromRightEdge = Math.abs(rightEdge - width);

        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
        break;
      }
    }

    // reached end
    if (!foundMatch) {
      indexOnLine = line.length - 1;
    }

    return indexOnLine;
  },


  /**
   * Moves cursor down
   * @param {Event} e Event object
   */
  moveCursorDown: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorUpOrDown('Down', e);
  },

  /**
   * Moves cursor up
   * @param {Event} e Event object
   */
  moveCursorUp: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorUpOrDown('Up', e);
  },

  /**
   * Moves cursor up or down, fires the events
   * @param {String} direction 'Up' or 'Down'
   * @param {Event} e Event object
   */
  _moveCursorUpOrDown: function(direction, e) {
    // getUpCursorOffset
    // getDownCursorOffset
    var action = 'get' + direction + 'CursorOffset',
        offset = this[action](e, this._selectionDirection === 'right');
    if (e.shiftKey) {
      this.moveCursorWithShift(offset);
    }
    else {
      this.moveCursorWithoutShift(offset);
    }
    if (offset !== 0) {
      this.setSelectionInBoundaries();
      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor with shift
   * @param {Number} offset
   */
  moveCursorWithShift: function(offset) {
    var newSelection = this._selectionDirection === 'left'
      ? this.selectionStart + offset
      : this.selectionEnd + offset;
    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
    return offset !== 0;
  },

  /**
   * Moves cursor up without shift
   * @param {Number} offset
   */
  moveCursorWithoutShift: function(offset) {
    if (offset < 0) {
      this.selectionStart += offset;
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionEnd += offset;
      this.selectionStart = this.selectionEnd;
    }
    return offset !== 0;
  },

  /**
   * Moves cursor left
   * @param {Event} e Event object
   */
  moveCursorLeft: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorLeftOrRight('Left', e);
  },

  /**
   * @private
   * @return {Boolean} true if a change happened
   */
  _move: function(e, prop, direction) {
    var newValue;
    if (e.altKey) {
      newValue = this['findWordBoundary' + direction](this[prop]);
    }
    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
      newValue = this['findLineBoundary' + direction](this[prop]);
    }
    else {
      this[prop] += direction === 'Left' ? -1 : 1;
      return true;
    }
    if (typeof newValue !== undefined && this[prop] !== newValue) {
      this[prop] = newValue;
      return true;
    }
  },

  /**
   * @private
   */
  _moveLeft: function(e, prop) {
    return this._move(e, prop, 'Left');
  },

  /**
   * @private
   */
  _moveRight: function(e, prop) {
    return this._move(e, prop, 'Right');
  },

  /**
   * Moves cursor left without keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithoutShift: function(e) {
    var change = true;
    this._selectionDirection = 'left';

    // only move cursor when there is no selection,
    // otherwise we discard it, and leave cursor on same place
    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
      change = this._moveLeft(e, 'selectionStart');

    }
    this.selectionEnd = this.selectionStart;
    return change;
  },

  /**
   * Moves cursor left while keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithShift: function(e) {
    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
      return this._moveLeft(e, 'selectionEnd');
    }
    else if (this.selectionStart !== 0){
      this._selectionDirection = 'left';
      return this._moveLeft(e, 'selectionStart');
    }
  },

  /**
   * Moves cursor right
   * @param {Event} e Event object
   */
  moveCursorRight: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorLeftOrRight('Right', e);
  },

  /**
   * Moves cursor right or Left, fires event
   * @param {String} direction 'Left', 'Right'
   * @param {Event} e Event object
   */
  _moveCursorLeftOrRight: function(direction, e) {
    var actionName = 'moveCursor' + direction + 'With';
    this._currentCursorOpacity = 1;

    if (e.shiftKey) {
      actionName += 'Shift';
    }
    else {
      actionName += 'outShift';
    }
    if (this[actionName](e)) {
      this.abortCursorAnimation();
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor right while keeping selection
   * @param {Event} e
   */
  moveCursorRightWithShift: function(e) {
    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
      return this._moveRight(e, 'selectionStart');
    }
    else if (this.selectionEnd !== this._text.length) {
      this._selectionDirection = 'right';
      return this._moveRight(e, 'selectionEnd');
    }
  },

  /**
   * Moves cursor right without keeping selection
   * @param {Event} e Event object
   */
  moveCursorRightWithoutShift: function(e) {
    var changed = true;
    this._selectionDirection = 'right';

    if (this.selectionStart === this.selectionEnd) {
      changed = this._moveRight(e, 'selectionStart');
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionStart = this.selectionEnd;
    }
    return changed;
  },

  /**
   * Removes characters from start/end
   * start/end ar per grapheme position in _text array.
   *
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  removeChars: function(start, end) {
    if (typeof end === 'undefined') {
      end = start + 1;
    }
    this.removeStyleFromTo(start, end);
    this._text.splice(start, end - start);
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

  /**
   * insert characters at start position, before start position.
   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
   * if style array is provided, it must be as the same length of text in graphemes
   * if end is provided and is bigger than start, old text is replaced.
   * start/end ar per grapheme position in _text array.
   *
   * @param {String} text text to insert
   * @param {Array} style array of style objects
   * @param {Number} start
   * @param {Number} end default to start + 1
   */
  insertChars: function(text, style, start, end) {
    if (typeof end === 'undefined') {
      end = start;
    }
    if (end > start) {
      this.removeStyleFromTo(start, end);
    }
    var graphemes = fabric.util.string.graphemeSplit(text);
    this.insertNewStyleBlock(graphemes, start, style);
    this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
    this.text = this._text.join('');
    this.set('dirty', true);
    if (this._shouldClearDimensionCache()) {
      this.initDimensions();
      this.setCoords();
    }
    this._removeExtraneousStyles();
  },

});


/* _TO_SVG_START_ */
(function() {
  var toFixed = fabric.util.toFixed,
      multipleSpacesRegex = /  +/g;

  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    _toSVG: function() {
      var offsets = this._getSVGLeftTopOffsets(),
          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
      return this._wrapSVGTextAndBg(textAndBg);
    },

    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      return this._createBaseSVGMarkup(
        this._toSVG(),
        { reviver: reviver, noStyle: true, withShadow: true }
      );
    },

    /**
     * @private
     */
    _getSVGLeftTopOffsets: function() {
      return {
        textLeft: -this.width / 2,
        textTop: -this.height / 2,
        lineTop: this.getHeightOfLine(0)
      };
    },

    /**
     * @private
     */
    _wrapSVGTextAndBg: function(textAndBg) {
      var noShadow = true,
          textDecoration = this.getSvgTextDecoration(this);
      return [
        textAndBg.textBgRects.join(''),
        '\t\t<text xml:space="preserve" ',
        (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
        (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
        (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
        (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
        (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
        'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
        textAndBg.textSpans.join(''),
        '</text>\n'
      ];
    },

    /**
     * @private
     * @param {Number} textTopOffset Text top offset
     * @param {Number} textLeftOffset Text left offset
     * @return {Object}
     */
    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
      var textSpans = [],
          textBgRects = [],
          height = textTopOffset, lineOffset;
      // bounding-box background
      this._setSVGBg(textBgRects);

      // text and text-background
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineOffset = this._getLineLeftOffset(i);
        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
        }
        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
        height += this.getHeightOfLine(i);
      }

      return {
        textSpans: textSpans,
        textBgRects: textBgRects
      };
    },

    /**
     * @private
     */
    _createTextCharSpan: function(_char, styleDecl, left, top) {
      var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
          styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
          fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
          dy = styleDecl.deltaY, dySpan = '',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      if (dy) {
        dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
      }
      return [
        '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
        toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
        fillStyles, '>',
        fabric.util.string.escapeXml(_char),
        '</tspan>'
      ].join('');
    },

    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          isJustify = this.textAlign.indexOf('justify') !== -1,
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox, style,
          boxWidth = 0,
          line = this._textLines[lineIndex],
          timeToRender;

      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          textLeftOffset += charBox.kernedWidth - charBox.width;
          boxWidth += charBox.width;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
        if (isJustify && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
        }
        if (timeToRender) {
          style = this._getStyleDeclaration(lineIndex, i) || { };
          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
          charsToRender = '';
          actualStyle = nextStyle;
          textLeftOffset += boxWidth;
          boxWidth = 0;
        }
      }
    },

    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
      textBgRects.push(
        '\t\t<rect ',
        this._getFillAttributes(color),
        ' x="',
        toFixed(left, NUM_FRACTION_DIGITS),
        '" y="',
        toFixed(top, NUM_FRACTION_DIGITS),
        '" width="',
        toFixed(width, NUM_FRACTION_DIGITS),
        '" height="',
        toFixed(height, NUM_FRACTION_DIGITS),
        '"></rect>\n');
    },

    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
      var line = this._textLines[i],
          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
          boxWidth = 0,
          boxStart = 0,
          charBox, currentColor,
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charBox = this.__charBounds[i][j];
        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
        if (currentColor !== lastColor) {
          lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
            textTopOffset, boxWidth, heightOfLine);
          boxStart = charBox.left;
          boxWidth = charBox.width;
          lastColor = currentColor;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
      }
      currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
        textTopOffset, boxWidth, heightOfLine);
    },

    /**
     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
     *
     * @private
     * @param {*} value
     * @return {String}
     */
    _getFillAttributes: function(value) {
      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
        return 'fill="' + value + '"';
      }
      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
    },

    /**
     * @private
     */
    _getSVGLineTopOffset: function(lineIndex) {
      var lineTopOffset = 0, lastHeight = 0;
      for (var j = 0; j < lineIndex; j++) {
        lineTopOffset += this.getHeightOfLine(j);
      }
      lastHeight = this.getHeightOfLine(j);
      return {
        lineTop: lineTopOffset,
        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
      };
    },

    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {
      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
      return svgStyle + ' white-space: pre;';
    },
  });
})();
/* _TO_SVG_END_ */


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = {});

  /**
   * Textbox class, based on IText, allows the user to resize the text rectangle
   * and wraps lines automatically. Textboxes have their Y scaling locked, the
   * user can only change width. Height is adjusted automatically based on the
   * wrapping of lines.
   * @class fabric.Textbox
   * @extends fabric.IText
   * @mixes fabric.Observable
   * @return {fabric.Textbox} thisArg
   * @see {@link fabric.Textbox#initialize} for constructor definition
   */
  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'textbox',

    /**
     * Minimum width of textbox, in pixels.
     * @type Number
     * @default
     */
    minWidth: 20,

    /**
     * Minimum calculated width of a textbox, in pixels.
     * fixed to 2 so that an empty textbox cannot go to 0
     * and is still selectable without text.
     * @type Number
     * @default
     */
    dynamicMinWidth: 2,

    /**
     * Cached array of text wrapping.
     * @type Array
     */
    __cachedLines: null,

    /**
     * Override standard Object class values
     */
    lockScalingFlip: true,

    /**
     * Override standard Object class values
     * Textbox needs this on false
     */
    noScaleCache: false,

    /**
     * Properties which when set cause object to change dimensions
     * @type Object
     * @private
     */
    _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat('width'),

    /**
     * Use this regular expression to split strings in breakable lines
     * @private
     */
    _wordJoiners: /[ \t\r]/,

    /**
     * Use this boolean property in order to split strings that have no white space concept.
     * this is a cheap way to help with chinese/japanese
     * @type Boolean
     * @since 2.6.0
     */
    splitByGrapheme: false,

    /**
     * Unlike superclass's version of this function, Textbox does not update
     * its width.
     * @private
     * @override
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this._clearCache();
      // clear dynamicMinWidth as it will be different after we re-wrap line
      this.dynamicMinWidth = 0;
      // wrap lines
      this._styleMap = this._generateStyleMap(this._splitText());
      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
      if (this.dynamicMinWidth > this.width) {
        this._set('width', this.dynamicMinWidth);
      }
      if (this.textAlign.indexOf('justify') !== -1) {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      // clear cache and re-calculate height
      this.height = this.calcTextHeight();
      this.saveState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Generate an object that translates the style object so that it is
     * broken up by visual lines (new lines and automatic wrapping).
     * The original text styles object is broken up by actual lines (new lines only),
     * which is only sufficient for Text / IText
     * @private
     */
    _generateStyleMap: function(textInfo) {
      var realLineCount     = 0,
          realLineCharCount = 0,
          charCount         = 0,
          map               = {};

      for (var i = 0; i < textInfo.graphemeLines.length; i++) {
        if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
          realLineCharCount = 0;
          charCount++;
          realLineCount++;
        }
        else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
          // this case deals with space's that are removed from end of lines when wrapping
          realLineCharCount++;
          charCount++;
        }

        map[i] = { line: realLineCount, offset: realLineCharCount };

        charCount += textInfo.graphemeLines[i].length;
        realLineCharCount += textInfo.graphemeLines[i].length;
      }

      return map;
    },

    /**
     * Returns true if object has a style property or has it on a specified line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (map) {
          lineIndex = map.line;
        }
      }
      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
    },

    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex , lineIndex is on wrapped lines.
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false,
          map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
      if (map) {
        lineIndex = map.line;
        offset = map.offset;
      }
      if (mapNextLine) {
        nextLineIndex = mapNextLine.line;
        shouldLimit = nextLineIndex === lineIndex;
        nextOffset = mapNextLine.offset;
      }
      obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
            // eslint-disable-next-line no-unused-vars
            for (var p3 in obj[p1][p2]) {
              return false;
            }
          }
        }
      }
      return true;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (!map) {
          return null;
        }
        lineIndex = map.line;
        charIndex = map.offset + charIndex;
      }
      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;

      this.styles[lineIndex][charIndex] = style;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * probably broken need a fix
     * Returns the real style line that correspond to the wrapped lineIndex line
     * Used just to verify if the line does exist or not.
     * @param {Number} lineIndex
     * @returns {Boolean} if the line exists or not
     * @private
     */
    _getLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      return !!this.styles[map.line];
    },

    /**
     * Set the line style to an empty object so that is initialized
     * @param {Number} lineIndex
     * @param {Object} style
     * @private
     */
    _setLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      this.styles[map.line] = {};
    },

    /**
     * Wraps text using the 'width' property of Textbox. First this function
     * splits text on newlines, so we preserve newlines entered by the user.
     * Then it wraps each line using the width of the Textbox by calling
     * _wrapLine().
     * @param {Array} lines The string array of text that is split into lines
     * @param {Number} desiredWidth width you want to wrap to
     * @returns {Array} Array of lines
     */
    _wrapText: function(lines, desiredWidth) {
      var wrapped = [], i;
      this.isWrapping = true;
      for (i = 0; i < lines.length; i++) {
        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
      }
      this.isWrapping = false;
      return wrapped;
    },

    /**
     * Helper function to measure a string of text, given its lineIndex and charIndex offset
     * it gets called when charBounds are not available yet.
     * @param {CanvasRenderingContext2D} ctx
     * @param {String} text
     * @param {number} lineIndex
     * @param {number} charOffset
     * @returns {number}
     * @private
     */
    _measureWord: function(word, lineIndex, charOffset) {
      var width = 0, prevGrapheme, skipLeft = true;
      charOffset = charOffset || 0;
      for (var i = 0, len = word.length; i < len; i++) {
        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
        width += box.kernedWidth;
        prevGrapheme = word[i];
      }
      return width;
    },

    /**
     * Wraps a line of text using the width of the Textbox and a context.
     * @param {Array} line The grapheme array that represent the line
     * @param {Number} lineIndex
     * @param {Number} desiredWidth width you want to wrap the line to
     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
     * @returns {Array} Array of line(s) into which the given text is wrapped
     * to.
     */
    _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
      var lineWidth = 0,
          splitByGrapheme = this.splitByGrapheme,
          graphemeLines = [],
          line = [],
          // spaces in different languages?
          words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners),
          word = '',
          offset = 0,
          infix = splitByGrapheme ? '' : ' ',
          wordWidth = 0,
          infixWidth = 0,
          largestWordWidth = 0,
          lineJustStarted = true,
          additionalSpace = this._getWidthOfCharSpacing(),
          reservedSpace = reservedSpace || 0;
      // fix a difference between split and graphemeSplit
      if (words.length === 0) {
        words.push([]);
      }
      desiredWidth -= reservedSpace;
      for (var i = 0; i < words.length; i++) {
        // if using splitByGrapheme words are already in graphemes.
        word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);
        wordWidth = this._measureWord(word, lineIndex, offset);
        offset += word.length;

        lineWidth += infixWidth + wordWidth - additionalSpace;
        if (lineWidth > desiredWidth && !lineJustStarted) {
          graphemeLines.push(line);
          line = [];
          lineWidth = wordWidth;
          lineJustStarted = true;
        }
        else {
          lineWidth += additionalSpace;
        }

        if (!lineJustStarted && !splitByGrapheme) {
          line.push(infix);
        }
        line = line.concat(word);

        infixWidth = splitByGrapheme ? 0 : this._measureWord([infix], lineIndex, offset);
        offset++;
        lineJustStarted = false;
        // keep track of largest word
        if (wordWidth > largestWordWidth) {
          largestWordWidth = wordWidth;
        }
      }

      i && graphemeLines.push(line);

      if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
        this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
      }
      return graphemeLines;
    },

    /**
     * Detect if the text line is ended with an hard break
     * text and itext do not have wrapping, return false
     * @param {Number} lineIndex text to split
     * @return {Boolean}
     */
    isEndOfWrapping: function(lineIndex) {
      if (!this._styleMap[lineIndex + 1]) {
        // is last line, return true;
        return true;
      }
      if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
        // this is last line before a line break, return true;
        return true;
      }
      return false;
    },

    /**
     * Detect if a line has a linebreak and so we need to account for it when moving
     * and counting style.
     * @return Number
     */
    missingNewlineOffset: function(lineIndex) {
      if (this.splitByGrapheme) {
        return this.isEndOfWrapping(lineIndex) ? 1 : 0;
      }
      return 1;
    },

    /**
    * Gets lines of text to render in the Textbox. This function calculates
    * text wrapping on the fly every time it is called.
    * @param {String} text text to split
    * @returns {Array} Array of lines in the Textbox.
    * @override
    */
    _splitTextIntoLines: function(text) {
      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
          graphemeLines = this._wrapText(newText.lines, this.width),
          lines = new Array(graphemeLines.length);
      for (var i = 0; i < graphemeLines.length; i++) {
        lines[i] = graphemeLines[i].join('');
      }
      newText.lines = lines;
      newText.graphemeLines = graphemeLines;
      return newText;
    },

    getMinWidth: function() {
      return Math.max(this.minWidth, this.dynamicMinWidth);
    },

    _removeExtraneousStyles: function() {
      var linesToKeep = {};
      for (var prop in this._styleMap) {
        if (this._textLines[prop]) {
          linesToKeep[this._styleMap[prop].line] = 1;
        }
      }
      for (var prop in this.styles) {
        if (!linesToKeep[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['minWidth', 'splitByGrapheme'].concat(propertiesToInclude));
    }
  });

  /**
   * Returns fabric.Textbox instance from an object representation
   * @static
   * @memberOf fabric.Textbox
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
   */
  fabric.Textbox.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Textbox', object, callback, 'text');
  };
})( true ? exports : 0);


(function() {

  var controlsUtils = fabric.controlsUtils,
      scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler,
      scaleStyleHandler = controlsUtils.scaleCursorStyleHandler,
      scalingEqually = controlsUtils.scalingEqually,
      scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX,
      scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY,
      scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName,
      objectControls = fabric.Object.prototype.controls;

  objectControls.ml = new fabric.Control({
    x: -0.5,
    y: 0,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingXOrSkewingY,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mr = new fabric.Control({
    x: 0.5,
    y: 0,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingXOrSkewingY,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mb = new fabric.Control({
    x: 0,
    y: 0.5,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingYOrSkewingX,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.mt = new fabric.Control({
    x: 0,
    y: -0.5,
    cursorStyleHandler: scaleSkewStyleHandler,
    actionHandler: scalingYOrSkewingX,
    getActionName: scaleOrSkewActionName,
  });

  objectControls.tl = new fabric.Control({
    x: -0.5,
    y: -0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.tr = new fabric.Control({
    x: 0.5,
    y: -0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.bl = new fabric.Control({
    x: -0.5,
    y: 0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.br = new fabric.Control({
    x: 0.5,
    y: 0.5,
    cursorStyleHandler: scaleStyleHandler,
    actionHandler: scalingEqually
  });

  objectControls.mtr = new fabric.Control({
    x: 0,
    y: -0.5,
    actionHandler: controlsUtils.rotationWithSnapping,
    cursorStyleHandler: controlsUtils.rotationStyleHandler,
    offsetY: -40,
    withConnection: true,
    actionName: 'rotate',
  });

  if (fabric.Textbox) {
    // this is breaking the prototype inheritance, no time / ideas to fix it.
    // is important to document that if you want to have all objects to have a
    // specific custom control, you have to add it to Object prototype and to Textbox
    // prototype. The controls are shared as references. So changes to control `tr`
    // can still apply to all objects if needed.
    var textBoxControls = fabric.Textbox.prototype.controls = { };

    textBoxControls.mtr = objectControls.mtr;
    textBoxControls.tr = objectControls.tr;
    textBoxControls.br = objectControls.br;
    textBoxControls.tl = objectControls.tl;
    textBoxControls.bl = objectControls.bl;
    textBoxControls.mt = objectControls.mt;
    textBoxControls.mb = objectControls.mb;

    textBoxControls.mr = new fabric.Control({
      x: 0.5,
      y: 0,
      actionHandler: controlsUtils.changeWidth,
      cursorStyleHandler: scaleSkewStyleHandler,
      actionName: 'resizing',
    });

    textBoxControls.ml = new fabric.Control({
      x: -0.5,
      y: 0,
      actionHandler: controlsUtils.changeWidth,
      cursorStyleHandler: scaleSkewStyleHandler,
      actionName: 'resizing',
    });
  }
})();



/***/ }),

/***/ "./node_modules/nouislider/distribute/nouislider.css":
/*!***********************************************************!*\
  !*** ./node_modules/nouislider/distribute/nouislider.css ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/nouislider/distribute/nouislider.js":
/*!**********************************************************!*\
  !*** ./node_modules/nouislider/distribute/nouislider.js ***!
  \**********************************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 14.6.3 - 11/19/2020 */
(function(factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
})(function() {
    "use strict";

    var VERSION = "14.6.3";

    //region Helper Methods

    function isValidFormatter(entry) {
        return typeof entry === "object" && typeof entry.to === "function" && typeof entry.from === "function";
    }

    function removeElement(el) {
        el.parentElement.removeChild(el);
    }

    function isSet(value) {
        return value !== null && value !== undefined;
    }

    // Bindable version
    function preventDefault(e) {
        e.preventDefault();
    }

    // Removes duplicates from an array.
    function unique(array) {
        return array.filter(function(a) {
            return !this[a] ? (this[a] = true) : false;
        }, {});
    }

    // Round a value to the closest 'to'.
    function closest(value, to) {
        return Math.round(value / to) * to;
    }

    // Current position of an element relative to the document.
    function offset(elem, orientation) {
        var rect = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var docElem = doc.documentElement;
        var pageOffset = getPageOffset(doc);

        // getBoundingClientRect contains left scroll in Chrome on Android.
        // I haven't found a feature detection that proves this. Worst case
        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
            pageOffset.x = 0;
        }

        return orientation
            ? rect.top + pageOffset.y - docElem.clientTop
            : rect.left + pageOffset.x - docElem.clientLeft;
    }

    // Checks whether a value is numerical.
    function isNumeric(a) {
        return typeof a === "number" && !isNaN(a) && isFinite(a);
    }

    // Sets a class and removes it after [duration] ms.
    function addClassFor(element, className, duration) {
        if (duration > 0) {
            addClass(element, className);
            setTimeout(function() {
                removeClass(element, className);
            }, duration);
        }
    }

    // Limits a value to 0 - 100
    function limit(a) {
        return Math.max(Math.min(a, 100), 0);
    }

    // Wraps a variable as an array, if it isn't one yet.
    // Note that an input array is returned by reference!
    function asArray(a) {
        return Array.isArray(a) ? a : [a];
    }

    // Counts decimals
    function countDecimals(numStr) {
        numStr = String(numStr);
        var pieces = numStr.split(".");
        return pieces.length > 1 ? pieces[1].length : 0;
    }

    // http://youmightnotneedjquery.com/#add_class
    function addClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
            el.classList.add(className);
        } else {
            el.className += " " + className;
        }
    }

    // http://youmightnotneedjquery.com/#remove_class
    function removeClass(el, className) {
        if (el.classList && !/\s/.test(className)) {
            el.classList.remove(className);
        } else {
            el.className = el.className.replace(
                new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"),
                " "
            );
        }
    }

    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/
    function hasClass(el, className) {
        return el.classList
            ? el.classList.contains(className)
            : new RegExp("\\b" + className + "\\b").test(el.className);
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
    function getPageOffset(doc) {
        var supportPageOffset = window.pageXOffset !== undefined;
        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
        var x = supportPageOffset
            ? window.pageXOffset
            : isCSS1Compat
                ? doc.documentElement.scrollLeft
                : doc.body.scrollLeft;
        var y = supportPageOffset
            ? window.pageYOffset
            : isCSS1Compat
                ? doc.documentElement.scrollTop
                : doc.body.scrollTop;

        return {
            x: x,
            y: y
        };
    }

    // we provide a function to compute constants instead
    // of accessing window.* as soon as the module needs it
    // so that we do not compute anything if not needed
    function getActions() {
        // Determine the events to bind. IE11 implements pointerEvents without
        // a prefix, which breaks compatibility with the IE10 implementation.
        return window.navigator.pointerEnabled
            ? {
                  start: "pointerdown",
                  move: "pointermove",
                  end: "pointerup"
              }
            : window.navigator.msPointerEnabled
                ? {
                      start: "MSPointerDown",
                      move: "MSPointerMove",
                      end: "MSPointerUp"
                  }
                : {
                      start: "mousedown touchstart",
                      move: "mousemove touchmove",
                      end: "mouseup touchend"
                  };
    }

    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // Issue #785
    function getSupportsPassive() {
        var supportsPassive = false;

        /* eslint-disable */
        try {
            var opts = Object.defineProperty({}, "passive", {
                get: function() {
                    supportsPassive = true;
                }
            });

            window.addEventListener("test", null, opts);
        } catch (e) {}
        /* eslint-enable */

        return supportsPassive;
    }

    function getSupportsTouchActionNone() {
        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
    }

    //endregion

    //region Range Calculation

    // Determine the size of a sub-range in relation to a full range.
    function subRangeRatio(pa, pb) {
        return 100 / (pb - pa);
    }

    // (percentage) How many percent is this value of this range?
    function fromPercentage(range, value, startRange) {
        return (value * 100) / (range[startRange + 1] - range[startRange]);
    }

    // (percentage) Where is this value on this range?
    function toPercentage(range, value) {
        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
    }

    // (value) How much is this percentage on this range?
    function isPercentage(range, value) {
        return (value * (range[1] - range[0])) / 100 + range[0];
    }

    function getJ(value, arr) {
        var j = 1;

        while (value >= arr[j]) {
            j += 1;
        }

        return j;
    }

    // (percentage) Input a value, find where, on a scale of 0-100, it applies.
    function toStepping(xVal, xPct, value) {
        if (value >= xVal.slice(-1)[0]) {
            return 100;
        }

        var j = getJ(value, xVal);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];

        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
    }

    // (value) Input a percentage, find where it is on the specified range.
    function fromStepping(xVal, xPct, value) {
        // There is no range group that fits 100
        if (value >= 100) {
            return xVal.slice(-1)[0];
        }

        var j = getJ(value, xPct);
        var va = xVal[j - 1];
        var vb = xVal[j];
        var pa = xPct[j - 1];
        var pb = xPct[j];

        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
    }

    // (percentage) Get the step that applies at a certain value.
    function getStep(xPct, xSteps, snap, value) {
        if (value === 100) {
            return value;
        }

        var j = getJ(value, xPct);
        var a = xPct[j - 1];
        var b = xPct[j];

        // If 'snap' is set, steps are used as fixed points on the slider.
        if (snap) {
            // Find the closest position, a or b.
            if (value - a > (b - a) / 2) {
                return b;
            }

            return a;
        }

        if (!xSteps[j - 1]) {
            return value;
        }

        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
    }

    function handleEntryPoint(index, value, that) {
        var percentage;

        // Wrap numerical input in an array.
        if (typeof value === "number") {
            value = [value];
        }

        // Reject any invalid input, by testing whether value is an array.
        if (!Array.isArray(value)) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
        }

        // Covert min/max syntax to 0 and 100.
        if (index === "min") {
            percentage = 0;
        } else if (index === "max") {
            percentage = 100;
        } else {
            percentage = parseFloat(index);
        }

        // Check for correct input.
        if (!isNumeric(percentage) || !isNumeric(value[0])) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
        }

        // Store values.
        that.xPct.push(percentage);
        that.xVal.push(value[0]);

        // NaN will evaluate to false too, but to keep
        // logging clear, set step explicitly. Make sure
        // not to override the 'step' setting with false.
        if (!percentage) {
            if (!isNaN(value[1])) {
                that.xSteps[0] = value[1];
            }
        } else {
            that.xSteps.push(isNaN(value[1]) ? false : value[1]);
        }

        that.xHighestCompleteStep.push(0);
    }

    function handleStepPoint(i, n, that) {
        // Ignore 'false' stepping.
        if (!n) {
            return;
        }

        // Step over zero-length ranges (#948);
        if (that.xVal[i] === that.xVal[i + 1]) {
            that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];

            return;
        }

        // Factor to range ratio
        that.xSteps[i] =
            fromPercentage([that.xVal[i], that.xVal[i + 1]], n, 0) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);

        var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];
        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
        var step = that.xVal[i] + that.xNumSteps[i] * highestStep;

        that.xHighestCompleteStep[i] = step;
    }

    //endregion

    //region Spectrum

    function Spectrum(entry, snap, singleStep) {
        this.xPct = [];
        this.xVal = [];
        this.xSteps = [singleStep || false];
        this.xNumSteps = [false];
        this.xHighestCompleteStep = [];

        this.snap = snap;

        var index;
        var ordered = []; // [0, 'min'], [1, '50%'], [2, 'max']

        // Map the object keys to an array.
        for (index in entry) {
            if (entry.hasOwnProperty(index)) {
                ordered.push([entry[index], index]);
            }
        }

        // Sort all entries by value (numeric sort).
        if (ordered.length && typeof ordered[0][0] === "object") {
            ordered.sort(function(a, b) {
                return a[0][0] - b[0][0];
            });
        } else {
            ordered.sort(function(a, b) {
                return a[0] - b[0];
            });
        }

        // Convert all entries to subranges.
        for (index = 0; index < ordered.length; index++) {
            handleEntryPoint(ordered[index][1], ordered[index][0], this);
        }

        // Store the actual step values.
        // xSteps is sorted in the same order as xPct and xVal.
        this.xNumSteps = this.xSteps.slice(0);

        // Convert all numeric steps to the percentage of the subrange they represent.
        for (index = 0; index < this.xNumSteps.length; index++) {
            handleStepPoint(index, this.xNumSteps[index], this);
        }
    }

    Spectrum.prototype.getDistance = function(value) {
        var index;
        var distances = [];

        for (index = 0; index < this.xNumSteps.length - 1; index++) {
            // last "range" can't contain step size as it is purely an endpoint.
            var step = this.xNumSteps[index];

            if (step && (value / step) % 1 !== 0) {
                throw new Error(
                    "noUiSlider (" +
                        VERSION +
                        "): 'limit', 'margin' and 'padding' of " +
                        this.xPct[index] +
                        "% range must be divisible by step."
                );
            }

            // Calculate percentual distance in current range of limit, margin or padding
            distances[index] = fromPercentage(this.xVal, value, index);
        }

        return distances;
    };

    // Calculate the percentual distance over the whole scale of ranges.
    // direction: 0 = backwards / 1 = forwards
    Spectrum.prototype.getAbsoluteDistance = function(value, distances, direction) {
        var xPct_index = 0;

        // Calculate range where to start calculation
        if (value < this.xPct[this.xPct.length - 1]) {
            while (value > this.xPct[xPct_index + 1]) {
                xPct_index++;
            }
        } else if (value === this.xPct[this.xPct.length - 1]) {
            xPct_index = this.xPct.length - 2;
        }

        // If looking backwards and the value is exactly at a range separator then look one range further
        if (!direction && value === this.xPct[xPct_index + 1]) {
            xPct_index++;
        }

        var start_factor;
        var rest_factor = 1;

        var rest_rel_distance = distances[xPct_index];

        var range_pct = 0;

        var rel_range_distance = 0;
        var abs_distance_counter = 0;
        var range_counter = 0;

        // Calculate what part of the start range the value is
        if (direction) {
            start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
        } else {
            start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
        }

        // Do until the complete distance across ranges is calculated
        while (rest_rel_distance > 0) {
            // Calculate the percentage of total range
            range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];

            // Detect if the margin, padding or limit is larger then the current range and calculate
            if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                // If larger then take the percentual distance of the whole range
                rel_range_distance = range_pct * start_factor;
                // Rest factor of relative percentual distance still to be calculated
                rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                // Set start factor to 1 as for next range it does not apply.
                start_factor = 1;
            } else {
                // If smaller or equal then take the percentual distance of the calculate percentual part of that range
                rel_range_distance = ((distances[xPct_index + range_counter] * range_pct) / 100) * rest_factor;
                // No rest left as the rest fits in current range
                rest_factor = 0;
            }

            if (direction) {
                abs_distance_counter = abs_distance_counter - rel_range_distance;
                // Limit range to first range when distance becomes outside of minimum range
                if (this.xPct.length + range_counter >= 1) {
                    range_counter--;
                }
            } else {
                abs_distance_counter = abs_distance_counter + rel_range_distance;
                // Limit range to last range when distance becomes outside of maximum range
                if (this.xPct.length - range_counter >= 1) {
                    range_counter++;
                }
            }

            // Rest of relative percentual distance still to be calculated
            rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
        }

        return value + abs_distance_counter;
    };

    Spectrum.prototype.toStepping = function(value) {
        value = toStepping(this.xVal, this.xPct, value);

        return value;
    };

    Spectrum.prototype.fromStepping = function(value) {
        return fromStepping(this.xVal, this.xPct, value);
    };

    Spectrum.prototype.getStep = function(value) {
        value = getStep(this.xPct, this.xSteps, this.snap, value);

        return value;
    };

    Spectrum.prototype.getDefaultStep = function(value, isDown, size) {
        var j = getJ(value, this.xPct);

        // When at the top or stepping down, look at the previous sub-range
        if (value === 100 || (isDown && value === this.xPct[j - 1])) {
            j = Math.max(j - 1, 1);
        }

        return (this.xVal[j] - this.xVal[j - 1]) / size;
    };

    Spectrum.prototype.getNearbySteps = function(value) {
        var j = getJ(value, this.xPct);

        return {
            stepBefore: {
                startValue: this.xVal[j - 2],
                step: this.xNumSteps[j - 2],
                highestStep: this.xHighestCompleteStep[j - 2]
            },
            thisStep: {
                startValue: this.xVal[j - 1],
                step: this.xNumSteps[j - 1],
                highestStep: this.xHighestCompleteStep[j - 1]
            },
            stepAfter: {
                startValue: this.xVal[j],
                step: this.xNumSteps[j],
                highestStep: this.xHighestCompleteStep[j]
            }
        };
    };

    Spectrum.prototype.countStepDecimals = function() {
        var stepDecimals = this.xNumSteps.map(countDecimals);
        return Math.max.apply(null, stepDecimals);
    };

    // Outside testing
    Spectrum.prototype.convert = function(value) {
        return this.getStep(this.toStepping(value));
    };

    //endregion

    //region Options

    /*	Every input option is tested and parsed. This'll prevent
        endless validation in internal methods. These tests are
        structured with an item for every option available. An
        option can be marked as required by setting the 'r' flag.
        The testing function is provided with three arguments:
            - The provided value for the option;
            - A reference to the options object;
            - The name for the option;

        The testing function returns false when an error is detected,
        or true when everything is OK. It can also modify the option
        object, to make sure all values can be correctly looped elsewhere. */

    //region Defaults

    var defaultFormatter = {
        to: function(value) {
            return value !== undefined && value.toFixed(2);
        },
        from: Number
    };

    var cssClasses = {
        target: "target",
        base: "base",
        origin: "origin",
        handle: "handle",
        handleLower: "handle-lower",
        handleUpper: "handle-upper",
        touchArea: "touch-area",
        horizontal: "horizontal",
        vertical: "vertical",
        background: "background",
        connect: "connect",
        connects: "connects",
        ltr: "ltr",
        rtl: "rtl",
        textDirectionLtr: "txt-dir-ltr",
        textDirectionRtl: "txt-dir-rtl",
        draggable: "draggable",
        drag: "state-drag",
        tap: "state-tap",
        active: "active",
        tooltip: "tooltip",
        pips: "pips",
        pipsHorizontal: "pips-horizontal",
        pipsVertical: "pips-vertical",
        marker: "marker",
        markerHorizontal: "marker-horizontal",
        markerVertical: "marker-vertical",
        markerNormal: "marker-normal",
        markerLarge: "marker-large",
        markerSub: "marker-sub",
        value: "value",
        valueHorizontal: "value-horizontal",
        valueVertical: "value-vertical",
        valueNormal: "value-normal",
        valueLarge: "value-large",
        valueSub: "value-sub"
    };

    // Namespaces of internal event listeners
    var INTERNAL_EVENT_NS = {
        tooltips: ".__tooltips",
        aria: ".__aria"
    };

    //endregion

    function validateFormat(entry) {
        // Any object with a to and from method is supported.
        if (isValidFormatter(entry)) {
            return true;
        }

        throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.");
    }

    function testStep(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
        }

        // The step option can still be used to set stepping
        // for linear sliders. Overwritten if set in 'range'.
        parsed.singleStep = entry;
    }

    function testKeyboardPageMultiplier(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'keyboardPageMultiplier' is not numeric.");
        }

        parsed.keyboardPageMultiplier = entry;
    }

    function testKeyboardDefaultStep(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'keyboardDefaultStep' is not numeric.");
        }

        parsed.keyboardDefaultStep = entry;
    }

    function testRange(parsed, entry) {
        // Filter incorrect input.
        if (typeof entry !== "object" || Array.isArray(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
        }

        // Catch missing start or end.
        if (entry.min === undefined || entry.max === undefined) {
            throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
        }

        // Catch equal start or end.
        if (entry.min === entry.max) {
            throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
        }

        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
    }

    function testStart(parsed, entry) {
        entry = asArray(entry);

        // Validate input. Values aren't tested, as the public .val method
        // will always provide a valid location.
        if (!Array.isArray(entry) || !entry.length) {
            throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
        }

        // Store the number of handles.
        parsed.handles = entry.length;

        // When the slider is initialized, the .val method will
        // be called with the start options.
        parsed.start = entry;
    }

    function testSnap(parsed, entry) {
        // Enforce 100% stepping within subranges.
        parsed.snap = entry;

        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.");
        }
    }

    function testAnimate(parsed, entry) {
        // Enforce 100% stepping within subranges.
        parsed.animate = entry;

        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.");
        }
    }

    function testAnimationDuration(parsed, entry) {
        parsed.animationDuration = entry;

        if (typeof entry !== "number") {
            throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.");
        }
    }

    function testConnect(parsed, entry) {
        var connect = [false];
        var i;

        // Map legacy options
        if (entry === "lower") {
            entry = [true, false];
        } else if (entry === "upper") {
            entry = [false, true];
        }

        // Handle boolean options
        if (entry === true || entry === false) {
            for (i = 1; i < parsed.handles; i++) {
                connect.push(entry);
            }

            connect.push(false);
        }

        // Reject invalid input
        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {
            throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
        } else {
            connect = entry;
        }

        parsed.connect = connect;
    }

    function testOrientation(parsed, entry) {
        // Set orientation to an a numerical value for easy
        // array selection.
        switch (entry) {
            case "horizontal":
                parsed.ort = 0;
                break;
            case "vertical":
                parsed.ort = 1;
                break;
            default:
                throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.");
        }
    }

    function testMargin(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
        }

        // Issue #582
        if (entry === 0) {
            return;
        }

        parsed.margin = parsed.spectrum.getDistance(entry);
    }

    function testLimit(parsed, entry) {
        if (!isNumeric(entry)) {
            throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
        }

        parsed.limit = parsed.spectrum.getDistance(entry);

        if (!parsed.limit || parsed.handles < 2) {
            throw new Error(
                "noUiSlider (" +
                    VERSION +
                    "): 'limit' option is only supported on linear sliders with 2 or more handles."
            );
        }
    }

    function testPadding(parsed, entry) {
        var index;

        if (!isNumeric(entry) && !Array.isArray(entry)) {
            throw new Error(
                "noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers."
            );
        }

        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
            throw new Error(
                "noUiSlider (" + VERSION + "): 'padding' option must be numeric or array of exactly 2 numbers."
            );
        }

        if (entry === 0) {
            return;
        }

        if (!Array.isArray(entry)) {
            entry = [entry, entry];
        }

        // 'getDistance' returns false for invalid values.
        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];

        for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {
            // last "range" can't contain step size as it is purely an endpoint.
            if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {
                throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number(s).");
            }
        }

        var totalPadding = entry[0] + entry[1];
        var firstValue = parsed.spectrum.xVal[0];
        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];

        if (totalPadding / (lastValue - firstValue) > 1) {
            throw new Error("noUiSlider (" + VERSION + "): 'padding' option must not exceed 100% of the range.");
        }
    }

    function testDirection(parsed, entry) {
        // Set direction as a numerical value for easy parsing.
        // Invert connection for RTL sliders, so that the proper
        // handles get the connect/background classes.
        switch (entry) {
            case "ltr":
                parsed.dir = 0;
                break;
            case "rtl":
                parsed.dir = 1;
                break;
            default:
                throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.");
        }
    }

    function testBehaviour(parsed, entry) {
        // Make sure the input is a string.
        if (typeof entry !== "string") {
            throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
        }

        // Check if the string contains any keywords.
        // None are required.
        var tap = entry.indexOf("tap") >= 0;
        var drag = entry.indexOf("drag") >= 0;
        var fixed = entry.indexOf("fixed") >= 0;
        var snap = entry.indexOf("snap") >= 0;
        var hover = entry.indexOf("hover") >= 0;
        var unconstrained = entry.indexOf("unconstrained") >= 0;

        if (fixed) {
            if (parsed.handles !== 2) {
                throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
            }

            // Use margin to enforce fixed state
            testMargin(parsed, parsed.start[1] - parsed.start[0]);
        }

        if (unconstrained && (parsed.margin || parsed.limit)) {
            throw new Error(
                "noUiSlider (" + VERSION + "): 'unconstrained' behaviour cannot be used with margin or limit"
            );
        }

        parsed.events = {
            tap: tap || snap,
            drag: drag,
            fixed: fixed,
            snap: snap,
            hover: hover,
            unconstrained: unconstrained
        };
    }

    function testTooltips(parsed, entry) {
        if (entry === false) {
            return;
        }

        if (entry === true) {
            parsed.tooltips = [];

            for (var i = 0; i < parsed.handles; i++) {
                parsed.tooltips.push(true);
            }
        } else {
            parsed.tooltips = asArray(entry);

            if (parsed.tooltips.length !== parsed.handles) {
                throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
            }

            parsed.tooltips.forEach(function(formatter) {
                if (
                    typeof formatter !== "boolean" &&
                    (typeof formatter !== "object" || typeof formatter.to !== "function")
                ) {
                    throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.");
                }
            });
        }
    }

    function testAriaFormat(parsed, entry) {
        parsed.ariaFormat = entry;
        validateFormat(entry);
    }

    function testFormat(parsed, entry) {
        parsed.format = entry;
        validateFormat(entry);
    }

    function testKeyboardSupport(parsed, entry) {
        parsed.keyboardSupport = entry;

        if (typeof entry !== "boolean") {
            throw new Error("noUiSlider (" + VERSION + "): 'keyboardSupport' option must be a boolean.");
        }
    }

    function testDocumentElement(parsed, entry) {
        // This is an advanced option. Passed values are used without validation.
        parsed.documentElement = entry;
    }

    function testCssPrefix(parsed, entry) {
        if (typeof entry !== "string" && entry !== false) {
            throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
        }

        parsed.cssPrefix = entry;
    }

    function testCssClasses(parsed, entry) {
        if (typeof entry !== "object") {
            throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
        }

        if (typeof parsed.cssPrefix === "string") {
            parsed.cssClasses = {};

            for (var key in entry) {
                if (!entry.hasOwnProperty(key)) {
                    continue;
                }

                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
            }
        } else {
            parsed.cssClasses = entry;
        }
    }

    // Test all developer settings and parse to assumption-safe values.
    function testOptions(options) {
        // To prove a fix for #537, freeze options here.
        // If the object is modified, an error will be thrown.
        // Object.freeze(options);

        var parsed = {
            margin: 0,
            limit: 0,
            padding: 0,
            animate: true,
            animationDuration: 300,
            ariaFormat: defaultFormatter,
            format: defaultFormatter
        };

        // Tests are executed in the order they are presented here.
        var tests = {
            step: { r: false, t: testStep },
            keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },
            keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },
            start: { r: true, t: testStart },
            connect: { r: true, t: testConnect },
            direction: { r: true, t: testDirection },
            snap: { r: false, t: testSnap },
            animate: { r: false, t: testAnimate },
            animationDuration: { r: false, t: testAnimationDuration },
            range: { r: true, t: testRange },
            orientation: { r: false, t: testOrientation },
            margin: { r: false, t: testMargin },
            limit: { r: false, t: testLimit },
            padding: { r: false, t: testPadding },
            behaviour: { r: true, t: testBehaviour },
            ariaFormat: { r: false, t: testAriaFormat },
            format: { r: false, t: testFormat },
            tooltips: { r: false, t: testTooltips },
            keyboardSupport: { r: true, t: testKeyboardSupport },
            documentElement: { r: false, t: testDocumentElement },
            cssPrefix: { r: true, t: testCssPrefix },
            cssClasses: { r: true, t: testCssClasses }
        };

        var defaults = {
            connect: false,
            direction: "ltr",
            behaviour: "tap",
            orientation: "horizontal",
            keyboardSupport: true,
            cssPrefix: "noUi-",
            cssClasses: cssClasses,
            keyboardPageMultiplier: 5,
            keyboardDefaultStep: 10
        };

        // AriaFormat defaults to regular format, if any.
        if (options.format && !options.ariaFormat) {
            options.ariaFormat = options.format;
        }

        // Run all options through a testing mechanism to ensure correct
        // input. It should be noted that options might get modified to
        // be handled properly. E.g. wrapping integers in arrays.
        Object.keys(tests).forEach(function(name) {
            // If the option isn't set, but it is required, throw an error.
            if (!isSet(options[name]) && defaults[name] === undefined) {
                if (tests[name].r) {
                    throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
                }

                return true;
            }

            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
        });

        // Forward pips options
        parsed.pips = options.pips;

        // All recent browsers accept unprefixed transform.
        // We need -ms- for IE9 and -webkit- for older Android;
        // Assume use of -webkit- if unprefixed and -ms- are not supported.
        // https://caniuse.com/#feat=transforms2d
        var d = document.createElement("div");
        var msPrefix = d.style.msTransform !== undefined;
        var noPrefix = d.style.transform !== undefined;

        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";

        // Pips don't move, so we can place them using left/top.
        var styles = [["left", "top"], ["right", "bottom"]];

        parsed.style = styles[parsed.dir][parsed.ort];

        return parsed;
    }

    //endregion

    function scope(target, options, originalOptions) {
        var actions = getActions();
        var supportsTouchActionNone = getSupportsTouchActionNone();
        var supportsPassive = supportsTouchActionNone && getSupportsPassive();

        // All variables local to 'scope' are prefixed with 'scope_'

        // Slider DOM Nodes
        var scope_Target = target;
        var scope_Base;
        var scope_Handles;
        var scope_Connects;
        var scope_Pips;
        var scope_Tooltips;

        // Slider state values
        var scope_Spectrum = options.spectrum;
        var scope_Values = [];
        var scope_Locations = [];
        var scope_HandleNumbers = [];
        var scope_ActiveHandlesCount = 0;
        var scope_Events = {};

        // Exposed API
        var scope_Self;

        // Document Nodes
        var scope_Document = target.ownerDocument;
        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
        var scope_Body = scope_Document.body;

        // Pips constants
        var PIPS_NONE = -1;
        var PIPS_NO_VALUE = 0;
        var PIPS_LARGE_VALUE = 1;
        var PIPS_SMALL_VALUE = 2;

        // For horizontal sliders in standard ltr documents,
        // make .noUi-origin overflow to the left so the document doesn't scroll.
        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;

        // Creates a node, adds it to target, returns the new node.
        function addNodeTo(addTarget, className) {
            var div = scope_Document.createElement("div");

            if (className) {
                addClass(div, className);
            }

            addTarget.appendChild(div);

            return div;
        }

        // Append a origin to the base
        function addOrigin(base, handleNumber) {
            var origin = addNodeTo(base, options.cssClasses.origin);
            var handle = addNodeTo(origin, options.cssClasses.handle);

            addNodeTo(handle, options.cssClasses.touchArea);

            handle.setAttribute("data-handle", handleNumber);

            if (options.keyboardSupport) {
                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
                // 0 = focusable and reachable
                handle.setAttribute("tabindex", "0");
                handle.addEventListener("keydown", function(event) {
                    return eventKeydown(event, handleNumber);
                });
            }

            handle.setAttribute("role", "slider");
            handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");

            if (handleNumber === 0) {
                addClass(handle, options.cssClasses.handleLower);
            } else if (handleNumber === options.handles - 1) {
                addClass(handle, options.cssClasses.handleUpper);
            }

            return origin;
        }

        // Insert nodes for connect elements
        function addConnect(base, add) {
            if (!add) {
                return false;
            }

            return addNodeTo(base, options.cssClasses.connect);
        }

        // Add handles to the slider base.
        function addElements(connectOptions, base) {
            var connectBase = addNodeTo(base, options.cssClasses.connects);

            scope_Handles = [];
            scope_Connects = [];

            scope_Connects.push(addConnect(connectBase, connectOptions[0]));

            // [::::O====O====O====]
            // connectOptions = [0, 1, 1, 1]

            for (var i = 0; i < options.handles; i++) {
                // Keep a list of all added handles.
                scope_Handles.push(addOrigin(base, i));
                scope_HandleNumbers[i] = i;
                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
            }
        }

        // Initialize a single slider.
        function addSlider(addTarget) {
            // Apply classes and data to the target.
            addClass(addTarget, options.cssClasses.target);

            if (options.dir === 0) {
                addClass(addTarget, options.cssClasses.ltr);
            } else {
                addClass(addTarget, options.cssClasses.rtl);
            }

            if (options.ort === 0) {
                addClass(addTarget, options.cssClasses.horizontal);
            } else {
                addClass(addTarget, options.cssClasses.vertical);
            }

            var textDirection = getComputedStyle(addTarget).direction;

            if (textDirection === "rtl") {
                addClass(addTarget, options.cssClasses.textDirectionRtl);
            } else {
                addClass(addTarget, options.cssClasses.textDirectionLtr);
            }

            return addNodeTo(addTarget, options.cssClasses.base);
        }

        function addTooltip(handle, handleNumber) {
            if (!options.tooltips[handleNumber]) {
                return false;
            }

            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
        }

        function isSliderDisabled() {
            return scope_Target.hasAttribute("disabled");
        }

        // Disable the slider dragging if any handle is disabled
        function isHandleDisabled(handleNumber) {
            var handleOrigin = scope_Handles[handleNumber];
            return handleOrigin.hasAttribute("disabled");
        }

        function removeTooltips() {
            if (scope_Tooltips) {
                removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
                scope_Tooltips.forEach(function(tooltip) {
                    if (tooltip) {
                        removeElement(tooltip);
                    }
                });
                scope_Tooltips = null;
            }
        }

        // The tooltips option is a shorthand for using the 'update' event.
        function tooltips() {
            removeTooltips();

            // Tooltips are added with options.tooltips in original order.
            scope_Tooltips = scope_Handles.map(addTooltip);

            bindEvent("update" + INTERNAL_EVENT_NS.tooltips, function(values, handleNumber, unencoded) {
                if (!scope_Tooltips[handleNumber]) {
                    return;
                }

                var formattedValue = values[handleNumber];

                if (options.tooltips[handleNumber] !== true) {
                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
                }

                scope_Tooltips[handleNumber].innerHTML = formattedValue;
            });
        }

        function aria() {
            removeEvent("update" + INTERNAL_EVENT_NS.aria);
            bindEvent("update" + INTERNAL_EVENT_NS.aria, function(values, handleNumber, unencoded, tap, positions) {
                // Update Aria Values for all handles, as a change in one changes min and max values for the next.
                scope_HandleNumbers.forEach(function(index) {
                    var handle = scope_Handles[index];

                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);

                    var now = positions[index];

                    // Formatted value for display
                    var text = options.ariaFormat.to(unencoded[index]);

                    // Map to slider range values
                    min = scope_Spectrum.fromStepping(min).toFixed(1);
                    max = scope_Spectrum.fromStepping(max).toFixed(1);
                    now = scope_Spectrum.fromStepping(now).toFixed(1);

                    handle.children[0].setAttribute("aria-valuemin", min);
                    handle.children[0].setAttribute("aria-valuemax", max);
                    handle.children[0].setAttribute("aria-valuenow", now);
                    handle.children[0].setAttribute("aria-valuetext", text);
                });
            });
        }

        function getGroup(mode, values, stepped) {
            // Use the range.
            if (mode === "range" || mode === "steps") {
                return scope_Spectrum.xVal;
            }

            if (mode === "count") {
                if (values < 2) {
                    throw new Error("noUiSlider (" + VERSION + "): 'values' (>= 2) required for mode 'count'.");
                }

                // Divide 0 - 100 in 'count' parts.
                var interval = values - 1;
                var spread = 100 / interval;

                values = [];

                // List these parts and have them handled as 'positions'.
                while (interval--) {
                    values[interval] = interval * spread;
                }

                values.push(100);

                mode = "positions";
            }

            if (mode === "positions") {
                // Map all percentages to on-range values.
                return values.map(function(value) {
                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
                });
            }

            if (mode === "values") {
                // If the value must be stepped, it needs to be converted to a percentage first.
                if (stepped) {
                    return values.map(function(value) {
                        // Convert to percentage, apply step, return to value.
                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                    });
                }

                // Otherwise, we can simply use the values.
                return values;
            }
        }

        function generateSpread(density, mode, group) {
            function safeIncrement(value, increment) {
                // Avoid floating point variance by dropping the smallest decimal places.
                return (value + increment).toFixed(7) / 1;
            }

            var indexes = {};
            var firstInRange = scope_Spectrum.xVal[0];
            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
            var ignoreFirst = false;
            var ignoreLast = false;
            var prevPct = 0;

            // Create a copy of the group, sort it and filter away all duplicates.
            group = unique(
                group.slice().sort(function(a, b) {
                    return a - b;
                })
            );

            // Make sure the range starts with the first element.
            if (group[0] !== firstInRange) {
                group.unshift(firstInRange);
                ignoreFirst = true;
            }

            // Likewise for the last one.
            if (group[group.length - 1] !== lastInRange) {
                group.push(lastInRange);
                ignoreLast = true;
            }

            group.forEach(function(current, index) {
                // Get the current step and the lower + upper positions.
                var step;
                var i;
                var q;
                var low = current;
                var high = group[index + 1];
                var newPct;
                var pctDifference;
                var pctPos;
                var type;
                var steps;
                var realSteps;
                var stepSize;
                var isSteps = mode === "steps";

                // When using 'steps' mode, use the provided steps.
                // Otherwise, we'll step on to the next subrange.
                if (isSteps) {
                    step = scope_Spectrum.xNumSteps[index];
                }

                // Default to a 'full' step.
                if (!step) {
                    step = high - low;
                }

                // Low can be 0, so test for false. Index 0 is already handled.
                if (low === false) {
                    return;
                }

                // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)
                if (high === undefined) {
                    high = low;
                }

                // Make sure step isn't 0, which would cause an infinite loop (#654)
                step = Math.max(step, 0.0000001);

                // Find all steps in the subrange.
                for (i = low; i <= high; i = safeIncrement(i, step)) {
                    // Get the percentage value for the current step,
                    // calculate the size for the subrange.
                    newPct = scope_Spectrum.toStepping(i);
                    pctDifference = newPct - prevPct;

                    steps = pctDifference / density;
                    realSteps = Math.round(steps);

                    // This ratio represents the amount of percentage-space a point indicates.
                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
                    // Round the percentage offset to an even number, then divide by two
                    // to spread the offset on both sides of the range.
                    stepSize = pctDifference / realSteps;

                    // Divide all points evenly, adding the correct number to this subrange.
                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.
                    for (q = 1; q <= realSteps; q += 1) {
                        // The ratio between the rounded value and the actual size might be ~1% off.
                        // Correct the percentage offset by the number of points
                        // per subrange. density = 1 will result in 100 points on the
                        // full range, 2 for 50, 4 for 25, etc.
                        pctPos = prevPct + q * stepSize;
                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];
                    }

                    // Determine the point type.
                    type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE;

                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.
                    if (!index && ignoreFirst && i !== high) {
                        type = 0;
                    }

                    if (!(i === high && ignoreLast)) {
                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
                        indexes[newPct.toFixed(5)] = [i, type];
                    }

                    // Update the percentage count.
                    prevPct = newPct;
                }
            });

            return indexes;
        }

        function addMarking(spread, filterFunc, formatter) {
            var element = scope_Document.createElement("div");

            var valueSizeClasses = [];
            valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;
            valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;
            valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;

            var markerSizeClasses = [];
            markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;
            markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;
            markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;

            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];
            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];

            addClass(element, options.cssClasses.pips);
            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);

            function getClasses(type, source) {
                var a = source === options.cssClasses.value;
                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;

                return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
            }

            function addSpread(offset, value, type) {
                // Apply the filter function, if it is set.
                type = filterFunc ? filterFunc(value, type) : type;

                if (type === PIPS_NONE) {
                    return;
                }

                // Add a marker for every point
                var node = addNodeTo(element, false);
                node.className = getClasses(type, options.cssClasses.marker);
                node.style[options.style] = offset + "%";

                // Values are only appended for points marked '1' or '2'.
                if (type > PIPS_NO_VALUE) {
                    node = addNodeTo(element, false);
                    node.className = getClasses(type, options.cssClasses.value);
                    node.setAttribute("data-value", value);
                    node.style[options.style] = offset + "%";
                    node.innerHTML = formatter.to(value);
                }
            }

            // Append all points.
            Object.keys(spread).forEach(function(offset) {
                addSpread(offset, spread[offset][0], spread[offset][1]);
            });

            return element;
        }

        function removePips() {
            if (scope_Pips) {
                removeElement(scope_Pips);
                scope_Pips = null;
            }
        }

        function pips(grid) {
            // Fix #669
            removePips();

            var mode = grid.mode;
            var density = grid.density || 1;
            var filter = grid.filter || false;
            var values = grid.values || false;
            var stepped = grid.stepped || false;
            var group = getGroup(mode, values, stepped);
            var spread = generateSpread(density, mode, group);
            var format = grid.format || {
                to: Math.round
            };

            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));

            return scope_Pips;
        }

        // Shorthand for base dimensions.
        function baseSize() {
            var rect = scope_Base.getBoundingClientRect();
            var alt = "offset" + ["Width", "Height"][options.ort];
            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
        }

        // Handler for attaching events trough a proxy.
        function attachEvent(events, element, callback, data) {
            // This function can be used to 'filter' events to the slider.
            // element is a node, not a nodeList

            var method = function(e) {
                e = fixEvent(e, data.pageOffset, data.target || element);

                // fixEvent returns false if this event has a different target
                // when handling (multi-) touch events;
                if (!e) {
                    return false;
                }

                // doNotReject is passed by all end events to make sure released touches
                // are not rejected, leaving the slider "stuck" to the cursor;
                if (isSliderDisabled() && !data.doNotReject) {
                    return false;
                }

                // Stop if an active 'tap' transition is taking place.
                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {
                    return false;
                }

                // Ignore right or middle clicks on start #454
                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {
                    return false;
                }

                // Ignore right or middle clicks on start #454
                if (data.hover && e.buttons) {
                    return false;
                }

                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
                // touch-action: manipulation, but that allows panning, which breaks
                // sliders after zooming/on non-responsive pages.
                // See: https://bugs.webkit.org/show_bug.cgi?id=133112
                if (!supportsPassive) {
                    e.preventDefault();
                }

                e.calcPoint = e.points[options.ort];

                // Call the event handler with the event [ and additional data ].
                callback(e, data);
            };

            var methods = [];

            // Bind a closure on the target for every event type.
            events.split(" ").forEach(function(eventName) {
                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
                methods.push([eventName, method]);
            });

            return methods;
        }

        // Provide a clean event with standardized offset values.
        function fixEvent(e, pageOffset, eventTarget) {
            // Filter the event to register the type, which can be
            // touch, mouse or pointer. Offset changes need to be
            // made on an event specific basis.
            var touch = e.type.indexOf("touch") === 0;
            var mouse = e.type.indexOf("mouse") === 0;
            var pointer = e.type.indexOf("pointer") === 0;

            var x;
            var y;

            // IE10 implemented pointer events with a prefix;
            if (e.type.indexOf("MSPointer") === 0) {
                pointer = true;
            }

            // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with
            // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore
            // events that have no touches or buttons associated with them. (#1057, #1079, #1095)
            if (e.type === "mousedown" && !e.buttons && !e.touches) {
                return false;
            }

            // The only thing one handle should be concerned about is the touches that originated on top of it.
            if (touch) {
                // Returns true if a touch originated on the target.
                var isTouchOnTarget = function(checkTouch) {
                    return (
                        checkTouch.target === eventTarget ||
                        eventTarget.contains(checkTouch.target) ||
                        (checkTouch.target.shadowRoot && checkTouch.target.shadowRoot.contains(eventTarget))
                    );
                };

                // In the case of touchstart events, we need to make sure there is still no more than one
                // touch on the target so we look amongst all touches.
                if (e.type === "touchstart") {
                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);

                    // Do not support more than one touch per handle.
                    if (targetTouches.length > 1) {
                        return false;
                    }

                    x = targetTouches[0].pageX;
                    y = targetTouches[0].pageY;
                } else {
                    // In the other cases, find on changedTouches is enough.
                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);

                    // Cancel if the target touch has not moved.
                    if (!targetTouch) {
                        return false;
                    }

                    x = targetTouch.pageX;
                    y = targetTouch.pageY;
                }
            }

            pageOffset = pageOffset || getPageOffset(scope_Document);

            if (mouse || pointer) {
                x = e.clientX + pageOffset.x;
                y = e.clientY + pageOffset.y;
            }

            e.pageOffset = pageOffset;
            e.points = [x, y];
            e.cursor = mouse || pointer; // Fix #435

            return e;
        }

        // Translate a coordinate in the document to a percentage on the slider
        function calcPointToPercentage(calcPoint) {
            var location = calcPoint - offset(scope_Base, options.ort);
            var proposal = (location * 100) / baseSize();

            // Clamp proposal between 0% and 100%
            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
            // are used (e.g. contained handles feature)
            proposal = limit(proposal);

            return options.dir ? 100 - proposal : proposal;
        }

        // Find handle closest to a certain percentage on the slider
        function getClosestHandle(clickedPosition) {
            var smallestDifference = 100;
            var handleNumber = false;

            scope_Handles.forEach(function(handle, index) {
                // Disabled handles are ignored
                if (isHandleDisabled(index)) {
                    return;
                }

                var handlePosition = scope_Locations[index];
                var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);

                // Initial state
                var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;

                // Difference with this handle is smaller than the previously checked handle
                var isCloser = differenceWithThisHandle < smallestDifference;
                var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;

                if (isCloser || isCloserAfter || clickAtEdge) {
                    handleNumber = index;
                    smallestDifference = differenceWithThisHandle;
                }
            });

            return handleNumber;
        }

        // Fire 'end' when a mouse or pen leaves the document.
        function documentLeave(event, data) {
            if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {
                eventEnd(event, data);
            }
        }

        // Handle movement on document for handle and range drag.
        function eventMove(event, data) {
            // Fix #498
            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
            // IE9 has .buttons and .which zero on mousemove.
            // Firefox breaks the spec MDN defines.
            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {
                return eventEnd(event, data);
            }

            // Check if we are moving up or down
            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);

            // Convert the movement into a percentage of the slider width/height
            var proposal = (movement * 100) / data.baseSize;

            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);
        }

        // Unbind move events on document, call callbacks.
        function eventEnd(event, data) {
            // The handle is no longer active, so remove the class.
            if (data.handle) {
                removeClass(data.handle, options.cssClasses.active);
                scope_ActiveHandlesCount -= 1;
            }

            // Unbind the move and end events, which are added on 'start'.
            data.listeners.forEach(function(c) {
                scope_DocumentElement.removeEventListener(c[0], c[1]);
            });

            if (scope_ActiveHandlesCount === 0) {
                // Remove dragging class.
                removeClass(scope_Target, options.cssClasses.drag);
                setZindex();

                // Remove cursor styles and text-selection events bound to the body.
                if (event.cursor) {
                    scope_Body.style.cursor = "";
                    scope_Body.removeEventListener("selectstart", preventDefault);
                }
            }

            data.handleNumbers.forEach(function(handleNumber) {
                fireEvent("change", handleNumber);
                fireEvent("set", handleNumber);
                fireEvent("end", handleNumber);
            });
        }

        // Bind move events on document.
        function eventStart(event, data) {
            // Ignore event if any handle is disabled
            if (data.handleNumbers.some(isHandleDisabled)) {
                return false;
            }

            var handle;

            if (data.handleNumbers.length === 1) {
                var handleOrigin = scope_Handles[data.handleNumbers[0]];

                handle = handleOrigin.children[0];
                scope_ActiveHandlesCount += 1;

                // Mark the handle as 'active' so it can be styled.
                addClass(handle, options.cssClasses.active);
            }

            // A drag should never propagate up to the 'tap' event.
            event.stopPropagation();

            // Record the event listeners.
            var listeners = [];

            // Attach the move and end events.
            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                // The event target has changed so we need to propagate the original one so that we keep
                // relying on it to extract target touches.
                target: event.target,
                handle: handle,
                listeners: listeners,
                startCalcPoint: event.calcPoint,
                baseSize: baseSize(),
                pageOffset: event.pageOffset,
                handleNumbers: data.handleNumbers,
                buttonsProperty: event.buttons,
                locations: scope_Locations.slice()
            });

            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                doNotReject: true,
                handleNumbers: data.handleNumbers
            });

            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                target: event.target,
                handle: handle,
                listeners: listeners,
                doNotReject: true,
                handleNumbers: data.handleNumbers
            });

            // We want to make sure we pushed the listeners in the listener list rather than creating
            // a new one as it has already been passed to the event handlers.
            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));

            // Text selection isn't an issue on touch devices,
            // so adding cursor styles can be skipped.
            if (event.cursor) {
                // Prevent the 'I' cursor and extend the range-drag cursor.
                scope_Body.style.cursor = getComputedStyle(event.target).cursor;

                // Mark the target with a dragging state.
                if (scope_Handles.length > 1) {
                    addClass(scope_Target, options.cssClasses.drag);
                }

                // Prevent text selection when dragging the handles.
                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
                // The 'cursor' flag is false.
                // See: http://caniuse.com/#search=selectstart
                scope_Body.addEventListener("selectstart", preventDefault, false);
            }

            data.handleNumbers.forEach(function(handleNumber) {
                fireEvent("start", handleNumber);
            });
        }

        // Move closest handle to tapped location.
        function eventTap(event) {
            // The tap event shouldn't propagate up
            event.stopPropagation();

            var proposal = calcPointToPercentage(event.calcPoint);
            var handleNumber = getClosestHandle(proposal);

            // Tackle the case that all handles are 'disabled'.
            if (handleNumber === false) {
                return false;
            }

            // Flag the slider as it is now in a transitional state.
            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.
            if (!options.events.snap) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }

            setHandle(handleNumber, proposal, true, true);

            setZindex();

            fireEvent("slide", handleNumber, true);
            fireEvent("update", handleNumber, true);
            fireEvent("change", handleNumber, true);
            fireEvent("set", handleNumber, true);

            if (options.events.snap) {
                eventStart(event, { handleNumbers: [handleNumber] });
            }
        }

        // Fires a 'hover' event for a hovered mouse/pen position.
        function eventHover(event) {
            var proposal = calcPointToPercentage(event.calcPoint);

            var to = scope_Spectrum.getStep(proposal);
            var value = scope_Spectrum.fromStepping(to);

            Object.keys(scope_Events).forEach(function(targetEvent) {
                if ("hover" === targetEvent.split(".")[0]) {
                    scope_Events[targetEvent].forEach(function(callback) {
                        callback.call(scope_Self, value);
                    });
                }
            });
        }

        // Handles keydown on focused handles
        // Don't move the document when pressing arrow keys on focused handles
        function eventKeydown(event, handleNumber) {
            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {
                return false;
            }

            var horizontalKeys = ["Left", "Right"];
            var verticalKeys = ["Down", "Up"];
            var largeStepKeys = ["PageDown", "PageUp"];
            var edgeKeys = ["Home", "End"];

            if (options.dir && !options.ort) {
                // On an right-to-left slider, the left and right keys act inverted
                horizontalKeys.reverse();
            } else if (options.ort && !options.dir) {
                // On a top-to-bottom slider, the up and down keys act inverted
                verticalKeys.reverse();
                largeStepKeys.reverse();
            }

            // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
            var key = event.key.replace("Arrow", "");

            var isLargeDown = key === largeStepKeys[0];
            var isLargeUp = key === largeStepKeys[1];
            var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
            var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
            var isMin = key === edgeKeys[0];
            var isMax = key === edgeKeys[1];

            if (!isDown && !isUp && !isMin && !isMax) {
                return true;
            }

            event.preventDefault();

            var to;

            if (isUp || isDown) {
                var multiplier = options.keyboardPageMultiplier;
                var direction = isDown ? 0 : 1;
                var steps = getNextStepsForHandle(handleNumber);
                var step = steps[direction];

                // At the edge of a slider, do nothing
                if (step === null) {
                    return false;
                }

                // No step set, use the default of 10% of the sub-range
                if (step === false) {
                    step = scope_Spectrum.getDefaultStep(
                        scope_Locations[handleNumber],
                        isDown,
                        options.keyboardDefaultStep
                    );
                }

                if (isLargeUp || isLargeDown) {
                    step *= multiplier;
                }

                // Step over zero-length ranges (#948);
                step = Math.max(step, 0.0000001);

                // Decrement for down steps
                step = (isDown ? -1 : 1) * step;

                to = scope_Values[handleNumber] + step;
            } else if (isMax) {
                // End key
                to = options.spectrum.xVal[options.spectrum.xVal.length - 1];
            } else {
                // Home key
                to = options.spectrum.xVal[0];
            }

            setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);

            fireEvent("slide", handleNumber);
            fireEvent("update", handleNumber);
            fireEvent("change", handleNumber);
            fireEvent("set", handleNumber);

            return false;
        }

        // Attach events to several slider parts.
        function bindSliderEvents(behaviour) {
            // Attach the standard drag event to the handles.
            if (!behaviour.fixed) {
                scope_Handles.forEach(function(handle, index) {
                    // These events are only bound to the visual handle
                    // element, not the 'real' origin element.
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [index]
                    });
                });
            }

            // Attach the tap event to the slider base.
            if (behaviour.tap) {
                attachEvent(actions.start, scope_Base, eventTap, {});
            }

            // Fire hover events
            if (behaviour.hover) {
                attachEvent(actions.move, scope_Base, eventHover, {
                    hover: true
                });
            }

            // Make the range draggable.
            if (behaviour.drag) {
                scope_Connects.forEach(function(connect, index) {
                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {
                        return;
                    }

                    var handleBefore = scope_Handles[index - 1];
                    var handleAfter = scope_Handles[index];
                    var eventHolders = [connect];

                    addClass(connect, options.cssClasses.draggable);

                    // When the range is fixed, the entire range can
                    // be dragged by the handles. The handle in the first
                    // origin will propagate the start event upward,
                    // but it needs to be bound manually on the other.
                    if (behaviour.fixed) {
                        eventHolders.push(handleBefore.children[0]);
                        eventHolders.push(handleAfter.children[0]);
                    }

                    eventHolders.forEach(function(eventHolder) {
                        attachEvent(actions.start, eventHolder, eventStart, {
                            handles: [handleBefore, handleAfter],
                            handleNumbers: [index - 1, index]
                        });
                    });
                });
            }
        }

        // Attach an event to this slider, possibly including a namespace
        function bindEvent(namespacedEvent, callback) {
            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
            scope_Events[namespacedEvent].push(callback);

            // If the event bound is 'update,' fire it immediately for all handles.
            if (namespacedEvent.split(".")[0] === "update") {
                scope_Handles.forEach(function(a, index) {
                    fireEvent("update", index);
                });
            }
        }

        function isInternalNamespace(namespace) {
            return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
        }

        // Undo attachment of event
        function removeEvent(namespacedEvent) {
            var event = namespacedEvent && namespacedEvent.split(".")[0];
            var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;

            Object.keys(scope_Events).forEach(function(bind) {
                var tEvent = bind.split(".")[0];
                var tNamespace = bind.substring(tEvent.length);
                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {
                    // only delete protected internal event if intentional
                    if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {
                        delete scope_Events[bind];
                    }
                }
            });
        }

        // External event handling
        function fireEvent(eventName, handleNumber, tap) {
            Object.keys(scope_Events).forEach(function(targetEvent) {
                var eventType = targetEvent.split(".")[0];

                if (eventName === eventType) {
                    scope_Events[targetEvent].forEach(function(callback) {
                        callback.call(
                            // Use the slider public API as the scope ('this')
                            scope_Self,
                            // Return values as array, so arg_1[arg_2] is always valid.
                            scope_Values.map(options.format.to),
                            // Handle index, 0 or 1
                            handleNumber,
                            // Un-formatted slider values
                            scope_Values.slice(),
                            // Event is fired by tap, true or false
                            tap || false,
                            // Left offset of the handle, in relation to the slider
                            scope_Locations.slice(),
                            // add the slider public API to an accessible parameter when this is unavailable
                            scope_Self
                        );
                    });
                }
            });
        }

        // Split out the handle positioning logic so the Move event can use it, too
        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
            var distance;

            // For sliders with multiple handles, limit movement to the other handle.
            // Apply the margin option by adding it to the handle positions.
            if (scope_Handles.length > 1 && !options.events.unconstrained) {
                if (lookBackward && handleNumber > 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, 0);
                    to = Math.max(to, distance);
                }

                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, 1);
                    to = Math.min(to, distance);
                }
            }

            // The limit option has the opposite effect, limiting handles to a
            // maximum distance from another. Limit must be > 0, as otherwise
            // handles would be unmovable.
            if (scope_Handles.length > 1 && options.limit) {
                if (lookBackward && handleNumber > 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, 0);
                    to = Math.min(to, distance);
                }

                if (lookForward && handleNumber < scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, 1);
                    to = Math.max(to, distance);
                }
            }

            // The padding option keeps the handles a certain distance from the
            // edges of the slider. Padding must be > 0.
            if (options.padding) {
                if (handleNumber === 0) {
                    distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], 0);
                    to = Math.max(to, distance);
                }

                if (handleNumber === scope_Handles.length - 1) {
                    distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], 1);
                    to = Math.min(to, distance);
                }
            }

            to = scope_Spectrum.getStep(to);

            // Limit percentage to the 0 - 100 range
            to = limit(to);

            // Return false if handle can't move
            if (to === reference[handleNumber] && !getValue) {
                return false;
            }

            return to;
        }

        // Uses slider orientation to create CSS rules. a = base value;
        function inRuleOrder(v, a) {
            var o = options.ort;
            return (o ? a : v) + ", " + (o ? v : a);
        }

        // Moves handle(s) by a percentage
        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])
        function moveHandles(upward, proposal, locations, handleNumbers) {
            var proposals = locations.slice();

            var b = [!upward, upward];
            var f = [upward, !upward];

            // Copy handleNumbers so we don't change the dataset
            handleNumbers = handleNumbers.slice();

            // Check to see which handle is 'leading'.
            // If that one can't move the second can't either.
            if (upward) {
                handleNumbers.reverse();
            }

            // Step 1: get the maximum percentage that any of the handles can move
            if (handleNumbers.length > 1) {
                handleNumbers.forEach(function(handleNumber, o) {
                    var to = checkHandlePosition(
                        proposals,
                        handleNumber,
                        proposals[handleNumber] + proposal,
                        b[o],
                        f[o],
                        false
                    );

                    // Stop if one of the handles can't move.
                    if (to === false) {
                        proposal = 0;
                    } else {
                        proposal = to - proposals[handleNumber];
                        proposals[handleNumber] = to;
                    }
                });
            }

            // If using one handle, check backward AND forward
            else {
                b = f = [true];
            }

            var state = false;

            // Step 2: Try to set the handles with the found percentage
            handleNumbers.forEach(function(handleNumber, o) {
                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
            });

            // Step 3: If a handle moved, fire events
            if (state) {
                handleNumbers.forEach(function(handleNumber) {
                    fireEvent("update", handleNumber);
                    fireEvent("slide", handleNumber);
                });
            }
        }

        // Takes a base value and an offset. This offset is used for the connect bar size.
        // In the initial design for this feature, the origin element was 1% wide.
        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223
        function transformDirection(a, b) {
            return options.dir ? 100 - a - b : a;
        }

        // Updates scope_Locations and scope_Values, updates visual state
        function updateHandlePosition(handleNumber, to) {
            // Update locations.
            scope_Locations[handleNumber] = to;

            // Convert the value to the slider stepping/range.
            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);

            var translation = 10 * (transformDirection(to, 0) - scope_DirOffset);
            var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";

            scope_Handles[handleNumber].style[options.transformRule] = translateRule;

            updateConnect(handleNumber);
            updateConnect(handleNumber + 1);
        }

        // Handles before the slider middle are stacked later = higher,
        // Handles after the middle later is lower
        // [[7] [8] .......... | .......... [5] [4]
        function setZindex() {
            scope_HandleNumbers.forEach(function(handleNumber) {
                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
                scope_Handles[handleNumber].style.zIndex = zIndex;
            });
        }

        // Test suggested values and apply margin, step.
        // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)
        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput) {
            if (!exactInput) {
                to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
            }

            if (to === false) {
                return false;
            }

            updateHandlePosition(handleNumber, to);

            return true;
        }

        // Updates style attribute for connect nodes
        function updateConnect(index) {
            // Skip connects set to false
            if (!scope_Connects[index]) {
                return;
            }

            var l = 0;
            var h = 100;

            if (index !== 0) {
                l = scope_Locations[index - 1];
            }

            if (index !== scope_Connects.length - 1) {
                h = scope_Locations[index];
            }

            // We use two rules:
            // 'translate' to change the left/top offset;
            // 'scale' to change the width of the element;
            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)
            var connectWidth = h - l;
            var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
            var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";

            scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
        }

        // Parses value passed to .set method. Returns current value if not parse-able.
        function resolveToValue(to, handleNumber) {
            // Setting with null indicates an 'ignore'.
            // Inputting 'false' is invalid.
            if (to === null || to === false || to === undefined) {
                return scope_Locations[handleNumber];
            }

            // If a formatted number was passed, attempt to decode it.
            if (typeof to === "number") {
                to = String(to);
            }

            to = options.format.from(to);
            to = scope_Spectrum.toStepping(to);

            // If parsing the number failed, use the current value.
            if (to === false || isNaN(to)) {
                return scope_Locations[handleNumber];
            }

            return to;
        }

        // Set the slider value.
        function valueSet(input, fireSetEvent, exactInput) {
            var values = asArray(input);
            var isInit = scope_Locations[0] === undefined;

            // Event fires by default
            fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;

            // Animation is optional.
            // Make sure the initial values were set before using animated placement.
            if (options.animate && !isInit) {
                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
            }

            // First pass, without lookAhead but with lookBackward. Values are set from left to right.
            scope_HandleNumbers.forEach(function(handleNumber) {
                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
            });

            var i = scope_HandleNumbers.length === 1 ? 0 : 1;

            // Secondary passes. Now that all base values are set, apply constraints.
            // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)
            for (; i < scope_HandleNumbers.length; ++i) {
                scope_HandleNumbers.forEach(function(handleNumber) {
                    setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
                });
            }

            setZindex();

            scope_HandleNumbers.forEach(function(handleNumber) {
                fireEvent("update", handleNumber);

                // Fire the event only for handles that received a new value, as per #579
                if (values[handleNumber] !== null && fireSetEvent) {
                    fireEvent("set", handleNumber);
                }
            });
        }

        // Reset slider to initial values
        function valueReset(fireSetEvent) {
            valueSet(options.start, fireSetEvent);
        }

        // Set value for a single handle
        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
            // Ensure numeric input
            handleNumber = Number(handleNumber);

            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {
                throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);
            }

            // Look both backward and forward, since we don't want this handle to "push" other handles (#960);
            // The exactInput argument can be used to ignore slider stepping (#436)
            setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);

            fireEvent("update", handleNumber);

            if (fireSetEvent) {
                fireEvent("set", handleNumber);
            }
        }

        // Get the slider value.
        function valueGet() {
            var values = scope_Values.map(options.format.to);

            // If only one handle is used, return a single value.
            if (values.length === 1) {
                return values[0];
            }

            return values;
        }

        // Removes classes from the root and empties it.
        function destroy() {
            // remove protected internal listeners
            removeEvent(INTERNAL_EVENT_NS.aria);
            removeEvent(INTERNAL_EVENT_NS.tooltips);

            for (var key in options.cssClasses) {
                if (!options.cssClasses.hasOwnProperty(key)) {
                    continue;
                }
                removeClass(scope_Target, options.cssClasses[key]);
            }

            while (scope_Target.firstChild) {
                scope_Target.removeChild(scope_Target.firstChild);
            }

            delete scope_Target.noUiSlider;
        }

        function getNextStepsForHandle(handleNumber) {
            var location = scope_Locations[handleNumber];
            var nearbySteps = scope_Spectrum.getNearbySteps(location);
            var value = scope_Values[handleNumber];
            var increment = nearbySteps.thisStep.step;
            var decrement = null;

            // If snapped, directly use defined step value
            if (options.snap) {
                return [
                    value - nearbySteps.stepBefore.startValue || null,
                    nearbySteps.stepAfter.startValue - value || null
                ];
            }

            // If the next value in this step moves into the next step,
            // the increment is the start of the next step - the current value
            if (increment !== false) {
                if (value + increment > nearbySteps.stepAfter.startValue) {
                    increment = nearbySteps.stepAfter.startValue - value;
                }
            }

            // If the value is beyond the starting point
            if (value > nearbySteps.thisStep.startValue) {
                decrement = nearbySteps.thisStep.step;
            } else if (nearbySteps.stepBefore.step === false) {
                decrement = false;
            }

            // If a handle is at the start of a step, it always steps back into the previous step first
            else {
                decrement = value - nearbySteps.stepBefore.highestStep;
            }

            // Now, if at the slider edges, there is no in/decrement
            if (location === 100) {
                increment = null;
            } else if (location === 0) {
                decrement = null;
            }

            // As per #391, the comparison for the decrement step can have some rounding issues.
            var stepDecimals = scope_Spectrum.countStepDecimals();

            // Round per #391
            if (increment !== null && increment !== false) {
                increment = Number(increment.toFixed(stepDecimals));
            }

            if (decrement !== null && decrement !== false) {
                decrement = Number(decrement.toFixed(stepDecimals));
            }

            return [decrement, increment];
        }

        // Get the current step size for the slider.
        function getNextSteps() {
            return scope_HandleNumbers.map(getNextStepsForHandle);
        }

        // Updateable: margin, limit, padding, step, range, animate, snap
        function updateOptions(optionsToUpdate, fireSetEvent) {
            // Spectrum is created using the range, snap, direction and step options.
            // 'snap' and 'step' can be updated.
            // If 'snap' and 'step' are not passed, they should remain unchanged.
            var v = valueGet();

            var updateAble = [
                "margin",
                "limit",
                "padding",
                "range",
                "animate",
                "snap",
                "step",
                "format",
                "pips",
                "tooltips"
            ];

            // Only change options that we're actually passed to update.
            updateAble.forEach(function(name) {
                // Check for undefined. null removes the value.
                if (optionsToUpdate[name] !== undefined) {
                    originalOptions[name] = optionsToUpdate[name];
                }
            });

            var newOptions = testOptions(originalOptions);

            // Load new options into the slider state
            updateAble.forEach(function(name) {
                if (optionsToUpdate[name] !== undefined) {
                    options[name] = newOptions[name];
                }
            });

            scope_Spectrum = newOptions.spectrum;

            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)
            options.margin = newOptions.margin;
            options.limit = newOptions.limit;
            options.padding = newOptions.padding;

            // Update pips, removes existing.
            if (options.pips) {
                pips(options.pips);
            } else {
                removePips();
            }

            // Update tooltips, removes existing.
            if (options.tooltips) {
                tooltips();
            } else {
                removeTooltips();
            }

            // Invalidate the current positioning so valueSet forces an update.
            scope_Locations = [];
            valueSet(optionsToUpdate.start || v, fireSetEvent);
        }

        // Initialization steps
        function setupSlider() {
            // Create the base element, initialize HTML and set classes.
            // Add handles and connect elements.
            scope_Base = addSlider(scope_Target);

            addElements(options.connect, scope_Base);

            // Attach user events.
            bindSliderEvents(options.events);

            // Use the public value method to set the start values.
            valueSet(options.start);

            if (options.pips) {
                pips(options.pips);
            }

            if (options.tooltips) {
                tooltips();
            }

            aria();
        }

        setupSlider();

        // noinspection JSUnusedGlobalSymbols
        scope_Self = {
            destroy: destroy,
            steps: getNextSteps,
            on: bindEvent,
            off: removeEvent,
            get: valueGet,
            set: valueSet,
            setHandle: valueSetHandle,
            reset: valueReset,
            // Exposed for unit testing, don't use this in your application.
            __moveHandles: function(a, b, c) {
                moveHandles(a, b, scope_Locations, c);
            },
            options: originalOptions, // Issue #600, #678
            updateOptions: updateOptions,
            target: scope_Target, // Issue #597
            removePips: removePips,
            removeTooltips: removeTooltips,
            getTooltips: function() {
                return scope_Tooltips;
            },
            getOrigins: function() {
                return scope_Handles;
            },
            pips: pips // Issue #594
        };

        return scope_Self;
    }

    // Run the standard initializer
    function initialize(target, originalOptions) {
        if (!target || !target.nodeName) {
            throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
        }

        // Throw an error if the slider was already initialized.
        if (target.noUiSlider) {
            throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
        }

        // Test the options and create the slider environment;
        var options = testOptions(originalOptions, target);
        var api = scope(target, options, originalOptions);

        target.noUiSlider = api;

        return api;
    }

    // Use an object instead of a function for future expandability;
    return {
        // Exposed for unit testing, don't use this in your application.
        __spectrum: Spectrum,
        version: VERSION,
        // A reference to the default classes, allows global changes.
        // Use the cssClasses option for changes to one slider.
        cssClasses: cssClasses,
        create: initialize
    };
});


/***/ }),

/***/ "?3216":
/*!***********************!*\
  !*** jsdom (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?aa72":
/*!********************************************************!*\
  !*** jsdom/lib/jsdom/living/generated/utils (ignored) ***!
  \********************************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c310":
/*!***************************************!*\
  !*** jsdom/lib/jsdom/utils (ignored) ***!
  \***************************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/app/layout.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtLy4vc3JjL2FwcC9hdXRoLmpzIiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vLi9zcmMvYXBwL2xheW91dC5qcyIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtLy4vbm9kZV9tb2R1bGVzL2ZhYnJpYy9kaXN0L2ZhYnJpYy5qcyIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtLy4vbm9kZV9tb2R1bGVzL25vdWlzbGlkZXIvZGlzdHJpYnV0ZS9ub3Vpc2xpZGVyLmNzcz8wZWM5Iiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuanMiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS9pZ25vcmVkfGpzZG9tIiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vaWdub3JlZHxqc2RvbS9saWIvanNkb20vbGl2aW5nL2dlbmVyYXRlZC91dGlscyIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtL2lnbm9yZWR8anNkb20vbGliL2pzZG9tL3V0aWxzIiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9yZXN0YXVyYW50X21hbmFnZW1lbnRfc3lzdGVtL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmVzdGF1cmFudF9tYW5hZ2VtZW50X3N5c3RlbS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Jlc3RhdXJhbnRfbWFuYWdlbWVudF9zeXN0ZW0vd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbInNpZ251cEZvcm0iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJsb2dpbkZvcm0iLCJsb2dvdXQiLCJnZXRFbGVtZW50QnlJZCIsImxvZ2luIiwic3R5bGUiLCJkaXNwbGF5IiwiZmlyZWJhc2UiLCJhcHBzIiwibGVuZ3RoIiwiZmlyZWJhc2VDb25maWciLCJhcGlLZXkiLCJhdXRoRG9tYWluIiwicHJvamVjdElkIiwic3RvcmFnZUJ1Y2tldCIsIm1lc3NhZ2luZ1NlbmRlcklkIiwiYXBwSWQiLCJtZWFzdXJlbWVudElkIiwiaW5pdGlhbGl6ZUFwcCIsImF1dGgiLCJkYiIsImRhdGFiYXNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm9uQXV0aFN0YXRlQ2hhbmdlZCIsInVzZXIiLCJzZXRJdGVtIiwibGluayIsImVtYWlsIiwiaW5kZXhPZiIsImlubmVySFRNTCIsImRpc3BsYXlOYW1lIiwicmVkaXJlY3QiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIndyaXRlVXNlckRhdGEiLCJ1c2VySWQiLCJuYW1lIiwicmVmIiwic2V0IiwidXNlcm5hbWUiLCJ0b2dnbGVTaWdudXAiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsInRvZ2dsZUxvZ2luIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImFsZXJ0IiwicmVzZXQiLCJ2YWx1ZSIsInBhc3N3b3JkIiwiY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIiwidGhlbiIsImNyZWQiLCJjdXJyZW50VXNlciIsInVwZGF0ZVByb2ZpbGUiLCJ1aWQiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJtZXNzYWdlIiwic2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQiLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJ0b0xvd2VyQ2FzZSIsInNpZ25PdXQiLCJjYW52YXMiLCJudW1iZXIiLCJncmlkIiwibGluZVN0cm9rZSIsInRhYmxlRmlsbCIsInRhYmxlU3Ryb2tlIiwidGFibGVTaGFkb3ciLCJjaGFpckZpbGwiLCJjaGFpclN0cm9rZSIsImNoYWlyU2hhZG93IiwiYmFyRmlsbCIsImJhclN0cm9rZSIsImJhclNoYWRvdyIsImJhclRleHQiLCJ3YWxsRmlsbCIsIndhbGxTdHJva2UiLCJ3YWxsU2hhZG93IiwicGhvdG9VcmxMYW5kc2NhcGUiLCJwaG90b1VybFBvcnRyYWl0Iiwid2lkdGhFbCIsImhlaWdodEVsIiwiY2FudmFzRWwiLCJzZXRBdHRyaWJ1dGUiLCJpbml0Q2FudmFzIiwiY2xlYXIiLCJkaXNwb3NlIiwiZmFicmljIiwicGFyc2VJbnQiLCJpIiwiaGVpZ2h0IiwibGluZVgiLCJzdHJva2UiLCJzZWxlY3RhYmxlIiwibGluZVkiLCJzZW5kTGluZXNUb0JhY2siLCJvbiIsInNuYXBUb0dyaWQiLCJ0YXJnZXQiLCJzY2FsZVgiLCJzY2FsZVkiLCJzdHJva2VXaWR0aFVuc2NhbGVkIiwic3Ryb2tlV2lkdGgiLCJNYXRoIiwicm91bmQiLCJicmluZ1RvRnJvbnQiLCJzZW5kVG9CYWNrIiwiY2hlY2tCb3VkbmluZ0JveCIsInJlc2l6ZUNhbnZhcyIsIndpZHRoIiwiY2FudmFzQ29udGFpbmVyRWwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2FudmFzTG9hZGVyIiwiZ2VuZXJhdGVJZCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiYWRkUmVjdCIsImxlZnQiLCJ0b3AiLCJpZCIsIm8iLCJmaWxsIiwic2hhZG93IiwicngiLCJyeSIsIm9yaWdpblgiLCJvcmlnaW5ZIiwiY2VudGVyZWRSb3RhdGlvbiIsInNuYXBBbmdsZSIsInQiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJ0ZXh0QWxpZ24iLCJnIiwiYWRkIiwiYWRkQ2lyY2xlIiwicmFkaXVzIiwiYWRkVHJpYW5nbGUiLCJhZGRDaGFpciIsImFkZEJhciIsImFkZFdhbGwiLCJvYmoiLCJzZXRDb29yZHMiLCJvYmpCb3VuZGluZ0JveCIsImdldEJvdW5kaW5nUmVjdCIsImdldE9iamVjdHMiLCJtYXAiLCJzZXRBY3RpdmVPYmplY3QiLCJnZXRBY3RpdmVPYmplY3QiLCJyZW1vdmUiLCJkaXNjYXJkQWN0aXZlT2JqZWN0IiwicmVuZGVyQWxsIiwiaGFzQ29udHJvbHMiLCJsb2NrTW92ZW1lbnRYIiwibG9ja01vdmVtZW50WSIsInR5cGUiLCJfb2JqZWN0cyIsInRleHQiLCJib3JkZXJDb2xvciIsImJvcmRlclNjYWxlRmFjdG9yIiwic2VsZWN0aW9uIiwiaG92ZXJDdXJzb3IiLCJhcnJheU9mVGFibGVzTm9zIiwidXNlclRhYmxlTm9zIiwic2F2ZVJlc2VydmF0aW9uIiwidGFibGVObyIsImRhdGUiLCJ0aW1lIiwib25jZSIsInNuYXAiLCJ2YWwiLCJzIiwicmVzZXJ2ZWRUYWJsZU5vIiwiRXJyb3IiLCJjbGljayIsInNlbGVjdGVkT2JqIiwib2JqZWN0cyIsImFkZERlZmF1bHRPYmplY3RzIiwidG90YWxUYWJsZXMiLCJjb250cm9sTnVtYmVyaW5nIiwianNvbl9jYW52YXMiLCJ0b0pTT04iLCJqc29uVmFyaWFibGUiLCJqc29uIiwibG9hZEZyb21KU09OIiwiYmluZCIsInJlc2VyRGF0ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJyZXNlclRpbWUiLCJhdmFpbFJlZiIsInJlc2VydmVkVGFibGVzIiwicmVzZXJ2ZWRUYWJsZU5vQXJyYXkiLCJzcGxpdCIsImpzb25DYW52YXNSZWFsdGltZSIsImZvckVhY2giLCJlbGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsSUFBTUEsVUFBVSxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsOEJBQXZCLENBQW5CO0FBQ0EsSUFBTUMsU0FBUyxHQUFHRixRQUFRLENB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LENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUNBQSxVQUFRLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBUjtBQUVBdEIsU0FBTyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEVBQWIsQ0FBUDtBQUNBQSxTQUFPLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVSxFQUFWLEVBQWMsRUFBZCxDQUFQO0FBQ0FBLFNBQU8sQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEVBQVgs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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWMsZ0ZBQWdGLHNEQUFzRDtBQUNqSyxhQUFhLFNBQVM7QUFDdEIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjLGdGQUFnRixzREFBc0Q7QUFDakssYUFBYSxTQUFTO0FBQ3RCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELFNBQVM7QUFDNUQsMEVBQTBFLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFlBQVk7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsZ0JBQWdCO0FBQzdCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTLG1CQUFtQjtBQUMzQyxlQUFlLEVBQUU7QUFDakIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTLG1CQUFtQjtBQUMzQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsS0FBOEIsYUFBYSxDQUFJOzs7QUFHbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRTs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVztBQUMzRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSx3QkFBd0IsRUFBRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBLHlDQUF5QyxPQUFPOztBQUVoRDtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RCw0Q0FBNEMsT0FBTztBQUNuRCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHFCQUFxQixZQUFZO0FBQ2pDO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0IsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87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QUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEUsOERBQThELGVBQWU7QUFDN0U7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDaG03QkQ7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQ7QUFDQSxRQUFRLGlDQUFPLEVBQUUsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUMzQixLQUFLLE1BQU0sRUFNTjtBQUNMLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG1DQUFtQztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLDhDQUE4QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQyxxQ0FBcUMsMENBQTBDO0FBQy9FLGtDQUFrQyx1Q0FBdUM7QUFDekUsb0JBQW9CLHdCQUF3QjtBQUM1QyxzQkFBc0IsMEJBQTBCO0FBQ2hELHdCQUF3Qiw0QkFBNEI7QUFDcEQsbUJBQW1CLHdCQUF3QjtBQUMzQyxzQkFBc0IsMkJBQTJCO0FBQ2pELGdDQUFnQyxxQ0FBcUM7QUFDckUsb0JBQW9CLHdCQUF3QjtBQUM1QywwQkFBMEIsK0JBQStCO0FBQ3pELHFCQUFxQiwwQkFBMEI7QUFDL0Msb0JBQW9CLHlCQUF5QjtBQUM3QyxzQkFBc0IsMkJBQTJCO0FBQ2pELHdCQUF3Qiw0QkFBNEI7QUFDcEQseUJBQXlCLDhCQUE4QjtBQUN2RCxxQkFBcUIsMEJBQTBCO0FBQy9DLHVCQUF1Qiw0QkFBNEI7QUFDbkQsOEJBQThCLGtDQUFrQztBQUNoRSw4QkFBOEIsbUNBQW1DO0FBQ2pFLHdCQUF3Qiw0QkFBNEI7QUFDcEQseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSxnQkFBZ0I7QUFDL0Y7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ3BvRkQsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0NyQkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGdDQUFnQyxZQUFZO1dBQzVDO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEEsc0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7VUNOQTtVQUNBO1VBQ0E7VUFDQSIsImZpbGUiOiJsYXlvdXQuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHsgYXV0aCB9IGZyb20gJy4vaW5kZXguanMnO1xyXG5jb25zdCBzaWdudXBGb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NpZ251cC1mb3JtLWNvbnRhaW5lcl9fZm9ybScpO1xyXG5jb25zdCBsb2dpbkZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbG9naW4tZm9ybS1jb250YWluZXJfX2Zvcm0nKTtcclxuY29uc3QgbG9nb3V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ291dCcpO1xyXG5jb25zdCBsb2dpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dpbicpO1xyXG5sb2dpbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XHJcbmxvZ291dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuLy8gRm9yIEZpcmViYXNlIEpTIFNESyB2Ny4yMC4wIGFuZCBsYXRlciwgbWVhc3VyZW1lbnRJZCBpcyBvcHRpb25hbFxyXG5pZiAoZmlyZWJhc2UuYXBwcy5sZW5ndGggPT09IDApIHtcclxuICAgIHZhciBmaXJlYmFzZUNvbmZpZyA9IHtcclxuICAgICAgICBhcGlLZXk6ICdBSXphU3lBelU4U1gwcTktVXNtR245a2RBSldXcjliNWpGUVdVSU0nLFxyXG4gICAgICAgIGF1dGhEb21haW46ICdyZXN0YXVyYW50LTg0ZmMyLmZpcmViYXNlYXBwLmNvbScsXHJcbiAgICAgICAgcHJvamVjdElkOiAncmVzdGF1cmFudC04NGZjMicsXHJcbiAgICAgICAgc3RvcmFnZUJ1Y2tldDogJ3Jlc3RhdXJhbnQtODRmYzIuYXBwc3BvdC5jb20nLFxyXG4gICAgICAgIG1lc3NhZ2luZ1NlbmRlcklkOiAnMjI1ODY2MTcyNTI3JyxcclxuICAgICAgICBhcHBJZDogJzE6MjI1ODY2MTcyNTI3OndlYjphMTM0YTg3YzdkZTNlYTQxNzM2NTlhJyxcclxuICAgICAgICBtZWFzdXJlbWVudElkOiAnRy03OVE3REdDU0dKJyxcclxuICAgIH07XHJcbiAgICAvLyBJbml0aWFsaXplIEZpcmViYXNlXHJcbiAgICBmaXJlYmFzZS5pbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKTtcclxufVxyXG5leHBvcnQgdmFyIGF1dGggPSBmaXJlYmFzZS5hdXRoKCk7XHJcbmV4cG9ydCB2YXIgZGIgPSBmaXJlYmFzZS5kYXRhYmFzZSgpO1xyXG5cclxuaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsb2dnZWRJbicpID09PSBudWxsKSB7XHJcbiAgICBhdXRoLm9uQXV0aFN0YXRlQ2hhbmdlZCgodXNlcikgPT4ge1xyXG4gICAgICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsb2dnZWRJbicsICd0cnVlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xvZ2dlZEluJywgJ2ZhbHNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIENvbnRyb2xzIGRpc3BsYXlpbmcgVXNlcm5hbWUgb24gaGVhZGVyXHJcbmF1dGgub25BdXRoU3RhdGVDaGFuZ2VkKCh1c2VyKSA9PiB7XHJcbiAgICBpZiAodXNlciAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbG9nZ2VkSW4nKSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgbGV0IGxpbmsgPSAnJztcclxuICAgICAgICBpZiAodXNlci5lbWFpbC5pbmRleE9mKCd2aW5lYXQnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgbGluayA9ICcvbWFuYWdlci5odG1sJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsaW5rID0gJy91c2VyLmh0bWwnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JlZXQtd3JhcHBlcicpLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgIGA8YSBocmVmPVwiJHtsaW5rfVwiIGlkPVwiZ3JlZXRcIj5gICtcclxuICAgICAgICAgICAgYEhlbGxvLCAke3VzZXIuZGlzcGxheU5hbWV9YCArXHJcbiAgICAgICAgICAgICc8L2E+JztcclxuICAgICAgICBsb2dvdXQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xyXG4gICAgICAgIGxvZ2luLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmVldC13cmFwcGVyJykuaW5uZXJIVE1MID0gYGA7XHJcbiAgICAgICAgbG9nb3V0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgbG9naW4uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIENvbnRyb2xzIHJlZGlyZWN0aW9uIGZyb20gYXV0aG91cml6YXRpb24gcGFnZVxyXG5mdW5jdGlvbiByZWRpcmVjdChlbWFpbCkge1xyXG4gICAgaWYgKGVtYWlsLmluZGV4T2YoJ0B2aW5lYXQuY29tJykgIT09IC0xKSB7XHJcbiAgICAgICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dyZWV0JykuaHJlZiA9ICcvbWFuYWdlci5odG1sJztcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSAnL21hbmFnZXIuaHRtbCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmVldCcpLmhyZWYgPSAnL3VzZXIuaHRtbCc7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gJy91c2VyLmh0bWwnO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBTYXZlcyBkYXRhIGludG8gRGF0YWJhc2VcclxuZnVuY3Rpb24gd3JpdGVVc2VyRGF0YSh1c2VySWQsIG5hbWUsIGVtYWlsKSB7XHJcbiAgICBmaXJlYmFzZVxyXG4gICAgICAgIC5kYXRhYmFzZSgpXHJcbiAgICAgICAgLnJlZigndXNlcnMvJyArIHVzZXJJZClcclxuICAgICAgICAuc2V0KHtcclxuICAgICAgICAgICAgdXNlcm5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIGVtYWlsOiBlbWFpbCxcclxuICAgICAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB0b2dnbGVTaWdudXAoKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9naW4tdG9nZ2xlJykuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ2luLXRvZ2dsZScpLnN0eWxlLmNvbG9yID0gJyMyMjInO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpZ251cC10b2dnbGUnKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnIzAwYTJmZic7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lnbnVwLXRvZ2dsZScpLnN0eWxlLmNvbG9yID0gJyNmZmYnO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ2luLWZvcm0tY29udGFpbmVyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaWdudXAtZm9ybS1jb250YWluZXInKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxufVxyXG53aW5kb3cudG9nZ2xlU2lnbnVwID0gdG9nZ2xlU2lnbnVwO1xyXG5mdW5jdGlvbiB0b2dnbGVMb2dpbigpIHtcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dpbi10b2dnbGUnKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnIzAwYTJmZic7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9naW4tdG9nZ2xlJykuc3R5bGUuY29sb3IgPSAnI2ZmZic7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lnbnVwLXRvZ2dsZScpLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZmZmJztcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaWdudXAtdG9nZ2xlJykuc3R5bGUuY29sb3IgPSAnIzIyMic7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lnbnVwLWZvcm0tY29udGFpbmVyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dpbi1mb3JtLWNvbnRhaW5lcicpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG59XHJcbndpbmRvdy50b2dnbGVMb2dpbiA9IHRvZ2dsZUxvZ2luO1xyXG5cclxuLy8gU2lnbnVwIGZ1bmN0aW9uYWxpdHlcclxuaWYgKHNpZ251cEZvcm0pIHtcclxuICAgIHNpZ251cEZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgKGUpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsb2dnZWRJbicpID09PSAndHJ1ZScpIHtcclxuICAgICAgICAgICAgYWxlcnQoJ1VzZXIgYWxyZWFkeSBsb2dnZWQgaW5cXG5QbGVhc2UgbG9nb3V0IHRvIGNvbnRpbnVlJyk7XHJcbiAgICAgICAgICAgIGxvZ2luRm9ybS5yZXNldCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xvZ2dlZEluJykgPT09ICdmYWxzZScpIHtcclxuICAgICAgICAgICAgY29uc3QgdXNlcm5hbWUgPSBzaWdudXBGb3JtWydzaWduLXVwLXVzZXJuYW1lJ10udmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVtYWlsID0gc2lnbnVwRm9ybVsnc2lnbi11cC1lbWFpbCddLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IHNpZ251cEZvcm1bJ3NpZ24tdXAtcGFzc3dvcmQnXS52YWx1ZTtcclxuICAgICAgICAgICAgYXV0aC5jcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKGNyZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBhdXRoLmN1cnJlbnRVc2VyLnVwZGF0ZVByb2ZpbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVc2VyRGF0YShjcmVkLnVzZXIudWlkLCB1c2VybmFtZSwgZW1haWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNyZWQudXNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbnVwRm9ybS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdTdWNlc3NmdWxseSBzaWduZWQgdXBcXG4gWW91IGNhbiBsb2cgaW4gbm93Jyk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGVtYWlsLCBwYXNzd29yZCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gTG9naW4gRnVuY3Rpb25hbGl0eVxyXG5pZiAobG9naW5Gb3JtKSB7XHJcbiAgICBsb2dpbkZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgKGUpID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsb2dnZWRJbicpID09PSAndHJ1ZScpIHtcclxuICAgICAgICAgICAgYWxlcnQoJ1VzZXIgYWxyZWFkeSBsb2dnZWQgaW5cXG5QbGVhc2UgbG9nb3V0IHRvIGNvbnRpbnVlJyk7XHJcbiAgICAgICAgICAgIGxvZ2luRm9ybS5yZXNldCgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xvZ2dlZEluJykgPT09ICdmYWxzZScpIHtcclxuICAgICAgICAgICAgY29uc3QgZW1haWwgPSBsb2dpbkZvcm1bJ2xvZy1pbi1lbWFpbCddLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IGxvZ2luRm9ybVsnbG9nLWluLXBhc3N3b3JkJ10udmFsdWU7XHJcbiAgICAgICAgICAgIGF1dGguc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKGNyZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjcmVkLnVzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ2luRm9ybS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdTdWNlc3NmdWxseSBsb2dnZWQgaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbG9nZ2VkSW4nLCAndHJ1ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9nZ2VkSW5Vc2VyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoY3JlZC51c2VyKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1c2VyID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbG9nZ2VkSW5Vc2VyJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0KHVzZXIuZW1haWwudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIExvZ291dCBGdW5jdGlvbmFsaXR5XHJcbmlmIChsb2dvdXQpIHtcclxuICAgIGxvZ291dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbG9nZ2VkSW4nKSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICAgIGF1dGguc2lnbk91dCgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoJ1N1Y2Vzc2Z1bGx5IGxvZ2dlZCBvdXQnKTtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsb2dnZWRJbicsICdmYWxzZScpO1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xvZ2dlZEluVXNlcicsICcnKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9ICdhdXRoLmh0bWwnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsb2dnZWRJbicpID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KCdZb3UgYXJlIG5vdCBsb2dnZWQgaW4nKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCJpbXBvcnQgeyBhdXRoIH0gZnJvbSAnLi9hdXRoJztcclxuaW1wb3J0IHsgZGIgfSBmcm9tICcuL2F1dGgnO1xyXG5cclxuLy8gY29uc29sZS5sb2coJ2hlbGxvLCBNYW5hZ2VyJyk7XHJcblxyXG5pbXBvcnQgeyBmYWJyaWMgfSBmcm9tICdmYWJyaWMnO1xyXG5cclxuaW1wb3J0IG5vVWlTbGlkZXIgZnJvbSAnbm91aXNsaWRlcic7XHJcbmltcG9ydCAnbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuY3NzJztcclxuXHJcbnZhciBjYW52YXM7XHJcbnZhciBudW1iZXI7XHJcbnZhciBncmlkID0gMzA7XHJcbnZhciBiYWNrZ3JvdW5kQ29sb3IgPSAnIzYyNjI2Mic7XHJcbnZhciBsaW5lU3Ryb2tlID0gJyNlYmViZWInO1xyXG52YXIgdGFibGVGaWxsID0gJ3JnYmEoMTg3LCAxODcsIDE4NywgMC43KSc7XHJcbnZhciB0YWJsZVN0cm9rZSA9ICcjNWM1YzVjJztcclxudmFyIHRhYmxlU2hhZG93ID0gJ3JnYmEoMCwgMCwgMCwgMC40KSAzcHggM3B4IDdweCc7XHJcbnZhciBjaGFpckZpbGwgPSAncmdiYSg3NSwgNzUsIDc1LCAwLjcpJztcclxudmFyIGNoYWlyU3Ryb2tlID0gJyMzMjIzMGInO1xyXG52YXIgY2hhaXJTaGFkb3cgPSAncmdiYSgwLCAwLCAwLCAwLjQpIDNweCAzcHggN3B4JztcclxuLy8gdmFyIGJhckZpbGwgPSAncmdiYSgwLCA5MywgMTI3LCAwLjcpJztcclxudmFyIGJhckZpbGwgPSAncmdiYSgwLCAxNjIsIDI1NSwgMC43KSc7XHJcbnZhciBiYXJTdHJva2UgPSAnIzAwM2U1NCc7XHJcbnZhciBiYXJTaGFkb3cgPSAncmdiYSgwLCAwLCAwLCAwLjQpIDNweCAzcHggN3B4JztcclxudmFyIGJhclRleHQgPSAnQmFyJztcclxudmFyIHdhbGxGaWxsID0gJ3JnYmEoMTM2LCAxMzYsIDEzNiwgMC43KSc7XHJcbnZhciB3YWxsU3Ryb2tlID0gJyM2ODY4NjgnO1xyXG52YXIgd2FsbFNoYWRvdyA9ICdyZ2JhKDAsIDAsIDAsIDAuNCkgNXB4IDVweCAyMHB4JztcclxuXHJcbnZhciBwaG90b1VybExhbmRzY2FwZSA9ICdodHRwczovL2ltYWdlczguYWxwaGFjb2RlcnMuY29tLzI5Mi8yOTIzNzkuanBnJyxcclxuICAgIHBob3RvVXJsUG9ydHJhaXQgPVxyXG4gICAgICAgICdodHRwczovL3ByZXNzcGFjay5ydGUuaWUvd3AtY29udGVudC9ibG9ncy5kaXIvMi9maWxlcy8yMDE1LzA0L0FNQ19UV0RfTWFnZ2llX1BvcnRyYWl0c180ODE3X1YxLmpwZyc7XHJcblxyXG52YXIgd2lkdGhFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aWR0aCcpO1xyXG52YXIgaGVpZ2h0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVpZ2h0Jyk7XHJcbnZhciBjYW52YXNFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTtcclxuXHJcbmlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2lkdGhFbCcpICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdoZWlnaHRFbCcpKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2lkdGgnKS52YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3aWR0aEVsJyk7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVpZ2h0JykudmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaGVpZ2h0RWwnKTtcclxufSBlbHNlIHtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdoZWlnaHRFbCcsIGhlaWdodEVsLnZhbHVlKTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3aWR0aEVsJywgd2lkdGhFbC52YWx1ZSk7XHJcbn1cclxuXHJcbmNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2lkdGhFbCcpKTtcclxuY2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaGVpZ2h0RWwnKSk7XHJcblxyXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xyXG4gICAgaWYgKGNhbnZhcykge1xyXG4gICAgICAgIGNhbnZhcy5jbGVhcigpO1xyXG4gICAgICAgIGNhbnZhcy5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FudmFzID0gbmV3IGZhYnJpYy5DYW52YXMoJ2NhbnZhcycpO1xyXG4gICAgbnVtYmVyID0gcGFyc2VJbnQobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RvdGFsVGFibGVzJykpICsgMTtcclxuICAgIC8vIG51bWJlciA9IDE7XHJcbiAgICBjYW52YXMuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xyXG4gICAgLy8gY2FudmFzLnNldEJhY2tncm91bmRJbWFnZShcclxuICAgIC8vICAgICAnaHR0cHM6Ly9wcmVzc3BhY2sucnRlLmllL3dwLWNvbnRlbnQvYmxvZ3MuZGlyLzIvZmlsZXMvMjAxNS8wNC9BTUNfVFdEX01hZ2dpZV9Qb3J0cmFpdHNfNDgxN19WMS5qcGcnLFxyXG4gICAgLy8gICAgIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpXHJcbiAgICAvLyApO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzLmhlaWdodCAvIGdyaWQ7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmVYID0gbmV3IGZhYnJpYy5MaW5lKFswLCBpICogZ3JpZCwgY2FudmFzLmhlaWdodCwgaSAqIGdyaWRdLCB7XHJcbiAgICAgICAgICAgIHN0cm9rZTogbGluZVN0cm9rZSxcclxuICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBsaW5lWSA9IG5ldyBmYWJyaWMuTGluZShbaSAqIGdyaWQsIDAsIGkgKiBncmlkLCBjYW52YXMuaGVpZ2h0XSwge1xyXG4gICAgICAgICAgICBzdHJva2U6IGxpbmVTdHJva2UsXHJcbiAgICAgICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBuYW1lOiAnbGluZScsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2FudmFzLmFkZChsaW5lWCk7XHJcbiAgICAgICAgLy8gY2FudmFzLmFkZChsaW5lWSk7XHJcbiAgICAgICAgc2VuZExpbmVzVG9CYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FudmFzLm9uKCdvYmplY3Q6bW92aW5nJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBzbmFwVG9HcmlkKGUudGFyZ2V0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNhbnZhcy5vbignb2JqZWN0OnNjYWxpbmcnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmIChlLnRhcmdldC5zY2FsZVggPiA1KSB7XHJcbiAgICAgICAgICAgIGUudGFyZ2V0LnNjYWxlWCA9IDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLnRhcmdldC5zY2FsZVkgPiA1KSB7XHJcbiAgICAgICAgICAgIGUudGFyZ2V0LnNjYWxlWSA9IDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS50YXJnZXQuc3Ryb2tlV2lkdGhVbnNjYWxlZCAmJiBlLnRhcmdldC5zdHJva2VXaWR0aCkge1xyXG4gICAgICAgICAgICBlLnRhcmdldC5zdHJva2VXaWR0aFVuc2NhbGVkID0gZS50YXJnZXQuc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLnRhcmdldC5zdHJva2VXaWR0aFVuc2NhbGVkKSB7XHJcbiAgICAgICAgICAgIGUudGFyZ2V0LnN0cm9rZVdpZHRoID1cclxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0cm9rZVdpZHRoVW5zY2FsZWQgLyBlLnRhcmdldC5zY2FsZVg7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5zdHJva2VXaWR0aCA9PT0gZS50YXJnZXQuc3Ryb2tlV2lkdGhVbnNjYWxlZCkge1xyXG4gICAgICAgICAgICAgICAgZS50YXJnZXQuc3Ryb2tlV2lkdGggPVxyXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LnN0cm9rZVdpZHRoVW5zY2FsZWQgLyBlLnRhcmdldC5zY2FsZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjYW52YXMub24oJ29iamVjdDptb2RpZmllZCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZS50YXJnZXQuc2NhbGVYID1cclxuICAgICAgICAgICAgZS50YXJnZXQuc2NhbGVYID49IDAuMjUgPyBNYXRoLnJvdW5kKGUudGFyZ2V0LnNjYWxlWCAqIDIpIC8gMiA6IDAuNTtcclxuICAgICAgICBlLnRhcmdldC5zY2FsZVkgPVxyXG4gICAgICAgICAgICBlLnRhcmdldC5zY2FsZVkgPj0gMC4yNSA/IE1hdGgucm91bmQoZS50YXJnZXQuc2NhbGVZICogMikgLyAyIDogMC41O1xyXG4gICAgICAgIHNuYXBUb0dyaWQoZS50YXJnZXQpO1xyXG4gICAgICAgIGlmIChlLnRhcmdldC5uYW1lID09PSAndGFibGUnKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5icmluZ1RvRnJvbnQoZS50YXJnZXQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5zZW5kVG9CYWNrKGUudGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VuZExpbmVzVG9CYWNrKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjYW52YXMub24oJ29iamVjdDptb3ZpbmcnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGNoZWNrQm91ZG5pbmdCb3goZSk7XHJcbiAgICB9KTtcclxuICAgIGNhbnZhcy5vbignb2JqZWN0OnJvdGF0aW5nJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBjaGVja0JvdWRuaW5nQm94KGUpO1xyXG4gICAgfSk7XHJcbiAgICBjYW52YXMub24oJ29iamVjdDpzY2FsaW5nJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBjaGVja0JvdWRuaW5nQm94KGUpO1xyXG4gICAgfSk7XHJcbn1cclxuaW5pdENhbnZhcygpO1xyXG5cclxuZnVuY3Rpb24gcmVzaXplQ2FudmFzKCkge1xyXG4gICAgd2lkdGhFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aWR0aCcpO1xyXG4gICAgaGVpZ2h0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVpZ2h0Jyk7XHJcbiAgICBjYW52YXNFbC53aWR0aCA9IHdpZHRoRWwudmFsdWUgPyB3aWR0aEVsLnZhbHVlIDogMzAyO1xyXG4gICAgY2FudmFzRWwuaGVpZ2h0ID0gaGVpZ2h0RWwudmFsdWUgPyBoZWlnaHRFbC52YWx1ZSA6IDgxMjtcclxuICAgIGNvbnN0IGNhbnZhc0NvbnRhaW5lckVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbnZhcy1jb250YWluZXInKVswXTtcclxuICAgIGNhbnZhc0NvbnRhaW5lckVsLnN0eWxlLndpZHRoID0gY2FudmFzRWwud2lkdGg7XHJcbiAgICBjYW52YXNDb250YWluZXJFbC5zdHlsZS5oZWlnaHQgPSBjYW52YXNFbC5oZWlnaHQ7XHJcbn1cclxucmVzaXplQ2FudmFzKCk7XHJcblxyXG53aWR0aEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcclxuICAgIHJlc2l6ZUNhbnZhcygpO1xyXG4gICAgaW5pdENhbnZhcygpO1xyXG4gICAgLy8gYWRkRGVmYXVsdE9iamVjdHMoKTtcclxuICAgIGNhbnZhc0xvYWRlcignanNvbl9jYW52YXMnKTtcclxuICAgIHNlbmRMaW5lc1RvQmFjaygpO1xyXG59KTtcclxuaGVpZ2h0RWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgcmVzaXplQ2FudmFzKCk7XHJcbiAgICBpbml0Q2FudmFzKCk7XHJcbiAgICAvLyBhZGREZWZhdWx0T2JqZWN0cygpO1xyXG4gICAgY2FudmFzTG9hZGVyKCdqc29uX2NhbnZhcycpO1xyXG4gICAgc2VuZExpbmVzVG9CYWNrKCk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcclxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcclxuICAgIGNvbnN0IG8gPSBuZXcgZmFicmljLlJlY3Qoe1xyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICBmaWxsOiB0YWJsZUZpbGwsXHJcbiAgICAgICAgc3Ryb2tlOiB0YWJsZVN0cm9rZSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzaGFkb3c6IHRhYmxlU2hhZG93LFxyXG4gICAgICAgIHJ4OiAxMCxcclxuICAgICAgICByeTogMTAsXHJcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXHJcbiAgICAgICAgY2VudGVyZWRSb3RhdGlvbjogdHJ1ZSxcclxuICAgICAgICBzbmFwQW5nbGU6IDQ1LFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHQgPSBuZXcgZmFicmljLklUZXh0KG51bWJlci50b1N0cmluZygpLCB7XHJcbiAgICAgICAgZm9udEZhbWlseTogJ0NhbGlicmknLFxyXG4gICAgICAgIGZvbnRTaXplOiAxNCxcclxuICAgICAgICBmaWxsOiAnIzAwMCcsXHJcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZyA9IG5ldyBmYWJyaWMuR3JvdXAoW28sIHRdLCB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBjZW50ZXJlZFJvdGF0aW9uOiB0cnVlLFxyXG4gICAgICAgIHNuYXBBbmdsZTogNDUsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBuYW1lOiAndGFibGUnLFxyXG4gICAgICAgIGlkOiBpZCxcclxuICAgICAgICBudW1iZXI6IG51bWJlcixcclxuICAgIH0pO1xyXG4gICAgY2FudmFzLmFkZChnKTtcclxuICAgIG51bWJlcisrO1xyXG4gICAgcmV0dXJuIGc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZENpcmNsZShsZWZ0LCB0b3AsIHJhZGl1cykge1xyXG4gICAgY29uc3QgaWQgPSBnZW5lcmF0ZUlkKCk7XHJcbiAgICBjb25zdCBvID0gbmV3IGZhYnJpYy5DaXJjbGUoe1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIGZpbGw6IHRhYmxlRmlsbCxcclxuICAgICAgICBzdHJva2U6IHRhYmxlU3Ryb2tlLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxyXG4gICAgICAgIHNoYWRvdzogdGFibGVTaGFkb3csXHJcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXHJcbiAgICAgICAgY2VudGVyZWRSb3RhdGlvbjogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgdCA9IG5ldyBmYWJyaWMuSVRleHQobnVtYmVyLnRvU3RyaW5nKCksIHtcclxuICAgICAgICBmb250RmFtaWx5OiAnQ2FsaWJyaScsXHJcbiAgICAgICAgZm9udFNpemU6IDE0LFxyXG4gICAgICAgIGZpbGw6ICcjMDAwJyxcclxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxyXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBnID0gbmV3IGZhYnJpYy5Hcm91cChbbywgdF0sIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGNlbnRlcmVkUm90YXRpb246IHRydWUsXHJcbiAgICAgICAgc25hcEFuZ2xlOiA0NSxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIG5hbWU6ICd0YWJsZScsXHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIG51bWJlcjogbnVtYmVyLFxyXG4gICAgfSk7XHJcbiAgICBjYW52YXMuYWRkKGcpO1xyXG4gICAgbnVtYmVyKys7XHJcbiAgICByZXR1cm4gZztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkVHJpYW5nbGUobGVmdCwgdG9wLCByYWRpdXMpIHtcclxuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJZCgpO1xyXG4gICAgY29uc3QgbyA9IG5ldyBmYWJyaWMuVHJpYW5nbGUoe1xyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIGZpbGw6IHRhYmxlRmlsbCxcclxuICAgICAgICBzdHJva2U6IHRhYmxlU3Ryb2tlLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxyXG4gICAgICAgIHNoYWRvdzogdGFibGVTaGFkb3csXHJcbiAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXHJcbiAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXHJcbiAgICAgICAgY2VudGVyZWRSb3RhdGlvbjogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgdCA9IG5ldyBmYWJyaWMuSVRleHQobnVtYmVyLnRvU3RyaW5nKCksIHtcclxuICAgICAgICBmb250RmFtaWx5OiAnQ2FsaWJyaScsXHJcbiAgICAgICAgZm9udFNpemU6IDE0LFxyXG4gICAgICAgIGZpbGw6ICcjMDAwJyxcclxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxyXG4gICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBnID0gbmV3IGZhYnJpYy5Hcm91cChbbywgdF0sIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGNlbnRlcmVkUm90YXRpb246IHRydWUsXHJcbiAgICAgICAgc25hcEFuZ2xlOiA0NSxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIG5hbWU6ICd0YWJsZScsXHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIG51bWJlcjogbnVtYmVyLFxyXG4gICAgfSk7XHJcbiAgICBjYW52YXMuYWRkKGcpO1xyXG4gICAgbnVtYmVyKys7XHJcbiAgICByZXR1cm4gZztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQ2hhaXIobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBvID0gbmV3IGZhYnJpYy5SZWN0KHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIHdpZHRoOiAzMCxcclxuICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgIGZpbGw6IGNoYWlyRmlsbCxcclxuICAgICAgICBzdHJva2U6IGNoYWlyU3Ryb2tlLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxyXG4gICAgICAgIHNoYWRvdzogY2hhaXJTaGFkb3csXHJcbiAgICAgICAgb3JpZ2luWDogJ2xlZnQnLFxyXG4gICAgICAgIG9yaWdpblk6ICd0b3AnLFxyXG4gICAgICAgIGNlbnRlcmVkUm90YXRpb246IHRydWUsXHJcbiAgICAgICAgc25hcEFuZ2xlOiA0NSxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIG5hbWU6ICdjaGFpcicsXHJcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgIH0pO1xyXG4gICAgY2FudmFzLmFkZChvKTtcclxuICAgIHJldHVybiBvO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRCYXIobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBvID0gbmV3IGZhYnJpYy5SZWN0KHtcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgZmlsbDogYmFyRmlsbCxcclxuICAgICAgICBzdHJva2U6IGJhclN0cm9rZSxcclxuICAgICAgICBzdHJva2VXaWR0aDogMixcclxuICAgICAgICBzaGFkb3c6IGJhclNoYWRvdyxcclxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcclxuICAgICAgICBuYW1lOiAnYmFyJyxcclxuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB0ID0gbmV3IGZhYnJpYy5JVGV4dChiYXJUZXh0LCB7XHJcbiAgICAgICAgZm9udEZhbWlseTogJ0NhbGlicmknLFxyXG4gICAgICAgIGZvbnRTaXplOiAxNCxcclxuICAgICAgICBmaWxsOiAnIzAwMCcsXHJcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcclxuICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZyA9IG5ldyBmYWJyaWMuR3JvdXAoW28sIHRdLCB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBjZW50ZXJlZFJvdGF0aW9uOiB0cnVlLFxyXG4gICAgICAgIHNuYXBBbmdsZTogNDUsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBuYW1lOiAnYmFyJyxcclxuICAgIH0pO1xyXG4gICAgY2FudmFzLmFkZChnKTtcclxuICAgIHJldHVybiBnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRXYWxsKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgY29uc3QgbyA9IG5ldyBmYWJyaWMuUmVjdCh7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgZmlsbDogd2FsbEZpbGwsXHJcbiAgICAgICAgc3Ryb2tlOiB3YWxsU3Ryb2tlLFxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxyXG4gICAgICAgIHNoYWRvdzogd2FsbFNoYWRvdyxcclxuICAgICAgICBvcmlnaW5YOiAnbGVmdCcsXHJcbiAgICAgICAgb3JpZ2luWTogJ3RvcCcsXHJcbiAgICAgICAgY2VudGVyZWRSb3RhdGlvbjogdHJ1ZSxcclxuICAgICAgICBzbmFwQW5nbGU6IDQ1LFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgbmFtZTogJ3dhbGwnLFxyXG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXHJcbiAgICB9KTtcclxuICAgIGNhbnZhcy5hZGQobyk7XHJcbiAgICByZXR1cm4gbztcclxufVxyXG5cclxuZnVuY3Rpb24gc25hcFRvR3JpZCh0YXJnZXQpIHtcclxuICAgIHRhcmdldC5zZXQoe1xyXG4gICAgICAgIGxlZnQ6IChNYXRoLnJvdW5kKHRhcmdldC5sZWZ0IC8gKGdyaWQgLyAyKSkgKiBncmlkKSAvIDIsXHJcbiAgICAgICAgdG9wOiAoTWF0aC5yb3VuZCh0YXJnZXQudG9wIC8gKGdyaWQgLyAyKSkgKiBncmlkKSAvIDIsXHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tCb3VkbmluZ0JveChlKSB7XHJcbiAgICBjb25zdCBvYmogPSBlLnRhcmdldDtcclxuXHJcbiAgICBpZiAoIW9iaikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIG9iai5zZXRDb29yZHMoKTtcclxuXHJcbiAgICBjb25zdCBvYmpCb3VuZGluZ0JveCA9IG9iai5nZXRCb3VuZGluZ1JlY3QoKTtcclxuICAgIGlmIChvYmpCb3VuZGluZ0JveC50b3AgPCAwKSB7XHJcbiAgICAgICAgb2JqLnNldCgndG9wJywgMCk7XHJcbiAgICAgICAgb2JqLnNldENvb3JkcygpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iakJvdW5kaW5nQm94LmxlZnQgPiBjYW52YXMud2lkdGggLSBvYmpCb3VuZGluZ0JveC53aWR0aCkge1xyXG4gICAgICAgIG9iai5zZXQoJ2xlZnQnLCBjYW52YXMud2lkdGggLSBvYmpCb3VuZGluZ0JveC53aWR0aCk7XHJcbiAgICAgICAgb2JqLnNldENvb3JkcygpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iakJvdW5kaW5nQm94LnRvcCA+IGNhbnZhcy5oZWlnaHQgLSBvYmpCb3VuZGluZ0JveC5oZWlnaHQpIHtcclxuICAgICAgICBvYmouc2V0KCd0b3AnLCBjYW52YXMuaGVpZ2h0IC0gb2JqQm91bmRpbmdCb3guaGVpZ2h0KTtcclxuICAgICAgICBvYmouc2V0Q29vcmRzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqQm91bmRpbmdCb3gubGVmdCA8IDApIHtcclxuICAgICAgICBvYmouc2V0KCdsZWZ0JywgMCk7XHJcbiAgICAgICAgb2JqLnNldENvb3JkcygpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZW5kTGluZXNUb0JhY2soKSB7XHJcbiAgICBjYW52YXMuZ2V0T2JqZWN0cygpLm1hcCgobykgPT4ge1xyXG4gICAgICAgIGlmIChvLm5hbWUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICBjYW52YXMuc2VuZFRvQmFjayhvKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZG9jdW1lbnRcclxuICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcucmVjdGFuZ2xlJylbMF1cclxuICAgIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBvID0gYWRkUmVjdCgwLCAwLCA2MCwgNjApO1xyXG4gICAgICAgIGNhbnZhcy5zZXRBY3RpdmVPYmplY3Qobyk7XHJcbiAgICB9KTtcclxuXHJcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaXJjbGUnKVswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IG8gPSBhZGRDaXJjbGUoMCwgMCwgMzApO1xyXG4gICAgY2FudmFzLnNldEFjdGl2ZU9iamVjdChvKTtcclxufSk7XHJcblxyXG4vLyBkb2N1bWVudFxyXG4vLyAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy50cmlhbmdsZScpWzBdXHJcbi8vICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbi8vICAgICAgICAgY29uc3QgbyA9IGFkZFRyaWFuZ2xlKDAsIDAsIDMwKTtcclxuLy8gICAgICAgICBjYW52YXMuc2V0QWN0aXZlT2JqZWN0KG8pO1xyXG4vLyAgICAgfSk7XHJcblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2hhaXInKVswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IG8gPSBhZGRDaGFpcigwLCAwKTtcclxuICAgIGNhbnZhcy5zZXRBY3RpdmVPYmplY3Qobyk7XHJcbn0pO1xyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJhcicpWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgbyA9IGFkZEJhcigwLCAwLCAxODAsIDYwKTtcclxuICAgIGNhbnZhcy5zZXRBY3RpdmVPYmplY3Qobyk7XHJcbn0pO1xyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLndhbGwnKVswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IG8gPSBhZGRXYWxsKDAsIDAsIDYwLCAxODApO1xyXG4gICAgY2FudmFzLnNldEFjdGl2ZU9iamVjdChvKTtcclxufSk7XHJcblxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucmVtb3ZlJylbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCBvID0gY2FudmFzLmdldEFjdGl2ZU9iamVjdCgpO1xyXG4gICAgaWYgKG8pIHtcclxuICAgICAgICAvLyBvLnJlbW92ZSgpO1xyXG4gICAgICAgIGNhbnZhcy5yZW1vdmUobyk7XHJcbiAgICAgICAgY2FudmFzLmRpc2NhcmRBY3RpdmVPYmplY3QoKTtcclxuICAgICAgICBjYW52YXMucmVuZGVyQWxsKCk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b21lci1tb2RlJylbMF0pIHtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b21lci1tb2RlJylbMF1cclxuICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5nZXRPYmplY3RzKCkubWFwKChvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvLmhhc0NvbnRyb2xzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBvLmxvY2tNb3ZlbWVudFggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgby5sb2NrTW92ZW1lbnRZID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChvLnR5cGUgIT0gJ2dyb3VwJyB8fCBvLl9vYmplY3RzWzFdLnRleHQgPT0gJ0JhcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLnNlbGVjdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG8uYm9yZGVyQ29sb3IgPSAnIzM0YTVlNyc7XHJcbiAgICAgICAgICAgICAgICBvLmJvcmRlclNjYWxlRmFjdG9yID0gMi41O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FudmFzLnNlbGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjYW52YXMuaG92ZXJDdXJzb3IgPSAncG9pbnRlcic7XHJcbiAgICAgICAgICAgIGNhbnZhcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XHJcbiAgICAgICAgICAgIGNhbnZhcy5yZW5kZXJBbGwoKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFkbWluLW1lbnUnKVswXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY3VzdG9tZXItbWVudScpWzBdLnN0eWxlLmRpc3BsYXkgPVxyXG4gICAgICAgICAgICAgICAgJ2Jsb2NrJztcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuY2FudmFzLmdldE9iamVjdHMoKS5tYXAoKG8pID0+IHtcclxuICAgIG8uaGFzQ29udHJvbHMgPSB0cnVlO1xyXG4gICAgby5sb2NrTW92ZW1lbnRYID0gZmFsc2U7XHJcbiAgICBvLmxvY2tNb3ZlbWVudFkgPSBmYWxzZTtcclxuICAgIGlmIChvLm5hbWUgPT09ICdjaGFpcicgfHwgby5uYW1lID09PSAnYmFyJyB8fCBvLm5hbWUgPT09ICd3YWxsJykge1xyXG4gICAgICAgIG8uc2VsZWN0YWJsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBvLmJvcmRlckNvbG9yID0gJ3JnYmEoMTAyLCAxNTMsIDI1NSwgMC43NSknO1xyXG4gICAgby5ib3JkZXJTY2FsZUZhY3RvciA9IDE7XHJcbn0pO1xyXG5jYW52YXMuc2VsZWN0aW9uID0gdHJ1ZTtcclxuY2FudmFzLmhvdmVyQ3Vyc29yID0gJ21vdmUnO1xyXG5jYW52YXMuZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xyXG5jYW52YXMucmVuZGVyQWxsKCk7XHJcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hZG1pbi1tZW51JylbMF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbi8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXN0b21lci1tZW51JylbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxudmFyIGFycmF5T2ZUYWJsZXNOb3M7XHJcbnZhciB1c2VyVGFibGVOb3M7XHJcblxyXG5mdW5jdGlvbiBzYXZlUmVzZXJ2YXRpb24odXNlcklkLCB0YWJsZU5vKSB7XHJcbiAgICBsZXQgZGF0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZXNlcnZhdGlvbi1kYXRlJykudmFsdWU7XHJcbiAgICBsZXQgdGltZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yZXNlcnZhdGlvbi10aW1lJykudmFsdWU7XHJcblxyXG4gICAgZGIucmVmKCdyZXNlcnZhdGlvbnMvJyArIGRhdGUgKyAnLycgKyB0aW1lKVxyXG5cclxuICAgICAgICAub25jZSgndmFsdWUnLCAoc25hcCkgPT4ge1xyXG4gICAgICAgICAgICBhcnJheU9mVGFibGVzTm9zID0gc25hcC52YWwoKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2l0ZXJhdGluZyBhZ2FpbicpO1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlPZlRhYmxlc05vcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHMgPSBhcnJheU9mVGFibGVzTm9zLnJlc2VydmVkVGFibGVObztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhcnJheU9mVGFibGVzTm9zLnJlc2VydmVkVGFibGVObyk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzKTtcclxuICAgICAgICAgICAgICAgIGlmIChzLmluZGV4T2YodGFibGVObykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ1RhYmxlIFVuYXZhaWxhYmxlIHJpZ2h0IG5vdyEnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIFVuYXZhaWxhYmxlIHJpZ2h0IG5vdyEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRiLnJlZigncmVzZXJ2YXRpb25zLycgKyBkYXRlICsgJy8nICsgdGltZSkuc2V0KHtcclxuICAgICAgICAgICAgICAgICAgICByZXNlcnZlZFRhYmxlTm86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T2ZUYWJsZXNOb3MucmVzZXJ2ZWRUYWJsZU5vICsgJywnICsgdGFibGVObyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGIucmVmKCdyZXNlcnZhdGlvbnMvJyArIGRhdGUgKyAnLycgKyB0aW1lKS5zZXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2VydmVkVGFibGVObzogdGFibGVObyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jaGVjay1hdmFpbGFiaWxpdHknKS5jbGljaygpO1xyXG4gICAgICAgICAgICBhbGVydCgnU3VjZXNzZnVsbHkgcmVzZXJ2ZWQhJyk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBkYi5yZWYoXHJcbiAgICAgICAgICAgICAgICAndXNlcnMvJyArIHVzZXJJZCArICcvcmVzZXJ2YXRpb25zLycgKyBkYXRlICsgJy8nICsgdGltZVxyXG4gICAgICAgICAgICApLm9uY2UoJ3ZhbHVlJywgKHNuYXApID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGUsIHRpbWUsIHNuYXApO1xyXG4gICAgICAgICAgICAgICAgdXNlclRhYmxlTm9zID0gc25hcC52YWwoKTtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyVGFibGVOb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHVzZXJUYWJsZU5vcy50YWJsZU5vO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmluZGV4T2YodGFibGVObykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdUYWJsZSBhbHJlYWR5IHJlc2VydmVkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGFscmVhZHkgcmVzZXJ2ZWQhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBkYi5yZWYoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2Vycy8nICsgdXNlcklkICsgJy9yZXNlcnZhdGlvbnMvJyArIGRhdGUgKyAnLycgKyB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgKS5zZXQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZU5vOiB1c2VyVGFibGVOb3MudGFibGVObyArICcsJyArIHRhYmxlTm8sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRiLnJlZihcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJzLycgKyB1c2VySWQgKyAnL3Jlc2VydmF0aW9ucy8nICsgZGF0ZSArICcvJyArIHRpbWVcclxuICAgICAgICAgICAgICAgICAgICApLnNldCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlTm86IHRhYmxlTm8sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgYWxlcnQoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5pZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnN1Ym1pdCcpWzBdKSB7XHJcbiAgICBkb2N1bWVudFxyXG4gICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VibWl0JylbMF1cclxuICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IGNhbnZhcy5nZXRBY3RpdmVPYmplY3QoKTtcclxuICAgICAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkZGVkJyk7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2VsZWN0ZWRPYmonLCBKU09OLnN0cmluZ2lmeShvYmopKTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE9iaiA9IEpTT04ucGFyc2UoXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NlbGVjdGVkT2JqJylcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbG9nZ2VkSW4nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRPYmoub2JqZWN0c1sxXS50ZXh0ID09PSAnUmVzZXJ2ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdUYWJsZSBVbmF2YWlsYWJsZSByaWdodCBub3chJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgVW5hdmFpbGFibGUgcmlnaHQgbm93IScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVSZXNlcnZhdGlvbih1c2VyLnVpZCwgc2VsZWN0ZWRPYmoub2JqZWN0c1sxXS50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdQbGVhc2UgbG9naW4gdG8gY29udGludWUnKTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSAnL2F1dGguaHRtbCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhbGVydCgnUGxlYXNlIHNlbGVjdCBhbnkgdGFibGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGREZWZhdWx0T2JqZWN0cygpIHtcclxuICAgIGFkZENoYWlyKDE1LCAxMDUpO1xyXG4gICAgYWRkQ2hhaXIoMTUsIDEzNSk7XHJcbiAgICBhZGRDaGFpcig3NSwgMTA1KTtcclxuICAgIGFkZENoYWlyKDc1LCAxMzUpO1xyXG4gICAgYWRkQ2hhaXIoMjI1LCA3NSk7XHJcbiAgICBhZGRDaGFpcigyNTUsIDc1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgMTM1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgMTM1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgMTk1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgMTk1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgMjU1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgMjU1KTtcclxuICAgIGFkZENoYWlyKDE1LCAxOTUpO1xyXG4gICAgYWRkQ2hhaXIoNDUsIDE5NSk7XHJcbiAgICBhZGRDaGFpcigxNSwgMjU1KTtcclxuICAgIGFkZENoYWlyKDQ1LCAyNTUpO1xyXG4gICAgYWRkQ2hhaXIoMTUsIDMxNSk7XHJcbiAgICBhZGRDaGFpcig0NSwgMzE1KTtcclxuICAgIGFkZENoYWlyKDE1LCAzNzUpO1xyXG4gICAgYWRkQ2hhaXIoNDUsIDM3NSk7XHJcbiAgICBhZGRDaGFpcigyMjUsIDMxNSk7XHJcbiAgICBhZGRDaGFpcigyNTUsIDMxNSk7XHJcbiAgICBhZGRDaGFpcigyMjUsIDM3NSk7XHJcbiAgICBhZGRDaGFpcigyNTUsIDM3NSk7XHJcbiAgICBhZGRDaGFpcigxNSwgNDM1KTtcclxuICAgIGFkZENoYWlyKDE1LCA0OTUpO1xyXG4gICAgYWRkQ2hhaXIoMTUsIDU1NSk7XHJcbiAgICBhZGRDaGFpcigxNSwgNjE1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgNjE1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNjE1KTtcclxuICAgIGFkZENoYWlyKDE5NSwgNDk1KTtcclxuICAgIGFkZENoYWlyKDE5NSwgNTI1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNDk1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNTI1KTtcclxuICAgIGFkZENoYWlyKDIyNSwgNjc1KTtcclxuICAgIGFkZENoYWlyKDI1NSwgNjc1KTtcclxuXHJcbiAgICBhZGRSZWN0KDMwLCA5MCwgNjAsIDkwKTtcclxuICAgIGFkZFJlY3QoMjEwLCA5MCwgOTAsIDYwKTtcclxuICAgIGFkZFJlY3QoMjEwLCAyMTAsIDkwLCA2MCk7XHJcbiAgICBhZGRSZWN0KDAsIDIxMCwgOTAsIDYwKTtcclxuICAgIGFkZFJlY3QoMCwgMzMwLCA5MCwgNjApO1xyXG4gICAgYWRkUmVjdCgyMTAsIDMzMCwgOTAsIDYwKTtcclxuICAgIGFkZFJlY3QoMCwgNDUwLCA2MCwgNjApO1xyXG4gICAgYWRkUmVjdCgwLCA1NzAsIDYwLCA2MCk7XHJcbiAgICBhZGRSZWN0KDIxMCwgNDgwLCA2MCwgOTApO1xyXG4gICAgYWRkUmVjdCgyMTAsIDYzMCwgOTAsIDYwKTtcclxuXHJcbiAgICBhZGRCYXIoMTIwLCAwLCAxODAsIDYwKTtcclxuXHJcbiAgICBhZGRXYWxsKDEyMCwgNTEwLCA2MCwgNjApO1xyXG59XHJcbi8vIGFkZERlZmF1bHRPYmplY3RzKCk7XHJcblxyXG52YXIgdG90YWxUYWJsZXMgPSAwO1xyXG5cclxuZnVuY3Rpb24gY29udHJvbE51bWJlcmluZyhqc29uX2NhbnZhcykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uX2NhbnZhcy5vYmplY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coanNvbl9jYW52YXMub2JqZWN0c1tpXSk7XHJcbiAgICAgICAgaWYgKGpzb25fY2FudmFzLm9iamVjdHNbaV0udHlwZSA9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZUludChqc29uX2NhbnZhcy5vYmplY3RzW2ldLm9iamVjdHNbMV0udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGpzb25fY2FudmFzLm9iamVjdHNbaV0ub2JqZWN0c1sxXS50ZXh0KTtcclxuICAgICAgICAgICAgICAgIHRvdGFsVGFibGVzKys7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG90YWxUYWJsZXMnLCB0b3RhbFRhYmxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b3RhbFRhYmxlcyA9IDA7XHJcblxyXG4gICAgcmV0dXJuIGpzb25fY2FudmFzO1xyXG59XHJcblxyXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2F2ZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgbGV0IGpzb25fY2FudmFzID0gY2FudmFzLnRvSlNPTigpO1xyXG4gICAganNvbl9jYW52YXMgPSBjb250cm9sTnVtYmVyaW5nKGpzb25fY2FudmFzKTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdqc29uX2NhbnZhcycsIEpTT04uc3RyaW5naWZ5KGpzb25fY2FudmFzKSk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnaGVpZ2h0RWwnLCBoZWlnaHRFbC52YWx1ZSk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2lkdGhFbCcsIHdpZHRoRWwudmFsdWUpO1xyXG59KTtcclxuXHJcbi8vIGNhbnZhcy5jbGVhcigpO1xyXG5mdW5jdGlvbiBjYW52YXNMb2FkZXIoanNvblZhcmlhYmxlID0gJ2pzb25fY2FudmFzJykge1xyXG4gICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGpzb25WYXJpYWJsZSkpO1xyXG4gICAgY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XHJcbn1cclxuY2FudmFzTG9hZGVyKCdqc29uX2NhbnZhcycpO1xyXG5zZW5kTGluZXNUb0JhY2soKTtcclxuXHJcbmlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2hlY2stYXZhaWxhYmlsaXR5JykpIHtcclxuICAgIC8vIENoZWNrcyB0aGUgYXZhaWxhYmlsaXR5IG9mIHRoZSB0YWJsZXNcclxuICAgIGRvY3VtZW50XHJcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5jaGVjay1hdmFpbGFiaWxpdHknKVxyXG4gICAgICAgIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NsaWNrZWQnKTtcclxuICAgICAgICAgICAgbGV0IHJlc2VyRGF0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXHJcbiAgICAgICAgICAgICAgICAncmVzZXJ2YXRpb24tZGF0ZSdcclxuICAgICAgICAgICAgKVswXS52YWx1ZTtcclxuICAgICAgICAgICAgbGV0IHJlc2VyVGltZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXHJcbiAgICAgICAgICAgICAgICAncmVzZXJ2YXRpb24tdGltZSdcclxuICAgICAgICAgICAgKVswXS52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKCFyZXNlckRhdGUgfHwgIXJlc2VyVGltZSkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoJ1BsZWFzZSBlbnRlciB0aGUgZGF0ZSBhbmQgdGltZScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBhdmFpbFJlZiA9IGRiLnJlZihcclxuICAgICAgICAgICAgICAgICdyZXNlcnZhdGlvbnMvJyArIHJlc2VyRGF0ZSArICcvJyArIHJlc2VyVGltZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBhdmFpbFJlZlxyXG4gICAgICAgICAgICAgICAgLm9uY2UoJ3ZhbHVlJywgKHNuYXApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzbmFwLnZhbCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc25hcC52YWwoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsZXJ0KCdUaGVyZSBhcmUgbm8gcmVzZXJ2YXRpb25zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignVGhlcmUgYXJlIG5vIHJlc2VydmF0aW9ucycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbmFwLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc2VydmVkVGFibGVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocmVzZXJ2ZWRUYWJsZXMudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNlcnZlZFRhYmxlcy52YWwoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0xvYWRlcignanNvbl9jYW52YXMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmN1c3RvbWVyLW1vZGUnKVswXS5jbGljaygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzZXJ2ZWRUYWJsZU5vQXJyYXkgPSByZXNlcnZlZFRhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAudmFsKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlc2VydmVkVGFibGVOby5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlc2VydmVkVGFibGVOb0FycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQganNvbkNhbnZhc1JlYWx0aW1lID0gSlNPTi5wYXJzZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2pzb25fY2FudmFzJylcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHR5cGVvZiBqc29uQ2FudmFzUmVhbHRpbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXNlcnZlZFRhYmxlTm9BcnJheS5mb3JFYWNoKChlbGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAganNvbkNhbnZhc1JlYWx0aW1lLm9iamVjdHMuZm9yRWFjaCgob2JqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLm9iamVjdHNbMV0udGV4dCA9PSBlbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cob2JqLm9iamVjdHNbMV0udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5vYmplY3RzWzFdLnRleHQgPSAnUmVzZXJ2ZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhvYmoub2JqZWN0c1sxXS50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNlbGVjdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGpzb25DYW52YXNSZWFsdGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdqc29uX2NhbnZhc19yZWFsdGltZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGpzb25DYW52YXNSZWFsdGltZSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0xvYWRlcignanNvbl9jYW52YXNfcmVhbHRpbWUnKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY3VzdG9tZXItbW9kZScpWzBdLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2pzb25fY2FudmFzX3JlYWx0aW1lJyk7XHJcbiAgICAgICAgICAgIC8vIGNhbnZhc0xvYWRlcignanNvbl9jYW52YXMnKTtcclxuICAgICAgICB9KTtcclxufVxyXG4iLCIvKiBidWlsZDogYG5vZGUgYnVpbGQuanMgbW9kdWxlcz1BTEwgZXhjbHVkZT1nZXN0dXJlcyxhY2Nlc3NvcnMgcmVxdWlyZWpzIG1pbmlmaWVyPXVnbGlmeWpzYCAqL1xuLyohIEZhYnJpYy5qcyBDb3B5cmlnaHQgMjAwOC0yMDE1LCBQcmludGlvIChKdXJpeSBaYXl0c2V2LCBNYXhpbSBDaGVybnlhaykgKi9cblxudmFyIGZhYnJpYyA9IGZhYnJpYyB8fCB7IHZlcnNpb246ICc0LjMuMScgfTtcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5mYWJyaWMgPSBmYWJyaWM7XG59XG4vKiBfQU1EX1NUQVJUXyAqL1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBmYWJyaWM7IH0pO1xufVxuLyogX0FNRF9FTkRfICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiAodHlwZW9mIEhUTUxEb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBIVE1MRG9jdW1lbnQgOiBEb2N1bWVudCkpIHtcbiAgICBmYWJyaWMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgfVxuICBlbHNlIHtcbiAgICBmYWJyaWMuZG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpO1xuICB9XG4gIGZhYnJpYy53aW5kb3cgPSB3aW5kb3c7XG59XG5lbHNlIHtcbiAgLy8gYXNzdW1lIHdlJ3JlIHJ1bm5pbmcgdW5kZXIgbm9kZS5qcyB3aGVuIGRvY3VtZW50L3dpbmRvdyBhcmUgbm90IHByZXNlbnRcbiAgdmFyIGpzZG9tID0gcmVxdWlyZSgnanNkb20nKTtcbiAgdmFyIHZpcnR1YWxXaW5kb3cgPSBuZXcganNkb20uSlNET00oXG4gICAgZGVjb2RlVVJJQ29tcG9uZW50KCclM0MhRE9DVFlQRSUyMGh0bWwlM0UlM0NodG1sJTNFJTNDaGVhZCUzRSUzQyUyRmhlYWQlM0UlM0Nib2R5JTNFJTNDJTJGYm9keSUzRSUzQyUyRmh0bWwlM0UnKSxcbiAgICB7XG4gICAgICBmZWF0dXJlczoge1xuICAgICAgICBGZXRjaEV4dGVybmFsUmVzb3VyY2VzOiBbJ2ltZyddXG4gICAgICB9LFxuICAgICAgcmVzb3VyY2VzOiAndXNhYmxlJ1xuICAgIH0pLndpbmRvdztcbiAgZmFicmljLmRvY3VtZW50ID0gdmlydHVhbFdpbmRvdy5kb2N1bWVudDtcbiAgZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIgPSByZXF1aXJlKCdqc2RvbS9saWIvanNkb20vbGl2aW5nL2dlbmVyYXRlZC91dGlscycpLmltcGxGb3JXcmFwcGVyO1xuICBmYWJyaWMubm9kZUNhbnZhcyA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS91dGlscycpLkNhbnZhcztcbiAgZmFicmljLndpbmRvdyA9IHZpcnR1YWxXaW5kb3c7XG4gIERPTVBhcnNlciA9IGZhYnJpYy53aW5kb3cuRE9NUGFyc2VyO1xufVxuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHRvdWNoIGV2ZW50c1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGZhYnJpYy53aW5kb3cgfHwgJ29udG91Y2hzdGFydCcgaW4gZmFicmljLmRvY3VtZW50IHx8XG4gIChmYWJyaWMud2luZG93ICYmIGZhYnJpYy53aW5kb3cubmF2aWdhdG9yICYmIGZhYnJpYy53aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCk7XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQncyBwcm9iYWJseSBOb2RlLmpzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc0xpa2VseU5vZGUgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG4vKiBfRlJPTV9TVkdfU1RBUlRfICovXG4vKipcbiAqIEF0dHJpYnV0ZXMgcGFyc2VkIGZyb20gYWxsIFNWRyBlbGVtZW50c1xuICogQHR5cGUgYXJyYXlcbiAqL1xuZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTID0gW1xuICAnZGlzcGxheScsXG4gICd0cmFuc2Zvcm0nLFxuICAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJyxcbiAgJ29wYWNpdHknLFxuICAnc3Ryb2tlJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsXG4gICdpZCcsICdwYWludC1vcmRlcicsICd2ZWN0b3ItZWZmZWN0JyxcbiAgJ2luc3RhbnRpYXRlZF9ieV91c2UnLCAnY2xpcC1wYXRoJyxcbl07XG4vKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4vKipcbiAqIFBpeGVsIHBlciBJbmNoIGFzIGEgZGVmYXVsdCB2YWx1ZSBzZXQgdG8gOTYuIENhbiBiZSBjaGFuZ2VkIGZvciBtb3JlIHJlYWxpc3RpYyBjb252ZXJzaW9uLlxuICovXG5mYWJyaWMuRFBJID0gOTY7XG5mYWJyaWMucmVOdW0gPSAnKD86Wy0rXT8oPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W2VFXVstK10/XFxcXGQrKT8pJztcbmZhYnJpYy5jb21tYVdzcCA9ICcoPzpcXFxccyssP1xcXFxzKnwsXFxcXHMqKSc7XG5mYWJyaWMucmVQYXRoQ29tbWFuZCA9IC8oWy0rXT8oKFxcZCtcXC5cXGQrKXwoKFxcZCspfChcXC5cXGQrKSkpKD86W2VFXVstK10/XFxkKyk/KS9pZztcbmZhYnJpYy5yZU5vbldvcmQgPSAvWyBcXG5cXC4sOyFcXD9cXC1dLztcbmZhYnJpYy5mb250UGF0aHMgPSB7IH07XG5mYWJyaWMuaU1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmZhYnJpYy5zdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzLiAxTXB4ICwgNE1weCBzaG91bGQgYmUgZmluZS5cbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCA9IDIwOTcxNTI7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzIHdpZHRoIG9yIGhlaWdodC4gSUUgZml4ZXMgdGhlIG1heGltdW0gYXQgNTAwMFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQgPSA0MDk2O1xuXG4vKipcbiAqIExvd2VzdCBwaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMsIHNldCBhdCAyNTZQWFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWluQ2FjaGVTaWRlTGltaXQgPSAyNTY7XG5cbi8qKlxuICogQ2FjaGUgT2JqZWN0IGZvciB3aWR0aHMgb2YgY2hhcnMgaW4gdGV4dCByZW5kZXJpbmcuXG4gKi9cbmZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogaWYgd2ViZ2wgaXMgZW5hYmxlZCBhbmQgYXZhaWxhYmxlLCB0ZXh0dXJlU2l6ZSB3aWxsIGRldGVybWluZSB0aGUgc2l6ZVxuICogb2YgdGhlIGNhbnZhcyBiYWNrZW5kXG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnRleHR1cmVTaXplID0gMjA0ODtcblxuLyoqXG4gKiBXaGVuICd0cnVlJywgc3R5bGUgaW5mb3JtYXRpb24gaXMgbm90IHJldGFpbmVkIHdoZW4gY29weS9wYXN0aW5nIHRleHQsIG1ha2luZ1xuICogcGFzdGVkIHRleHQgdXNlIGRlc3RpbmF0aW9uIHN0eWxlLlxuICogRGVmYXVsdHMgdG8gJ2ZhbHNlJy5cbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUgPSBmYWxzZTtcblxuLyoqXG4gKiBFbmFibGUgd2ViZ2wgZm9yIGZpbHRlcmluZyBwaWN0dXJlIGlzIGF2YWlsYWJsZVxuICogQSBmaWx0ZXJpbmcgYmFja2VuZCB3aWxsIGJlIGluaXRpYWxpemVkLCB0aGlzIHdpbGwgYm90aCB0YWtlIG1lbW9yeSBhbmRcbiAqIHRpbWUgc2luY2UgYSBkZWZhdWx0IDIwNDh4MjA0OCBjYW52YXMgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgZ2wgY29udGV4dFxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgPSB0cnVlO1xuXG4vKipcbiAqIERldmljZSBQaXhlbCBSYXRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSFRNTC1jYW52YXMtZ3VpZGUvU2V0dGluZ1VwdGhlQ2FudmFzL1NldHRpbmdVcHRoZUNhbnZhcy5odG1sXG4gKi9cbmZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID0gZmFicmljLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1vekRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcbi8qKlxuICogQnJvd3Nlci1zcGVjaWZpYyBjb25zdGFudCB0byBhZGp1c3QgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnNoYWRvd0JsdXIgdmFsdWUsXG4gKiB3aGljaCBpcyB1bml0bGVzcyBhbmQgbm90IHJlbmRlcmVkIGVxdWFsbHkgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIFZhbHVlcyB0aGF0IHdvcmsgcXVpdGUgd2VsbCAoYXMgb2YgT2N0b2JlciAyMDE3KSBhcmU6XG4gKiAtIENocm9tZTogMS41XG4gKiAtIEVkZ2U6IDEuNzVcbiAqIC0gRmlyZWZveDogMC45XG4gKiAtIFNhZmFyaTogMC45NVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdCAxXG4gKi9cbmZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ID0gMTtcblxuLyoqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIGFyYyB0byBiZXppZXIgY29udmVyc2lvbiBmb3IgZmFzdGVyIHJldHJpZXZpbmcgaWYgdGhlIHNhbWUgYXJjIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCBhZ2Fpbi5cbiAqIEl0IHdhcyBhbiBpbnRlcm5hbCB2YXJpYWJsZSwgaXMgYWNjZXNzaWJsZSBzaW5jZSB2ZXJzaW9uIDIuMy40XG4gKi9cbmZhYnJpYy5hcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogVGhpcyBvYmplY3Qga2VlcHMgdGhlIHJlc3VsdHMgb2YgdGhlIGJvdW5kc09mQ3VydmUgY2FsY3VsYXRpb24gbWFwcGVkIGJ5IHRoZSBqb2luZWQgYXJndW1lbnRzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgaXQuXG4gKiBJdCBkb2VzIHNwZWVkIHVwIGNhbGN1bGF0aW9uLCBpZiB5b3UgcGFyc2UgYW5kIGFkZCBhbHdheXMgdGhlIHNhbWUgcGF0aHMsIGJ1dCBpbiBjYXNlIG9mIGhlYXZ5IHVzYWdlIG9mIGZyZWVkcmF3aW5nXG4gKiB5b3UgZG8gbm90IGdldCBhbnkgc3BlZWQgYmVuZWZpdCBhbmQgeW91IGdldCBhIGJpZyBvYmplY3QgaW4gbWVtb3J5LlxuICogVGhlIG9iamVjdCB3YXMgYSBwcml2YXRlIHZhcmlhYmxlIGJlZm9yZSwgd2hpbGUgbm93IGlzIGFwcGVuZGVkIHRvIHRoZSBsaWIgc28gdGhhdCB5b3UgaGF2ZSBhY2Nlc3MgdG8gaXQgYW5kIHlvdVxuICogY2FuIGV2ZW50dWFsbHkgY2xlYXIgaXQuXG4gKiBJdCB3YXMgYW4gaW50ZXJuYWwgdmFyaWFibGUsIGlzIGFjY2Vzc2libGUgc2luY2UgdmVyc2lvbiAyLjMuNFxuICovXG5mYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlID0geyB9O1xuXG4vKipcbiAqIElmIGRpc2FibGVkIGJvdW5kc09mQ3VydmVDYWNoZSBpcyBub3QgdXNlZC4gRm9yIGFwcHMgdGhhdCBtYWtlIGhlYXZ5IHVzYWdlIG9mIHBlbmNpbCBkcmF3aW5nIHByb2JhYmx5IGRpc2FibGluZyBpdCBpcyBiZXR0ZXJcbiAqIEBkZWZhdWx0IHRydWVcbiAqL1xuZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUgPSB0cnVlO1xuXG4vKipcbiAqIFNraXAgcGVyZm9ybWFuY2UgdGVzdGluZyBvZiBzZXR1cEdMQ29udGV4dCBhbmQgZm9yY2UgdGhlIHVzZSBvZiBwdXRJbWFnZURhdGEgdGhhdCBzZWVtcyB0byBiZSB0aGUgb25lIHRoYXQgd29ya3MgYmVzdCBvblxuICogQ2hyb21lICsgb2xkIGhhcmR3YXJlLiBpZiB5b3VyIHVzZXJzIGFyZSBleHBlcmllbmNpbmcgZW1wdHkgaW1hZ2VzIGFmdGVyIGZpbHRlcmluZyB5b3UgbWF5IHRyeSB0byBmb3JjZSB0aGlzIHRvIHRydWVcbiAqIHRoaXMgaGFzIHRvIGJlIHNldCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgZmlsdGVyaW5nIGJhY2tlbmQgKCBiZWZvcmUgZmlsdGVyaW5nIHRoZSBmaXJzdCBpbWFnZSApXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5mYWJyaWMuZm9yY2VHTFB1dEltYWdlRGF0YSA9IGZhbHNlO1xuXG5mYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGZhYnJpYy5lbmFibGVHTEZpbHRlcmluZyAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZChmYWJyaWMudGV4dHVyZVNpemUpKSB7XG4gICAgY29uc29sZS5sb2coJ21heCB0ZXh0dXJlIHNpemU6ICcgKyBmYWJyaWMubWF4VGV4dHVyZVNpemUpO1xuICAgIHJldHVybiAobmV3IGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQoeyB0aWxlU2l6ZTogZmFicmljLnRleHR1cmVTaXplIH0pKTtcbiAgfVxuICBlbHNlIGlmIChmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKSB7XG4gICAgcmV0dXJuIChuZXcgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCgpKTtcbiAgfVxufTtcblxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBlbnN1cmUgZ2xvYmFsaXR5IGV2ZW4gaWYgZW50aXJlIGxpYnJhcnkgd2VyZSBmdW5jdGlvbiB3cmFwcGVkIChhcyBpbiBNZXRlb3IuanMgcGFja2FnaW5nIHN5c3RlbSlcbiAgd2luZG93LmZhYnJpYyA9IGZhYnJpYztcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBldmVudExpc3RlbmVyW2V2ZW50TGlzdGVuZXIuaW5kZXhPZihoYW5kbGVyKV0gPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMudXRpbC5hcnJheS5maWxsKGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZXMgc3BlY2lmaWVkIGV2ZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb25cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVycyA9IHsgfTtcbiAgICB9XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub24ocHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBldmVudCBvYnNlcnZpbmcgZm9yIGEgcGFydGljdWxhciBldmVudCBoYW5kbGVyLiBDYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIHdpdGhvdXQgYXJndW1lbnRzIHJlbW92ZXMgYWxsIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb2ZmXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnROYW1lIEV2ZW50IG5hbWUgKGVnLiAnYWZ0ZXI6cmVuZGVyJykgb3Igb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIChlZy4geydhZnRlcjpyZW5kZXInOiBoYW5kbGVyLCAnc2VsZWN0aW9uOmNsZWFyZWQnOiBoYW5kbGVyfSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0byBiZSBkZWxldGVkIGZyb20gRXZlbnRMaXN0ZW5lcnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwga2V5L3ZhbHVlIHBhaXJzIChldmVudCBuYW1lIC0+IGV2ZW50IGhhbmRsZXIpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgcHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBmaXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzRm9yRXZlbnQgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICBpZiAoIWxpc3RlbmVyc0ZvckV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc0ZvckV2ZW50W2ldICYmIGxpc3RlbmVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgb3B0aW9ucyB8fCB7IH0pO1xuICAgIH1cbiAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IGxpc3RlbmVyc0ZvckV2ZW50LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2V2ZW50c31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9ldmVudHN8RXZlbnRzIGRlbW99XG4gICAqL1xuICBmYWJyaWMuT2JzZXJ2YWJsZSA9IHtcbiAgICBmaXJlOiBmaXJlLFxuICAgIG9uOiBvbixcbiAgICBvZmY6IG9mZixcbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db2xsZWN0aW9uXG4gKi9cbmZhYnJpYy5Db2xsZWN0aW9uID0ge1xuXG4gIF9vYmplY3RzOiBbXSxcblxuICAvKipcbiAgICogQWRkcyBvYmplY3RzIHRvIGNvbGxlY3Rpb24sIENhbnZhcyBvciBHcm91cCwgdGhlbiByZW5kZXJzIGNhbnZhc1xuICAgKiAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYCkuXG4gICAqIGluIGNhc2Ugb2YgR3JvdXAgbm8gY2hhbmdlcyB0byBib3VuZGluZyBib3ggYXJlIG1hZGUuXG4gICAqIE9iamVjdHMgc2hvdWxkIGJlIGluc3RhbmNlcyBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBmb3IgZ3JvdXBzLlxuICAgKiB5b3UgY2FuIGFkZCBhIGJ1bmNoIG9mIG9iamVjdHMgd2l0aCB0aGUgYWRkIG1ldGhvZCBidXQgdGhlbiB5b3UgTkVFRFxuICAgKiB0byBydW4gYSBhZGRXaXRoVXBkYXRlIGNhbGwgZm9yIHRoZSBHcm91cCBjbGFzcyBvciBwb3NpdGlvbi9iYm94IHdpbGwgYmUgd3JvbmcuXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fb2JqZWN0cy5wdXNoLmFwcGx5KHRoaXMuX29iamVjdHMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX29uT2JqZWN0QWRkZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb25PYmplY3RBZGRlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIG9iamVjdCBpbnRvIGNvbGxlY3Rpb24gYXQgc3BlY2lmaWVkIGluZGV4LCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBBbiBvYmplY3Qgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogVXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGZvciBncm91cHMuXG4gICAqIHlvdSBjYW4gYWRkIGEgYnVuY2ggb2Ygb2JqZWN0cyB3aXRoIHRoZSBpbnNlcnRBdCBtZXRob2QgYnV0IHRoZW4geW91IE5FRURcbiAgICogdG8gcnVuIGEgYWRkV2l0aFVwZGF0ZSBjYWxsIGZvciB0aGUgR3JvdXAgY2xhc3Mgb3IgcG9zaXRpb24vYmJveCB3aWxsIGJlIHdyb25nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIGluc2VydCBvYmplY3QgYXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBub25TcGxpY2luZyBXaGVuIGB0cnVlYCwgbm8gc3BsaWNpbmcgKHNoaWZ0aW5nKSBvZiBvYmplY3RzIG9jY3Vyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGluc2VydEF0OiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgbm9uU3BsaWNpbmcpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHM7XG4gICAgaWYgKG5vblNwbGljaW5nKSB7XG4gICAgICBvYmplY3RzW2luZGV4XSA9IG9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5fb25PYmplY3RBZGRlZCAmJiB0aGlzLl9vbk9iamVjdEFkZGVkKG9iamVjdCk7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBvYmplY3RzIGZyb20gYSBjb2xsZWN0aW9uLCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICBpbmRleCwgc29tZXRoaW5nUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2YoYXJndW1lbnRzW2ldKTtcblxuICAgICAgLy8gb25seSBjYWxsIG9uT2JqZWN0UmVtb3ZlZCBpZiBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IHJlbW92ZWRcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc29tZXRoaW5nUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fb25PYmplY3RSZW1vdmVkICYmIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgc29tZXRoaW5nUmVtb3ZlZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggb2JqZWN0IGluIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGN1cnJlbnQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICBpbmRleCAtIGFzIHNlY29uZCBhbmQgYW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgLSBhcyB0aGlyZC5cbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaXMgaW52b2tlZCBpbiBhIGNvbnRleHQgb2YgR2xvYmFsIE9iamVjdCAoZS5nLiBgd2luZG93YClcbiAgICogICAgICAgICAgICAgICAgICAgd2hlbiBubyBgY29udGV4dGAgYXJndW1lbnQgaXMgZ2l2ZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCAoYWthIHRoaXNPYmplY3QpXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZm9yRWFjaE9iamVjdDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdHNbaV0sIGksIG9iamVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2VcbiAgICogVHlwZSBwYXJhbWV0ZXIgaW50cm9kdWNlZCBpbiAxLjMuMTBcbiAgICogc2luY2UgMi4zLjUgdGhpcyBtZXRob2QgcmV0dXJuIGFsd2F5cyBhIENPUFkgb2YgdGhlIGFycmF5O1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFdoZW4gc3BlY2lmaWVkLCBvbmx5IG9iamVjdHMgb2YgdGhpcyB0eXBlIGFyZSByZXR1cm5lZFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldE9iamVjdHM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5jb25jYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnR5cGUgPT09IHR5cGU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IGF0IHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKi9cbiAgaXRlbTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHNbaW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBubyBvYmplY3RzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY29sbGVjdGlvbiBpcyBlbXB0eVxuICAgKi9cbiAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpemUgb2YgYSBjb2xsZWN0aW9uIChpLmU6IGxlbmd0aCBvZiBhbiBhcnJheSBjb250YWluaW5nIGl0cyBvYmplY3RzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbGxlY3Rpb24gc2l6ZVxuICAgKi9cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICovXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xsZWN0aW9uIGNvbXBsZXhpdHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAqL1xuICBjb21wbGV4aXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXJyZW50KSB7XG4gICAgICBtZW1vICs9IGN1cnJlbnQuY29tcGxleGl0eSA/IGN1cnJlbnQuY29tcGxleGl0eSgpIDogMDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29tbW9uTWV0aG9kc1xuICovXG5mYWJyaWMuQ29tbW9uTWV0aG9kcyA9IHtcblxuICAvKipcbiAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBfc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXQocHJvcCwgb3B0aW9uc1twcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ZpbGxlcl0gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gcHJvcGVydHkgdG8gc2V0IHRoZSBHcmFkaWVudCB0b1xuICAgKi9cbiAgX2luaXRHcmFkaWVudDogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSkge1xuICAgIGlmIChmaWxsZXIgJiYgZmlsbGVyLmNvbG9yU3RvcHMgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuR3JhZGllbnQpKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5HcmFkaWVudChmaWxsZXIpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIFBhdHRlcm4gdG9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgcGF0dGVybiBsb2FkXG4gICAqL1xuICBfaW5pdFBhdHRlcm46IGZ1bmN0aW9uKGZpbGxlciwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuc291cmNlICYmICEoZmlsbGVyIGluc3RhbmNlb2YgZmFicmljLlBhdHRlcm4pKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5QYXR0ZXJuKGZpbGxlciwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICB0aGlzLl9zZXQocHJvcCwgb2JqW3Byb3BdKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgcHJvcGVydHkgdG8gYSBnaXZlbiB2YWx1ZS4gV2hlbiBjaGFuZ2luZyBwb3NpdGlvbi9kaW1lbnNpb24gLXJlbGF0ZWQgcHJvcGVydGllcyAobGVmdCwgdG9wLCBzY2FsZSwgYW5nbGUsIGV0Yy4pIGBzZXRgIGRvZXMgbm90IHVwZGF0ZSBwb3NpdGlvbiBvZiBvYmplY3QncyBib3JkZXJzL2NvbnRyb2xzLiBJZiB5b3UgbmVlZCB0byB1cGRhdGUgdGhvc2UsIGNhbGwgYHNldENvb3JkcygpYC5cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBrZXkgUHJvcGVydHkgbmFtZSBvciBvYmplY3QgKGlmIG9iamVjdCwgaXRlcmF0ZSBvdmVyIHRoZSBvYmplY3QgcHJvcGVydGllcylcbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5fc2V0T2JqZWN0KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYHRydWVgIHRvIGBmYWxzZWAgb3IgZnJvbSBgZmFsc2VgIHRvIGB0cnVlYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gdG9nZ2xlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgdG9nZ2xlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KHByb3BlcnR5KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCAhdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQmFzaWMgZ2V0dGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAqIEByZXR1cm4geyp9IHZhbHVlIG9mIGEgcHJvcGVydHlcbiAgICovXG4gIGdldDogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XG4gIH1cbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgICAgcG93ID0gTWF0aC5wb3csXG4gICAgICBQaUJ5MTgwID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgIFBpQnkyID0gTWF0aC5QSSAvIDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWxcbiAgICovXG4gIGZhYnJpYy51dGlsID0ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb3Mgb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBjb3M6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDE7IH1cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gY29zKGEpID0gY29zKC1hKVxuICAgICAgICBhbmdsZSA9IC1hbmdsZTtcbiAgICAgIH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5MjtcbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IGNhc2UgMzogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaW4gb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBzaW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5Miwgc2lnbiA9IDE7XG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIC8vIHNpbigtYSkgPSAtc2luKGEpXG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBzaWduO1xuICAgICAgICBjYXNlIDI6IHJldHVybiAwO1xuICAgICAgICBjYXNlIDM6IHJldHVybiAtc2lnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNpbihhbmdsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBQcmVzZW5jZSBvZiB2YWx1ZSAoYW5kIGl0cyBwb3NpdGlvbiBpbiBhbiBhcnJheSkgaXMgZGV0ZXJtaW5lZCB2aWEgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3JpZ2luYWwgYXJyYXlcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tQXJyYXk6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDIgc3BlY2lmaWVkIG9uZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbG93ZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IHVwcGVyIGxpbWl0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSByYW5kb20gdmFsdWUgKGJldHdlZW4gbWluIGFuZCBtYXgpXG4gICAgICovXG4gICAgZ2V0UmFuZG9tSW50OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZGVncmVlcyB0byByYWRpYW5zLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgZGVncmVlc1RvUmFkaWFuczogZnVuY3Rpb24oZGVncmVlcykge1xuICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIHJhZGlhbnNUb0RlZ3JlZXM6IGZ1bmN0aW9uKHJhZGlhbnMpIHtcbiAgICAgIHJldHVybiByYWRpYW5zIC8gUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgcG9pbnRgIGFyb3VuZCBgb3JpZ2luYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW4sIHJhZGlhbnMpIHtcbiAgICAgIHBvaW50LnN1YnRyYWN0RXF1YWxzKG9yaWdpbik7XG4gICAgICB2YXIgdiA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3Rvcihwb2ludCwgcmFkaWFucyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkuYWRkRXF1YWxzKG9yaWdpbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHZlY3RvcmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHJvdGF0ZSAoeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlVmVjdG9yOiBmdW5jdGlvbih2ZWN0b3IsIHJhZGlhbnMpIHtcbiAgICAgIHZhciBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkaWFucyksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHJhZGlhbnMpLFxuICAgICAgICAgIHJ4ID0gdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbixcbiAgICAgICAgICByeSA9IHZlY3Rvci54ICogc2luICsgdmVjdG9yLnkgKiBjb3M7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByeCxcbiAgICAgICAgeTogcnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0IHRvIHBvaW50IHBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLlBvaW50fSBwIFRoZSBwb2ludCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2lnbm9yZU9mZnNldF0gSW5kaWNhdGVzIHRoYXQgdGhlIG9mZnNldCBzaG91bGQgbm90IGJlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwLCB0LCBpZ25vcmVPZmZzZXQpIHtcbiAgICAgIGlmIChpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnksXG4gICAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSArIHRbNF0sXG4gICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55ICsgdFs1XVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBwb2ludHMncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgNCBwb2ludHMgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmb3JtXSBhbiBhcnJheSBvZiA2IG51bWJlcnMgcmVwcmVzZW50aW5nIGEgMngzIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbWFrZUJvdW5kaW5nQm94RnJvbVBvaW50czogZnVuY3Rpb24ocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludHNbaV0sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB4UG9pbnRzID0gW3BvaW50c1swXS54LCBwb2ludHNbMV0ueCwgcG9pbnRzWzJdLngsIHBvaW50c1szXS54XSxcbiAgICAgICAgICBtaW5YID0gZmFicmljLnV0aWwuYXJyYXkubWluKHhQb2ludHMpLFxuICAgICAgICAgIG1heFggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeFBvaW50cyksXG4gICAgICAgICAgd2lkdGggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICB5UG9pbnRzID0gW3BvaW50c1swXS55LCBwb2ludHNbMV0ueSwgcG9pbnRzWzJdLnksIHBvaW50c1szXS55XSxcbiAgICAgICAgICBtaW5ZID0gZmFicmljLnV0aWwuYXJyYXkubWluKHlQb2ludHMpLFxuICAgICAgICAgIG1heFkgPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeVBvaW50cyksXG4gICAgICAgICAgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52ZXJ0IHRyYW5zZm9ybWF0aW9uIHRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBpbnZlcnRlZCB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBpbnZlcnRUcmFuc2Zvcm06IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBhID0gMSAvICh0WzBdICogdFszXSAtIHRbMV0gKiB0WzJdKSxcbiAgICAgICAgICByID0gW2EgKiB0WzNdLCAtYSAqIHRbMV0sIC1hICogdFsyXSwgYSAqIHRbMF1dLFxuICAgICAgICAgIG8gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh7IHg6IHRbNF0sIHk6IHRbNV0gfSwgciwgdHJ1ZSk7XG4gICAgICByWzRdID0gLW8ueDtcbiAgICAgIHJbNV0gPSAtby55O1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBhcm91bmQgTnVtYmVyI3RvRml4ZWQsIHdoaWNoIGNvbnRyYXJ5IHRvIG5hdGl2ZSBtZXRob2QgcmV0dXJucyBudW1iZXIsIG5vdCBzdHJpbmcuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIG51bWJlciB0byBvcGVyYXRlIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYWN0aW9uRGlnaXRzIG51bWJlciBvZiBmcmFjdGlvbiBkaWdpdHMgdG8gXCJsZWF2ZVwiXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRvRml4ZWQ6IGZ1bmN0aW9uKG51bWJlciwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KE51bWJlcihudW1iZXIpLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZnJvbSBhdHRyaWJ1dGUgdmFsdWUgdG8gcGl4ZWwgdmFsdWUgaWYgYXBwbGljYWJsZS5cbiAgICAgKiBSZXR1cm5zIGNvbnZlcnRlZCBwaXhlbHMgb3Igb3JpZ2luYWwgdmFsdWUgbm90IGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlIG51bWJlciB0byBvcGVyYXRlIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplXG4gICAgICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAgICAgKi9cbiAgICBwYXJzZVVuaXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb250U2l6ZSkge1xuICAgICAgdmFyIHVuaXQgPSAvXFxEezAsMn0kLy5leGVjKHZhbHVlKSxcbiAgICAgICAgICBudW1iZXIgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmICghZm9udFNpemUpIHtcbiAgICAgICAgZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHVuaXRbMF0pIHtcbiAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMjUuNDtcblxuICAgICAgICBjYXNlICdjbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyAyLjU0O1xuXG4gICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSTtcblxuICAgICAgICBjYXNlICdwdCc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MjsgLy8gb3IgKiA0IC8gM1xuXG4gICAgICAgIGNhc2UgJ3BjJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDcyICogMTI7IC8vIG9yICogMTZcblxuICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZvbnRTaXplO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmYWxzZUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IG9mIGdpdmVuIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2Ygb2JqZWN0IChlZy4gJ2NpcmNsZScpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ga2xhc3MgXCJDbGFzc1wiXG4gICAgICovXG4gICAgZ2V0S2xhc3M6IGZ1bmN0aW9uKHR5cGUsIG5hbWVzcGFjZSkge1xuICAgICAgLy8gY2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb25seVxuICAgICAgdHlwZSA9IGZhYnJpYy51dGlsLnN0cmluZy5jYW1lbGl6ZSh0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwucmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UpW3R5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFycmF5IG9mIGF0dHJpYnV0ZXMgZm9yIGdpdmVuIHN2ZyB0aGF0IGZhYnJpYyBwYXJzZXNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHN2ZyBlbGVtZW50IChlZy4gJ2NpcmNsZScpXG4gICAgICogQHJldHVybiB7QXJyYXl9IHN0cmluZyBuYW1lcyBvZiBzdXBwb3J0ZWQgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGdldFN2Z0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gW1xuICAgICAgICAnaW5zdGFudGlhdGVkX2J5X3VzZScsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdjbGFzcydcbiAgICAgIF07XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbGluZWFyR3JhZGllbnQnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJywgJ2dyYWRpZW50VW5pdHMnLCAnZ3JhZGllbnRUcmFuc2Zvcm0nXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JhZGlhbEdyYWRpZW50JzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWydncmFkaWVudFVuaXRzJywgJ2dyYWRpZW50VHJhbnNmb3JtJywgJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknLCAnZnInXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0b3AnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ29mZnNldCcsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eSddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSBzdHJpbmcgZS5nLiAnZmFicmljLkltYWdlLmZpbHRlcicgb3IgJ2ZhYnJpYydcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBmb3IgZ2l2ZW4gbmFtZXNwYWNlIChkZWZhdWx0IGZhYnJpYylcbiAgICAgKi9cbiAgICByZXNvbHZlTmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcbiAgICAgIGlmICghbmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWM7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJ0cyA9IG5hbWVzcGFjZS5zcGxpdCgnLicpLFxuICAgICAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aCwgaSxcbiAgICAgICAgICBvYmogPSBnbG9iYWwgfHwgZmFicmljLndpbmRvdztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG9iaiA9IG9ialtwYXJ0c1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWRzIGltYWdlIGVsZW1lbnQgZnJvbSBnaXZlbiB1cmwgYW5kIHBhc3NlcyBpdCB0byBhIGNhbGxiYWNrXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgcmVwcmVzZW50aW5nIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2s7IGludm9rZWQgd2l0aCBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSBDb250ZXh0IHRvIGludm9rZSBjYWxsYmFjayBpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIHZhbHVlIHRvIHNldCBpbWFnZSBlbGVtZW50IHRvXG4gICAgICovXG4gICAgbG9hZEltYWdlOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBjb250ZXh0LCBjcm9zc09yaWdpbikge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCB1cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWcgPSBmYWJyaWMudXRpbC5jcmVhdGVJbWFnZSgpO1xuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgdmFyIG9uTG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGltZywgZmFsc2UpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9ubG9hZCA9IG9uTG9hZENhbGxiYWNrO1xuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhYnJpYy5sb2coJ0Vycm9yIGxvYWRpbmcgJyArIGltZy5zcmMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG51bGwsIHRydWUpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLy8gZGF0YS11cmxzIGFwcGVhciB0byBiZSBidWdneSB3aXRoIGNyb3NzT3JpZ2luXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9jb21taXQvZDBhYmI5MGYxY2Q1YzVlZjlkMmE5NGQzZmIyMWEyMjMzMGRhM2UwYSNjb21taXRjb21tZW50LTQ1MTM3NjdcbiAgICAgIC8vIHNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzE1MTUyXG4gICAgICAvLyAgICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTM1MDY5XG4gICAgICAvLyBjcm9zc09yaWdpbiBudWxsIGlzIHRoZSBzYW1lIGFzIG5vdCBzZXQuXG4gICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGEnKSAhPT0gMCAmJlxuICAgICAgICBjcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICAvLyBJRTEwIC8gSUUxMS1GaXg6IFNWRyBjb250ZW50cyBmcm9tIGRhdGE6IFVSSVxuICAgICAgLy8gd2lsbCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgSU1HIGlzIHByZXNlbnRcbiAgICAgIC8vIGluIHRoZSBET00gKGFuZCB2aXNpYmxlKVxuICAgICAgaWYgKHVybC5zdWJzdHJpbmcoMCwxNCkgPT09ICdkYXRhOmltYWdlL3N2ZycpIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZUluRG9tKGltZywgb25Mb2FkQ2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBTVkcgaW1hZ2Ugd2l0aCBkYXRhOiBVUkwgdG8gdGhlIGRvbVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWcgSW1hZ2Ugb2JqZWN0IHdpdGggZGF0YTppbWFnZS9zdmcgc3JjXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2s7IGludm9rZWQgd2l0aCBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IERPTSBlbGVtZW50IChkaXYgY29udGFpbmluZyB0aGUgU1ZHIGltYWdlKVxuICAgICAqL1xuICAgIGxvYWRJbWFnZUluRG9tOiBmdW5jdGlvbihpbWcsIG9uTG9hZENhbGxiYWNrKSB7XG4gICAgICB2YXIgZGl2ID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9ICcxcHgnO1xuICAgICAgZGl2LnN0eWxlLmxlZnQgPSBkaXYuc3R5bGUudG9wID0gJy0xMDAlJztcbiAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIGZhYnJpYy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcCBpbiBmdW5jdGlvbiB0bzpcbiAgICAgICAqICAgMS4gQ2FsbCBleGlzdGluZyBjYWxsYmFja1xuICAgICAgICogICAyLiBDbGVhbnVwIERPTVxuICAgICAgICovXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkxvYWRDYWxsYmFjaygpO1xuICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjb3JyZXNwb25kaW5nIGZhYnJpYyBpbnN0YW5jZXMgZnJvbSB0aGVpciBvYmplY3QgcmVwcmVzZW50YXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgT2JqZWN0cyB0byBlbmxpdmVuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIG9iamVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSB0byBnZXQga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBmcm9tXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmV2aXZlciBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBvYmplY3QgZWxlbWVudHMsXG4gICAgICogY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIGVubGl2ZW5PYmplY3RzOiBmdW5jdGlvbihvYmplY3RzLCBjYWxsYmFjaywgbmFtZXNwYWNlLCByZXZpdmVyKSB7XG4gICAgICBvYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcblxuICAgICAgdmFyIGVubGl2ZW5lZE9iamVjdHMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRPYmplY3RzID0gMCxcbiAgICAgICAgICBudW1Ub3RhbE9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZE9iamVjdHMgPT09IG51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB1bmRlZmluZWQgb2JqZWN0cyAob2JqZWN0cyB0aGF0IGdhdmUgZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG8sIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHNwYXJzZSBhcnJheVxuICAgICAgICBpZiAoIW8gfHwgIW8udHlwZSkge1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbGFzcyA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG8udHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAga2xhc3MuZnJvbU9iamVjdChvLCBmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgIGVycm9yIHx8IChlbmxpdmVuZWRPYmplY3RzW2luZGV4XSA9IG9iaik7XG4gICAgICAgICAgcmV2aXZlciAmJiByZXZpdmVyKG8sIG9iaiwgZXJyb3IpO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgd2FpdCBmb3IgbG9hZGluZyBvZiBwYXR0ZXJuc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuUGF0dGVybnM6IGZ1bmN0aW9uKHBhdHRlcm5zLCBjYWxsYmFjaykge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucyB8fCBbXTtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZFBhdHRlcm5zID09PSBudW1QYXR0ZXJucykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkUGF0dGVybnMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRQYXR0ZXJucyA9IDAsXG4gICAgICAgICAgbnVtUGF0dGVybnMgPSBwYXR0ZXJucy5sZW5ndGg7XG5cbiAgICAgIGlmICghbnVtUGF0dGVybnMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIGlmIChwICYmIHAuc291cmNlKSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy5QYXR0ZXJuKHAsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHBhdHRlcm47XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHA7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBTVkcgZWxlbWVudHMgKHVzdWFsbHkgdGhvc2UgcmV0cmlldmVkIGZyb20gU1ZHIGRvY3VtZW50KVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBTVkcgZWxlbWVudHMgdG8gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVmFsdWUgdG8gc2V0IHNvdXJjZVBhdGggdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fGZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICBncm91cFNWR0VsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdDtcbiAgICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgICBvcHRpb25zLmNlbnRlclBvaW50ID0ge1xuICAgICAgICAgICAgeDogb3B0aW9ucy53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBvcHRpb25zLmhlaWdodCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0ID0gbmV3IGZhYnJpYy5Hcm91cChlbGVtZW50cywgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG5hbWVzIHRvIGluY2x1ZGVcbiAgICAgKi9cbiAgICBwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvcGVydGllcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGRhc2hlZCBsaW5lIGJldHdlZW4gdHdvIHBvaW50c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkcmF3IGRhc2hlZCBsaW5lIGFyb3VuZCBzZWxlY3Rpb24gYXJlYS5cbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDU3NjcyNC9kb3R0ZWQtc3Ryb2tlLWluLWNhbnZhc1wiPmRvdHRlZCBzdHJva2UgaW4gY2FudmFzPC9hPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggIHN0YXJ0IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHN0YXJ0IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBlbmQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIGVuZCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYSBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKi9cbiAgICBkcmF3RGFzaGVkTGluZTogZnVuY3Rpb24oY3R4LCB4LCB5LCB4MiwgeTIsIGRhKSB7XG4gICAgICB2YXIgZHggPSB4MiAtIHgsXG4gICAgICAgICAgZHkgPSB5MiAtIHksXG4gICAgICAgICAgbGVuID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgcm90ID0gYXRhbjIoZHksIGR4KSxcbiAgICAgICAgICBkYyA9IGRhLmxlbmd0aCxcbiAgICAgICAgICBkaSA9IDAsXG4gICAgICAgICAgZHJhdyA9IHRydWU7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgIGN0eC5yb3RhdGUocm90KTtcblxuICAgICAgeCA9IDA7XG4gICAgICB3aGlsZSAobGVuID4geCkge1xuICAgICAgICB4ICs9IGRhW2RpKysgJSBkY107XG4gICAgICAgIGlmICh4ID4gbGVuKSB7XG4gICAgICAgICAgeCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBjdHhbZHJhdyA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHgsIDApO1xuICAgICAgICBkcmF3ID0gIWRyYXc7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYW52YXMgZWxlbWVudCB0aGF0IGlzIGEgY29weSBvZiBhbm90aGVyIGFuZCBpcyBhbHNvIHBhaW50ZWRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VsZW1lbnR9IGNhbnZhcyB0byBjb3B5IHNpemUgYW5kIGNvbnRlbnQgb2ZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb3B5Q2FudmFzRWxlbWVudDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB2YXIgbmV3Q2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgbmV3Q2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICBuZXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcbiAgICAgIHJldHVybiBuZXdDYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpbmNlIDIuNi4wIG1vdmVkIGZyb20gY2FudmFzIGluc3RhbmNlIHRvIHV0aWxpdHkuXG4gICAgICogQHBhcmFtIHtDYW52YXNFbGVtZW50fSBjYW52YXNFbCB0byBjb3B5IHNpemUgYW5kIGNvbnRlbnQgb2ZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0ICdqcGVnJyBvciAncG5nJywgaW4gc29tZSBicm93c2VycyAnd2VicCcgaXMgb2sgdG9vXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF1YWxpdHkgPD0gMSBhbmQgPiAwXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZGF0YSB1cmxcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKGNhbnZhc0VsLCBmb3JtYXQsIHF1YWxpdHkpIHtcbiAgICAgIHJldHVybiBjYW52YXNFbC50b0RhdGFVUkwoJ2ltYWdlLycgKyBmb3JtYXQsIHF1YWxpdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGltYWdlIGVsZW1lbnQgKHdvcmtzIG9uIGNsaWVudCBhbmQgbm9kZSlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSFRNTCBpbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlSW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgbWF0cml4IEEgYnkgbWF0cml4IEIgdG8gbmVzdCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgRmlyc3QgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGIgU2Vjb25kIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzMngyIGZsYWcgdG8gbXVsdGlwbHkgbWF0cmljZXMgYXMgMngyIG1hdHJpY2VzXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBwcm9kdWN0IG9mIHRoZSB0d28gdHJhbnNmb3JtIG1hdHJpY2VzXG4gICAgICovXG4gICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlczogZnVuY3Rpb24oYSwgYiwgaXMyeDIpIHtcbiAgICAgIC8vIE1hdHJpeCBtdWx0aXBseSBhICogYlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYVswXSAqIGJbMF0gKyBhWzJdICogYlsxXSxcbiAgICAgICAgYVsxXSAqIGJbMF0gKyBhWzNdICogYlsxXSxcbiAgICAgICAgYVswXSAqIGJbMl0gKyBhWzJdICogYlszXSxcbiAgICAgICAgYVsxXSAqIGJbMl0gKyBhWzNdICogYlszXSxcbiAgICAgICAgaXMyeDIgPyAwIDogYVswXSAqIGJbNF0gKyBhWzJdICogYls1XSArIGFbNF0sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMV0gKiBiWzRdICsgYVszXSAqIGJbNV0gKyBhWzVdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNvbXBvc2VzIHN0YW5kYXJkIDJ4MyBtYXRyaXggaW50byB0cmFuc2Zvcm0gY29tcG9uZW50c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYSB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbXBvbmVudHMgb2YgdHJhbnNmb3JtXG4gICAgICovXG4gICAgcXJEZWNvbXBvc2U6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBhbmdsZSA9IGF0YW4yKGFbMV0sIGFbMF0pLFxuICAgICAgICAgIGRlbm9tID0gcG93KGFbMF0sIDIpICsgcG93KGFbMV0sIDIpLFxuICAgICAgICAgIHNjYWxlWCA9IHNxcnQoZGVub20pLFxuICAgICAgICAgIHNjYWxlWSA9IChhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdKSAvIHNjYWxlWCxcbiAgICAgICAgICBza2V3WCA9IGF0YW4yKGFbMF0gKiBhWzJdICsgYVsxXSAqIGEgWzNdLCBkZW5vbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZTogYW5nbGUgLyBQaUJ5MTgwLFxuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIHNrZXdYOiBza2V3WCAvIFBpQnkxODAsXG4gICAgICAgIHNrZXdZOiAwLFxuICAgICAgICB0cmFuc2xhdGVYOiBhWzRdLFxuICAgICAgICB0cmFuc2xhdGVZOiBhWzVdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNmb3JtIG1hdHJpeCBzdGFydGluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBraW5kIG9mXG4gICAgICogdGhlIG9uZSByZXR1cm5lZCBmcm9tIHFyRGVjb21wb3NlLCB1c2VmdWwgYWxzbyBpZiB5b3Ugd2FudCB0byBjYWxjdWxhdGUgc29tZVxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBmcm9tIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBlbmxpdmVkIHlldFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBjYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgICAgfVxuICAgICAgdmFyIHRoZXRhID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLmFuZ2xlKSxcbiAgICAgICAgICBjb3MgPSBmYWJyaWMudXRpbC5jb3ModGhldGEpLFxuICAgICAgICAgIHNpbiA9IGZhYnJpYy51dGlsLnNpbih0aGV0YSk7XG4gICAgICByZXR1cm4gW2Nvcywgc2luLCAtc2luLCBjb3MsIDAsIDBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNmb3JtIG1hdHJpeCBzdGFydGluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBraW5kIG9mXG4gICAgICogdGhlIG9uZSByZXR1cm5lZCBmcm9tIHFyRGVjb21wb3NlLCB1c2VmdWwgYWxzbyBpZiB5b3Ugd2FudCB0byBjYWxjdWxhdGUgc29tZVxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBmcm9tIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBlbmxpdmVkIHlldC5cbiAgICAgKiBpcyBjYWxsZWQgRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeCBiZWNhdXNlIHRob3NlIHByb3BlcnRpZXMgYXJlIHRoZSBvbmUgdGhhdCBpbmZsdWVuY2VcbiAgICAgKiB0aGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIGJveCBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWV1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWF1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWV1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBjYWxjRGltZW5zaW9uc01hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNjYWxlWCA9IHR5cGVvZiBvcHRpb25zLnNjYWxlWCA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogb3B0aW9ucy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gdHlwZW9mIG9wdGlvbnMuc2NhbGVZID09PSAndW5kZWZpbmVkJyA/IDEgOiBvcHRpb25zLnNjYWxlWSxcbiAgICAgICAgICBzY2FsZU1hdHJpeCA9IFtcbiAgICAgICAgICAgIG9wdGlvbnMuZmxpcFggPyAtc2NhbGVYIDogc2NhbGVYLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBvcHRpb25zLmZsaXBZID8gLXNjYWxlWSA6IHNjYWxlWSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXSxcbiAgICAgICAgICBtdWx0aXBseSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG4gICAgICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG4gICAgICBpZiAob3B0aW9ucy5za2V3WCkge1xuICAgICAgICBzY2FsZU1hdHJpeCA9IG11bHRpcGx5KFxuICAgICAgICAgIHNjYWxlTWF0cml4LFxuICAgICAgICAgIFsxLCAwLCBNYXRoLnRhbihkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuc2tld1gpKSwgMV0sXG4gICAgICAgICAgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5za2V3WSkge1xuICAgICAgICBzY2FsZU1hdHJpeCA9IG11bHRpcGx5KFxuICAgICAgICAgIHNjYWxlTWF0cml4LFxuICAgICAgICAgIFsxLCBNYXRoLnRhbihkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuc2tld1kpKSwgMCwgMV0sXG4gICAgICAgICAgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGVNYXRyaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmFuc2Zvcm0gbWF0cml4IHN0YXJ0aW5nIGZyb20gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIGtpbmQgb2ZcbiAgICAgKiB0aGUgb25lIHJldHVybmVkIGZyb20gcXJEZWNvbXBvc2UsIHVzZWZ1bCBhbHNvIGlmIHlvdSB3YW50IHRvIGNhbGN1bGF0ZSBzb21lXG4gICAgICogdHJhbnNmb3JtYXRpb25zIGZyb20gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGVubGl2ZWQgeWV0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuYW5nbGVdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVldXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFhdXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFldXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMudHJhbnNsYXRlWF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnRyYW5zbGF0ZVldXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBjb21wb3NlTWF0cml4OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbWF0cml4ID0gWzEsIDAsIDAsIDEsIG9wdGlvbnMudHJhbnNsYXRlWCB8fCAwLCBvcHRpb25zLnRyYW5zbGF0ZVkgfHwgMF0sXG4gICAgICAgICAgbXVsdGlwbHkgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzO1xuICAgICAgaWYgKG9wdGlvbnMuYW5nbGUpIHtcbiAgICAgICAgbWF0cml4ID0gbXVsdGlwbHkobWF0cml4LCBmYWJyaWMudXRpbC5jYWxjUm90YXRlTWF0cml4KG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNjYWxlWCAhPT0gMSB8fCBvcHRpb25zLnNjYWxlWSAhPT0gMSB8fFxuICAgICAgICAgIG9wdGlvbnMuc2tld1ggfHwgb3B0aW9ucy5za2V3WSB8fCBvcHRpb25zLmZsaXBYIHx8IG9wdGlvbnMuZmxpcFkpIHtcbiAgICAgICAgbWF0cml4ID0gbXVsdGlwbHkobWF0cml4LCBmYWJyaWMudXRpbC5jYWxjRGltZW5zaW9uc01hdHJpeChvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCBhbiBvYmplY3QgdHJhbnNmb3JtIHN0YXRlIHRvIG5ldXRyYWwuIFRvcCBhbmQgbGVmdCBhcmUgbm90IGFjY291bnRlZCBmb3JcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IG9iamVjdCB0byB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICByZXNldE9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnNjYWxlWCA9IDE7XG4gICAgICB0YXJnZXQuc2NhbGVZID0gMTtcbiAgICAgIHRhcmdldC5za2V3WCA9IDA7XG4gICAgICB0YXJnZXQuc2tld1kgPSAwO1xuICAgICAgdGFyZ2V0LmZsaXBYID0gZmFsc2U7XG4gICAgICB0YXJnZXQuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRhcmdldC5yb3RhdGUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgT2JqZWN0IHRyYW5zZm9ybSB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IG9iamVjdCB0byByZWFkIGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbXBvbmVudHMgb2YgdHJhbnNmb3JtXG4gICAgICovXG4gICAgc2F2ZU9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0YXJnZXQuc2tld1gsXG4gICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgIGFuZ2xlOiB0YXJnZXQuYW5nbGUsXG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICBmbGlwWDogdGFyZ2V0LmZsaXBYLFxuICAgICAgICBmbGlwWTogdGFyZ2V0LmZsaXBZLFxuICAgICAgICB0b3A6IHRhcmdldC50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBjb250ZXh0IGhhcyB0cmFuc3BhcmVudCBwaXhlbFxuICAgICAqIGF0IHNwZWNpZmllZCBsb2NhdGlvbiAodGFraW5nIHRvbGVyYW5jZSBpbnRvIGFjY291bnQpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2VcbiAgICAgKi9cbiAgICBpc1RyYW5zcGFyZW50OiBmdW5jdGlvbihjdHgsIHgsIHksIHRvbGVyYW5jZSkge1xuXG4gICAgICAvLyBJZiB0b2xlcmFuY2UgaXMgPiAwIGFkanVzdCBzdGFydCBjb29yZHMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICAvLyBJZiBtb3ZlcyBvZmYgQ2FudmFzIGZpeCB0byAwXG4gICAgICBpZiAodG9sZXJhbmNlID4gMCkge1xuICAgICAgICBpZiAoeCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHggLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgeSAtPSB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9pc1RyYW5zcGFyZW50ID0gdHJ1ZSwgaSwgdGVtcCxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksICh0b2xlcmFuY2UgKiAyKSB8fCAxLCAodG9sZXJhbmNlICogMikgfHwgMSksXG4gICAgICAgICAgbCA9IGltYWdlRGF0YS5kYXRhLmxlbmd0aDtcblxuICAgICAgLy8gU3BsaXQgaW1hZ2UgZGF0YSAtIGZvciB0b2xlcmFuY2UgPiAxLCBwaXhlbERhdGFTaXplID0gNDtcbiAgICAgIGZvciAoaSA9IDM7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgdGVtcCA9IGltYWdlRGF0YS5kYXRhW2ldO1xuICAgICAgICBfaXNUcmFuc3BhcmVudCA9IHRlbXAgPD0gMDtcbiAgICAgICAgaWYgKF9pc1RyYW5zcGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIGlmIGNvbG91ciBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGltYWdlRGF0YSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBfaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGUgZnJvbSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSB0byBiZSBwYXJzZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsaWduIGFuZCBtZWV0T3JTbGljZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIG1lZXRPclNsaWNlID0gJ21lZXQnLCBhbGlnblggPSAnTWlkJywgYWxpZ25ZID0gJ01pZCcsXG4gICAgICAgICAgYXNwZWN0UmF0aW9BdHRycyA9IGF0dHJpYnV0ZS5zcGxpdCgnICcpLCBhbGlnbjtcblxuICAgICAgaWYgKGFzcGVjdFJhdGlvQXR0cnMgJiYgYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICBpZiAobWVldE9yU2xpY2UgIT09ICdtZWV0JyAmJiBtZWV0T3JTbGljZSAhPT0gJ3NsaWNlJykge1xuICAgICAgICAgIGFsaWduID0gbWVldE9yU2xpY2U7XG4gICAgICAgICAgbWVldE9yU2xpY2UgPSAnbWVldCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICBhbGlnbiA9IGFzcGVjdFJhdGlvQXR0cnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZGl2aWRlIGFsaWduIGluIGFsaWduWCBhbmQgYWxpZ25ZXG4gICAgICBhbGlnblggPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoMSwgNCkgOiAnbm9uZSc7XG4gICAgICBhbGlnblkgPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoNSwgOCkgOiAnbm9uZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWV0T3JTbGljZTogbWVldE9yU2xpY2UsXG4gICAgICAgIGFsaWduWDogYWxpZ25YLFxuICAgICAgICBhbGlnblk6IGFsaWduWVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgY2hhciB3aWR0aHMgY2FjaGUgZm9yIHRoZSBnaXZlbiBmb250IGZhbWlseSBvciBhbGwgdGhlIGNhY2hlIGlmIG5vXG4gICAgICogZm9udEZhbWlseSBpcyBzcGVjaWZpZWQuXG4gICAgICogVXNlIGl0IGlmIHlvdSBrbm93IHlvdSBhcmUgbG9hZGluZyBmb250cyBpbiBhIGxhenkgd2F5IGFuZCB5b3UgYXJlIG5vdCB3YWl0aW5nXG4gICAgICogZm9yIGN1c3RvbSBmb250cyB0byBsb2FkIHByb3Blcmx5IHdoZW4gYWRkaW5nIHRleHQgb2JqZWN0cyB0byB0aGUgY2FudmFzLlxuICAgICAqIElmIGEgdGV4dCBvYmplY3QgaXMgYWRkZWQgd2hlbiBpdHMgb3duIGZvbnQgaXMgbm90IGxvYWRlZCB5ZXQsIHlvdSB3aWxsIGdldCB3cm9uZ1xuICAgICAqIG1lYXN1cmVtZW50IGFuZCBzbyB3cm9uZyBib3VuZGluZyBib3hlcy5cbiAgICAgKiBBZnRlciB0aGUgZm9udCBjYWNoZSBpcyBjbGVhcmVkLCBlaXRoZXIgY2hhbmdlIHRoZSB0ZXh0T2JqZWN0IHRleHQgY29udGVudCBvciBjYWxsXG4gICAgICogaW5pdERpbWVuc2lvbnMoKSB0byB0cmlnZ2VyIGEgcmVjYWxjdWxhdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udEZhbWlseV0gZm9udCBmYW1pbHkgdG8gY2xlYXJcbiAgICAgKi9cbiAgICBjbGVhckZhYnJpY0ZvbnRDYWNoZTogZnVuY3Rpb24oZm9udEZhbWlseSkge1xuICAgICAgZm9udEZhbWlseSA9IChmb250RmFtaWx5IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBjdXJyZW50IGFzcGVjdCByYXRpbywgZGV0ZXJtaW5lcyB0aGUgbWF4IHdpZHRoIGFuZCBoZWlnaHQgdGhhdCBjYW5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXIgYXNwZWN0IHJhdGlvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW1BcmVhIE1heGltdW0gYXJlYSB5b3Ugd2FudCB0byBhY2hpZXZlXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnh9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBYXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBZXG4gICAgICovXG4gICAgbGltaXREaW1zQnlBcmVhOiBmdW5jdGlvbihhciwgbWF4aW11bUFyZWEpIHtcbiAgICAgIHZhciByb3VnaFdpZHRoID0gTWF0aC5zcXJ0KG1heGltdW1BcmVhICogYXIpLFxuICAgICAgICAgIHBlcmZMaW1pdFNpemVZID0gTWF0aC5mbG9vcihtYXhpbXVtQXJlYSAvIHJvdWdoV2lkdGgpO1xuICAgICAgcmV0dXJuIHsgeDogTWF0aC5mbG9vcihyb3VnaFdpZHRoKSwgeTogcGVyZkxpbWl0U2l6ZVkgfTtcbiAgICB9LFxuXG4gICAgY2FwVmFsdWU6IGZ1bmN0aW9uKG1pbiwgdmFsdWUsIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc2NhbGUgZm9yIHRoZSBvYmplY3Qgc291cmNlIHRvIGZpdCBpbnNpZGUgdGhlIG9iamVjdCBkZXN0aW5hdGlvbixcbiAgICAgKiBrZWVwaW5nIGFzcGVjdCByYXRpbyBpbnRhY3QuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IGRlc3RpbmF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGUgZmFjdG9yIHRvIGFwcGx5IHRvIHNvdXJjZSB0byBmaXQgaW50byBkZXN0aW5hdGlvblxuICAgICAqL1xuICAgIGZpbmRTY2FsZVRvRml0OiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oZGVzdGluYXRpb24ud2lkdGggLyBzb3VyY2Uud2lkdGgsIGRlc3RpbmF0aW9uLmhlaWdodCAvIHNvdXJjZS5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc2NhbGUgZm9yIHRoZSBvYmplY3Qgc291cmNlIHRvIGNvdmVyIGVudGlyZWx5IHRoZSBvYmplY3QgZGVzdGluYXRpb24sXG4gICAgICoga2VlcGluZyBhc3BlY3QgcmF0aW8gaW50YWN0LlxuICAgICAqIHJlc3BlY3QgdGhlIHRvdGFsIGFsbG93ZWQgYXJlYSBmb3IgdGhlIGNhY2hlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2Uud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBkZXN0aW5hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlIGZhY3RvciB0byBhcHBseSB0byBzb3VyY2UgdG8gY292ZXIgZGVzdGluYXRpb25cbiAgICAgKi9cbiAgICBmaW5kU2NhbGVUb0NvdmVyOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoZGVzdGluYXRpb24ud2lkdGggLyBzb3VyY2Uud2lkdGgsIGRlc3RpbmF0aW9uLmhlaWdodCAvIHNvdXJjZS5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhbiBhcnJheSBvZiA2IG51bWJlciByZXR1cm5zIHNvbWV0aGluZyBsaWtlIGBcIm1hdHJpeCguLi5udW1iZXJzKVwiYFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSBhbiBhcnJheSB3aXRoIDYgbnVtYmVyc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdHJhbnNmb3JtIG1hdHJpeCBmb3Igc3ZnXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBZXG4gICAgICovXG4gICAgbWF0cml4VG9TVkc6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuICdtYXRyaXgoJyArIHRyYW5zZm9ybS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRvRml4ZWQodmFsdWUsIGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyk7XG4gICAgICB9KS5qb2luKCcgJykgKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGEgd2lkdGggYW5kIGhlaWdodCwgcmV0dXJuIHRoZSBzaXplIG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAgKiB0aGF0IGNhbiBjb250YWlucyB0aGUgYm94IHdpdGggd2lkdGgvaGVpZ2h0IHdpdGggYXBwbGllZCB0cmFuc2Zvcm1cbiAgICAgKiBkZXNjcmliZWQgaW4gb3B0aW9ucy5cbiAgICAgKiBVc2UgdG8gY2FsY3VsYXRlIHRoZSBib3hlcyBhcm91bmQgb2JqZWN0cyBmb3IgY29udHJvbHMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2NhbGVZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2tld1hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5za2V3WVxuICAgICAqIEByZXR1cm4ge09iamVjdC54fSB3aWR0aCBvZiBjb250YWluaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IGhlaWdodCBvZiBjb250YWluaW5nXG4gICAgICovXG4gICAgc2l6ZUFmdGVyVHJhbnNmb3JtOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGltWCA9IHdpZHRoIC8gMiwgZGltWSA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAtZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IGRpbVgsXG4gICAgICAgICAgICAgIHk6IC1kaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAtZGltWCxcbiAgICAgICAgICAgICAgeTogZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogZGltWVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgdHJhbnNmb3JtTWF0cml4ID0gZmFicmljLnV0aWwuY2FsY0RpbWVuc2lvbnNNYXRyaXgob3B0aW9ucyksXG4gICAgICAgICAgYmJveCA9IGZhYnJpYy51dGlsLm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmJveC53aWR0aCxcbiAgICAgICAgeTogYmJveC5oZWlnaHQsXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luLFxuICAgICAgY29tbWFuZExlbmd0aHMgPSB7XG4gICAgICAgIG06IDIsXG4gICAgICAgIGw6IDIsXG4gICAgICAgIGg6IDEsXG4gICAgICAgIHY6IDEsXG4gICAgICAgIGM6IDYsXG4gICAgICAgIHM6IDQsXG4gICAgICAgIHE6IDQsXG4gICAgICAgIHQ6IDIsXG4gICAgICAgIGE6IDdcbiAgICAgIH0sXG4gICAgICByZXBlYXRlZENvbW1hbmRzID0ge1xuICAgICAgICBtOiAnbCcsXG4gICAgICAgIE06ICdMJ1xuICAgICAgfTtcbiAgZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKHRoMiwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpIHtcbiAgICB2YXIgY29zdGgyID0gZmFicmljLnV0aWwuY29zKHRoMiksXG4gICAgICAgIHNpbnRoMiA9IGZhYnJpYy51dGlsLnNpbih0aDIpLFxuICAgICAgICBjb3N0aDMgPSBmYWJyaWMudXRpbC5jb3ModGgzKSxcbiAgICAgICAgc2ludGgzID0gZmFicmljLnV0aWwuc2luKHRoMyksXG4gICAgICAgIHRvWCA9IGNvc1RoICogcnggKiBjb3N0aDMgLSBzaW5UaCAqIHJ5ICogc2ludGgzICsgY3gxLFxuICAgICAgICB0b1kgPSBzaW5UaCAqIHJ4ICogY29zdGgzICsgY29zVGggKiByeSAqIHNpbnRoMyArIGN5MSxcbiAgICAgICAgY3AxWCA9IGZyb21YICsgbVQgKiAoIC1jb3NUaCAqIHJ4ICogc2ludGgyIC0gc2luVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMVkgPSBmcm9tWSArIG1UICogKCAtc2luVGggKiByeCAqIHNpbnRoMiArIGNvc1RoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDJYID0gdG9YICsgbVQgKiAoIGNvc1RoICogcnggKiBzaW50aDMgKyBzaW5UaCAqIHJ5ICogY29zdGgzKSxcbiAgICAgICAgY3AyWSA9IHRvWSArIG1UICogKCBzaW5UaCAqIHJ4ICogc2ludGgzIC0gY29zVGggKiByeSAqIGNvc3RoMyk7XG5cbiAgICByZXR1cm4gWydDJyxcbiAgICAgIGNwMVgsIGNwMVksXG4gICAgICBjcDJYLCBjcDJZLFxuICAgICAgdG9YLCB0b1lcbiAgICBdO1xuICB9XG5cbiAgLyogQWRhcHRlZCBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9jb250ZW50L3N2Zy9jb250ZW50L3NyYy9uc1NWR1BhdGhEYXRhUGFyc2VyLmNwcFxuICAgKiBieSBBbmRyZWEgQm9nYXp6aSBjb2RlIGlzIHVuZGVyIE1QTC4gaWYgeW91IGRvbid0IGhhdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIHlvdSBjYW4gdGFrZSBpdCBoZXJlXG4gICAqIGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wL1xuICAgKi9cbiAgZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh0b1gsIHRvWSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgpIHtcbiAgICB2YXIgUEkgPSBNYXRoLlBJLCB0aCA9IHJvdGF0ZVggKiBQSSAvIDE4MCxcbiAgICAgICAgc2luVGggPSBmYWJyaWMudXRpbC5zaW4odGgpLFxuICAgICAgICBjb3NUaCA9IGZhYnJpYy51dGlsLmNvcyh0aCksXG4gICAgICAgIGZyb21YID0gMCwgZnJvbVkgPSAwO1xuXG4gICAgcnggPSBNYXRoLmFicyhyeCk7XG4gICAgcnkgPSBNYXRoLmFicyhyeSk7XG5cbiAgICB2YXIgcHggPSAtY29zVGggKiB0b1ggKiAwLjUgLSBzaW5UaCAqIHRvWSAqIDAuNSxcbiAgICAgICAgcHkgPSAtY29zVGggKiB0b1kgKiAwLjUgKyBzaW5UaCAqIHRvWCAqIDAuNSxcbiAgICAgICAgcngyID0gcnggKiByeCwgcnkyID0gcnkgKiByeSwgcHkyID0gcHkgKiBweSwgcHgyID0gcHggKiBweCxcbiAgICAgICAgcGwgPSByeDIgKiByeTIgLSByeDIgKiBweTIgLSByeTIgKiBweDIsXG4gICAgICAgIHJvb3QgPSAwO1xuXG4gICAgaWYgKHBsIDwgMCkge1xuICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHBsIC8gKHJ4MiAqIHJ5MikpO1xuICAgICAgcnggKj0gcztcbiAgICAgIHJ5ICo9IHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcm9vdCA9IChsYXJnZSA9PT0gc3dlZXAgPyAtMS4wIDogMS4wKSAqXG4gICAgICAgICAgICAgIE1hdGguc3FydCggcGwgLyAocngyICogcHkyICsgcnkyICogcHgyKSk7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gcm9vdCAqIHJ4ICogcHkgLyByeSxcbiAgICAgICAgY3kgPSAtcm9vdCAqIHJ5ICogcHggLyByeCxcbiAgICAgICAgY3gxID0gY29zVGggKiBjeCAtIHNpblRoICogY3kgKyB0b1ggKiAwLjUsXG4gICAgICAgIGN5MSA9IHNpblRoICogY3ggKyBjb3NUaCAqIGN5ICsgdG9ZICogMC41LFxuICAgICAgICBtVGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoMSwgMCwgKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5KSxcbiAgICAgICAgZHRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSwgKC1weCAtIGN4KSAvIHJ4LCAoLXB5IC0gY3kpIC8gcnkpO1xuXG4gICAgaWYgKHN3ZWVwID09PSAwICYmIGR0aGV0YSA+IDApIHtcbiAgICAgIGR0aGV0YSAtPSAyICogUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN3ZWVwID09PSAxICYmIGR0aGV0YSA8IDApIHtcbiAgICAgIGR0aGV0YSArPSAyICogUEk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIGN1YmljIGJlemllciBzZWdtZW50cyA8PSA5MGRlZ1xuICAgIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhkdGhldGEgLyBQSSAqIDIpKSxcbiAgICAgICAgcmVzdWx0ID0gW10sIG1EZWx0YSA9IGR0aGV0YSAvIHNlZ21lbnRzLFxuICAgICAgICBtVCA9IDggLyAzICogTWF0aC5zaW4obURlbHRhIC8gNCkgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAvIE1hdGguc2luKG1EZWx0YSAvIDIpLFxuICAgICAgICB0aDMgPSBtVGhldGEgKyBtRGVsdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHNlZ21lbnRUb0JlemllcihtVGhldGEsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKTtcbiAgICAgIGZyb21YID0gcmVzdWx0W2ldWzVdO1xuICAgICAgZnJvbVkgPSByZXN1bHRbaV1bNl07XG4gICAgICBtVGhldGEgPSB0aDM7XG4gICAgICB0aDMgKz0gbURlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgICogUHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1ZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gICAgdmFyIHRhID0gTWF0aC5hdGFuMih1eSwgdXgpLFxuICAgICAgICB0YiA9IE1hdGguYXRhbjIodnksIHZ4KTtcbiAgICBpZiAodGIgPj0gdGEpIHtcbiAgICAgIHJldHVybiB0YiAtIHRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAtICh0YSAtIHRiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhIGJlemllcmN1cnZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MCBzdGFydGluZyBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzZWNvbmRvIGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MyBlbmQgb2YgYmV6aWVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICAgKi9cbiAgLy8gdGFrZW4gZnJvbSBodHRwOi8vanNiaW4uY29tL2l2b21pcS81Ni9lZGl0ICBubyBjcmVkaXRzIGF2YWlsYWJsZSBmb3IgdGhhdC5cbiAgLy8gVE9ETzogY2FuIHdlIG5vcm1hbGl6ZSB0aGlzIHdpdGggdGhlIHN0YXJ0aW5nIHBvaW50cyBzZXQgYXQgMCBhbmQgdGhlbiB0cmFuc2xhdGVkIHRoZSBiYm94P1xuICBmdW5jdGlvbiBnZXRCb3VuZHNPZkN1cnZlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBhcmdzU3RyaW5nO1xuICAgIGlmIChmYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSkge1xuICAgICAgYXJnc1N0cmluZyA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGlmIChmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgICBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCB0dmFsdWVzID0gW10sXG4gICAgICAgIGJvdW5kcyA9IFtbXSwgW11dLFxuICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuXG4gICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3FydGIyYWMgPSBzcXJ0KGIyYWMpO1xuICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICAgIH1cbiAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCwgamxlbiA9IGosIG10O1xuICAgIHdoaWxlIChqLS0pIHtcbiAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgbXQgPSAxIC0gdDtcbiAgICAgIHggPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgICBib3VuZHNbMF1bal0gPSB4O1xuXG4gICAgICB5ID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICAgICAgYm91bmRzWzFdW2pdID0geTtcbiAgICB9XG5cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIHZhciByZXN1bHQgPSBbXG4gICAgICB7XG4gICAgICAgIHg6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pLFxuICAgICAgICB5OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1heC5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9XG4gICAgXTtcbiAgICBpZiAoZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUpIHtcbiAgICAgIGZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10gPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYXJjIHRvIGEgYnVuY2ggb2YgYmV6aWVyIGN1cnZlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZnggc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0gZnkgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgQXJjIGNvbW1hbmRcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21BcmNUb0JlemllcnMoZngsIGZ5LCBjb29yZHMpIHtcbiAgICB2YXIgcnggPSBjb29yZHNbMV0sXG4gICAgICAgIHJ5ID0gY29vcmRzWzJdLFxuICAgICAgICByb3QgPSBjb29yZHNbM10sXG4gICAgICAgIGxhcmdlID0gY29vcmRzWzRdLFxuICAgICAgICBzd2VlcCA9IGNvb3Jkc1s1XSxcbiAgICAgICAgdHggPSBjb29yZHNbNl0sXG4gICAgICAgIHR5ID0gY29vcmRzWzddLFxuICAgICAgICBzZWdzTm9ybSA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vnc05vcm0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNlZ3NOb3JtW2ldWzFdICs9IGZ4O1xuICAgICAgc2Vnc05vcm1baV1bMl0gKz0gZnk7XG4gICAgICBzZWdzTm9ybVtpXVszXSArPSBmeDtcbiAgICAgIHNlZ3NOb3JtW2ldWzRdICs9IGZ5O1xuICAgICAgc2Vnc05vcm1baV1bNV0gKz0gZng7XG4gICAgICBzZWdzTm9ybVtpXVs2XSArPSBmeTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ3NOb3JtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2UgYSBwYXJzZWQgU1ZHIHBhdGggYW5kIG1ha2UgaXQgc2ltcGxlciBmb3IgZmFicmljSlMgbG9naWMuXG4gICAqIHNpbXBsaWZpY2F0aW9uIGNvbnNpc3Qgb2Y6IG9ubHkgVVBQRVJDQVNFIGFic29sdXRlIGNvbW1hbmRzICggcmVsYXRpdmUgY29udmVydGVkIHRvIGFic29sdXRlIClcbiAgICogUyBjb252ZXJ0ZWQgaW4gQywgVCBjb252ZXJ0ZWQgaW4gUSwgQSBjb252ZXJ0ZWQgaW4gQy5cbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCB0aGUgYXJyYXkgb2YgY29tbWFuZHMgb2YgYSBwYXJzZWQgc3ZnIHBhdGggZm9yIGZhYnJpYy5QYXRoXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGUgc2ltcGxpZmllZCBhcnJheSBvZiBjb21tYW5kcyBvZiBhIHBhcnNlZCBzdmcgcGF0aCBmb3IgZmFicmljLlBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VQYXRoU2ltcGxlcihwYXRoKSB7XG4gICAgLy8geCBhbmQgeSByZXByZXNlbnQgdGhlIGxhc3QgcG9pbnQgb2YgdGhlIHBhdGguIHRoZSBwcmV2aW91cyBjb21tYW5kIHBvaW50LlxuICAgIC8vIHdlIGFkZCB0aGVtIHRvIGVhY2ggcmVsYXRpdmUgY29tbWFuZCB0byBtYWtlIGl0IGFuIGFic29sdXRlIGNvbW1lbnQuXG4gICAgLy8gd2UgYWxzbyBzd2FwIHRoZSB2IFYgaCBIIHdpdGggTCwgYmVjYXVzZSBhcmUgZWFzaWVyIHRvIHRyYW5zZm9ybS5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgLy8geDEgYW5kIHkxIHJlcHJlc2VudCB0aGUgbGFzdCBwb2ludCBvZiB0aGUgc3VicGF0aC4gdGhlIHN1YnBhdGggaXMgc3RhcnRlZCB3aXRoXG4gICAgICAgIC8vIG0gb3IgTSBjb21tYW5kLiBXaGVuIGEgeiBvciBaIGNvbW1hbmQgaXMgZHJhd24sIHggYW5kIHkgbmVlZCB0byBiZSByZXNldHRlZCB0b1xuICAgICAgICAvLyB0aGUgbGFzdCB4MSBhbmQgeTEuXG4gICAgICAgIHgxID0gMCwgeTEgPSAwLCBjdXJyZW50LCBpLCBjb252ZXJ0ZWQsXG4gICAgICAgIC8vIHByZXZpb3VzIHdpbGwgaG9zdCB0aGUgbGV0dGVyIG9mIHRoZSBwcmV2aW91cyBjb21tYW5kLCB0byBoYW5kbGUgUyBhbmQgVC5cbiAgICAgICAgLy8gY29udHJvbFggYW5kIGNvbnRyb2xZIHdpbGwgaG9zdCB0aGUgcHJldmlvdXMgcmVmbGVjdGVkIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgZGVzdGluYXRpb25QYXRoID0gW10sIHByZXZpb3VzLCBjb250cm9sWCwgY29udHJvbFk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb252ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2ldLnNsaWNlKDApO1xuICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuICAgICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTCc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgY3VycmVudFswXSA9ICdMJztcbiAgICAgICAgICBjdXJyZW50WzJdID0geTtcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0wnO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTSc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQyc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbNV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzZdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdTJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbM10gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzRdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAvLyB3b3VsZCBiZSBzU2NDIGJ1dCBzaW5jZSB3ZSBhcmUgc3dhcHBpbmcgc1NjIGZvciBDLCB3ZSBjaGVjayBqdXN0IHRoYXQuXG4gICAgICAgICAgaWYgKHByZXZpb3VzID09PSAnQycpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0MnO1xuICAgICAgICAgIGN1cnJlbnRbNV0gPSBjdXJyZW50WzNdO1xuICAgICAgICAgIGN1cnJlbnRbNl0gPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGN1cnJlbnRbM10gPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGN1cnJlbnRbNF0gPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSBjb250cm9sWDtcbiAgICAgICAgICBjdXJyZW50WzJdID0gY29udHJvbFk7XG4gICAgICAgICAgLy8gY3VycmVudFszXSBhbmQgY3VycmVudFs0XSBhcmUgTk9XIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAvLyB3ZSBrZWVwIGl0IGZvciB0aGUgbmV4dCByZWZsZWN0aW9uLlxuICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnUSc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnVCc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1EnO1xuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSBjb250cm9sWDtcbiAgICAgICAgICBjdXJyZW50WzJdID0gY29udHJvbFk7XG4gICAgICAgICAgY3VycmVudFszXSA9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSA9IHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQSc7XG4gICAgICAgICAgY3VycmVudFs2XSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbN10gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGNvbnZlcnRlZCA9IHRydWU7XG4gICAgICAgICAgZGVzdGluYXRpb25QYXRoID0gZGVzdGluYXRpb25QYXRoLmNvbmNhdChmcm9tQXJjVG9CZXppZXJzKHgsIHksIGN1cnJlbnQpKTtcbiAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIHggPSB4MTtcbiAgICAgICAgICB5ID0geTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgICBpZiAoIWNvbnZlcnRlZCkge1xuICAgICAgICBkZXN0aW5hdGlvblBhdGgucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzID0gY3VycmVudFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uUGF0aDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsYyBsZW5ndGggZnJvbSBwb2ludCB4MSx5MSB0byB4Mix5MlxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geTIgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBzZWdtZW50XG4gICAqL1xuICBmdW5jdGlvbiBjYWxjTGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfVxuXG4gIC8vIGZ1bmN0aW9ucyBmb3IgdGhlIEN1YmljIGJlaXplclxuICAvLyB0YWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20va29udmFqcy9rb252YS9ibG9iLzcuMC41L3NyYy9zaGFwZXMvUGF0aC50cyNMMzUwXG4gIGZ1bmN0aW9uIENCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBDQjIodCkge1xuICAgIHJldHVybiAzICogdCAqIHQgKiAoMSAtIHQpO1xuICB9XG4gIGZ1bmN0aW9uIENCMyh0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cbiAgZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRPbkN1YmljQmV6aWVySXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocGN0KSB7XG4gICAgICB2YXIgYzEgPSBDQjEocGN0KSwgYzIgPSBDQjIocGN0KSwgYzMgPSBDQjMocGN0KSwgYzQgPSBDQjQocGN0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHA0eCAqIGMxICsgcDN4ICogYzIgKyBwMnggKiBjMyArIHAxeCAqIGM0LFxuICAgICAgICB5OiBwNHkgKiBjMSArIHAzeSAqIGMyICsgcDJ5ICogYzMgKyBwMXkgKiBjNFxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFuZ2VudEN1YmljSXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBjdCkge1xuICAgICAgdmFyIGludlQgPSAxIC0gcGN0LFxuICAgICAgICAgIHRhbmdlbnRYID0gKDMgKiBpbnZUICogaW52VCAqIChwMnggLSBwMXgpKSArICg2ICogaW52VCAqIHBjdCAqIChwM3ggLSBwMngpKSArXG4gICAgICAgICAgKDMgKiBwY3QgKiBwY3QgKiAocDR4IC0gcDN4KSksXG4gICAgICAgICAgdGFuZ2VudFkgPSAoMyAqIGludlQgKiBpbnZUICogKHAyeSAtIHAxeSkpICsgKDYgKiBpbnZUICogcGN0ICogKHAzeSAtIHAyeSkpICtcbiAgICAgICAgICAoMyAqIHBjdCAqIHBjdCAqIChwNHkgLSBwM3kpKTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRhbmdlbnRZLCB0YW5nZW50WCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFFCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG5cbiAgZnVuY3Rpb24gUUIyKHQpIHtcbiAgICByZXR1cm4gMiAqIHQgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gUUIzKHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVySXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwY3QpIHtcbiAgICAgIHZhciBjMSA9IFFCMShwY3QpLCBjMiA9IFFCMihwY3QpLCBjMyA9IFFCMyhwY3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDN4ICogYzEgKyBwMnggKiBjMiArIHAxeCAqIGMzLFxuICAgICAgICB5OiBwM3kgKiBjMSArIHAyeSAqIGMyICsgcDF5ICogYzNcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhbmdlbnRRdWFkcmF0aWNJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwY3QpIHtcbiAgICAgIHZhciBpbnZUID0gMSAtIHBjdCxcbiAgICAgICAgICB0YW5nZW50WCA9ICgyICogaW52VCAqIChwMnggLSBwMXgpKSArICgyICogcGN0ICogKHAzeCAtIHAyeCkpLFxuICAgICAgICAgIHRhbmdlbnRZID0gKDIgKiBpbnZUICogKHAyeSAtIHAxeSkpICsgKDIgKiBwY3QgKiAocDN5IC0gcDJ5KSk7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0YW5nZW50WSwgdGFuZ2VudFgpO1xuICAgIH07XG4gIH1cblxuXG4gIC8vIHRoaXMgd2lsbCBydW4gb3ZlciBhIHBhdGggc2VnbWVudCAoIGEgY3ViaWMgb3IgcXVhZHJhdGljIHNlZ21lbnQpIGFuZCBhcHByb3hpbWF0ZSBpdFxuICAvLyB3aXRoIDEwMCBzZWdlbW50cy4gVGhpcyB3aWxsIGdvb2QgZW5vdWdoIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJ2ZVxuICBmdW5jdGlvbiBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSkge1xuICAgIHZhciB0ZW1wUCA9IHsgeDogeDEsIHk6IHkxIH0sIHAsIHRtcExlbiA9IDAsIHBlcmM7XG4gICAgZm9yIChwZXJjID0gMC4wMTsgcGVyYyA8PSAxOyBwZXJjICs9IDAuMDEpIHtcbiAgICAgIHAgPSBpdGVyYXRvcihwZXJjKTtcbiAgICAgIHRtcExlbiArPSBjYWxjTGluZUxlbmd0aCh0ZW1wUC54LCB0ZW1wUC55LCBwLngsIHAueSk7XG4gICAgICB0ZW1wUCA9IHA7XG4gICAgfVxuICAgIHJldHVybiB0bXBMZW47XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwYXRoSW5mbywgYW5kIGEgZGlzdGFuY2UgaW4gcGl4ZWxzLCBmaW5kIHRoZSBwZXJjZW50YWdlIGZyb20gMCB0byAxXG4gICAqIHRoYXQgY29ycmVzcG9uZCB0byB0aGF0IHBpeGVscyBydW4gb3ZlciB0aGUgcGF0aC5cbiAgICogVGhlIHBlcmNlbnRhZ2Ugd2lsbCBiZSB0aGVuIHVzZWQgdG8gZmluZCB0aGUgY29ycmVjdCBwb2ludCBvbiB0aGUgY2FudmFzIGZvciB0aGUgcGF0aC5cbiAgICogQHBhcmFtIHtBcnJheX0gc2VnSW5mbyBmYWJyaWNKUyBjb2xsZWN0aW9uIG9mIGluZm9ybWF0aW9uIG9uIGEgcGFyc2VkIHBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIGZyb20gc3RhcnRpbmcgcG9pbnQsIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBpbmZvIG9iamVjdCB3aXRoIHggYW5kIHkgKCB0aGUgcG9pbnQgb24gY2FudmFzICkgYW5kIGFuZ2xlLCB0aGUgdGFuZ2VudCBvbiB0aGF0IHBvaW50O1xuICAgKi9cbiAgZnVuY3Rpb24gZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZShzZWdJbmZvLCBkaXN0YW5jZSkge1xuICAgIHZhciBwZXJjID0gMCwgdG1wTGVuID0gMCwgaXRlcmF0b3IgPSBzZWdJbmZvLml0ZXJhdG9yLCB0ZW1wUCA9IHsgeDogc2VnSW5mby54LCB5OiBzZWdJbmZvLnkgfSxcbiAgICAgICAgcCwgbmV4dExlbiwgbmV4dFN0ZXAgPSAwLjAxLCBhbmdsZUZpbmRlciA9IHNlZ0luZm8uYW5nbGVGaW5kZXIsIGxhc3RQZXJjO1xuICAgIC8vIG5leHRTdGVwID4gMC4wMDAxIGNvdmVycyAwLjAwMDE1NjI1IHRoYXQgMS82NHRoIG9mIDEvMTAwXG4gICAgLy8gdGhlIHBhdGhcbiAgICB3aGlsZSAodG1wTGVuIDwgZGlzdGFuY2UgJiYgcGVyYyA8PSAxICYmIG5leHRTdGVwID4gMC4wMDAxKSB7XG4gICAgICBwID0gaXRlcmF0b3IocGVyYyk7XG4gICAgICBsYXN0UGVyYyA9IHBlcmM7XG4gICAgICBuZXh0TGVuID0gY2FsY0xpbmVMZW5ndGgodGVtcFAueCwgdGVtcFAueSwgcC54LCBwLnkpO1xuICAgICAgLy8gY29tcGFyZSB0bXBMZW4gZWFjaCBjeWNsZSB3aXRoIGRpc3RhbmNlLCBkZWNpZGUgbmV4dCBwZXJjIHRvIHRlc3QuXG4gICAgICBpZiAoKG5leHRMZW4gKyB0bXBMZW4pID4gZGlzdGFuY2UpIHtcbiAgICAgICAgLy8gd2UgZGlzY2FyZCB0aGlzIHN0ZXAgYW5kIHdlIG1ha2Ugc21hbGxlciBzdGVwcy5cbiAgICAgICAgbmV4dFN0ZXAgLz0gMjtcbiAgICAgICAgcGVyYyAtPSBuZXh0U3RlcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0ZW1wUCA9IHA7XG4gICAgICAgIHBlcmMgKz0gbmV4dFN0ZXA7XG4gICAgICAgIHRtcExlbiArPSBuZXh0TGVuO1xuICAgICAgfVxuICAgIH1cbiAgICBwLmFuZ2xlID0gYW5nbGVGaW5kZXIobGFzdFBlcmMpO1xuICAgIHJldHVybiBwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBvdmVyIGEgcGFyc2VkIGFuZCBzaW1wbGlmZWQgcGF0aCBhbmQgZXh0cmFjIHNvbWUgaW5mb3JtYXRpb25zLlxuICAgKiBpbmZvcm1hdGlvbnMgYXJlIGxlbmd0aCBvZiBlYWNoIGNvbW1hbmQgYW5kIHN0YXJ0aW5nIHBvaW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZmFicmljSlMgcGFyc2VkIHBhdGggY29tbWFuZHNcbiAgICogQHJldHVybiB7QXJyYXl9IHBhdGggY29tbWFuZHMgaW5mb3JtYXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQYXRoU2VnbWVudHNJbmZvKHBhdGgpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSAwLCBsZW4gPSBwYXRoLmxlbmd0aCwgY3VycmVudCxcbiAgICAgICAgLy94MiBhbmQgeTIgYXJlIHRoZSBjb29yZHMgb2Ygc2VnbWVudCBzdGFydFxuICAgICAgICAvL3gxIGFuZCB5MSBhcmUgdGhlIGNvb3JkcyBvZiB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICB4MSA9IDAsIHkxID0gMCwgeDIgPSAwLCB5MiA9IDAsIGluZm8gPSBbXSwgaXRlcmF0b3IsIHRlbXBJbmZvLCBhbmdsZUZpbmRlcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjdXJyZW50ID0gcGF0aFtpXTtcbiAgICAgIHRlbXBJbmZvID0ge1xuICAgICAgICB4OiB4MSxcbiAgICAgICAgeTogeTEsXG4gICAgICAgIGNvbW1hbmQ6IGN1cnJlbnRbMF0sXG4gICAgICB9O1xuICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vZmlyc3QgbGV0dGVyXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IDA7XG4gICAgICAgICAgeDIgPSB4MSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeTIgPSB5MSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IGNhbGNMaW5lTGVuZ3RoKHgxLCB5MSwgY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkxID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgaXRlcmF0b3IgPSBnZXRQb2ludE9uQ3ViaWNCZXppZXJJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICApO1xuICAgICAgICAgIGFuZ2xlRmluZGVyID0gZ2V0VGFuZ2VudEN1YmljSXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICBjdXJyZW50WzZdXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0ZW1wSW5mby5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICAgIHRlbXBJbmZvLmFuZ2xlRmluZGVyID0gYW5nbGVGaW5kZXI7XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gcGF0aEl0ZXJhdG9yKGl0ZXJhdG9yLCB4MSwgeTEpO1xuICAgICAgICAgIHgxID0gY3VycmVudFs1XTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgIGl0ZXJhdG9yID0gZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllckl0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF1cbiAgICAgICAgICApO1xuICAgICAgICAgIGFuZ2xlRmluZGVyID0gZ2V0VGFuZ2VudFF1YWRyYXRpY0l0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRlbXBJbmZvLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgICAgdGVtcEluZm8uYW5nbGVGaW5kZXIgPSBhbmdsZUZpbmRlcjtcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSk7XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzNdO1xuICAgICAgICAgIHkxID0gY3VycmVudFs0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgIC8vIHdlIGFkZCB0aG9zZSBpbiBvcmRlciB0byBlYXNlIGNhbGN1bGF0aW9ucyBsYXRlclxuICAgICAgICAgIHRlbXBJbmZvLmRlc3RYID0geDI7XG4gICAgICAgICAgdGVtcEluZm8uZGVzdFkgPSB5MjtcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBjYWxjTGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdG90YWxMZW5ndGggKz0gdGVtcEluZm8ubGVuZ3RoO1xuICAgICAgaW5mby5wdXNoKHRlbXBJbmZvKTtcbiAgICB9XG4gICAgaW5mby5wdXNoKHsgbGVuZ3RoOiB0b3RhbExlbmd0aCwgeDogeDEsIHk6IHkxIH0pO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRPblBhdGgocGF0aCwgZGlzdGFuY2UsIGluZm9zKSB7XG4gICAgaWYgKCFpbmZvcykge1xuICAgICAgaW5mb3MgPSBnZXRQYXRoU2VnbWVudHNJbmZvKHBhdGgpO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKChkaXN0YW5jZSAtIGluZm9zW2ldLmxlbmd0aCA+IDApICYmIGkgPCAoaW5mb3MubGVuZ3RoIC0gMikpIHtcbiAgICAgIGRpc3RhbmNlIC09IGluZm9zW2ldLmxlbmd0aDtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgLy8gdmFyIGRpc3RhbmNlID0gaW5mb3NbaW5mb3MubGVuZ3RoIC0gMV0gKiBwZXJjO1xuICAgIHZhciBzZWdJbmZvID0gaW5mb3NbaV0sIHNlZ1BlcmNlbnQgPSBkaXN0YW5jZSAvIHNlZ0luZm8ubGVuZ3RoLFxuICAgICAgICBjb21tYW5kID0gc2VnSW5mby5jb21tYW5kLCBzZWdtZW50ID0gcGF0aFtpXSwgaW5mbztcblxuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIHJldHVybiB7IHg6IHNlZ0luZm8ueCwgeTogc2VnSW5mby55LCBhbmdsZTogMCB9O1xuICAgICAgY2FzZSAnWic6XG4gICAgICBjYXNlICd6JzpcbiAgICAgICAgaW5mbyA9IG5ldyBmYWJyaWMuUG9pbnQoc2VnSW5mby54LCBzZWdJbmZvLnkpLmxlcnAoXG4gICAgICAgICAgbmV3IGZhYnJpYy5Qb2ludChzZWdJbmZvLmRlc3RYLCBzZWdJbmZvLmRlc3RZKSxcbiAgICAgICAgICBzZWdQZXJjZW50XG4gICAgICAgICk7XG4gICAgICAgIGluZm8uYW5nbGUgPSBNYXRoLmF0YW4yKHNlZ0luZm8uZGVzdFkgLSBzZWdJbmZvLnksIHNlZ0luZm8uZGVzdFggLSBzZWdJbmZvLngpO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICBpbmZvID0gbmV3IGZhYnJpYy5Qb2ludChzZWdJbmZvLngsIHNlZ0luZm8ueSkubGVycChcbiAgICAgICAgICBuZXcgZmFicmljLlBvaW50KHNlZ21lbnRbMV0sIHNlZ21lbnRbMl0pLFxuICAgICAgICAgIHNlZ1BlcmNlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaW5mby5hbmdsZSA9IE1hdGguYXRhbjIoc2VnbWVudFsyXSAtIHNlZ0luZm8ueSwgc2VnbWVudFsxXSAtIHNlZ0luZm8ueCk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgY2FzZSAnQyc6XG4gICAgICAgIHJldHVybiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKTtcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICByZXR1cm4gZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZShzZWdJbmZvLCBkaXN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGhTdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvb3JkcyA9IFtdLFxuICAgICAgICBjdXJyZW50UGF0aCxcbiAgICAgICAgcGFyc2VkLFxuICAgICAgICByZSA9IGZhYnJpYy5yZVBhdGhDb21tYW5kLFxuICAgICAgICByTnVtYmVyID0gJ1stK10/KD86XFxcXGQqXFxcXC5cXFxcZCt8XFxcXGQrXFxcXC4/KSg/OltlRV1bLStdP1xcXFxkKyk/XFxcXHMqJyxcbiAgICAgICAgck51bWJlckNvbW1hV3NwID0gJygnICsgck51bWJlciArICcpJyArIGZhYnJpYy5jb21tYVdzcCxcbiAgICAgICAgckZsYWdDb21tYVdzcCA9ICcoWzAxXSknICsgZmFicmljLmNvbW1hV3NwICsgJz8nLFxuICAgICAgICByQXJjU2VxID0gck51bWJlckNvbW1hV3NwICsgJz8nICsgck51bWJlckNvbW1hV3NwICsgJz8nICsgck51bWJlckNvbW1hV3NwICsgckZsYWdDb21tYVdzcCArIHJGbGFnQ29tbWFXc3AgK1xuICAgICAgICAgIHJOdW1iZXJDb21tYVdzcCArICc/KCcgKyByTnVtYmVyICsgJyknLFxuICAgICAgICByZWdBcmNBcmd1bWVudFNlcXVlbmNlID0gbmV3IFJlZ0V4cChyQXJjU2VxLCAnZycpLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgY29vcmRzU3RyLFxuICAgICAgICAvLyBvbmUgb2YgY29tbWFuZHMgKG0sTSxsLEwscSxRLGMsQyxldGMuKSBmb2xsb3dlZCBieSBub24tY29tbWFuZCBjaGFyYWN0ZXJzIChpLmUuIGNvbW1hbmQgdmFsdWVzKVxuICAgICAgICBwYXRoO1xuICAgIGlmICghcGF0aFN0cmluZyB8fCAhcGF0aFN0cmluZy5tYXRjaCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGF0aCA9IHBhdGhTdHJpbmcubWF0Y2goL1ttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qL2dpKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjb29yZHNQYXJzZWQsIGxlbiA9IHBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnRQYXRoID0gcGF0aFtpXTtcblxuICAgICAgY29vcmRzU3RyID0gY3VycmVudFBhdGguc2xpY2UoMSkudHJpbSgpO1xuICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG5cbiAgICAgIHZhciBjb21tYW5kID0gY3VycmVudFBhdGguY2hhckF0KDApO1xuICAgICAgY29vcmRzUGFyc2VkID0gW2NvbW1hbmRdO1xuXG4gICAgICBpZiAoY29tbWFuZC50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgLy8gYXJjcyBoYXZlIHNwZWNpYWwgZmxhZ3MgdGhhdCBhcHBhcmVudGx5IGRvbid0IHJlcXVpcmUgc3BhY2VzIHNvIGhhbmRsZSBzcGVjaWFsXG4gICAgICAgIGZvciAodmFyIGFyZ3M7IChhcmdzID0gcmVnQXJjQXJndW1lbnRTZXF1ZW5jZS5leGVjKGNvb3Jkc1N0cikpOykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29vcmRzLnB1c2goYXJnc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoY29vcmRzU3RyKSkpIHtcbiAgICAgICAgICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBjb29yZHMubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlRmxvYXQoY29vcmRzW2pdKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgY29vcmRzUGFyc2VkLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tbWFuZExlbmd0aCA9IGNvbW1hbmRMZW5ndGhzW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgcmVwZWF0ZWRDb21tYW5kID0gcmVwZWF0ZWRDb21tYW5kc1tjb21tYW5kXSB8fCBjb21tYW5kO1xuXG4gICAgICBpZiAoY29vcmRzUGFyc2VkLmxlbmd0aCAtIDEgPiBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY29vcmRzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtjb21tYW5kXS5jb25jYXQoY29vcmRzUGFyc2VkLnNsaWNlKGssIGsgKyBjb21tYW5kTGVuZ3RoKSkpO1xuICAgICAgICAgIGNvbW1hbmQgPSByZXBlYXRlZENvbW1hbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChjb29yZHNQYXJzZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggb2YgYSBlbGxpcHRpYy1hcmNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4IHN0YXJ0IHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge051bWJlcn0gZnlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4IGhvcml6b250YWwgcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeSB2ZXJ0aWNhbCByYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdCBhbmdsZSBvZiBob3Jpem9udGFsIGF4aXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxhcmdlIDEgb3IgMCwgd2hhdGV2ZXIgdGhlIGFyYyBpcyB0aGUgYmlnIG9yIHRoZSBzbWFsbCBvbiB0aGUgMiBwb2ludHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN3ZWVwIDEgb3IgMCwgMSBjbG9ja3dpc2Ugb3IgY291bnRlcmNsb2Nrd2lzZSBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR4IGVuZCBwb2ludCBvZiBhcmNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHR5XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCb3VuZHNPZkFyYyhmeCwgZnksIHJ4LCByeSwgcm90LCBsYXJnZSwgc3dlZXAsIHR4LCB0eSkge1xuXG4gICAgdmFyIGZyb21YID0gMCwgZnJvbVkgPSAwLCBib3VuZCwgYm91bmRzID0gW10sXG4gICAgICAgIHNlZ3MgPSBhcmNUb1NlZ21lbnRzKHR4IC0gZngsIHR5IC0gZnksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGJvdW5kID0gZ2V0Qm91bmRzT2ZDdXJ2ZShmcm9tWCwgZnJvbVksIHNlZ3NbaV1bMV0sIHNlZ3NbaV1bMl0sIHNlZ3NbaV1bM10sIHNlZ3NbaV1bNF0sIHNlZ3NbaV1bNV0sIHNlZ3NbaV1bNl0pO1xuICAgICAgYm91bmRzLnB1c2goeyB4OiBib3VuZFswXS54ICsgZngsIHk6IGJvdW5kWzBdLnkgKyBmeSB9KTtcbiAgICAgIGJvdW5kcy5wdXNoKHsgeDogYm91bmRbMV0ueCArIGZ4LCB5OiBib3VuZFsxXS55ICsgZnkgfSk7XG4gICAgICBmcm9tWCA9IHNlZ3NbaV1bNV07XG4gICAgICBmcm9tWSA9IHNlZ3NbaV1bNl07XG4gICAgfVxuICAgIHJldHVybiBib3VuZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYXdzIGFyY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeFxuICAgKiBAcGFyYW0ge051bWJlcn0gZnlcbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRzIGNvb3JkcyBvZiB0aGUgYXJjLCB3aXRob3V0IHRoZSBmcm9udCAnQS9hJ1xuICAgKi9cbiAgZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGZ4LCBmeSwgY29vcmRzKSB7XG4gICAgY29vcmRzID0gY29vcmRzLnNsaWNlKDApLnVuc2hpZnQoJ1gnKTsgLy8gY29tbWFuZCBBIG9yIGEgZG9lcyBub3QgbWF0dGVyXG4gICAgdmFyIGJlemllcnMgPSBmcm9tQXJjVG9CZXppZXJzKGZ4LCBmeSwgY29vcmRzKTtcbiAgICBiZXppZXJzLmZvckVhY2goZnVuY3Rpb24oYmV6aWVyKSB7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUby5hcHBseShjdHgsIGJlemllci5zbGljZSgxKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZmFicmljLnV0aWwucGFyc2VQYXRoID0gcGFyc2VQYXRoO1xuICBmYWJyaWMudXRpbC5tYWtlUGF0aFNpbXBsZXIgPSBtYWtlUGF0aFNpbXBsZXI7XG4gIGZhYnJpYy51dGlsLmdldFBhdGhTZWdtZW50c0luZm8gPSBnZXRQYXRoU2VnbWVudHNJbmZvO1xuICBmYWJyaWMudXRpbC5mcm9tQXJjVG9CZXppZXJzID0gZnJvbUFyY1RvQmV6aWVycztcbiAgLyoqXG4gICAqIFR5cG8gb2YgYGZyb21BcmNUb0JlemllcnNgIGtlcHQgZm9yIG5vdCBicmVha2luZyB0aGUgYXBpIG9uY2UgY29ycmVjdGVkLlxuICAgKiBXaWxsIGJlIHJlbW92ZWQgaW4gZmFicmljIDUuMFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZmFicmljLnV0aWwuZnJvbUFyY1RvQmVpemVycyA9IGZyb21BcmNUb0JlemllcnM7XG4gIGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUgPSBnZXRCb3VuZHNPZkN1cnZlO1xuICBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aCA9IGdldFBvaW50T25QYXRoO1xuICAvLyBrZXB0IGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gbWFrZSBicmVha2luZyBjaGFuZ2VzLlxuICAvLyBidXQgdXNlbGVzcyBhbmQgZGVwcmVjYXRlZC5cbiAgZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZBcmMgPSBnZXRCb3VuZHNPZkFyYztcbiAgZmFicmljLnV0aWwuZHJhd0FyYyA9IGRyYXdBcmM7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEludm9rZXMgbWV0aG9kIG9uIGFsbCBpdGVtcyBpbiBhIGdpdmVuIGFycmF5XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBOYW1lIG9mIGEgbWV0aG9kIHRvIGludm9rZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIGludm9rZShhcnJheSwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gYXJncy5sZW5ndGggPyBhcnJheVtpXVttZXRob2RdLmFwcGx5KGFycmF5W2ldLCBhcmdzKSA6IGFycmF5W2ldW21ldGhvZF0uY2FsbChhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgbWF4aW11bSB2YWx1ZSBpbiBhcnJheSAobm90IG5lY2Vzc2FyaWx5IFwiZmlyc3RcIiBvbmUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5UHJvcGVydHlcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIG1heChhcnJheSwgYnlQcm9wZXJ0eSkge1xuICAgIHJldHVybiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgcmV0dXJuIHZhbHVlMSA+PSB2YWx1ZTI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgbWluaW11bSB2YWx1ZSBpbiBhcnJheSAobm90IG5lY2Vzc2FyaWx5IFwiZmlyc3RcIiBvbmUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5UHJvcGVydHlcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIG1pbihhcnJheSwgYnlQcm9wZXJ0eSkge1xuICAgIHJldHVybiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgcmV0dXJuIHZhbHVlMSA8IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgayA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoay0tKSB7XG4gICAgICBhcnJheVtrXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGNvbmRpdGlvbikge1xuICAgIGlmICghYXJyYXkgfHwgYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGggLSAxLFxuICAgICAgICByZXN1bHQgPSBieVByb3BlcnR5ID8gYXJyYXlbaV1bYnlQcm9wZXJ0eV0gOiBhcnJheVtpXTtcbiAgICBpZiAoYnlQcm9wZXJ0eSkge1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uKGFycmF5W2ldW2J5UHJvcGVydHldLCByZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXJyYXlbaV1bYnlQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuYXJyYXlcbiAgICovXG4gIGZhYnJpYy51dGlsLmFycmF5ID0ge1xuICAgIGZpbGw6IGZpbGwsXG4gICAgaW52b2tlOiBpbnZva2UsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBDb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBvbmUganMgb2JqZWN0IHRvIGFub3RoZXJcbiAgICogdGhpcyBkb2VzIG5vdCBhbmQgY2Fubm90IGNvbXBldGUgd2l0aCBnZW5lcmljIHV0aWxzLlxuICAgKiBEb2VzIG5vdCBjbG9uZSBvciBleHRlbmQgZmFicmljLk9iamVjdCBzdWJjbGFzc2VzLlxuICAgKiBUaGlzIGlzIG1vc3RseSBmb3IgaW50ZXJuYWwgdXNlIGFuZCBoYXMgZXh0cmEgaGFuZGxpbmcgZm9yIGZhYnJpY0pTIG9iamVjdHNcbiAgICogaXQgc2tpcHMgdGhlIGNhbnZhcyBhbmQgZ3JvdXAgcHJvcGVydGllcyBpbiBkZWVwIGNsb25pbmcuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIFdoZXJlIHRvIGNvcHkgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBXaGVyZSB0byBjb3B5IGZyb21cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBleHRlbmQoZGVzdGluYXRpb24sIHNvdXJjZSwgZGVlcCkge1xuICAgIC8vIEpTY3JpcHQgRG9udEVudW0gYnVnIGlzIG5vdCB0YWtlbiBjYXJlIG9mXG4gICAgLy8gdGhlIGRlZXAgY2xvbmUgaXMgZm9yIGludGVybmFsIHVzZSwgaXMgbm90IG1lYW50IHRvIGF2b2lkXG4gICAgLy8gamF2YXNjcmlwdCB0cmFwcyBvciBjbG9uaW5nIGh0bWwgZWxlbWVudCBvciBzZWxmIHJlZmVyZW5jZWQgb2JqZWN0cy5cbiAgICBpZiAoZGVlcCkge1xuICAgICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlICYmIHNvdXJjZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgLy8gYXZvaWQgY2xvbmluZyBkZWVwIGltYWdlcywgY2FudmFzZXMsXG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZGVzdGluYXRpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW2ldID0gZXh0ZW5kKHsgfSwgc291cmNlW2ldLCBkZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlICYmIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NhbnZhcycgfHwgcHJvcGVydHkgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGNsb25lIHRoaXMgcHJvcHMgYXQgYWxsLlxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBrZWVwIHRoZSBrZXlzIGluIHRoZSBjb3B5XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbcHJvcGVydHldLCBkZWVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHNvdW5kcyBvZGQgZm9yIGFuIGV4dGVuZCBidXQgaXMgb2sgZm9yIHJlY3Vyc2l2ZSB1c2VcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVtcHR5IG9iamVjdCBhbmQgY29waWVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3QgdG8gaXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLm9iamVjdFxuICAgKiBUT0RPOiB0aGlzIGZ1bmN0aW9uIHJldHVybiBhbiBlbXB0eSBvYmplY3QgaWYgeW91IHRyeSB0byBjbG9uZSBudWxsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNsb25lXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGZ1bmN0aW9uIGNsb25lKG9iamVjdCwgZGVlcCkge1xuICAgIHJldHVybiBleHRlbmQoeyB9LCBvYmplY3QsIGRlZXApO1xuICB9XG5cbiAgLyoqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwub2JqZWN0ICovXG4gIGZhYnJpYy51dGlsLm9iamVjdCA9IHtcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBjbG9uZTogY2xvbmVcbiAgfTtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMudXRpbCwgZmFicmljLk9ic2VydmFibGUpO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIENhbWVsaXplcyBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNhbWVsaXplXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ2FtZWxpemVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLSsoLik/L2csIGZ1bmN0aW9uKG1hdGNoLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBjaGFyYWN0ZXIgPyBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcGl0YWxpemVzIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gY2FwaXRhbGl6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmaXJzdExldHRlck9ubHldIElmIHRydWUgb25seSBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWRcbiAgICogYW5kIG90aGVyIGxldHRlcnMgc3RheSB1bnRvdWNoZWQsIGlmIGZhbHNlIGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgKiBhbmQgb3RoZXIgbGV0dGVycyBhcmUgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBDYXBpdGFsaXplZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZywgZmlyc3RMZXR0ZXJPbmx5KSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArXG4gICAgICAoZmlyc3RMZXR0ZXJPbmx5ID8gc3RyaW5nLnNsaWNlKDEpIDogc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgWE1MIGluIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gZXNjYXBlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gRXNjYXBlZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVYbWwoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAucmVwbGFjZSgvJy9nLCAnJmFwb3M7JylcbiAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlIGEgc3RyaW5nIGluIHRoZSB1c2VyIHBlcmNlaXZlZCBzaW5nbGUgdW5pdHNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dHN0cmluZyBTdHJpbmcgdG8gZXNjYXBlXG4gICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBjb250YWluaW5nIHRoZSBncmFwaGVtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdyYXBoZW1lU3BsaXQodGV4dHN0cmluZykge1xuICAgIHZhciBpID0gMCwgY2hyLCBncmFwaGVtZXMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBjaHI7IGkgPCB0ZXh0c3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKGNociA9IGdldFdob2xlQ2hhcih0ZXh0c3RyaW5nLCBpKSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZ3JhcGhlbWVzLnB1c2goY2hyKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYXBoZW1lcztcbiAgfVxuXG4gIC8vIHRha2VuIGZyb20gbWRuIGluIHRoZSBjaGFyQXQgZG9jIHBhZ2UuXG4gIGZ1bmN0aW9uIGdldFdob2xlQ2hhcihzdHIsIGkpIHtcbiAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICByZXR1cm4gJyc7IC8vIFBvc2l0aW9uIG5vdCBmb3VuZFxuICAgIH1cbiAgICBpZiAoY29kZSA8IDB4RDgwMCB8fCBjb2RlID4gMHhERkZGKSB7XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdChpKTtcbiAgICB9XG5cbiAgICAvLyBIaWdoIHN1cnJvZ2F0ZSAoY291bGQgY2hhbmdlIGxhc3QgaGV4IHRvIDB4REI3RiB0byB0cmVhdCBoaWdoIHByaXZhdGVcbiAgICAvLyBzdXJyb2dhdGVzIGFzIHNpbmdsZSBjaGFyYWN0ZXJzKVxuICAgIGlmICgweEQ4MDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REJGRikge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPD0gKGkgKyAxKSkge1xuICAgICAgICB0aHJvdyAnSGlnaCBzdXJyb2dhdGUgd2l0aG91dCBmb2xsb3dpbmcgbG93IHN1cnJvZ2F0ZSc7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IHN0ci5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGlmICgweERDMDAgPiBuZXh0IHx8IG5leHQgPiAweERGRkYpIHtcbiAgICAgICAgdGhyb3cgJ0hpZ2ggc3Vycm9nYXRlIHdpdGhvdXQgZm9sbG93aW5nIGxvdyBzdXJyb2dhdGUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoaSkgKyBzdHIuY2hhckF0KGkgKyAxKTtcbiAgICB9XG4gICAgLy8gTG93IHN1cnJvZ2F0ZSAoMHhEQzAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERGRkYpXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHRocm93ICdMb3cgc3Vycm9nYXRlIHdpdGhvdXQgcHJlY2VkaW5nIGhpZ2ggc3Vycm9nYXRlJztcbiAgICB9XG4gICAgdmFyIHByZXYgPSBzdHIuY2hhckNvZGVBdChpIC0gMSk7XG5cbiAgICAvLyAoY291bGQgY2hhbmdlIGxhc3QgaGV4IHRvIDB4REI3RiB0byB0cmVhdCBoaWdoIHByaXZhdGVcbiAgICAvLyBzdXJyb2dhdGVzIGFzIHNpbmdsZSBjaGFyYWN0ZXJzKVxuICAgIGlmICgweEQ4MDAgPiBwcmV2IHx8IHByZXYgPiAweERCRkYpIHtcbiAgICAgIHRocm93ICdMb3cgc3Vycm9nYXRlIHdpdGhvdXQgcHJlY2VkaW5nIGhpZ2ggc3Vycm9nYXRlJztcbiAgICB9XG4gICAgLy8gV2UgY2FuIHBhc3Mgb3ZlciBsb3cgc3Vycm9nYXRlcyBub3cgYXMgdGhlIHNlY29uZCBjb21wb25lbnRcbiAgICAvLyBpbiBhIHBhaXIgd2hpY2ggd2UgaGF2ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFN0cmluZyB1dGlsaXRpZXNcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICovXG4gIGZhYnJpYy51dGlsLnN0cmluZyA9IHtcbiAgICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gICAgY2FwaXRhbGl6ZTogY2FwaXRhbGl6ZSxcbiAgICBlc2NhcGVYbWw6IGVzY2FwZVhtbCxcbiAgICBncmFwaGVtZVNwbGl0OiBncmFwaGVtZVNwbGl0XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbigpIHsgfSxcblxuICAgICAgSVNfRE9OVEVOVU1fQlVHR1kgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4geyB0b1N0cmluZzogMSB9KSB7XG4gICAgICAgICAgaWYgKHAgPT09ICd0b1N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KSgpLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgYWRkTWV0aG9kcyA9IGZ1bmN0aW9uKGtsYXNzLCBzb3VyY2UsIHBhcmVudCkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcblxuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbiBrbGFzcy5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgKHNvdXJjZVtwcm9wZXJ0eV0gKyAnJykuaW5kZXhPZignY2FsbFN1cGVyJykgPiAtMSkge1xuXG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID0gKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdXBlcmNsYXNzID0gdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcztcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gJ2luaXRpYWxpemUnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChJU19ET05URU5VTV9CVUdHWSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUudG9TdHJpbmcgPSBzb3VyY2UudG9TdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikge1xuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUudmFsdWVPZiA9IHNvdXJjZS52YWx1ZU9mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICBmdW5jdGlvbiBTdWJjbGFzcygpIHsgfVxuXG4gIGZ1bmN0aW9uIGNhbGxTdXBlcihtZXRob2ROYW1lKSB7XG4gICAgdmFyIHBhcmVudE1ldGhvZCA9IG51bGwsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIC8vIGNsaW1iIHByb3RvdHlwZSBjaGFpbiB0byBmaW5kIG1ldGhvZCBub3QgZXF1YWwgdG8gY2FsbGVlJ3MgbWV0aG9kXG4gICAgd2hpbGUgKF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MpIHtcbiAgICAgIHZhciBzdXBlckNsYXNzTWV0aG9kID0gX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV07XG4gICAgICBpZiAoX3RoaXNbbWV0aG9kTmFtZV0gIT09IHN1cGVyQ2xhc3NNZXRob2QpIHtcbiAgICAgICAgcGFyZW50TWV0aG9kID0gc3VwZXJDbGFzc01ldGhvZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIF90aGlzID0gX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcy5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJlbnRNZXRob2QpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZygndHJpZWQgdG8gY2FsbFN1cGVyICcgKyBtZXRob2ROYW1lICsgJywgbWV0aG9kIG5vdCBmb3VuZCBpbiBwcm90b3R5cGUgY2hhaW4nLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgPyBwYXJlbnRNZXRob2QuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKVxuICAgICAgOiBwYXJlbnRNZXRob2QuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGNyZWF0aW9uIG9mIFwiY2xhc3Nlc1wiLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmVudF0gb3B0aW9uYWwgXCJDbGFzc1wiIHRvIGluaGVyaXQgZnJvbVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzc1xuICAgKiAgICAgICAgICAgICAgICAgIChiZSBjYXJlZnVsIG1vZGlmeWluZyBvYmplY3RzIGRlZmluZWQgaGVyZSBhcyB0aGlzIHdvdWxkIGFmZmVjdCBhbGwgaW5zdGFuY2VzKVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoKSB7XG4gICAgdmFyIHBhcmVudCA9IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmVudCA9IHByb3BlcnRpZXMuc2hpZnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24ga2xhc3MoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBrbGFzcy5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgIGtsYXNzLnN1YmNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIFN1YmNsYXNzLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICBrbGFzcy5wcm90b3R5cGUgPSBuZXcgU3ViY2xhc3MoKTtcbiAgICAgIHBhcmVudC5zdWJjbGFzc2VzLnB1c2goa2xhc3MpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYWRkTWV0aG9kcyhrbGFzcywgcHJvcGVydGllc1tpXSwgcGFyZW50KTtcbiAgICB9XG4gICAgaWYgKCFrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSkge1xuICAgICAga2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUgPSBlbXB0eUZ1bmN0aW9uO1xuICAgIH1cbiAgICBrbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBrbGFzcztcbiAgICBrbGFzcy5wcm90b3R5cGUuY2FsbFN1cGVyID0gY2FsbFN1cGVyO1xuICAgIHJldHVybiBrbGFzcztcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzID0gY3JlYXRlQ2xhc3M7XG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIHNpbmNlIGllMTEgY2FuIHVzZSBhZGRFdmVudExpc3RlbmVyIGJ1dCB0aGV5IGRvIG5vdCBzdXBwb3J0IG9wdGlvbnMsIGkgbmVlZCB0byBjaGVja1xuICB2YXIgY291bGRVc2VBdHRhY2hFdmVudCA9ICEhZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLmF0dGFjaEV2ZW50LFxuICAgICAgdG91Y2hFdmVudHMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ107XG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGNvdWxkVXNlQXR0YWNoRXZlbnQgPyBmYWxzZSA6IG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmYWJyaWMudXRpbC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgY291bGRVc2VBdHRhY2hFdmVudCA/IGZhbHNlIDogb3B0aW9ucyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hJbmZvKGV2ZW50KSB7XG4gICAgdmFyIHRvdWNoUHJvcCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgIGlmICh0b3VjaFByb3AgJiYgdG91Y2hQcm9wWzBdKSB7XG4gICAgICByZXR1cm4gdG91Y2hQcm9wWzBdO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICBmYWJyaWMudXRpbC5nZXRQb2ludGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgc2Nyb2xsID0gZmFicmljLnV0aWwuZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSxcbiAgICAgICAgX2V2dCA9IGdldFRvdWNoSW5mbyhldmVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IF9ldnQuY2xpZW50WCArIHNjcm9sbC5sZWZ0LFxuICAgICAgeTogX2V2dC5jbGllbnRZICsgc2Nyb2xsLnRvcFxuICAgIH07XG4gIH07XG5cbiAgZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gdG91Y2hFdmVudHMuaW5kZXhPZihldmVudC50eXBlKSA+IC0xIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDcm9zcy1icm93c2VyIHdyYXBwZXIgZm9yIHNldHRpbmcgZWxlbWVudCdzIHN0eWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHNldFN0eWxlKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIHZhciBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGlmICghZWxlbWVudFN0eWxlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgKz0gJzsnICsgc3R5bGVzO1xuICAgICAgcmV0dXJuIHN0eWxlcy5pbmRleE9mKCdvcGFjaXR5JykgPiAtMVxuICAgICAgICA/IHNldE9wYWNpdHkoZWxlbWVudCwgc3R5bGVzLm1hdGNoKC9vcGFjaXR5OlxccyooXFxkP1xcLj9cXGQqKS8pWzFdKVxuICAgICAgICA6IGVsZW1lbnQ7XG4gICAgfVxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHN0eWxlcykge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgc2V0T3BhY2l0eShlbGVtZW50LCBzdHlsZXNbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFByb3BlcnR5ID0gKHByb3BlcnR5ID09PSAnZmxvYXQnIHx8IHByb3BlcnR5ID09PSAnY3NzRmxvYXQnKVxuICAgICAgICAgID8gKHR5cGVvZiBlbGVtZW50U3R5bGUuc3R5bGVGbG9hdCA9PT0gJ3VuZGVmaW5lZCcgPyAnY3NzRmxvYXQnIDogJ3N0eWxlRmxvYXQnKVxuICAgICAgICAgIDogcHJvcGVydHk7XG4gICAgICAgIGVsZW1lbnRTdHlsZVtub3JtYWxpemVkUHJvcGVydHldID0gc3R5bGVzW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB2YXIgcGFyc2VFbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHN1cHBvcnRzT3BhY2l0eSA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLm9wYWNpdHkgPT09ICdzdHJpbmcnLFxuICAgICAgc3VwcG9ydHNGaWx0ZXJzID0gdHlwZW9mIHBhcnNlRWwuc3R5bGUuZmlsdGVyID09PSAnc3RyaW5nJyxcbiAgICAgIHJlT3BhY2l0eSA9IC9hbHBoYVxccypcXChcXHMqb3BhY2l0eVxccyo9XFxzKihbXlxcKV0rKVxcKS8sXG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQ7IH07XG5cbiAgaWYgKHN1cHBvcnRzT3BhY2l0eSkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cbiAgZWxzZSBpZiAoc3VwcG9ydHNGaWx0ZXJzKSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgIHZhciBlcyA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUgJiYgIWVsZW1lbnQuY3VycmVudFN0eWxlLmhhc0xheW91dCkge1xuICAgICAgICBlcy56b29tID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU9wYWNpdHkudGVzdChlcy5maWx0ZXIpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPj0gMC45OTk5ID8gJycgOiAoJ2FscGhhKG9wYWNpdHk9JyArICh2YWx1ZSAqIDEwMCkgKyAnKScpO1xuICAgICAgICBlcy5maWx0ZXIgPSBlcy5maWx0ZXIucmVwbGFjZShyZU9wYWNpdHksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlcy5maWx0ZXIgKz0gJyBhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLnNldFN0eWxlID0gc2V0U3R5bGU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIFRha2VzIGlkIGFuZCByZXR1cm5zIGFuIGVsZW1lbnQgd2l0aCB0aGF0IGlkIChpZiBvbmUgZXhpc3RzIGluIGEgZG9jdW1lbnQpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gaWRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGZhYnJpYy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcbiAgfVxuXG4gIHZhciBzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMsXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGFuIGFycmF5LWxpa2Ugb2JqZWN0IChlLmcuIGFyZ3VtZW50cyBvciBOb2RlTGlzdCkgdG8gYW4gYXJyYXlcbiAgICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHRvQXJyYXkgPSBmdW5jdGlvbihhcnJheUxpa2UpIHtcbiAgICAgICAgcmV0dXJuIF9zbGljZS5jYWxsKGFycmF5TGlrZSwgMCk7XG4gICAgICB9O1xuXG4gIHRyeSB7XG4gICAgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzID0gdG9BcnJheShmYWJyaWMuZG9jdW1lbnQuY2hpbGROb2RlcykgaW5zdGFuY2VvZiBBcnJheTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7IH1cblxuICBpZiAoIXNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cykge1xuICAgIHRvQXJyYXkgPSBmdW5jdGlvbihhcnJheUxpa2UpIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoYXJyYXlMaWtlLmxlbmd0aCksIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBzcGVjaWZpZWQgZWxlbWVudCB3aXRoIHNwZWNpZmllZCBhdHRyaWJ1dGVzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBUeXBlIG9mIGFuIGVsZW1lbnQgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gQXR0cmlidXRlcyB0byBzZXQgb24gYW4gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gTmV3bHkgY3JlYXRlZCBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBtYWtlRWxlbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAocHJvcCA9PT0gJ2NsYXNzJykge1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ2ZvcicpIHtcbiAgICAgICAgZWwuaHRtbEZvciA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBjbGFzcyB0byBhbiBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gYWRkIGNsYXNzIHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgQ2xhc3MgdG8gYWRkIHRvIGFuIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtZW50ICYmICgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbGFzc05hbWUgKyAnICcpID09PSAtMSkge1xuICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gKGVsZW1lbnQuY2xhc3NOYW1lID8gJyAnIDogJycpICsgY2xhc3NOYW1lO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBlbGVtZW50IHdpdGggYW5vdGhlciBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gd3JhcFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gd3JhcHBlciBFbGVtZW50IHRvIHdyYXAgd2l0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGEgd3JhcHBlclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gd3JhcHBlclxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcEVsZW1lbnQoZWxlbWVudCwgd3JhcHBlciwgYXR0cmlidXRlcykge1xuICAgIGlmICh0eXBlb2Ygd3JhcHBlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHdyYXBwZXIgPSBtYWtlRWxlbWVudCh3cmFwcGVyLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh3cmFwcGVyLCBlbGVtZW50KTtcbiAgICB9XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVsZW1lbnQgc2Nyb2xsIG9mZnNldHNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBvcGVyYXRlIG9uXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdC90b3AgdmFsdWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpIHtcblxuICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgdG9wID0gMCxcbiAgICAgICAgZG9jRWxlbWVudCA9IGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIGJvZHkgPSBmYWJyaWMuZG9jdW1lbnQuYm9keSB8fCB7XG4gICAgICAgICAgc2Nyb2xsTGVmdDogMCwgc2Nyb2xsVG9wOiAwXG4gICAgICAgIH07XG5cbiAgICAvLyBXaGlsZSBsb29wIGNoZWNrcyAoYW5kIHRoZW4gc2V0cyBlbGVtZW50IHRvKSAucGFyZW50Tm9kZSBPUiAuaG9zdFxuICAgIC8vICB0byBhY2NvdW50IGZvciBTaGFkb3dET00uIFdlIHN0aWxsIHdhbnQgdG8gdHJhdmVyc2UgdXAgb3V0IG9mIFNoYWRvd0RPTSxcbiAgICAvLyAgYnV0IHRoZSAucGFyZW50Tm9kZSBvZiBhIHJvb3QgU2hhZG93RE9NIG5vZGUgd2lsbCBhbHdheXMgYmUgbnVsbCwgaW5zdGVhZFxuICAgIC8vICBpdCBzaG91bGQgYmUgYWNjZXNzZWQgdGhyb3VnaCAuaG9zdC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI0NzY1NTI4LzQzODM5MzhcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdCkpIHtcblxuICAgICAgLy8gU2V0IGVsZW1lbnQgdG8gZWxlbWVudCBwYXJlbnQsIG9yICdob3N0JyBpbiBjYXNlIG9mIFNoYWRvd0RPTVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG5cbiAgICAgIGlmIChlbGVtZW50ID09PSBmYWJyaWMuZG9jdW1lbnQpIHtcbiAgICAgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbGVtZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgIGRvY0VsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGVmdCArPSBlbGVtZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgdG9wICs9IGVsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSAxICYmIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9mZnNldCBmb3IgYSBnaXZlbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBvZmZzZXQgZm9yXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggXCJsZWZ0XCIgYW5kIFwidG9wXCIgcHJvcGVydGllc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSB7XG4gICAgdmFyIGRvY0VsZW0sXG4gICAgICAgIGRvYyA9IGVsZW1lbnQgJiYgZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgICBib3ggPSB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuICAgICAgICBvZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuICAgICAgICBzY3JvbGxMZWZ0VG9wLFxuICAgICAgICBvZmZzZXRBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgIGJvcmRlckxlZnRXaWR0aDogJ2xlZnQnLFxuICAgICAgICAgIGJvcmRlclRvcFdpZHRoOiAgJ3RvcCcsXG4gICAgICAgICAgcGFkZGluZ0xlZnQ6ICAgICAnbGVmdCcsXG4gICAgICAgICAgcGFkZGluZ1RvcDogICAgICAndG9wJ1xuICAgICAgICB9O1xuXG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYXR0ciBpbiBvZmZzZXRBdHRyaWJ1dGVzKSB7XG4gICAgICBvZmZzZXRbb2Zmc2V0QXR0cmlidXRlc1thdHRyXV0gKz0gcGFyc2VJbnQoZ2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIGF0dHIpLCAxMCkgfHwgMDtcbiAgICB9XG5cbiAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICBib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cblxuICAgIHNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdFRvcC5sZWZ0IC0gKGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwKSArIG9mZnNldC5sZWZ0LFxuICAgICAgdG9wOiBib3gudG9wICsgc2Nyb2xsTGVmdFRvcC50b3AgLSAoZG9jRWxlbS5jbGllbnRUb3AgfHwgMCkgICsgb2Zmc2V0LnRvcFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYSBnaXZlbiBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IHN0eWxlIGF0dHJpYnV0ZSBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgU3R5bGUgYXR0cmlidXRlIHRvIGdldCBmb3IgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0eWxlIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICovXG4gIHZhciBnZXRFbGVtZW50U3R5bGU7XG4gIGlmIChmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICBnZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgc3R5bGUgPSBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgIHJldHVybiBzdHlsZSA/IHN0eWxlW2F0dHJdIDogdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5zdHlsZVthdHRyXTtcbiAgICAgIGlmICghdmFsdWUgJiYgZWxlbWVudC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmN1cnJlbnRTdHlsZVthdHRyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgICAgICBzZWxlY3RQcm9wID0gJ3VzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgPyAndXNlclNlbGVjdCdcbiAgICAgICAgICA6ICdNb3pVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgPyAnTW96VXNlclNlbGVjdCdcbiAgICAgICAgICAgIDogJ1dlYmtpdFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgID8gJ1dlYmtpdFVzZXJTZWxlY3QnXG4gICAgICAgICAgICAgIDogJ0todG1sVXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgICAgICA/ICdLaHRtbFVzZXJTZWxlY3QnXG4gICAgICAgICAgICAgICAgOiAnJztcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgdW5zZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2UgdW5zZWxlY3RhYmxlXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGUoZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhYnJpYy51dGlsLmZhbHNlRnVuY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3NlbGVjdFByb3BdID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudW5zZWxlY3RhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50LnVuc2VsZWN0YWJsZSA9ICdvbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHNlbGVjdGFibGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbWFrZSBzZWxlY3RhYmxlXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUVsZW1lbnRTZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudW5zZWxlY3RhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50LnVuc2VsZWN0YWJsZSA9ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUgPSBtYWtlRWxlbWVudFVuc2VsZWN0YWJsZTtcbiAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFNlbGVjdGFibGUgPSBtYWtlRWxlbWVudFNlbGVjdGFibGU7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUNhbnZhcyhlbGVtZW50KSB7XG4gICAgdmFyIGltcGwgPSBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlcihlbGVtZW50KTtcbiAgICByZXR1cm4gaW1wbC5fY2FudmFzIHx8IGltcGwuX2ltYWdlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNsZWFuVXBKc2RvbU5vZGUoZWxlbWVudCkge1xuICAgIGlmICghZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW1wbCA9IGZhYnJpYy5qc2RvbUltcGxGb3JXcmFwcGVyKGVsZW1lbnQpO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICBpbXBsLl9pbWFnZSA9IG51bGw7XG4gICAgICBpbXBsLl9jYW52YXMgPSBudWxsO1xuICAgICAgLy8gdW5zdXJlIGlmIG5lY2Vzc2FyeVxuICAgICAgaW1wbC5fY3VycmVudFNyYyA9IG51bGw7XG4gICAgICBpbXBsLl9hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgIGltcGwuX2NsYXNzTGlzdCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB2YWx1ZSkge1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWRcbiAgICAgIHx8IGN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC5vSW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRJbWFnZVNtb290aGluZyBzZXRzIHRoZSBjb250ZXh0IGltYWdlU21vb3RoaW5nRW5hYmxlZCBwcm9wZXJ0eS5cbiAgICogVXNlZCBieSBjYW52YXMgYW5kIGJ5IEltYWdlT2JqZWN0LlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBwYXJhbSB7SFRNTFJlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRvIHNldCBvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHRydWUgb3IgZmFsc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLnNldEltYWdlU21vb3RoaW5nID0gc2V0SW1hZ2VTbW9vdGhpbmc7XG4gIGZhYnJpYy51dGlsLmdldEJ5SWQgPSBnZXRCeUlkO1xuICBmYWJyaWMudXRpbC50b0FycmF5ID0gdG9BcnJheTtcbiAgZmFicmljLnV0aWwuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgZmFicmljLnV0aWwubWFrZUVsZW1lbnQgPSBtYWtlRWxlbWVudDtcbiAgZmFicmljLnV0aWwud3JhcEVsZW1lbnQgPSB3cmFwRWxlbWVudDtcbiAgZmFicmljLnV0aWwuZ2V0U2Nyb2xsTGVmdFRvcCA9IGdldFNjcm9sbExlZnRUb3A7XG4gIGZhYnJpYy51dGlsLmdldEVsZW1lbnRPZmZzZXQgPSBnZXRFbGVtZW50T2Zmc2V0O1xuICBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzID0gZ2V0Tm9kZUNhbnZhcztcbiAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSA9IGNsZWFuVXBKc2RvbU5vZGU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIGFkZFBhcmFtVG9VcmwodXJsLCBwYXJhbSkge1xuICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHBhcmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlGbigpIHsgfVxuXG4gIC8qKlxuICAgKiBDcm9zcy1icm93c2VyIGFic3RyYWN0aW9uIGZvciBzZW5kaW5nIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBzZW5kIFhNTEh0dHBSZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1cIkdFVFwiXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1ldGVyc10gcGFyYW1ldGVycyB0byBhcHBlbmQgdG8gdXJsIGluIEdFVCBvciBpbiBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ib2R5XSBib2R5IHRvIHNlbmQgd2l0aCBQT1NUIG9yIFBVVCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25Db21wbGV0ZSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiByZXF1ZXN0IGlzIGNvbXBsZXRlZFxuICAgKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH0gcmVxdWVzdFxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJyxcbiAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgeGhyID0gbmV3IGZhYnJpYy53aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLnBhcmFtZXRlcnM7XG5cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBvbkNvbXBsZXRlKHhocik7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eUZuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgYm9keSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucGFyYW1ldGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdXJsID0gYWRkUGFyYW1Ub1VybCh1cmwsIG9wdGlvbnMucGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ1BPU1QnIHx8IG1ldGhvZCA9PT0gJ1BVVCcpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSk7XG4gICAgcmV0dXJuIHhocjtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLnJlcXVlc3QgPSByZXF1ZXN0O1xufSkoKTtcblxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLmxvZ2AgKHdoZW4gYXZhaWxhYmxlKVxuICogQHBhcmFtIHsqfSBbdmFsdWVzXSBWYWx1ZXMgdG8gbG9nXG4gKi9cbmZhYnJpYy5sb2cgPSBjb25zb2xlLmxvZztcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgY29uc29sZS53YXJuYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2cgYXMgYSB3YXJuaW5nXG4gKi9cbmZhYnJpYy53YXJuID0gY29uc29sZS53YXJuO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBub29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHZhbHVlIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnRWYWx1ZT0wXSBTdGFydGluZyB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZW5kVmFsdWU9MTAwXSBFbmRpbmcgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ5VmFsdWU9MTAwXSBWYWx1ZSB0byBtb2RpZnkgdGhlIHByb3BlcnR5IGJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbj01MDBdIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmFib3J0XSBBZGRpdGlvbmFsIGZ1bmN0aW9uIHdpdGggbG9naWMuIElmIHJldHVybnMgdHJ1ZSwgb25Db21wbGV0ZSBpcyBjYWxsZWQuXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMpIHtcblxuICAgIHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGltZXN0YW1wIHx8ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCA1MDAsXG4gICAgICAgICAgZmluaXNoID0gc3RhcnQgKyBkdXJhdGlvbiwgdGltZSxcbiAgICAgICAgICBvbkNoYW5nZSA9IG9wdGlvbnMub25DaGFuZ2UgfHwgbm9vcCxcbiAgICAgICAgICBhYm9ydCA9IG9wdGlvbnMuYWJvcnQgfHwgbm9vcCxcbiAgICAgICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlIHx8IG5vb3AsXG4gICAgICAgICAgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgZGVmYXVsdEVhc2luZyxcbiAgICAgICAgICBzdGFydFZhbHVlID0gJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUgOiAwLFxuICAgICAgICAgIGVuZFZhbHVlID0gJ2VuZFZhbHVlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5lbmRWYWx1ZSA6IDEwMCxcbiAgICAgICAgICBieVZhbHVlID0gb3B0aW9ucy5ieVZhbHVlIHx8IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcblxuICAgICAgb3B0aW9ucy5vblN0YXJ0ICYmIG9wdGlvbnMub25TdGFydCgpO1xuXG4gICAgICAoZnVuY3Rpb24gdGljayh0aWNrdGltZSkge1xuICAgICAgICAvLyBUT0RPOiBtb3ZlIGFib3J0IGNhbGwgYWZ0ZXIgY2FsY3VsYXRpb25cbiAgICAgICAgLy8gYW5kIHBhc3MgKGN1cnJlbnQsdmFsdWVQZXJjLCB0aW1lUGVyYykgYXMgYXJndW1lbnRzXG4gICAgICAgIHRpbWUgPSB0aWNrdGltZSB8fCArbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGltZSA+IGZpbmlzaCA/IGR1cmF0aW9uIDogKHRpbWUgLSBzdGFydCksXG4gICAgICAgICAgICB0aW1lUGVyYyA9IGN1cnJlbnRUaW1lIC8gZHVyYXRpb24sXG4gICAgICAgICAgICBjdXJyZW50ID0gZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbiksXG4gICAgICAgICAgICB2YWx1ZVBlcmMgPSBNYXRoLmFicygoY3VycmVudCAtIHN0YXJ0VmFsdWUpIC8gYnlWYWx1ZSk7XG4gICAgICAgIGlmIChhYm9ydCgpKSB7XG4gICAgICAgICAgb25Db21wbGV0ZShlbmRWYWx1ZSwgMSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lID4gZmluaXNoKSB7XG4gICAgICAgICAgb25DaGFuZ2UoZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIG9uQ29tcGxldGUoZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKHRpY2spO1xuICAgICAgICB9XG4gICAgICB9KShzdGFydCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgX3JlcXVlc3RBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWJyaWMud2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgdmFyIF9jYW5jZWxBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGZhYnJpYy53aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG4gIC8qKlxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYmFzZWQgb24gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICogSW4gb3JkZXIgdG8gZ2V0IGEgcHJlY2lzZSBzdGFydCB0aW1lLCBgcmVxdWVzdEFuaW1GcmFtZWAgc2hvdWxkIGJlIGNhbGxlZCBhcyBhbiBlbnRyeSBpbnRvIHRoZSBtZXRob2RcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgb3B0aW9uYWwgRWxlbWVudCB0byBhc3NvY2lhdGUgd2l0aCBhbmltYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0QW5pbUZyYW1lLmFwcGx5KGZhYnJpYy53aW5kb3csIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9jYW5jZWxBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGUgPSBhbmltYXRlO1xuICBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZTtcbiAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lID0gY2FuY2VsQW5pbUZyYW1lO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIENhbGN1bGF0ZSBhbiBpbi1iZXR3ZWVuIGNvbG9yLiBSZXR1cm5zIGEgXCJyZ2JhKClcIiBzdHJpbmcuXG4gIC8vIENyZWRpdDogRWR3aW4gTWFydGluIDxlZHdpbkBiaXRzdG9ybS5vcmc+XG4gIC8vICAgICAgICAgaHR0cDovL3d3dy5iaXRzdG9ybS5vcmcvanF1ZXJ5L2NvbG9yLWFuaW1hdGlvbi9qcXVlcnkuYW5pbWF0ZS1jb2xvcnMuanNcbiAgZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3IoYmVnaW4sIGVuZCwgcG9zKSB7XG4gICAgdmFyIGNvbG9yID0gJ3JnYmEoJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblswXSArIHBvcyAqIChlbmRbMF0gLSBiZWdpblswXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMV0gKyBwb3MgKiAoZW5kWzFdIC0gYmVnaW5bMV0pKSwgMTApICsgJywnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzJdICsgcG9zICogKGVuZFsyXSAtIGJlZ2luWzJdKSksIDEwKTtcblxuICAgIGNvbG9yICs9ICcsJyArIChiZWdpbiAmJiBlbmQgPyBwYXJzZUZsb2F0KGJlZ2luWzNdICsgcG9zICogKGVuZFszXSAtIGJlZ2luWzNdKSkgOiAxKTtcbiAgICBjb2xvciArPSAnKSc7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGNvbG9yIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21Db2xvciBUaGUgc3RhcnRpbmcgY29sb3IgaW4gaGV4IG9yIHJnYihhKSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b0NvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24gb2YgY2hhbmdlIChpbiBtcykuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNvbXBsZXRlXSBDYWxsYmFjazsgaW52b2tlZCB3aGVuIHZhbHVlIGNoYW5nZSBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY29sb3JFYXNpbmddIEVhc2luZyBmdW5jdGlvbi4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gb25seSB0YWtlIHR3byBhcmd1bWVudHMgKGN1cnJlbnRUaW1lLCBkdXJhdGlvbikuIFRodXMgdGhlIHJlZ3VsYXIgYW5pbWF0aW9uIGVhc2luZyBmdW5jdGlvbnMgY2Fubm90IGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmFib3J0XSBBZGRpdGlvbmFsIGZ1bmN0aW9uIHdpdGggbG9naWMuIElmIHJldHVybnMgdHJ1ZSwgb25Db21wbGV0ZSBpcyBjYWxsZWQuXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlQ29sb3IoZnJvbUNvbG9yLCB0b0NvbG9yLCBkdXJhdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBzdGFydENvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihmcm9tQ29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICBlbmRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodG9Db2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgIG9yaWdpbmFsT25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSxcbiAgICAgICAgb3JpZ2luYWxPbkNoYW5nZSA9IG9wdGlvbnMub25DaGFuZ2U7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBmYWJyaWMudXRpbC5hbmltYXRlKGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQob3B0aW9ucywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uIHx8IDUwMCxcbiAgICAgIHN0YXJ0VmFsdWU6IHN0YXJ0Q29sb3IsXG4gICAgICBlbmRWYWx1ZTogZW5kQ29sb3IsXG4gICAgICBieVZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGVhc2luZzogZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgcG9zVmFsdWUgPSBvcHRpb25zLmNvbG9yRWFzaW5nXG4gICAgICAgICAgPyBvcHRpb25zLmNvbG9yRWFzaW5nKGN1cnJlbnRUaW1lLCBkdXJhdGlvbilcbiAgICAgICAgICA6IDEgLSBNYXRoLmNvcyhjdXJyZW50VGltZSAvIGR1cmF0aW9uICogKE1hdGguUEkgLyAyKSk7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcihzdGFydFZhbHVlLCBieVZhbHVlLCBwb3NWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gaGFzIHRvIHRha2UgaW4gYWNjb3VudCBmb3IgY29sb3IgcmVzdG9yaW5nO1xuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYykge1xuICAgICAgICBpZiAob3JpZ2luYWxPbkNvbXBsZXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25Db21wbGV0ZShcbiAgICAgICAgICAgIGNhbGN1bGF0ZUNvbG9yKGVuZENvbG9yLCBlbmRDb2xvciwgMCksXG4gICAgICAgICAgICB2YWx1ZVBlcmMsXG4gICAgICAgICAgICB0aW1lUGVyY1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24oY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYykge1xuICAgICAgICBpZiAob3JpZ2luYWxPbkNoYW5nZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkNoYW5nZShcbiAgICAgICAgICAgICAgY2FsY3VsYXRlQ29sb3IoY3VycmVudCwgY3VycmVudCwgMCksXG4gICAgICAgICAgICAgIHZhbHVlUGVyYyxcbiAgICAgICAgICAgICAgdGltZVBlcmNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9yaWdpbmFsT25DaGFuZ2UoY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5hbmltYXRlQ29sb3IgPSBhbmltYXRlQ29sb3I7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBjLCBwLCBzKSB7XG4gICAgaWYgKGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgYSA9IGM7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9oYW5kbGUgdGhlIDAvMCBjYXNlOlxuICAgICAgaWYgKGMgPT09IDAgJiYgYSA9PT0gMCkge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYTogYSwgYzogYywgcDogcCwgczogcyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZWxhc3RpYyhvcHRzLCB0LCBkKSB7XG4gICAgcmV0dXJuIG9wdHMuYSAqXG4gICAgICBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbiggKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Q3ViaWModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0UXVhcnQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIC1jIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWludGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluUXVpbnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWludGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0ICogdCArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWludGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWludCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluU2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogTWF0aC5jb3ModCAvIGQgKiAoTWF0aC5QSSAvIDIpKSArIGMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zaW4odCAvIGQgKiAoTWF0aC5QSSAvIDIpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jIC8gMiAqIChNYXRoLmNvcyhNYXRoLlBJICogdCAvIGQpIC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluRXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuICh0ID09PSAwKSA/IGIgOiBjICogTWF0aC5wb3coMiwgMTAgKiAodCAvIGQgLSAxKSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRFeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IGQpID8gYiArIGMgOiBjICogKC1NYXRoLnBvdygyLCAtMTAgKiB0IC8gZCkgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgaWYgKHQgPT09IGQpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoLU1hdGgucG93KDIsIC0xMCAqIC0tdCkgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5DaXJjKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiAoTWF0aC5zcXJ0KDEgLSAodCAvPSBkKSAqIHQpIC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDaXJjKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqIE1hdGguc3FydCgxIC0gKHQgPSB0IC8gZCAtIDEpICogdCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRDaXJjKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC1jIC8gMiAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGFzdGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluRWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQ7XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqIDAuMztcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgcmV0dXJuIC1lbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGFzdGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRFbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gb3B0cy5hICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGFzdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRFbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPT09IDIpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqICgwLjMgKiAxLjUpO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogZWxhc3RpYyhvcHRzLCB0LCBkKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiAodCAtPSAxKSkgKlxuICAgICAgTWF0aC5zaW4oKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKSAqIDAuNSArIG9wdHMuYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogKChzICsgMSkgKiB0IC0gcykgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5Cb3VuY2UodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjIC0gZWFzZU91dEJvdW5jZSAoZCAtIHQsIDAsIGMsIGQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Qm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAoKHQgLz0gZCkgPCAoMSAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiB0ICogdCkgKyBiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0IDwgKDIgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAwLjc1KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMi41IC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIDAuOTM3NSkgKyBiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NSkgKyBiO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Qm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAodCA8IGQgLyAyKSB7XG4gICAgICByZXR1cm4gZWFzZUluQm91bmNlICh0ICogMiwgMCwgYywgZCkgKiAwLjUgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gZWFzZU91dEJvdW5jZSh0ICogMiAtIGQsIDAsIGMsIGQpICogMC41ICsgYyAqIDAuNSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWFzaW5nIGZ1bmN0aW9uc1xuICAgKiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9naXptYS5jb20vZWFzaW5nL1wiPkVhc2luZyBFcXVhdGlvbnMgYnkgUm9iZXJ0IFBlbm5lcjwvYT5cbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmYWJyaWMudXRpbC5lYXNlID0ge1xuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluUXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIG91dFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgdCAvPSAoZCAvIDIpO1xuICAgICAgaWYgKHQgPCAxKSB7XG4gICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtYyAvIDIgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDdWJpYyBlYXNpbmcgaW5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKyBiO1xuICAgIH0sXG5cbiAgICBlYXNlT3V0Q3ViaWM6IGVhc2VPdXRDdWJpYyxcbiAgICBlYXNlSW5PdXRDdWJpYzogZWFzZUluT3V0Q3ViaWMsXG4gICAgZWFzZUluUXVhcnQ6IGVhc2VJblF1YXJ0LFxuICAgIGVhc2VPdXRRdWFydDogZWFzZU91dFF1YXJ0LFxuICAgIGVhc2VJbk91dFF1YXJ0OiBlYXNlSW5PdXRRdWFydCxcbiAgICBlYXNlSW5RdWludDogZWFzZUluUXVpbnQsXG4gICAgZWFzZU91dFF1aW50OiBlYXNlT3V0UXVpbnQsXG4gICAgZWFzZUluT3V0UXVpbnQ6IGVhc2VJbk91dFF1aW50LFxuICAgIGVhc2VJblNpbmU6IGVhc2VJblNpbmUsXG4gICAgZWFzZU91dFNpbmU6IGVhc2VPdXRTaW5lLFxuICAgIGVhc2VJbk91dFNpbmU6IGVhc2VJbk91dFNpbmUsXG4gICAgZWFzZUluRXhwbzogZWFzZUluRXhwbyxcbiAgICBlYXNlT3V0RXhwbzogZWFzZU91dEV4cG8sXG4gICAgZWFzZUluT3V0RXhwbzogZWFzZUluT3V0RXhwbyxcbiAgICBlYXNlSW5DaXJjOiBlYXNlSW5DaXJjLFxuICAgIGVhc2VPdXRDaXJjOiBlYXNlT3V0Q2lyYyxcbiAgICBlYXNlSW5PdXRDaXJjOiBlYXNlSW5PdXRDaXJjLFxuICAgIGVhc2VJbkVsYXN0aWM6IGVhc2VJbkVsYXN0aWMsXG4gICAgZWFzZU91dEVsYXN0aWM6IGVhc2VPdXRFbGFzdGljLFxuICAgIGVhc2VJbk91dEVsYXN0aWM6IGVhc2VJbk91dEVsYXN0aWMsXG4gICAgZWFzZUluQmFjazogZWFzZUluQmFjayxcbiAgICBlYXNlT3V0QmFjazogZWFzZU91dEJhY2ssXG4gICAgZWFzZUluT3V0QmFjazogZWFzZUluT3V0QmFjayxcbiAgICBlYXNlSW5Cb3VuY2U6IGVhc2VJbkJvdW5jZSxcbiAgICBlYXNlT3V0Qm91bmNlOiBlYXNlT3V0Qm91bmNlLFxuICAgIGVhc2VJbk91dEJvdW5jZTogZWFzZUluT3V0Qm91bmNlXG4gIH07XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQG5hbWUgZmFicmljXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBwYXJzZVVuaXQgPSBmYWJyaWMudXRpbC5wYXJzZVVuaXQsXG4gICAgICBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcblxuICAgICAgc3ZnVmFsaWRUYWdOYW1lcyA9IFsncGF0aCcsICdjaXJjbGUnLCAncG9seWdvbicsICdwb2x5bGluZScsICdlbGxpcHNlJywgJ3JlY3QnLCAnbGluZScsXG4gICAgICAgICdpbWFnZScsICd0ZXh0J10sXG4gICAgICBzdmdWaWV3Qm94RWxlbWVudHMgPSBbJ3N5bWJvbCcsICdpbWFnZScsICdtYXJrZXInLCAncGF0dGVybicsICd2aWV3JywgJ3N2ZyddLFxuICAgICAgc3ZnSW52YWxpZEFuY2VzdG9ycyA9IFsncGF0dGVybicsICdkZWZzJywgJ3N5bWJvbCcsICdtZXRhZGF0YScsICdjbGlwUGF0aCcsICdtYXNrJywgJ2Rlc2MnXSxcbiAgICAgIHN2Z1ZhbGlkUGFyZW50cyA9IFsnc3ltYm9sJywgJ2cnLCAnYScsICdzdmcnLCAnY2xpcFBhdGgnLCAnZGVmcyddLFxuXG4gICAgICBhdHRyaWJ1dGVzTWFwID0ge1xuICAgICAgICBjeDogICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICB4OiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICByOiAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cycsXG4gICAgICAgIGN5OiAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgeTogICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICBkaXNwbGF5OiAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB2aXNpYmlsaXR5OiAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB0cmFuc2Zvcm06ICAgICAgICAgICAgJ3RyYW5zZm9ybU1hdHJpeCcsXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiAgICAgICAnZmlsbE9wYWNpdHknLFxuICAgICAgICAnZmlsbC1ydWxlJzogICAgICAgICAgJ2ZpbGxSdWxlJyxcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JzogICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6ICAgICAgICAgICdmb250U2l6ZScsXG4gICAgICAgICdmb250LXN0eWxlJzogICAgICAgICAnZm9udFN0eWxlJyxcbiAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogICAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICAgJ2xldHRlci1zcGFjaW5nJzogICAgICdjaGFyU3BhY2luZycsXG4gICAgICAgICdwYWludC1vcmRlcic6ICAgICAgICAncGFpbnRGaXJzdCcsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogICAnc3Ryb2tlRGFzaEFycmF5JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogICdzdHJva2VEYXNoT2Zmc2V0JyxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogICAgICdzdHJva2VMaW5lQ2FwJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbic6ICAgICdzdHJva2VMaW5lSm9pbicsXG4gICAgICAgICdzdHJva2UtbWl0ZXJsaW1pdCc6ICAnc3Ryb2tlTWl0ZXJMaW1pdCcsXG4gICAgICAgICdzdHJva2Utb3BhY2l0eSc6ICAgICAnc3Ryb2tlT3BhY2l0eScsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAgICAgICAnc3Ryb2tlV2lkdGgnLFxuICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogICAgJ3RleHREZWNvcmF0aW9uJyxcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogICAgICAgICd0ZXh0QW5jaG9yJyxcbiAgICAgICAgb3BhY2l0eTogICAgICAgICAgICAgICdvcGFjaXR5JyxcbiAgICAgICAgJ2NsaXAtcGF0aCc6ICAgICAgICAgICdjbGlwUGF0aCcsXG4gICAgICAgICdjbGlwLXJ1bGUnOiAgICAgICAgICAnY2xpcFJ1bGUnLFxuICAgICAgICAndmVjdG9yLWVmZmVjdCc6ICAgICAgJ3N0cm9rZVVuaWZvcm0nLFxuICAgICAgICAnaW1hZ2UtcmVuZGVyaW5nJzogICAgJ2ltYWdlU21vb3RoaW5nJyxcbiAgICAgIH0sXG5cbiAgICAgIGNvbG9yQXR0cmlidXRlcyA9IHtcbiAgICAgICAgc3Ryb2tlOiAnc3Ryb2tlT3BhY2l0eScsXG4gICAgICAgIGZpbGw6ICAgJ2ZpbGxPcGFjaXR5J1xuICAgICAgfSxcblxuICAgICAgZlNpemUgPSAnZm9udC1zaXplJywgY1BhdGggPSAnY2xpcC1wYXRoJztcblxuICBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRUYWdOYW1lcyk7XG4gIGZhYnJpYy5zdmdWaWV3Qm94RWxlbWVudHNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZpZXdCb3hFbGVtZW50cyk7XG4gIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXggPSBnZXRTdmdSZWdleChzdmdJbnZhbGlkQW5jZXN0b3JzKTtcbiAgZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRQYXJlbnRzKTtcblxuICBmYWJyaWMuY3NzUnVsZXMgPSB7IH07XG4gIGZhYnJpYy5ncmFkaWVudERlZnMgPSB7IH07XG4gIGZhYnJpYy5jbGlwUGF0aHMgPSB7IH07XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXR0cihhdHRyKSB7XG4gICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBuYW1lc1xuICAgIGlmIChhdHRyIGluIGF0dHJpYnV0ZXNNYXApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzTWFwW2F0dHJdO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKGF0dHIsIHZhbHVlLCBwYXJlbnRBdHRyaWJ1dGVzLCBmb250U2l6ZSkge1xuICAgIHZhciBpc0FycmF5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgICAgcGFyc2VkO1xuXG4gICAgaWYgKChhdHRyID09PSAnZmlsbCcgfHwgYXR0ciA9PT0gJ3N0cm9rZScpICYmIHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VVbmlmb3JtJykge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gJ25vbi1zY2FsaW5nLXN0cm9rZScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnc3Ryb2tlRGFzaEFycmF5Jykge1xuICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLC9nLCAnICcpLnNwbGl0KC9cXHMrLykubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndHJhbnNmb3JtTWF0cml4Jykge1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFsdWUgPSBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4LCBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd2aXNpYmxlJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gJ25vbmUnICYmIHZhbHVlICE9PSAnaGlkZGVuJztcbiAgICAgIC8vIGRpc3BsYXk9bm9uZSBvbiBwYXJlbnQgZWxlbWVudCBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNoaWxkIGVsZW1lbnRcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ29wYWNpdHknKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgdHlwZW9mIHBhcmVudEF0dHJpYnV0ZXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgKj0gcGFyZW50QXR0cmlidXRlcy5vcGFjaXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndGV4dEFuY2hvcicgLyogdGV4dC1hbmNob3IgKi8pIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdzdGFydCcgPyAnbGVmdCcgOiB2YWx1ZSA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdjaGFyU3BhY2luZycpIHtcbiAgICAgIC8vIHBhcnNlVW5pdCByZXR1cm5zIHB4IGFuZCB3ZSBjb252ZXJ0IGl0IHRvIGVtXG4gICAgICBwYXJzZWQgPSBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKSAvIGZvbnRTaXplICogMTAwMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3BhaW50Rmlyc3QnKSB7XG4gICAgICB2YXIgZmlsbEluZGV4ID0gdmFsdWUuaW5kZXhPZignZmlsbCcpO1xuICAgICAgdmFyIHN0cm9rZUluZGV4ID0gdmFsdWUuaW5kZXhPZignc3Ryb2tlJyk7XG4gICAgICB2YXIgdmFsdWUgPSAnZmlsbCc7XG4gICAgICBpZiAoZmlsbEluZGV4ID4gLTEgJiYgc3Ryb2tlSW5kZXggPiAtMSAmJiBzdHJva2VJbmRleCA8IGZpbGxJbmRleCkge1xuICAgICAgICB2YWx1ZSA9ICdzdHJva2UnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmlsbEluZGV4ID09PSAtMSAmJiBzdHJva2VJbmRleCA+IC0xKSB7XG4gICAgICAgIHZhbHVlID0gJ3N0cm9rZSc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdocmVmJyB8fCBhdHRyID09PSAneGxpbms6aHJlZicgfHwgYXR0ciA9PT0gJ2ZvbnQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdpbWFnZVNtb290aGluZycpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT09ICdvcHRpbWl6ZVF1YWxpdHknKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWQgPSBpc0FycmF5ID8gdmFsdWUubWFwKHBhcnNlVW5pdCkgOiBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCFpc0FycmF5ICYmIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZCk7XG4gIH1cblxuICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3ZnUmVnZXgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIGFyci5qb2luKCd8JykgKyAnKVxcXFxiJywgJ2knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0U3Ryb2tlRmlsbE9wYWNpdHkoYXR0cmlidXRlcykge1xuICAgIGZvciAodmFyIGF0dHIgaW4gY29sb3JBdHRyaWJ1dGVzKSB7XG5cbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dID09PSAndW5kZWZpbmVkJyB8fCBhdHRyaWJ1dGVzW2F0dHJdID09PSAnJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2F0dHJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlc1thdHRyXS5pbmRleE9mKCd1cmwoJykgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gY29sb3Iuc2V0QWxwaGEodG9GaXhlZChjb2xvci5nZXRBbHBoYSgpICogYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dLCAyKSkudG9SZ2JhKCk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIG5vZGVOYW1lcykge1xuICAgIHZhciBub2RlTmFtZSwgbm9kZUFycmF5ID0gW10sIG5vZGVMaXN0LCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gbm9kZU5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlTmFtZSA9IG5vZGVOYW1lc1tpXTtcbiAgICAgIG5vZGVMaXN0ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5vZGVOYW1lKTtcbiAgICAgIG5vZGVBcnJheSA9IG5vZGVBcnJheS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVBcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlVmFsdWUgU3RyaW5nIGNvbnRhaW5pbmcgYXR0cmlidXRlIHZhbHVlXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiA2IGVsZW1lbnRzIHJlcHJlc2VudGluZyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICovXG4gIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgY29zID0gZmFicmljLnV0aWwuY29zKGFyZ3NbMF0pLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4oYXJnc1swXSksXG4gICAgICAgICAgeCA9IDAsIHkgPSAwO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHggPSBhcmdzWzFdO1xuICAgICAgICB5ID0gYXJnc1syXTtcbiAgICAgIH1cblxuICAgICAgbWF0cml4WzBdID0gY29zO1xuICAgICAgbWF0cml4WzFdID0gc2luO1xuICAgICAgbWF0cml4WzJdID0gLXNpbjtcbiAgICAgIG1hdHJpeFszXSA9IGNvcztcbiAgICAgIG1hdHJpeFs0XSA9IHggLSAoY29zICogeCAtIHNpbiAqIHkpO1xuICAgICAgbWF0cml4WzVdID0geSAtIChzaW4gKiB4ICsgY29zICogeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgbXVsdGlwbGllclggPSBhcmdzWzBdLFxuICAgICAgICAgIG11bHRpcGxpZXJZID0gKGFyZ3MubGVuZ3RoID09PSAyKSA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuXG4gICAgICBtYXRyaXhbMF0gPSBtdWx0aXBsaWVyWDtcbiAgICAgIG1hdHJpeFszXSA9IG11bHRpcGxpZXJZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCBwb3MpIHtcbiAgICAgIG1hdHJpeFtwb3NdID0gTWF0aC50YW4oZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhhcmdzWzBdKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncykge1xuICAgICAgbWF0cml4WzRdID0gYXJnc1swXTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtYXRyaXhbNV0gPSBhcmdzWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlkZW50aXR5IG1hdHJpeFxuICAgIHZhciBpTWF0cml4ID0gZmFicmljLmlNYXRyaXgsXG5cbiAgICAgICAgLy8gPT0gYmVnaW4gdHJhbnNmb3JtIHJlZ2V4cFxuICAgICAgICBudW1iZXIgPSBmYWJyaWMucmVOdW0sXG5cbiAgICAgICAgY29tbWFXc3AgPSBmYWJyaWMuY29tbWFXc3AsXG5cbiAgICAgICAgc2tld1ggPSAnKD86KHNrZXdYKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2tld1kgPSAnKD86KHNrZXdZKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgcm90YXRlID0gJyg/Oihyb3RhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBzY2FsZSA9ICcoPzooc2NhbGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNsYXRlID0gJyg/Oih0cmFuc2xhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgbWF0cml4ID0gJyg/OihtYXRyaXgpXFxcXHMqXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAnXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICB0cmFuc2Zvcm0gPSAnKD86JyArXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1ggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBza2V3WSArXG4gICAgICAgICAgICAgICAgICAgICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1zID0gJyg/OicgKyB0cmFuc2Zvcm0gKyAnKD86JyArIGNvbW1hV3NwICsgJyonICsgdHJhbnNmb3JtICsgJykqJyArICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1MaXN0ID0gJ15cXFxccyooPzonICsgdHJhbnNmb3JtcyArICc/KVxcXFxzKiQnLFxuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNUcmFuc2Zvcm1BdHRyaWJ1dGVcbiAgICAgICAgcmVUcmFuc2Zvcm1MaXN0ID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm1MaXN0KSxcbiAgICAgICAgLy8gPT0gZW5kIHRyYW5zZm9ybSByZWdleHBcblxuICAgICAgICByZVRyYW5zZm9ybSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtLCAnZycpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG5cbiAgICAgIC8vIHN0YXJ0IHdpdGggaWRlbnRpdHkgbWF0cml4XG4gICAgICB2YXIgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKSxcbiAgICAgICAgICBtYXRyaWNlcyA9IFtdO1xuXG4gICAgICAvLyByZXR1cm4gaWYgbm8gYXJndW1lbnQgd2FzIGdpdmVuIG9yXG4gICAgICAvLyBhbiBhcmd1bWVudCBkb2VzIG5vdCBtYXRjaCB0cmFuc2Zvcm0gYXR0cmlidXRlIHJlZ2V4cFxuICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAoYXR0cmlidXRlVmFsdWUgJiYgIXJlVHJhbnNmb3JtTGlzdC50ZXN0KGF0dHJpYnV0ZVZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlVmFsdWUucmVwbGFjZShyZVRyYW5zZm9ybSwgZnVuY3Rpb24obWF0Y2gpIHtcblxuICAgICAgICB2YXIgbSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtKS5leGVjKG1hdGNoKS5maWx0ZXIoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIG1hdGNoICE9PSAnJyAmJiBtYXRjaCAhPSBudWxsXG4gICAgICAgICAgICAgIHJldHVybiAoISFtYXRjaCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IG1bMV0sXG4gICAgICAgICAgICBhcmdzID0gbS5zbGljZSgyKS5tYXAocGFyc2VGbG9hdCk7XG5cbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgYXJnc1swXSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoYXJnc1swXSk7XG4gICAgICAgICAgICByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgIHNjYWxlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgICBza2V3TWF0cml4KG1hdHJpeCwgYXJncywgMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdza2V3WSc6XG4gICAgICAgICAgICBza2V3TWF0cml4KG1hdHJpeCwgYXJncywgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgbWF0cml4ID0gYXJncztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc25hcHNob3QgY3VycmVudCBtYXRyaXggaW50byBtYXRyaWNlcyBhcnJheVxuICAgICAgICBtYXRyaWNlcy5wdXNoKG1hdHJpeC5jb25jYXQoKSk7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNvbWJpbmVkTWF0cml4ID0gbWF0cmljZXNbMF07XG4gICAgICB3aGlsZSAobWF0cmljZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBtYXRyaWNlcy5zaGlmdCgpO1xuICAgICAgICBjb21iaW5lZE1hdHJpeCA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoY29tYmluZWRNYXRyaXgsIG1hdHJpY2VzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZE1hdHJpeDtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZVN0cmluZyhzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIHN0eWxlLnJlcGxhY2UoLztcXHMqJC8sICcnKS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB2YXIgcGFpciA9IGNodW5rLnNwbGl0KCc6Jyk7XG5cbiAgICAgIGF0dHIgPSBwYWlyWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSAgcGFpclsxXS50cmltKCk7XG5cbiAgICAgIG9TdHlsZVthdHRyXSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0eWxlT2JqZWN0KHN0eWxlLCBvU3R5bGUpIHtcbiAgICB2YXIgYXR0ciwgdmFsdWU7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHlsZVtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGF0dHIgPSBwcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQoZWxlbWVudCwgc3ZnVWlkKSB7XG4gICAgdmFyIHN0eWxlcyA9IHsgfTtcbiAgICBmb3IgKHZhciBydWxlIGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdKSB7XG4gICAgICBpZiAoZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHJ1bGUuc3BsaXQoJyAnKSkpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV0pIHtcbiAgICAgICAgICBzdHlsZXNbcHJvcGVydHldID0gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV1bcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgZmlyc3RNYXRjaGluZywgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIC8vc3RhcnQgZnJvbSByaWdodG1vc3Qgc2VsZWN0b3IuXG4gICAgZmlyc3RNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcnMucG9wKCkpO1xuICAgIGlmIChmaXJzdE1hdGNoaW5nICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RNYXRjaGluZyAmJiBwYXJlbnRNYXRjaGluZyAmJiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCk7XG4gIH1cblxuICBmdW5jdGlvbiBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBzZWxlY3RvciwgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIGlmIChwYXJlbnRNYXRjaGluZykge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9ycy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLFxuICAgICAgICBjbGFzc05hbWVzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksXG4gICAgICAgIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyksIG1hdGNoZXIsIGk7XG4gICAgLy8gaSBjaGVjayBpZiBhIHNlbGVjdG9yIG1hdGNoZXMgc2xpY2luZyBhd2F5IHBhcnQgZnJvbSBpdC5cbiAgICAvLyBpZiBpIGdldCBlbXB0eSBzdHJpbmcgaSBzaG91bGQgbWF0Y2hcbiAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXicgKyBub2RlTmFtZSwgJ2knKTtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIGlmIChpZCAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCcjJyArIGlkICsgJyg/IVthLXpBLVpcXFxcLV0rKScsICdpJyk7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKGkgPSBjbGFzc05hbWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXFxcXC4nICsgY2xhc3NOYW1lc1tpXSArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3IubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRvIHN1cHBvcnQgSUU4IG1pc3NpbmcgZ2V0RWxlbWVudEJ5SWQgb24gU1ZHZG9jdW1lbnQgYW5kIG9uIG5vZGUgeG1sRE9NXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50QnlJZChkb2MsIGlkKSB7XG4gICAgdmFyIGVsO1xuICAgIGRvYy5nZXRFbGVtZW50QnlJZCAmJiAoZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgdmFyIG5vZGUsIGksIGxlbiwgbm9kZWxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVsaXN0W2ldO1xuICAgICAgaWYgKGlkID09PSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpIHtcbiAgICB2YXIgbm9kZWxpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIFsndXNlJywgJ3N2Zzp1c2UnXSksIGkgPSAwO1xuICAgIHdoaWxlIChub2RlbGlzdC5sZW5ndGggJiYgaSA8IG5vZGVsaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGVsID0gbm9kZWxpc3RbaV0sXG4gICAgICAgICAgeGxpbmsgPSAoZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykgfHwgZWwuZ2V0QXR0cmlidXRlKCdocmVmJykpLnN1YnN0cigxKSxcbiAgICAgICAgICB4ID0gZWwuZ2V0QXR0cmlidXRlKCd4JykgfHwgMCxcbiAgICAgICAgICB5ID0gZWwuZ2V0QXR0cmlidXRlKCd5JykgfHwgMCxcbiAgICAgICAgICBlbDIgPSBlbGVtZW50QnlJZChkb2MsIHhsaW5rKS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgY3VycmVudFRyYW5zID0gKGVsMi5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArICcgdHJhbnNsYXRlKCcgKyB4ICsgJywgJyArIHkgKyAnKScsXG4gICAgICAgICAgcGFyZW50Tm9kZSwgb2xkTGVuZ3RoID0gbm9kZWxpc3QubGVuZ3RoLCBhdHRyLCBqLCBhdHRycywgbGVuLCBuYW1lc3BhY2UgPSBmYWJyaWMuc3ZnTlM7XG5cbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbDIpO1xuICAgICAgaWYgKC9ec3ZnJC9pLnRlc3QoZWwyLm5vZGVOYW1lKSkge1xuICAgICAgICB2YXIgZWwzID0gZWwyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgJ2cnKTtcbiAgICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbDIuYXR0cmlidXRlcywgbGVuID0gYXR0cnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgICBlbDMuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyLm5vZGVOYW1lLCBhdHRyLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWwyLmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgICB3aGlsZSAoZWwyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBlbDMuYXBwZW5kQ2hpbGQoZWwyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsMiA9IGVsMztcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzLCBsZW4gPSBhdHRycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgaWYgKGF0dHIubm9kZU5hbWUgPT09ICd4JyB8fCBhdHRyLm5vZGVOYW1lID09PSAneScgfHxcbiAgICAgICAgICBhdHRyLm5vZGVOYW1lID09PSAneGxpbms6aHJlZicgfHwgYXR0ci5ub2RlTmFtZSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnMgPSBhdHRyLm5vZGVWYWx1ZSArICcgJyArIGN1cnJlbnRUcmFucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbDIuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBjdXJyZW50VHJhbnMpO1xuICAgICAgZWwyLnNldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScsICcxJyk7XG4gICAgICBlbDIucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbDIsIGVsKTtcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgZG8gbm90IHNob3J0ZW4gbm9kZWxpc3QgYWZ0ZXIgcmVwbGFjZUNoaWxkIChJRTgpXG4gICAgICBpZiAobm9kZWxpc3QubGVuZ3RoID09PSBvbGRMZW5ndGgpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNWaWV3Qm94QXR0cmlidXRlXG4gIC8vIG1hdGNoZXMsIGUuZy46ICsxNC41NmUtMTIsIGV0Yy5cbiAgdmFyIHJlVmlld0JveEF0dHJWYWx1ZSA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyonICtcbiAgICAnJCdcbiAgKTtcblxuICAvKipcbiAgICogQWRkIGEgPGc+IGVsZW1lbnQgdGhhdCBlbnZlbG9wIGFsbCBjaGlsZCBlbGVtZW50cyBhbmQgbWFrZXMgdGhlIHZpZXdib3ggdHJhbnNmb3JtTWF0cml4IGRlc2NlbmQgb24gYWxsIGVsZW1lbnRzXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWxlbWVudCkge1xuICAgIGlmICghZmFicmljLnN2Z1ZpZXdCb3hFbGVtZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHZpZXdCb3hBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSxcbiAgICAgICAgc2NhbGVYID0gMSxcbiAgICAgICAgc2NhbGVZID0gMSxcbiAgICAgICAgbWluWCA9IDAsXG4gICAgICAgIG1pblkgPSAwLFxuICAgICAgICB2aWV3Qm94V2lkdGgsIHZpZXdCb3hIZWlnaHQsIG1hdHJpeCwgZWwsXG4gICAgICAgIHdpZHRoQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICBoZWlnaHRBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICB4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwLFxuICAgICAgICB5ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLFxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKSB8fCAnJyxcbiAgICAgICAgbWlzc2luZ1ZpZXdCb3ggPSAoIXZpZXdCb3hBdHRyIHx8ICEodmlld0JveEF0dHIgPSB2aWV3Qm94QXR0ci5tYXRjaChyZVZpZXdCb3hBdHRyVmFsdWUpKSksXG4gICAgICAgIG1pc3NpbmdEaW1BdHRyID0gKCF3aWR0aEF0dHIgfHwgIWhlaWdodEF0dHIgfHwgd2lkdGhBdHRyID09PSAnMTAwJScgfHwgaGVpZ2h0QXR0ciA9PT0gJzEwMCUnKSxcbiAgICAgICAgdG9CZVBhcnNlZCA9IG1pc3NpbmdWaWV3Qm94ICYmIG1pc3NpbmdEaW1BdHRyLFxuICAgICAgICBwYXJzZWREaW0gPSB7IH0sIHRyYW5zbGF0ZU1hdHJpeCA9ICcnLCB3aWR0aERpZmYgPSAwLCBoZWlnaHREaWZmID0gMDtcblxuICAgIHBhcnNlZERpbS53aWR0aCA9IDA7XG4gICAgcGFyc2VkRGltLmhlaWdodCA9IDA7XG4gICAgcGFyc2VkRGltLnRvQmVQYXJzZWQgPSB0b0JlUGFyc2VkO1xuXG4gICAgaWYgKG1pc3NpbmdWaWV3Qm94KSB7XG4gICAgICBpZiAoKCh4IHx8IHkpICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudCcpKSB7XG4gICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgICAgICBtYXRyaXggPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArIHRyYW5zbGF0ZU1hdHJpeDtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1hdHJpeCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvQmVQYXJzZWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdWaWV3Qm94KSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICAvLyBzZXQgYSB0cmFuc2Zvcm0gZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB4IHkgYW5kIGFyZSBpbm5lcihvbmx5KSBTVkdzXG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cbiAgICBtaW5YID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMV0pO1xuICAgIG1pblkgPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsyXSk7XG4gICAgdmlld0JveFdpZHRoID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0clszXSk7XG4gICAgdmlld0JveEhlaWdodCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbNF0pO1xuICAgIHBhcnNlZERpbS5taW5YID0gbWluWDtcbiAgICBwYXJzZWREaW0ubWluWSA9IG1pblk7XG4gICAgcGFyc2VkRGltLnZpZXdCb3hXaWR0aCA9IHZpZXdCb3hXaWR0aDtcbiAgICBwYXJzZWREaW0udmlld0JveEhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgaWYgKCFtaXNzaW5nRGltQXR0cikge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgc2NhbGVYID0gcGFyc2VkRGltLndpZHRoIC8gdmlld0JveFdpZHRoO1xuICAgICAgc2NhbGVZID0gcGFyc2VkRGltLmhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gdmlld0JveFdpZHRoO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBpcyB0byBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW9cbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCAhPT0gJ25vbmUnKSB7XG4gICAgICAvL3RyYW5zbGF0ZSBhbGwgY29udGFpbmVyIGZvciB0aGUgZWZmZWN0IG9mIE1pZCwgTWluLCBNYXhcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWSA6IHNjYWxlWCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVggOiBzY2FsZVkpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICB3aWR0aERpZmYgPSBwYXJzZWREaW0ud2lkdGggLSB2aWV3Qm94V2lkdGggKiBzY2FsZVg7XG4gICAgICBoZWlnaHREaWZmID0gcGFyc2VkRGltLmhlaWdodCAtIHZpZXdCb3hIZWlnaHQgKiBzY2FsZVg7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgIHdpZHRoRGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICBoZWlnaHREaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgIHdpZHRoRGlmZiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgIGhlaWdodERpZmYgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxICYmIG1pblggPT09IDAgJiYgbWluWSA9PT0gMCAmJiB4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuICAgIGlmICgoeCB8fCB5KSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQnKSB7XG4gICAgICB0cmFuc2xhdGVNYXRyaXggPSAnIHRyYW5zbGF0ZSgnICsgcGFyc2VVbml0KHgpICsgJyAnICsgcGFyc2VVbml0KHkpICsgJykgJztcbiAgICB9XG5cbiAgICBtYXRyaXggPSB0cmFuc2xhdGVNYXRyaXggKyAnIG1hdHJpeCgnICsgc2NhbGVYICtcbiAgICAgICAgICAgICAgICAgICcgMCcgK1xuICAgICAgICAgICAgICAgICAgJyAwICcgK1xuICAgICAgICAgICAgICAgICAgc2NhbGVZICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5YICogc2NhbGVYICsgd2lkdGhEaWZmKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWSAqIHNjYWxlWSArIGhlaWdodERpZmYpICsgJykgJztcbiAgICAvLyBzZWVtcyB1bnVzZWQuXG4gICAgLy8gcGFyc2VkRGltLnZpZXdib3hUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUobWF0cml4KTtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGVsID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmYWJyaWMuc3ZnTlMsICdnJyk7XG4gICAgICAvLyBlbGVtZW50LmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWwgPSBlbGVtZW50O1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3knKTtcbiAgICAgIG1hdHJpeCA9IGVsLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgKyBtYXRyaXg7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICByZXR1cm4gcGFyc2VkRGltO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWxlbWVudCwgbm9kZU5hbWUpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIGNvbnZlcnRzIGl0IHRvIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzIGFuZCBwYXNzZXMgdGhlbSB0byBhIGNhbGxiYWNrXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIHdoZW4gcGFyc2luZyBpcyBmaW5pc2hlZDtcbiAgICogSXQncyBiZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZWxlbWVudHMgKHBhcnNlZCBmcm9tIGEgZG9jdW1lbnQpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2luZ09wdGlvbnNdIG9wdGlvbnMgZm9yIHBhcnNpbmcgZG9jdW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gc2V0dGluZ3NcbiAgICovXG4gIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jLCBjYWxsYmFjaywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpO1xuXG4gICAgdmFyIHN2Z1VpZCA9ICBmYWJyaWMuT2JqZWN0Ll9fdWlkKyssIGksIGxlbixcbiAgICAgICAgb3B0aW9ucyA9IGFwcGx5Vmlld2JveFRyYW5zZm9ybShkb2MpLFxuICAgICAgICBkZXNjZW5kYW50cyA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBwYXJzaW5nT3B0aW9ucyAmJiBwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICBvcHRpb25zLnN2Z1VpZCA9IHN2Z1VpZDtcblxuICAgIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDAgJiYgZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgLy8gd2UncmUgbGlrZWx5IGluIG5vZGUsIHdoZXJlIFwibzMteG1sXCIgbGlicmFyeSBmYWlscyB0byBnRUJUTihcIipcIilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL25vZGUtbzMteG1sL2lzc3Vlcy8yMVxuICAgICAgZGVzY2VuZGFudHMgPSBkb2Muc2VsZWN0Tm9kZXMoJy8vKltuYW1lKC4pIT1cInN2Z1wiXScpO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gZGVzY2VuZGFudHNbaV07XG4gICAgICB9XG4gICAgICBkZXNjZW5kYW50cyA9IGFycjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbCk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpICYmXG4gICAgICAgICAgICAhaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWwsIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXgpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICB9KTtcbiAgICBpZiAoIWVsZW1lbnRzIHx8IChlbGVtZW50cyAmJiAhZWxlbWVudHMubGVuZ3RoKSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soW10sIHt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNsaXBQYXRocyA9IHsgfTtcbiAgICBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpID09PSAnY2xpcFBhdGgnO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgIGNsaXBQYXRoc1tpZF0gPSBmYWJyaWMudXRpbC50b0FycmF5KGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdID0gZmFicmljLmdldEdyYWRpZW50RGVmcyhkb2MpO1xuICAgIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdID0gZmFicmljLmdldENTU1J1bGVzKGRvYyk7XG4gICAgZmFicmljLmNsaXBQYXRoc1tzdmdVaWRdID0gY2xpcFBhdGhzO1xuICAgIC8vIFByZWNlZGVuY2Ugb2YgcnVsZXM6ICAgc3R5bGUgPiBjbGFzcyA+IGF0dHJpYnV0ZVxuICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMsIGVsZW1lbnRzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaW5zdGFuY2VzLCBvcHRpb25zLCBlbGVtZW50cywgZGVzY2VuZGFudHMpO1xuICAgICAgICBkZWxldGUgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdO1xuICAgICAgICBkZWxldGUgZmFicmljLmNzc1J1bGVzW3N2Z1VpZF07XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2xpcFBhdGhzW3N2Z1VpZF07XG4gICAgICB9XG4gICAgfSwgY2xvbmUob3B0aW9ucyksIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCBncmFkaWVudCkge1xuICAgIHZhciBncmFkaWVudHNBdHRycyA9IFsnZ3JhZGllbnRUcmFuc2Zvcm0nLCAneDEnLCAneDInLCAneTEnLCAneTInLCAnZ3JhZGllbnRVbml0cycsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5J10sXG4gICAgICAgIHhsaW5rQXR0ciA9ICd4bGluazpocmVmJyxcbiAgICAgICAgeExpbmsgPSBncmFkaWVudC5nZXRBdHRyaWJ1dGUoeGxpbmtBdHRyKS5zdWJzdHIoMSksXG4gICAgICAgIHJlZmVyZW5jZWRHcmFkaWVudCA9IGVsZW1lbnRCeUlkKGRvYywgeExpbmspO1xuICAgIGlmIChyZWZlcmVuY2VkR3JhZGllbnQgJiYgcmVmZXJlbmNlZEdyYWRpZW50LmdldEF0dHJpYnV0ZSh4bGlua0F0dHIpKSB7XG4gICAgICByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCByZWZlcmVuY2VkR3JhZGllbnQpO1xuICAgIH1cbiAgICBncmFkaWVudHNBdHRycy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VkR3JhZGllbnQgJiYgIWdyYWRpZW50Lmhhc0F0dHJpYnV0ZShhdHRyKSAmJiByZWZlcmVuY2VkR3JhZGllbnQuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZShhdHRyLCByZWZlcmVuY2VkR3JhZGllbnQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWdyYWRpZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIHJlZmVyZW5jZUNsb25lID0gcmVmZXJlbmNlZEdyYWRpZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHdoaWxlIChyZWZlcmVuY2VDbG9uZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGdyYWRpZW50LmFwcGVuZENoaWxkKHJlZmVyZW5jZUNsb25lLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBncmFkaWVudC5yZW1vdmVBdHRyaWJ1dGUoeGxpbmtBdHRyKTtcbiAgfVxuXG4gIHZhciByZUZvbnREZWNsYXJhdGlvbiA9IG5ldyBSZWdFeHAoXG4gICAgJyhub3JtYWx8aXRhbGljKT9cXFxccyoobm9ybWFsfHNtYWxsLWNhcHMpP1xcXFxzKicgK1xuICAgICcobm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDApP1xcXFxzKignICtcbiAgICAgIGZhYnJpYy5yZU51bSArXG4gICAgJyg/OnB4fGNtfG1tfGVtfHB0fHBjfGluKSopKD86XFxcXC8obm9ybWFsfCcgKyBmYWJyaWMucmVOdW0gKyAnKSk/XFxcXHMrKC4qKScpO1xuXG4gIGV4dGVuZChmYWJyaWMsIHtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzaG9ydCBmb250IGRlY2xhcmF0aW9uLCBidWlsZGluZyBhZGRpbmcgaXRzIHByb3BlcnRpZXMgdG8gYSBzdHlsZSBvYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBmb250IGRlY2xhcmF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9TdHlsZSBkZWZpbml0aW9uXG4gICAgICovXG4gICAgcGFyc2VGb250RGVjbGFyYXRpb246IGZ1bmN0aW9uKHZhbHVlLCBvU3R5bGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlRm9udERlY2xhcmF0aW9uKTtcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZm9udFN0eWxlID0gbWF0Y2hbMV0sXG4gICAgICAgICAgLy8gZm9udCB2YXJpYW50IGlzIG5vdCB1c2VkXG4gICAgICAgICAgLy8gZm9udFZhcmlhbnQgPSBtYXRjaFsyXSxcbiAgICAgICAgICBmb250V2VpZ2h0ID0gbWF0Y2hbM10sXG4gICAgICAgICAgZm9udFNpemUgPSBtYXRjaFs0XSxcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gbWF0Y2hbNV0sXG4gICAgICAgICAgZm9udEZhbWlseSA9IG1hdGNoWzZdO1xuXG4gICAgICBpZiAoZm9udFN0eWxlKSB7XG4gICAgICAgIG9TdHlsZS5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICB9XG4gICAgICBpZiAoZm9udFdlaWdodCkge1xuICAgICAgICBvU3R5bGUuZm9udFdlaWdodCA9IGlzTmFOKHBhcnNlRmxvYXQoZm9udFdlaWdodCkpID8gZm9udFdlaWdodCA6IHBhcnNlRmxvYXQoZm9udFdlaWdodCk7XG4gICAgICB9XG4gICAgICBpZiAoZm9udFNpemUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTaXplID0gcGFyc2VVbml0KGZvbnRTaXplKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250RmFtaWx5KSB7XG4gICAgICAgIG9TdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSGVpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodCA9PT0gJ25vcm1hbCcgPyAxIDogbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIFNWRyBkb2N1bWVudCwgcmV0dXJuaW5nIGFsbCBvZiB0aGUgZ3JhZGllbnQgZGVjbGFyYXRpb25zIGZvdW5kIGluIGl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBHcmFkaWVudCBkZWZpbml0aW9uczsga2V5IGNvcnJlc3BvbmRzIHRvIGVsZW1lbnQgaWQsIHZhbHVlIC0tIHRvIGdyYWRpZW50IGRlZmluaXRpb24gZWxlbWVudFxuICAgICAqL1xuICAgIGdldEdyYWRpZW50RGVmczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgdGFnQXJyYXkgPSBbXG4gICAgICAgICAgICAnbGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3JhZGlhbEdyYWRpZW50JyxcbiAgICAgICAgICAgICdzdmc6bGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpyYWRpYWxHcmFkaWVudCddLFxuICAgICAgICAgIGVsTGlzdCA9IF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgdGFnQXJyYXkpLFxuICAgICAgICAgIGVsLCBqID0gMCwgZ3JhZGllbnREZWZzID0geyB9O1xuICAgICAgaiA9IGVsTGlzdC5sZW5ndGg7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGVsID0gZWxMaXN0W2pdO1xuICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykpIHtcbiAgICAgICAgICByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnREZWZzW2VsLmdldEF0dHJpYnV0ZSgnaWQnKV0gPSBlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFkaWVudERlZnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMnIG5hbWUvdmFsdWUsIGdpdmVuIGVsZW1lbnQgYW5kIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcztcbiAgICAgKiBQYXJzZXMgcGFyZW50IFwiZ1wiIG5vZGVzIHJlY3Vyc2l2ZWx5IHVwd2FyZHMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGF0dHJpYnV0ZXMgQXJyYXkgb2YgYXR0cmlidXRlcyB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgcGFyc2VkIGF0dHJpYnV0ZXMnIG5hbWVzL3ZhbHVlc1xuICAgICAqL1xuICAgIHBhcnNlQXR0cmlidXRlczogZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcywgc3ZnVWlkKSB7XG5cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0geyB9LFxuICAgICAgICAgIGZvbnRTaXplLCBwYXJlbnRGb250U2l6ZTtcblxuICAgICAgaWYgKHR5cGVvZiBzdmdVaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN2Z1VpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdmdVaWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwYXJlbnQgY29udGFpbmVyIChgZ2Agb3IgYGFgIG9yIGBzeW1ib2xgIG5vZGUpLCBwYXJzZSBpdHMgYXR0cmlidXRlcyByZWN1cnNpdmVseSB1cHdhcmRzXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeC50ZXN0KGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudC5wYXJlbnROb2RlLCBhdHRyaWJ1dGVzLCBzdmdVaWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3duQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGF0dHIpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICBtZW1vW2F0dHJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCB7IH0pO1xuICAgICAgLy8gYWRkIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSwgd2hpY2ggdGFrZSBwcmVjZWRlbmNlIG92ZXIgYXR0cmlidXRlc1xuICAgICAgLy8gKHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0eWxpbmcuaHRtbCNVc2luZ1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMpXG4gICAgICB2YXIgY3NzQXR0cnMgPSBleHRlbmQoXG4gICAgICAgIGdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQoZWxlbWVudCwgc3ZnVWlkKSxcbiAgICAgICAgZmFicmljLnBhcnNlU3R5bGVBdHRyaWJ1dGUoZWxlbWVudClcbiAgICAgICk7XG4gICAgICBvd25BdHRyaWJ1dGVzID0gZXh0ZW5kKFxuICAgICAgICBvd25BdHRyaWJ1dGVzLFxuICAgICAgICBjc3NBdHRyc1xuICAgICAgKTtcbiAgICAgIGlmIChjc3NBdHRyc1tjUGF0aF0pIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY1BhdGgsIGNzc0F0dHJzW2NQYXRoXSk7XG4gICAgICB9XG4gICAgICBmb250U2l6ZSA9IHBhcmVudEZvbnRTaXplID0gcGFyZW50QXR0cmlidXRlcy5mb250U2l6ZSB8fCBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgICBpZiAob3duQXR0cmlidXRlc1tmU2l6ZV0pIHtcbiAgICAgICAgLy8gbG9va3MgbGlrZSB0aGUgbWluaW11bSBzaG91bGQgYmUgOXB4IHdoZW4gZGVhbGluZyB3aXRoIGVtcy4gdGhpcyBpcyB3aGF0IGxvb2tzIGxpa2UgaW4gYnJvd3NlcnMuXG4gICAgICAgIG93bkF0dHJpYnV0ZXNbZlNpemVdID0gZm9udFNpemUgPSBwYXJzZVVuaXQob3duQXR0cmlidXRlc1tmU2l6ZV0sIHBhcmVudEZvbnRTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZWRBdHRyLCBub3JtYWxpemVkVmFsdWUsIG5vcm1hbGl6ZWRTdHlsZSA9IHt9O1xuICAgICAgZm9yICh2YXIgYXR0ciBpbiBvd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRBdHRyID0gbm9ybWFsaXplQXR0cihhdHRyKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVmFsdWUobm9ybWFsaXplZEF0dHIsIG93bkF0dHJpYnV0ZXNbYXR0cl0sIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKTtcbiAgICAgICAgbm9ybWFsaXplZFN0eWxlW25vcm1hbGl6ZWRBdHRyXSA9IG5vcm1hbGl6ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub3JtYWxpemVkU3R5bGUgJiYgbm9ybWFsaXplZFN0eWxlLmZvbnQpIHtcbiAgICAgICAgZmFicmljLnBhcnNlRm9udERlY2xhcmF0aW9uKG5vcm1hbGl6ZWRTdHlsZS5mb250LCBub3JtYWxpemVkU3R5bGUpO1xuICAgICAgfVxuICAgICAgdmFyIG1lcmdlZEF0dHJzID0gZXh0ZW5kKHBhcmVudEF0dHJpYnV0ZXMsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5ub2RlTmFtZSkgPyBtZXJnZWRBdHRycyA6IF9zZXRTdHJva2VGaWxsT3BhY2l0eShtZXJnZWRBdHRycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2Ygc3ZnIGVsZW1lbnRzIHRvIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBBcnJheSBvZiBlbGVtZW50cyB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEJlaW5nIHBhc3NlZCBhbiBhcnJheSBvZiBmYWJyaWMgaW5zdGFuY2VzICh0cmFuc2Zvcm1lZCBmcm9tIFNWRyBlbGVtZW50cylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIHBhcnNlRWxlbWVudHM6IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICAgIG5ldyBmYWJyaWMuRWxlbWVudHNQYXJzZXIoZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykucGFyc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIFwic3R5bGVcIiBhdHRyaWJ1dGUsIHJldHVuaW5nIGFuIG9iamVjdCB3aXRoIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdHMgd2l0aCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUgYXR0cmlidXRlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwYXJzZVN0eWxlQXR0cmlidXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgb1N0eWxlID0geyB9LFxuICAgICAgICAgIHN0eWxlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG9TdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyc2VTdHlsZVN0cmluZyhzdHlsZSwgb1N0eWxlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwYXJzZVN0eWxlT2JqZWN0KHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb1N0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJwb2ludHNcIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludHMgcG9pbnRzIGF0dHJpYnV0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcG9pbnRzXG4gICAgICovXG4gICAgcGFyc2VQb2ludHNBdHRyaWJ1dGU6IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAvLyBwb2ludHMgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGFuZCBtdXN0IG5vdCBiZSBlbXB0eVxuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcGxhY2UgY29tbWFzIHdpdGggd2hpdGVzcGFjZSBhbmQgcmVtb3ZlIGJvb2tlbmRpbmcgd2hpdGVzcGFjZVxuICAgICAgcG9pbnRzID0gcG9pbnRzLnJlcGxhY2UoLywvZywgJyAnKS50cmltKCk7XG5cbiAgICAgIHBvaW50cyA9IHBvaW50cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHBhcnNlZFBvaW50cyA9IFtdLCBpLCBsZW47XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBwYXJzZWRQb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogcGFyc2VGbG9hdChwb2ludHNbaV0pLFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9kZCBudW1iZXIgb2YgcG9pbnRzIGlzIGFuIGVycm9yXG4gICAgICAvLyBpZiAocGFyc2VkUG9pbnRzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHJ1bGVzIGZvciBhIGdpdmVuIFNWRyBkb2N1bWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHJ1bGVzIG9mIHRoaXMgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBnZXRDU1NSdWxlczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgc3R5bGVzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpLCBpLCBsZW4sXG4gICAgICAgICAgYWxsUnVsZXMgPSB7IH0sIHJ1bGVzO1xuXG4gICAgICAvLyB2ZXJ5IGNydWRlIHBhcnNpbmcgb2Ygc3R5bGUgY29udGVudHNcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgc3R5bGVDb250ZW50cyA9IHN0eWxlc1tpXS50ZXh0Q29udGVudDtcblxuICAgICAgICAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgc3R5bGVDb250ZW50cyA9IHN0eWxlQ29udGVudHMucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJyk7XG4gICAgICAgIGlmIChzdHlsZUNvbnRlbnRzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBydWxlcyA9IHN0eWxlQ29udGVudHMubWF0Y2goL1tee10qXFx7W1xcc1xcU10qP1xcfS9nKTtcbiAgICAgICAgcnVsZXMgPSBydWxlcy5tYXAoZnVuY3Rpb24ocnVsZSkgeyByZXR1cm4gcnVsZS50cmltKCk7IH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuXG4gICAgICAgICAgdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgvKFtcXHNcXFNdKj8pXFxzKlxceyhbXn1dKilcXH0vKSxcbiAgICAgICAgICAgICAgcnVsZU9iaiA9IHsgfSwgZGVjbGFyYXRpb24gPSBtYXRjaFsyXS50cmltKCksXG4gICAgICAgICAgICAgIHByb3BlcnR5VmFsdWVQYWlycyA9IGRlY2xhcmF0aW9uLnJlcGxhY2UoLzskLywgJycpLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3BlcnR5VmFsdWVQYWlycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBwcm9wZXJ0eVZhbHVlUGFpcnNbaV0uc3BsaXQoL1xccyo6XFxzKi8pLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFpclswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV07XG4gICAgICAgICAgICBydWxlT2JqW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlID0gbWF0Y2hbMV07XG4gICAgICAgICAgcnVsZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24oX3J1bGUpIHtcbiAgICAgICAgICAgIF9ydWxlID0gX3J1bGUucmVwbGFjZSgvXnN2Zy9pLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKF9ydWxlID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsUnVsZXNbX3J1bGVdKSB7XG4gICAgICAgICAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoYWxsUnVsZXNbX3J1bGVdLCBydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhbGxSdWxlc1tfcnVsZV0gPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUocnVsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbFJ1bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1cmwgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0cy5cbiAgICAgKiBOb3RlIHRoYXQgU1ZHIGlzIGZldGNoZWQgdmlhIFhNTEh0dHBSZXF1ZXN0LCBzbyBpdCBuZWVkcyB0byBjb25mb3JtIHRvIFNPUCAoU2FtZSBPcmlnaW4gUG9saWN5KVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBjcm9zc09yaWdpbiBzZXR0aW5nIHRvIHVzZSBmb3IgZXh0ZXJuYWwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21VUkw6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIHJldml2ZXIsIG9wdGlvbnMpIHtcblxuICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15cXG5cXHMqLywgJycpLnRyaW0oKTtcbiAgICAgIG5ldyBmYWJyaWMudXRpbC5yZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShyKSB7XG5cbiAgICAgICAgdmFyIHhtbCA9IHIucmVzcG9uc2VYTUw7XG4gICAgICAgIGlmICgheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoeG1sLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKTtcbiAgICAgICAgfSwgcmV2aXZlciwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIGNyb3NzT3JpZ2luIHNldHRpbmcgdG8gdXNlIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVN0cmluZzogZnVuY3Rpb24oc3RyaW5nLCBjYWxsYmFjaywgcmV2aXZlciwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBmYWJyaWMud2luZG93LkRPTVBhcnNlcigpLFxuICAgICAgICAgIGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3RyaW5nLnRyaW0oKSwgJ3RleHQveG1sJyk7XG4gICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudChkb2MuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cykge1xuICAgICAgICBjYWxsYmFjayhyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKTtcbiAgICAgIH0sIHJldml2ZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zLCBkb2MpIHtcbiAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMucmV2aXZlciA9IHJldml2ZXI7XG4gIHRoaXMuc3ZnVWlkID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdmdVaWQpIHx8IDA7XG4gIHRoaXMucGFyc2luZ09wdGlvbnMgPSBwYXJzaW5nT3B0aW9ucztcbiAgdGhpcy5yZWdleFVybCA9IC9edXJsXFwoWydcIl0/IyhbXidcIl0rKVsnXCJdP1xcKS9nO1xuICB0aGlzLmRvYyA9IGRvYztcbn07XG5cbihmdW5jdGlvbihwcm90bykge1xuICBwcm90by5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IEFycmF5KHRoaXMuZWxlbWVudHMubGVuZ3RoKTtcbiAgICB0aGlzLm51bUVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5jcmVhdGVPYmplY3RzKCk7XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGkpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdmdVaWQnLCBfdGhpcy5zdmdVaWQpO1xuICAgICAgX3RoaXMuY3JlYXRlT2JqZWN0KGVsZW1lbnQsIGkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHByb3RvLmZpbmRUYWcgPSBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiBmYWJyaWNbZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUoZWwudGFnTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKV07XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlT2JqZWN0ID0gZnVuY3Rpb24oZWwsIGluZGV4KSB7XG4gICAgdmFyIGtsYXNzID0gdGhpcy5maW5kVGFnKGVsKTtcbiAgICBpZiAoa2xhc3MgJiYga2xhc3MuZnJvbUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGtsYXNzLmZyb21FbGVtZW50KGVsLCB0aGlzLmNyZWF0ZUNhbGxiYWNrKGluZGV4LCBlbCksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGZhYnJpYy5sb2coZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrSWZEb25lKCk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmNyZWF0ZUNhbGxiYWNrID0gZnVuY3Rpb24oaW5kZXgsIGVsKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgX29wdGlvbnM7XG4gICAgICBfdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCBlbCwgJ2ZpbGwnKTtcbiAgICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosIGVsLCAnc3Ryb2tlJyk7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgZmFicmljLkltYWdlICYmIG9iai5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIF9vcHRpb25zID0gb2JqLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZShlbCk7XG4gICAgICB9XG4gICAgICBvYmouX3JlbW92ZVRyYW5zZm9ybU1hdHJpeChfb3B0aW9ucyk7XG4gICAgICBfdGhpcy5yZXNvbHZlQ2xpcFBhdGgob2JqLCBlbCk7XG4gICAgICBfdGhpcy5yZXZpdmVyICYmIF90aGlzLnJldml2ZXIoZWwsIG9iaik7XG4gICAgICBfdGhpcy5pbnN0YW5jZXNbaW5kZXhdID0gb2JqO1xuICAgICAgX3RoaXMuY2hlY2tJZkRvbmUoKTtcbiAgICB9O1xuICB9O1xuXG4gIHByb3RvLmV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24gPSBmdW5jdGlvbihvYmosIHByb3BlcnR5LCBzdG9yYWdlKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BlcnR5XSwgcmVnZXggPSB0aGlzLnJlZ2V4VXJsO1xuICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgaWQgPSByZWdleC5leGVjKHZhbHVlKVsxXTtcbiAgICByZWdleC5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBmYWJyaWNbc3RvcmFnZV1bdGhpcy5zdmdVaWRdW2lkXTtcbiAgfTtcblxuICBwcm90by5yZXNvbHZlR3JhZGllbnQgPSBmdW5jdGlvbihvYmosIGVsLCBwcm9wZXJ0eSkge1xuICAgIHZhciBncmFkaWVudERlZiA9IHRoaXMuZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbihvYmosIHByb3BlcnR5LCAnZ3JhZGllbnREZWZzJyk7XG4gICAgaWYgKGdyYWRpZW50RGVmKSB7XG4gICAgICB2YXIgb3BhY2l0eUF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUocHJvcGVydHkgKyAnLW9wYWNpdHknKTtcbiAgICAgIHZhciBncmFkaWVudCA9IGZhYnJpYy5HcmFkaWVudC5mcm9tRWxlbWVudChncmFkaWVudERlZiwgb2JqLCBvcGFjaXR5QXR0ciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG9iai5zZXQocHJvcGVydHksIGdyYWRpZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlQ2xpcFBhdGhDYWxsYmFjayA9IGZ1bmN0aW9uKG9iaiwgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF9uZXdPYmopIHtcbiAgICAgIF9uZXdPYmouX3JlbW92ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgX25ld09iai5maWxsUnVsZSA9IF9uZXdPYmouY2xpcFJ1bGU7XG4gICAgICBjb250YWluZXIucHVzaChfbmV3T2JqKTtcbiAgICB9O1xuICB9O1xuXG4gIHByb3RvLnJlc29sdmVDbGlwUGF0aCA9IGZ1bmN0aW9uKG9iaiwgdXNpbmdFbGVtZW50KSB7XG4gICAgdmFyIGNsaXBQYXRoID0gdGhpcy5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uKG9iaiwgJ2NsaXBQYXRoJywgJ2NsaXBQYXRocycpLFxuICAgICAgICBlbGVtZW50LCBrbGFzcywgb2JqVHJhbnNmb3JtSW52LCBjb250YWluZXIsIGdUcmFuc2Zvcm0sIG9wdGlvbnM7XG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgIG9ialRyYW5zZm9ybUludiA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybShvYmouY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgIC8vIG1vdmUgdGhlIGNsaXBQYXRoIHRhZyBhcyBzaWJsaW5nIHRvIHRoZSByZWFsIGVsZW1lbnQgdGhhdCBpcyB1c2luZyBpdFxuICAgICAgdmFyIGNsaXBQYXRoVGFnID0gY2xpcFBhdGhbMF0ucGFyZW50Tm9kZTtcbiAgICAgIHZhciBjbGlwUGF0aE93bmVyID0gdXNpbmdFbGVtZW50O1xuICAgICAgd2hpbGUgKGNsaXBQYXRoT3duZXIucGFyZW50Tm9kZSAmJiBjbGlwUGF0aE93bmVyLmdldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJykgIT09IG9iai5jbGlwUGF0aCkge1xuICAgICAgICBjbGlwUGF0aE93bmVyID0gY2xpcFBhdGhPd25lci5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgY2xpcFBhdGhPd25lci5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGNsaXBQYXRoVGFnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IGNsaXBQYXRoW2ldO1xuICAgICAgICBrbGFzcyA9IHRoaXMuZmluZFRhZyhlbGVtZW50KTtcbiAgICAgICAga2xhc3MuZnJvbUVsZW1lbnQoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNyZWF0ZUNsaXBQYXRoQ2FsbGJhY2sob2JqLCBjb250YWluZXIpLFxuICAgICAgICAgIHRoaXMub3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5lci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2xpcFBhdGggPSBjb250YWluZXJbMF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGggPSBuZXcgZmFicmljLkdyb3VwKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICBnVHJhbnNmb3JtID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgb2JqVHJhbnNmb3JtSW52LFxuICAgICAgICBjbGlwUGF0aC5jYWxjVHJhbnNmb3JtTWF0cml4KClcbiAgICAgICk7XG4gICAgICBpZiAoY2xpcFBhdGguY2xpcFBhdGgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlQ2xpcFBhdGgoY2xpcFBhdGgsIGNsaXBQYXRoT3duZXIpO1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShnVHJhbnNmb3JtKTtcbiAgICAgIGNsaXBQYXRoLmZsaXBYID0gZmFsc2U7XG4gICAgICBjbGlwUGF0aC5mbGlwWSA9IGZhbHNlO1xuICAgICAgY2xpcFBhdGguc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICBjbGlwUGF0aC5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgIGNsaXBQYXRoLmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgIGNsaXBQYXRoLnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgIGNsaXBQYXRoLnNrZXdZID0gMDtcbiAgICAgIGNsaXBQYXRoLnNldFBvc2l0aW9uQnlPcmlnaW4oeyB4OiBvcHRpb25zLnRyYW5zbGF0ZVgsIHk6IG9wdGlvbnMudHJhbnNsYXRlWSB9LCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgb2JqLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gaWYgY2xpcC1wYXRoIGRvZXMgbm90IHJlc29sdmUgdG8gYW55IGVsZW1lbnQsIGRlbGV0ZSB0aGUgcHJvcGVydHkuXG4gICAgICBkZWxldGUgb2JqLmNsaXBQYXRoO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jaGVja0lmRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgtLXRoaXMubnVtRWxlbWVudHMgPT09IDApIHtcbiAgICAgIHRoaXMuaW5zdGFuY2VzID0gdGhpcy5pbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcbiAgICAgICAgcmV0dXJuIGVsICE9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5pbnN0YW5jZXMsIHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiAgfTtcbn0pKGZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogQWRhcHRhdGlvbiBvZiB3b3JrIG9mIEtldmluIExpbmRzZXkgKGtldmluQGtldmxpbmRldi5jb20pICovXG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuUG9pbnQpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBvaW50IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZhYnJpYy5Qb2ludCA9IFBvaW50O1xuXG4gIC8qKlxuICAgKiBQb2ludCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvaW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIFBvaW50LnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLlBvaW50LnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAncG9pbnQnLFxuXG4gICAgY29uc3RydWN0b3I6IFBvaW50LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIHBvaW50IHRvIHRoaXMgb25lIGFuZCByZXR1cm5zIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBpbnN0YW5jZSB3aXRoIGFkZGVkIHZhbHVlc1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhhdC54LCB0aGlzLnkgKyB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRFcXVhbHM6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggKz0gdGhhdC54O1xuICAgICAgdGhpcy55ICs9IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhbHVlIHRvIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IHdpdGggYWRkZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzY2FsYXJBZGQ6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgc2NhbGFyLCB0aGlzLnkgKyBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhbHVlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxhckFkZEVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICs9IHNjYWxhcjtcbiAgICAgIHRoaXMueSArPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGFub3RoZXIgcG9pbnQgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggc3VidHJhY3RlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gdGhhdC54LCB0aGlzLnkgLSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzdWJ0cmFjdEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCAtPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgLT0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB2YWx1ZSBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBzY2FsYXJTdWJ0cmFjdDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBzY2FsYXIsIHRoaXMueSAtIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB2YWx1ZSBmcm9tIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggLT0gc2NhbGFyO1xuICAgICAgdGhpcy55IC09IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHkgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhck11bHRpcGx5RXF1YWxzIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgbXVsdGlwbHlFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJEaXZpZGUgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBkaXZpZGU6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gc2NhbGFyLCB0aGlzLnkgLyBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJEaXZpZGVFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXZpZGVFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAvPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLz0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGVxOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPT09IHRoYXQueCAmJiB0aGlzLnkgPT09IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBsdDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDwgdGhhdC54ICYmIHRoaXMueSA8IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBsdGU6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA8PSB0aGF0LnggJiYgdGhpcy55IDw9IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBndDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID4gdGhhdC54ICYmIHRoaXMueSA+IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBndGU6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA+PSB0aGF0LnggJiYgdGhpcy55ID49IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0aGlzIG9uZSBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ICwgcG9zaXRpb24gb2YgaW50ZXJwb2xhdGlvbiwgYmV0d2VlbiAwIGFuZCAxIGRlZmF1bHQgMC41XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGxlcnA6IGZ1bmN0aW9uICh0aGF0LCB0KSB7XG4gICAgICBpZiAodHlwZW9mIHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHQgPSAwLjU7XG4gICAgICB9XG4gICAgICB0ID0gTWF0aC5tYXgoTWF0aC5taW4oMSwgdCksIDApO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyAodGhhdC54IC0gdGhpcy54KSAqIHQsIHRoaXMueSArICh0aGF0LnkgLSB0aGlzLnkpICogdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMueCAtIHRoYXQueCxcbiAgICAgICAgICBkeSA9IHRoaXMueSAtIHRoYXQueTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBiZXR3ZWVuIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWlkUG9pbnRGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVycCh0aGF0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWluIG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1pbih0aGlzLngsIHRoYXQueCksIE1hdGgubWluKHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIG1heCBvZiB0aGlzIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5tYXgodGhpcy54LCB0aGF0LngpLCBNYXRoLm1heCh0aGlzLnksIHRoYXQueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBvaW50XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICsgJywnICsgdGhpcy55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHgveSBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYWTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeCBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB5IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRZOiBmdW5jdGlvbiAoeSkge1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHgveSBvZiB0aGlzIHBvaW50IGZyb20gYW5vdGhlciBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEZyb21Qb2ludDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB4L3kgb2YgdGhpcyBwb2ludCBhbmQgYW5vdGhlciBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICovXG4gICAgc3dhcDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgIHkgPSB0aGlzLnk7XG4gICAgICB0aGlzLnggPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgPSB0aGF0Lnk7XG4gICAgICB0aGF0LnggPSB4O1xuICAgICAgdGhhdC55ID0geTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgY2xvbmVkIGluc3RhbmNlIG9mIHRoZSBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuSW50ZXJzZWN0aW9uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5JbnRlcnNlY3Rpb24gaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyc2VjdGlvbiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkludGVyc2VjdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gIH1cblxuICBmYWJyaWMuSW50ZXJzZWN0aW9uID0gSW50ZXJzZWN0aW9uO1xuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuSW50ZXJzZWN0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICBjb25zdHJ1Y3RvcjogSW50ZXJzZWN0aW9uLFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIHBvaW50IHRvIGludGVyc2VjdGlvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBwb2ludHMgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgIHRoaXMucG9pbnRzID0gdGhpcy5wb2ludHMuY29uY2F0KHBvaW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvbmUgbGluZSBpbnRlcnNlY3RzIGFub3RoZXJcbiAgICogVE9ETzogcmVuYW1lIGluIGludGVyc2VjdFNlZ21lbnRTZWdtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVMaW5lID0gZnVuY3Rpb24gKGExLCBhMiwgYjEsIGIyKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgdWFUID0gKGIyLnggLSBiMS54KSAqIChhMS55IC0gYjEueSkgLSAoYjIueSAtIGIxLnkpICogKGExLnggLSBiMS54KSxcbiAgICAgICAgdWJUID0gKGEyLnggLSBhMS54KSAqIChhMS55IC0gYjEueSkgLSAoYTIueSAtIGExLnkpICogKGExLnggLSBiMS54KSxcbiAgICAgICAgdUIgPSAoYjIueSAtIGIxLnkpICogKGEyLnggLSBhMS54KSAtIChiMi54IC0gYjEueCkgKiAoYTIueSAtIGExLnkpO1xuICAgIGlmICh1QiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFUIC8gdUIsXG4gICAgICAgICAgdWIgPSB1YlQgLyB1QjtcbiAgICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ0ludGVyc2VjdGlvbicpO1xuICAgICAgICByZXN1bHQuYXBwZW5kUG9pbnQobmV3IGZhYnJpYy5Qb2ludChhMS54ICsgdWEgKiAoYTIueCAtIGExLngpLCBhMS55ICsgdWEgKiAoYTIueSAtIGExLnkpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh1YVQgPT09IDAgfHwgdWJUID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ0NvaW5jaWRlbnQnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdQYXJhbGxlbCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgbGluZSBpbnRlcnNlY3RzIHBvbHlnb25cbiAgICogVE9ETzogcmVuYW1lIGluIGludGVyc2VjdFNlZ21lbnRQb2x5Z29uXG4gICAqIGZpeCBkZXRlY3Rpb24gb2YgY29pbmNpZGVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTJcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uID0gZnVuY3Rpb24oYTEsIGEyLCBwb2ludHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBiMSwgYjIsIGludGVyLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBiMSA9IHBvaW50c1tpXTtcbiAgICAgIGIyID0gcG9pbnRzWyhpICsgMSkgJSBsZW5ndGhdO1xuICAgICAgaW50ZXIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZUxpbmUoYTEsIGEyLCBiMSwgYjIpO1xuXG4gICAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyLnBvaW50cyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvbHlnb24gaW50ZXJzZWN0cyBhbm90aGVyIHBvbHlnb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzMSwgcG9pbnRzMikge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCksXG4gICAgICAgIGxlbmd0aCA9IHBvaW50czEubGVuZ3RoLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYTEgPSBwb2ludHMxW2ldLFxuICAgICAgICAgIGEyID0gcG9pbnRzMVsoaSArIDEpICUgbGVuZ3RoXSxcbiAgICAgICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihhMSwgYTIsIHBvaW50czIpO1xuXG4gICAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyLnBvaW50cyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvbHlnb24gaW50ZXJzZWN0cyByZWN0YW5nbGVcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIxXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSByMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHBvaW50cywgcjEsIHIyKSB7XG4gICAgdmFyIG1pbiA9IHIxLm1pbihyMiksXG4gICAgICAgIG1heCA9IHIxLm1heChyMiksXG4gICAgICAgIHRvcFJpZ2h0ID0gbmV3IGZhYnJpYy5Qb2ludChtYXgueCwgbWluLnkpLFxuICAgICAgICBib3R0b21MZWZ0ID0gbmV3IGZhYnJpYy5Qb2ludChtaW4ueCwgbWF4LnkpLFxuICAgICAgICBpbnRlcjEgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24obWluLCB0b3BSaWdodCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKHRvcFJpZ2h0LCBtYXgsIHBvaW50cyksXG4gICAgICAgIGludGVyMyA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtYXgsIGJvdHRvbUxlZnQsIHBvaW50cyksXG4gICAgICAgIGludGVyNCA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihib3R0b21MZWZ0LCBtaW4sIHBvaW50cyksXG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKTtcblxuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIxLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjIucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMy5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXI0LnBvaW50cyk7XG5cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkNvbG9yKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Db2xvciBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbG9yIGNsYXNzXG4gICAqIFRoZSBwdXJwb3NlIG9mIHtAbGluayBmYWJyaWMuQ29sb3J9IGlzIHRvIGFic3RyYWN0IGFuZCBlbmNhcHN1bGF0ZSBjb21tb24gY29sb3Igb3BlcmF0aW9ucztcbiAgICoge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgYSBjb25zdHJ1Y3RvciBhbmQgY3JlYXRlcyBpbnN0YW5jZXMgb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gb2JqZWN0cy5cbiAgICpcbiAgICogQGNsYXNzIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3Igb3B0aW9uYWwgaW4gaGV4IG9yIHJnYihhKSBvciBoc2wgZm9ybWF0IG9yIGZyb20ga25vd24gY29sb3IgbGlzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIvI2NvbG9yc31cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgdGhpcy5zZXRTb3VyY2UoWzAsIDAsIDAsIDFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90cnlQYXJzaW5nQ29sb3IoY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZhYnJpYy5Db2xvciA9IENvbG9yO1xuXG4gIGZhYnJpYy5Db2xvci5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Db2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gY29sb3IgQ29sb3IgdmFsdWUgdG8gcGFyc2VcbiAgICAgKi9cbiAgICBfdHJ5UGFyc2luZ0NvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgdmFyIHNvdXJjZTtcblxuICAgICAgaWYgKGNvbG9yIGluIENvbG9yLmNvbG9yTmFtZU1hcCkge1xuICAgICAgICBjb2xvciA9IENvbG9yLmNvbG9yTmFtZU1hcFtjb2xvcl07XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBzb3VyY2UgPSBbMjU1LCAyNTUsIDI1NSwgMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21IZXgoY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tSHNsKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIC8vaWYgY29sb3IgaXMgbm90IHJlY29nbml6ZSBsZXQncyBtYWtlIGJsYWNrIGFzIGNhbnZhcyBkb2VzXG4gICAgICAgIHNvdXJjZSA9IFswLCAwLCAwLCAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwczovL3Jhd2dpdGh1Yi5jb20vbWppamFja3Nvbi9tamlqYWNrc29uLmdpdGh1Yi5jb20vbWFzdGVyLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdC5odG1sXCI+aHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb248L2E+XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciBSZWQgY29sb3IgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyBHcmVlbiBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIEJsdWUgY29sb3IgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gSHNsIGNvbG9yXG4gICAgICovXG4gICAgX3JnYlRvSHNsOiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICByIC89IDI1NTsgZyAvPSAyNTU7IGIgLz0gMjU1O1xuXG4gICAgICB2YXIgaCwgcywgbCxcbiAgICAgICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoW3IsIGcsIGJdKSxcbiAgICAgICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4oW3IsIGcsIGJdKTtcblxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgucm91bmQoaCAqIDM2MCksXG4gICAgICAgIE1hdGgucm91bmQocyAqIDEwMCksXG4gICAgICAgIE1hdGgucm91bmQobCAqIDEwMClcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc291cmNlIG9mIHRoaXMgY29sb3IgKHdoZXJlIHNvdXJjZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbjsgZXg6IFsyMDAsIDIwMCwgMTAwLCAxXSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZVxuICAgICAqL1xuICAgIHNldFNvdXJjZTogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gUkdCIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSlcbiAgICAgKi9cbiAgICB0b1JnYjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHJldHVybiAncmdiKCcgKyBzb3VyY2VbMF0gKyAnLCcgKyBzb3VyY2VbMV0gKyAnLCcgKyBzb3VyY2VbMl0gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gUkdCQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiByZ2JhKDAtMjU1LDAtMjU1LDAtMjU1LDAtMSlcbiAgICAgKi9cbiAgICB0b1JnYmE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICByZXR1cm4gJ3JnYmEoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcsJyArIHNvdXJjZVszXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIU0wgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogaHNsKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSlcbiAgICAgKi9cbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBoc2wgPSB0aGlzLl9yZ2JUb0hzbChzb3VyY2VbMF0sIHNvdXJjZVsxXSwgc291cmNlWzJdKTtcblxuICAgICAgcmV0dXJuICdoc2woJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhTTEEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogaHNsYSgwLTM2MCwwJS0xMDAlLDAlLTEwMCUsMC0xKVxuICAgICAqL1xuICAgIHRvSHNsYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBoc2wgPSB0aGlzLl9yZ2JUb0hzbChzb3VyY2VbMF0sIHNvdXJjZVsxXSwgc291cmNlWzJdKTtcblxuICAgICAgcmV0dXJuICdoc2xhKCcgKyBoc2xbMF0gKyAnLCcgKyBoc2xbMV0gKyAnJSwnICsgaHNsWzJdICsgJyUsJyArIHNvdXJjZVszXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIRVggZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogRkY1NTU1XG4gICAgICovXG4gICAgdG9IZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksIHIsIGcsIGI7XG5cbiAgICAgIHIgPSBzb3VyY2VbMF0udG9TdHJpbmcoMTYpO1xuICAgICAgciA9IChyLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgcikgOiByO1xuXG4gICAgICBnID0gc291cmNlWzFdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGcgPSAoZy5sZW5ndGggPT09IDEpID8gKCcwJyArIGcpIDogZztcblxuICAgICAgYiA9IHNvdXJjZVsyXS50b1N0cmluZygxNik7XG4gICAgICBiID0gKGIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBiKSA6IGI7XG5cbiAgICAgIHJldHVybiByLnRvVXBwZXJDYXNlKCkgKyBnLnRvVXBwZXJDYXNlKCkgKyBiLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSEVYQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBGRjU1NTVDQ1xuICAgICAqL1xuICAgIHRvSGV4YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSwgYTtcblxuICAgICAgYSA9IE1hdGgucm91bmQoc291cmNlWzNdICogMjU1KTtcbiAgICAgIGEgPSBhLnRvU3RyaW5nKDE2KTtcbiAgICAgIGEgPSAoYS5sZW5ndGggPT09IDEpID8gKCcwJyArIGEpIDogYTtcblxuICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKSArIGEudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiBhbHBoYSBjaGFubmVsIGZvciB0aGlzIGNvbG9yXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAwLTFcbiAgICAgKi9cbiAgICBnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKVszXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2YWx1ZSBvZiBhbHBoYSBjaGFubmVsIGZvciB0aGlzIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIEFscGhhIHZhbHVlIDAtMVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICBzb3VyY2VbM10gPSBhbHBoYTtcbiAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb2xvciB0byBpdHMgZ3JheXNjYWxlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgdG9HcmF5c2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IHBhcnNlSW50KChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSwgMTApLFxuICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IHNvdXJjZVszXTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBibGFjayBhbmQgd2hpdGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgdG9CbGFja1doaXRlOiBmdW5jdGlvbih0aHJlc2hvbGQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGF2ZXJhZ2UgPSAoc291cmNlWzBdICogMC4zICsgc291cmNlWzFdICogMC41OSArIHNvdXJjZVsyXSAqIDAuMTEpLnRvRml4ZWQoMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuXG4gICAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMTI3O1xuXG4gICAgICBhdmVyYWdlID0gKE51bWJlcihhdmVyYWdlKSA8IE51bWJlcih0aHJlc2hvbGQpKSA/IDAgOiAyNTU7XG4gICAgICB0aGlzLnNldFNvdXJjZShbYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY3VycmVudEFscGhhXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheXMgY29sb3Igd2l0aCBhbm90aGVyIGNvbG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd8ZmFicmljLkNvbG9yfSBvdGhlckNvbG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgb3ZlcmxheVdpdGg6IGZ1bmN0aW9uKG90aGVyQ29sb3IpIHtcbiAgICAgIGlmICghKG90aGVyQ29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcbiAgICAgICAgb3RoZXJDb2xvciA9IG5ldyBDb2xvcihvdGhlckNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIGFscGhhID0gdGhpcy5nZXRBbHBoYSgpLFxuICAgICAgICAgIG90aGVyQWxwaGEgPSAwLjUsXG4gICAgICAgICAgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBvdGhlclNvdXJjZSA9IG90aGVyQ29sb3IuZ2V0U291cmNlKCksIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5yb3VuZCgoc291cmNlW2ldICogKDEgLSBvdGhlckFscGhhKSkgKyAob3RoZXJTb3VyY2VbaV0gKiBvdGhlckFscGhhKSkpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbM10gPSBhbHBoYTtcbiAgICAgIHRoaXMuc2V0U291cmNlKHJlc3VsdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIFJHQiBvciBSR0JBIGZvcm1hdHMgKGV4OiByZ2IoMCwgMCwgMCksIHJnYmEoMjU1LCAxMDAsIDEwLCAwLjUpLCByZ2JhKCAyNTUgLCAxMDAgLCAxMCAsIDAuNSApLCByZ2IoMSwxLDEpLCByZ2JhKDEwMCUsIDYwJSwgMTAlLCAwLjUpKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuQ29sb3IucmVSR0JhID0gL15yZ2JhP1xcKFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyosXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqKD86XFxzKixcXHMqKCg/OlxcZCpcXC4/XFxkKyk/KVxccyopP1xcKSQvaTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gSFNMIG9yIEhTTEEgZm9ybWF0cyAoZXg6IGhzbCgyMDAsIDgwJSwgMTAlKSwgaHNsYSgzMDAsIDUwJSwgODAlLCAwLjUpLCBoc2xhKCAzMDAgLCA1MCUgLCA4MCUgLCAwLjUgKSlcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnJlSFNMYSA9IC9eaHNsYT9cXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqLFxccyooXFxkezEsM31cXCUpXFxzKig/OlxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyopP1xcKSQvaTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gSEVYIGZvcm1hdCAoZXg6ICNGRjU1NDRDQywgI0ZGNTU1NSwgMDEwMTU1LCBhZmYpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5yZUhleCA9IC9eIz8oWzAtOWEtZl17OH18WzAtOWEtZl17Nn18WzAtOWEtZl17NH18WzAtOWEtZl17M30pJC9pO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgdGhlIDE0OCBjb2xvciBuYW1lcyB3aXRoIEhFWCBjb2RlXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLmNvbG9yTmFtZU1hcCA9IHtcbiAgICBhbGljZWJsdWU6ICAgICAgICAgICAgJyNGMEY4RkYnLFxuICAgIGFudGlxdWV3aGl0ZTogICAgICAgICAnI0ZBRUJENycsXG4gICAgYXF1YTogICAgICAgICAgICAgICAgICcjMDBGRkZGJyxcbiAgICBhcXVhbWFyaW5lOiAgICAgICAgICAgJyM3RkZGRDQnLFxuICAgIGF6dXJlOiAgICAgICAgICAgICAgICAnI0YwRkZGRicsXG4gICAgYmVpZ2U6ICAgICAgICAgICAgICAgICcjRjVGNURDJyxcbiAgICBiaXNxdWU6ICAgICAgICAgICAgICAgJyNGRkU0QzQnLFxuICAgIGJsYWNrOiAgICAgICAgICAgICAgICAnIzAwMDAwMCcsXG4gICAgYmxhbmNoZWRhbG1vbmQ6ICAgICAgICcjRkZFQkNEJyxcbiAgICBibHVlOiAgICAgICAgICAgICAgICAgJyMwMDAwRkYnLFxuICAgIGJsdWV2aW9sZXQ6ICAgICAgICAgICAnIzhBMkJFMicsXG4gICAgYnJvd246ICAgICAgICAgICAgICAgICcjQTUyQTJBJyxcbiAgICBidXJseXdvb2Q6ICAgICAgICAgICAgJyNERUI4ODcnLFxuICAgIGNhZGV0Ymx1ZTogICAgICAgICAgICAnIzVGOUVBMCcsXG4gICAgY2hhcnRyZXVzZTogICAgICAgICAgICcjN0ZGRjAwJyxcbiAgICBjaG9jb2xhdGU6ICAgICAgICAgICAgJyNEMjY5MUUnLFxuICAgIGNvcmFsOiAgICAgICAgICAgICAgICAnI0ZGN0Y1MCcsXG4gICAgY29ybmZsb3dlcmJsdWU6ICAgICAgICcjNjQ5NUVEJyxcbiAgICBjb3Juc2lsazogICAgICAgICAgICAgJyNGRkY4REMnLFxuICAgIGNyaW1zb246ICAgICAgICAgICAgICAnI0RDMTQzQycsXG4gICAgY3lhbjogICAgICAgICAgICAgICAgICcjMDBGRkZGJyxcbiAgICBkYXJrYmx1ZTogICAgICAgICAgICAgJyMwMDAwOEInLFxuICAgIGRhcmtjeWFuOiAgICAgICAgICAgICAnIzAwOEI4QicsXG4gICAgZGFya2dvbGRlbnJvZDogICAgICAgICcjQjg4NjBCJyxcbiAgICBkYXJrZ3JheTogICAgICAgICAgICAgJyNBOUE5QTknLFxuICAgIGRhcmtncmV5OiAgICAgICAgICAgICAnI0E5QTlBOScsXG4gICAgZGFya2dyZWVuOiAgICAgICAgICAgICcjMDA2NDAwJyxcbiAgICBkYXJra2hha2k6ICAgICAgICAgICAgJyNCREI3NkInLFxuICAgIGRhcmttYWdlbnRhOiAgICAgICAgICAnIzhCMDA4QicsXG4gICAgZGFya29saXZlZ3JlZW46ICAgICAgICcjNTU2QjJGJyxcbiAgICBkYXJrb3JhbmdlOiAgICAgICAgICAgJyNGRjhDMDAnLFxuICAgIGRhcmtvcmNoaWQ6ICAgICAgICAgICAnIzk5MzJDQycsXG4gICAgZGFya3JlZDogICAgICAgICAgICAgICcjOEIwMDAwJyxcbiAgICBkYXJrc2FsbW9uOiAgICAgICAgICAgJyNFOTk2N0EnLFxuICAgIGRhcmtzZWFncmVlbjogICAgICAgICAnIzhGQkM4RicsXG4gICAgZGFya3NsYXRlYmx1ZTogICAgICAgICcjNDgzRDhCJyxcbiAgICBkYXJrc2xhdGVncmF5OiAgICAgICAgJyMyRjRGNEYnLFxuICAgIGRhcmtzbGF0ZWdyZXk6ICAgICAgICAnIzJGNEY0RicsXG4gICAgZGFya3R1cnF1b2lzZTogICAgICAgICcjMDBDRUQxJyxcbiAgICBkYXJrdmlvbGV0OiAgICAgICAgICAgJyM5NDAwRDMnLFxuICAgIGRlZXBwaW5rOiAgICAgICAgICAgICAnI0ZGMTQ5MycsXG4gICAgZGVlcHNreWJsdWU6ICAgICAgICAgICcjMDBCRkZGJyxcbiAgICBkaW1ncmF5OiAgICAgICAgICAgICAgJyM2OTY5NjknLFxuICAgIGRpbWdyZXk6ICAgICAgICAgICAgICAnIzY5Njk2OScsXG4gICAgZG9kZ2VyYmx1ZTogICAgICAgICAgICcjMUU5MEZGJyxcbiAgICBmaXJlYnJpY2s6ICAgICAgICAgICAgJyNCMjIyMjInLFxuICAgIGZsb3JhbHdoaXRlOiAgICAgICAgICAnI0ZGRkFGMCcsXG4gICAgZm9yZXN0Z3JlZW46ICAgICAgICAgICcjMjI4QjIyJyxcbiAgICBmdWNoc2lhOiAgICAgICAgICAgICAgJyNGRjAwRkYnLFxuICAgIGdhaW5zYm9ybzogICAgICAgICAgICAnI0RDRENEQycsXG4gICAgZ2hvc3R3aGl0ZTogICAgICAgICAgICcjRjhGOEZGJyxcbiAgICBnb2xkOiAgICAgICAgICAgICAgICAgJyNGRkQ3MDAnLFxuICAgIGdvbGRlbnJvZDogICAgICAgICAgICAnI0RBQTUyMCcsXG4gICAgZ3JheTogICAgICAgICAgICAgICAgICcjODA4MDgwJyxcbiAgICBncmV5OiAgICAgICAgICAgICAgICAgJyM4MDgwODAnLFxuICAgIGdyZWVuOiAgICAgICAgICAgICAgICAnIzAwODAwMCcsXG4gICAgZ3JlZW55ZWxsb3c6ICAgICAgICAgICcjQURGRjJGJyxcbiAgICBob25leWRldzogICAgICAgICAgICAgJyNGMEZGRjAnLFxuICAgIGhvdHBpbms6ICAgICAgICAgICAgICAnI0ZGNjlCNCcsXG4gICAgaW5kaWFucmVkOiAgICAgICAgICAgICcjQ0Q1QzVDJyxcbiAgICBpbmRpZ286ICAgICAgICAgICAgICAgJyM0QjAwODInLFxuICAgIGl2b3J5OiAgICAgICAgICAgICAgICAnI0ZGRkZGMCcsXG4gICAga2hha2k6ICAgICAgICAgICAgICAgICcjRjBFNjhDJyxcbiAgICBsYXZlbmRlcjogICAgICAgICAgICAgJyNFNkU2RkEnLFxuICAgIGxhdmVuZGVyYmx1c2g6ICAgICAgICAnI0ZGRjBGNScsXG4gICAgbGF3bmdyZWVuOiAgICAgICAgICAgICcjN0NGQzAwJyxcbiAgICBsZW1vbmNoaWZmb246ICAgICAgICAgJyNGRkZBQ0QnLFxuICAgIGxpZ2h0Ymx1ZTogICAgICAgICAgICAnI0FERDhFNicsXG4gICAgbGlnaHRjb3JhbDogICAgICAgICAgICcjRjA4MDgwJyxcbiAgICBsaWdodGN5YW46ICAgICAgICAgICAgJyNFMEZGRkYnLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI0ZBRkFEMicsXG4gICAgbGlnaHRncmF5OiAgICAgICAgICAgICcjRDNEM0QzJyxcbiAgICBsaWdodGdyZXk6ICAgICAgICAgICAgJyNEM0QzRDMnLFxuICAgIGxpZ2h0Z3JlZW46ICAgICAgICAgICAnIzkwRUU5MCcsXG4gICAgbGlnaHRwaW5rOiAgICAgICAgICAgICcjRkZCNkMxJyxcbiAgICBsaWdodHNhbG1vbjogICAgICAgICAgJyNGRkEwN0EnLFxuICAgIGxpZ2h0c2VhZ3JlZW46ICAgICAgICAnIzIwQjJBQScsXG4gICAgbGlnaHRza3libHVlOiAgICAgICAgICcjODdDRUZBJyxcbiAgICBsaWdodHNsYXRlZ3JheTogICAgICAgJyM3Nzg4OTknLFxuICAgIGxpZ2h0c2xhdGVncmV5OiAgICAgICAnIzc3ODg5OScsXG4gICAgbGlnaHRzdGVlbGJsdWU6ICAgICAgICcjQjBDNERFJyxcbiAgICBsaWdodHllbGxvdzogICAgICAgICAgJyNGRkZGRTAnLFxuICAgIGxpbWU6ICAgICAgICAgICAgICAgICAnIzAwRkYwMCcsXG4gICAgbGltZWdyZWVuOiAgICAgICAgICAgICcjMzJDRDMyJyxcbiAgICBsaW5lbjogICAgICAgICAgICAgICAgJyNGQUYwRTYnLFxuICAgIG1hZ2VudGE6ICAgICAgICAgICAgICAnI0ZGMDBGRicsXG4gICAgbWFyb29uOiAgICAgICAgICAgICAgICcjODAwMDAwJyxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiAgICAgJyM2NkNEQUEnLFxuICAgIG1lZGl1bWJsdWU6ICAgICAgICAgICAnIzAwMDBDRCcsXG4gICAgbWVkaXVtb3JjaGlkOiAgICAgICAgICcjQkE1NUQzJyxcbiAgICBtZWRpdW1wdXJwbGU6ICAgICAgICAgJyM5MzcwREInLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAgICAgICAnIzNDQjM3MScsXG4gICAgbWVkaXVtc2xhdGVibHVlOiAgICAgICcjN0I2OEVFJyxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogICAgJyMwMEZBOUEnLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogICAgICAnIzQ4RDFDQycsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAgICAgICcjQzcxNTg1JyxcbiAgICBtaWRuaWdodGJsdWU6ICAgICAgICAgJyMxOTE5NzAnLFxuICAgIG1pbnRjcmVhbTogICAgICAgICAgICAnI0Y1RkZGQScsXG4gICAgbWlzdHlyb3NlOiAgICAgICAgICAgICcjRkZFNEUxJyxcbiAgICBtb2NjYXNpbjogICAgICAgICAgICAgJyNGRkU0QjUnLFxuICAgIG5hdmFqb3doaXRlOiAgICAgICAgICAnI0ZGREVBRCcsXG4gICAgbmF2eTogICAgICAgICAgICAgICAgICcjMDAwMDgwJyxcbiAgICBvbGRsYWNlOiAgICAgICAgICAgICAgJyNGREY1RTYnLFxuICAgIG9saXZlOiAgICAgICAgICAgICAgICAnIzgwODAwMCcsXG4gICAgb2xpdmVkcmFiOiAgICAgICAgICAgICcjNkI4RTIzJyxcbiAgICBvcmFuZ2U6ICAgICAgICAgICAgICAgJyNGRkE1MDAnLFxuICAgIG9yYW5nZXJlZDogICAgICAgICAgICAnI0ZGNDUwMCcsXG4gICAgb3JjaGlkOiAgICAgICAgICAgICAgICcjREE3MEQ2JyxcbiAgICBwYWxlZ29sZGVucm9kOiAgICAgICAgJyNFRUU4QUEnLFxuICAgIHBhbGVncmVlbjogICAgICAgICAgICAnIzk4RkI5OCcsXG4gICAgcGFsZXR1cnF1b2lzZTogICAgICAgICcjQUZFRUVFJyxcbiAgICBwYWxldmlvbGV0cmVkOiAgICAgICAgJyNEQjcwOTMnLFxuICAgIHBhcGF5YXdoaXA6ICAgICAgICAgICAnI0ZGRUZENScsXG4gICAgcGVhY2hwdWZmOiAgICAgICAgICAgICcjRkZEQUI5JyxcbiAgICBwZXJ1OiAgICAgICAgICAgICAgICAgJyNDRDg1M0YnLFxuICAgIHBpbms6ICAgICAgICAgICAgICAgICAnI0ZGQzBDQicsXG4gICAgcGx1bTogICAgICAgICAgICAgICAgICcjRERBMEREJyxcbiAgICBwb3dkZXJibHVlOiAgICAgICAgICAgJyNCMEUwRTYnLFxuICAgIHB1cnBsZTogICAgICAgICAgICAgICAnIzgwMDA4MCcsXG4gICAgcmViZWNjYXB1cnBsZTogICAgICAgICcjNjYzMzk5JyxcbiAgICByZWQ6ICAgICAgICAgICAgICAgICAgJyNGRjAwMDAnLFxuICAgIHJvc3licm93bjogICAgICAgICAgICAnI0JDOEY4RicsXG4gICAgcm95YWxibHVlOiAgICAgICAgICAgICcjNDE2OUUxJyxcbiAgICBzYWRkbGVicm93bjogICAgICAgICAgJyM4QjQ1MTMnLFxuICAgIHNhbG1vbjogICAgICAgICAgICAgICAnI0ZBODA3MicsXG4gICAgc2FuZHlicm93bjogICAgICAgICAgICcjRjRBNDYwJyxcbiAgICBzZWFncmVlbjogICAgICAgICAgICAgJyMyRThCNTcnLFxuICAgIHNlYXNoZWxsOiAgICAgICAgICAgICAnI0ZGRjVFRScsXG4gICAgc2llbm5hOiAgICAgICAgICAgICAgICcjQTA1MjJEJyxcbiAgICBzaWx2ZXI6ICAgICAgICAgICAgICAgJyNDMEMwQzAnLFxuICAgIHNreWJsdWU6ICAgICAgICAgICAgICAnIzg3Q0VFQicsXG4gICAgc2xhdGVibHVlOiAgICAgICAgICAgICcjNkE1QUNEJyxcbiAgICBzbGF0ZWdyYXk6ICAgICAgICAgICAgJyM3MDgwOTAnLFxuICAgIHNsYXRlZ3JleTogICAgICAgICAgICAnIzcwODA5MCcsXG4gICAgc25vdzogICAgICAgICAgICAgICAgICcjRkZGQUZBJyxcbiAgICBzcHJpbmdncmVlbjogICAgICAgICAgJyMwMEZGN0YnLFxuICAgIHN0ZWVsYmx1ZTogICAgICAgICAgICAnIzQ2ODJCNCcsXG4gICAgdGFuOiAgICAgICAgICAgICAgICAgICcjRDJCNDhDJyxcbiAgICB0ZWFsOiAgICAgICAgICAgICAgICAgJyMwMDgwODAnLFxuICAgIHRoaXN0bGU6ICAgICAgICAgICAgICAnI0Q4QkZEOCcsXG4gICAgdG9tYXRvOiAgICAgICAgICAgICAgICcjRkY2MzQ3JyxcbiAgICB0dXJxdW9pc2U6ICAgICAgICAgICAgJyM0MEUwRDAnLFxuICAgIHZpb2xldDogICAgICAgICAgICAgICAnI0VFODJFRScsXG4gICAgd2hlYXQ6ICAgICAgICAgICAgICAgICcjRjVERUIzJyxcbiAgICB3aGl0ZTogICAgICAgICAgICAgICAgJyNGRkZGRkYnLFxuICAgIHdoaXRlc21va2U6ICAgICAgICAgICAnI0Y1RjVGNScsXG4gICAgeWVsbG93OiAgICAgICAgICAgICAgICcjRkZGRjAwJyxcbiAgICB5ZWxsb3dncmVlbjogICAgICAgICAgJyM5QUNEMzInXG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkge1xuICAgICAgdCArPSAxO1xuICAgIH1cbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIHQgLT0gMTtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gNikge1xuICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDIpIHtcbiAgICAgIHJldHVybiBxO1xuICAgIH1cbiAgICBpZiAodCA8IDIgLyAzKSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIFJHQiBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSlcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21SZ2IoY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gUkdCIG9yIFJHQkEgZm9ybWF0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpLCByZ2IoMCUtMTAwJSwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tUmdiID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB2YXIgbWF0Y2ggPSBjb2xvci5tYXRjaChDb2xvci5yZVJHQmEpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHIgPSBwYXJzZUludChtYXRjaFsxXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFsxXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbMV0pID8gMjU1IDogMSksXG4gICAgICAgICAgZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsyXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDI1NSA6IDEpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxMCksXG4gICAgICAgIHBhcnNlSW50KGcsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTApLFxuICAgICAgICBtYXRjaFs0XSA/IHBhcnNlRmxvYXQobWF0Y2hbNF0pIDogMVxuICAgICAgXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIFJHQkEgZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tUmdiYSA9IENvbG9yLmZyb21SZ2I7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhTTCBmb3JtYXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiBoc2woMC0yNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSHNsID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tSHNsKGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIEhTTCBvciBIU0xBIGZvcm1hdC5cbiAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwczovL3Jhd2dpdGh1Yi5jb20vbWppamFja3Nvbi9tamlqYWNrc29uLmdpdGh1Yi5jb20vbWFzdGVyLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdC5odG1sXCI+aHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb248L2E+XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKSBvciBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwgMC0xKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqIEBzZWUgaHR0cDovL2h0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI2hzbC1jb2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlSFNMYSk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChtYXRjaFsxXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjAsXG4gICAgICAgIHMgPSBwYXJzZUZsb2F0KG1hdGNoWzJdKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSksXG4gICAgICAgIGwgPSBwYXJzZUZsb2F0KG1hdGNoWzNdKSAvICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMTAwIDogMSksXG4gICAgICAgIHIsIGcsIGI7XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcSA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzLFxuICAgICAgICAgIHAgPSBsICogMiAtIHE7XG5cbiAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIE1hdGgucm91bmQociAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGcgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChiICogMjU1KSxcbiAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2xhID0gQ29sb3IuZnJvbUhzbDtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSEVYIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiBGRjU1NTVcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21IZXgoY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSEVYIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIGV4OiBGRjU1NTUgb3IgRkY1NTQ0Q0MgKFJHQmEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tSGV4ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICBpZiAoY29sb3IubWF0Y2goQ29sb3IucmVIZXgpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBjb2xvci5zbGljZShjb2xvci5pbmRleE9mKCcjJykgKyAxKSxcbiAgICAgICAgICBpc1Nob3J0Tm90YXRpb24gPSAodmFsdWUubGVuZ3RoID09PSAzIHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgaXNSR0JhID0gKHZhbHVlLmxlbmd0aCA9PT0gOCB8fCB2YWx1ZS5sZW5ndGggPT09IDQpLFxuICAgICAgICAgIHIgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDApICsgdmFsdWUuY2hhckF0KDApKSA6IHZhbHVlLnN1YnN0cmluZygwLCAyKSxcbiAgICAgICAgICBnID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgxKSArIHZhbHVlLmNoYXJBdCgxKSkgOiB2YWx1ZS5zdWJzdHJpbmcoMiwgNCksXG4gICAgICAgICAgYiA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMikgKyB2YWx1ZS5jaGFyQXQoMikpIDogdmFsdWUuc3Vic3RyaW5nKDQsIDYpLFxuICAgICAgICAgIGEgPSBpc1JHQmEgPyAoaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgzKSArIHZhbHVlLmNoYXJBdCgzKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNiwgOCkpIDogJ0ZGJztcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2VJbnQociwgMTYpLFxuICAgICAgICBwYXJzZUludChnLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGIsIDE2KSxcbiAgICAgICAgcGFyc2VGbG9hdCgocGFyc2VJbnQoYSwgMTYpIC8gMjU1KS50b0ZpeGVkKDIpKVxuICAgICAgXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBjb2xvciBpbiBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsyMDAsIDEwMCwgMTAwLCAwLjVdKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tU291cmNlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgdmFyIG9Db2xvciA9IG5ldyBDb2xvcigpO1xuICAgIG9Db2xvci5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICByZXR1cm4gb0NvbG9yO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBzY2FsZU1hcCA9IFsnZScsICdzZScsICdzJywgJ3N3JywgJ3cnLCAnbncnLCAnbicsICduZScsICdlJ10sXG4gICAgICBza2V3TWFwID0gWyducycsICduZXN3JywgJ2V3JywgJ253c2UnXSxcbiAgICAgIGNvbnRyb2xzID0ge30sXG4gICAgICBMRUZUID0gJ2xlZnQnLCBUT1AgPSAndG9wJywgUklHSFQgPSAncmlnaHQnLCBCT1RUT00gPSAnYm90dG9tJywgQ0VOVEVSID0gJ2NlbnRlcicsXG4gICAgICBvcHBvc2l0ZSA9IHtcbiAgICAgICAgdG9wOiBCT1RUT00sXG4gICAgICAgIGJvdHRvbTogVE9QLFxuICAgICAgICBsZWZ0OiBSSUdIVCxcbiAgICAgICAgcmlnaHQ6IExFRlQsXG4gICAgICAgIGNlbnRlcjogQ0VOVEVSLFxuICAgICAgfSwgcmFkaWFuc1RvRGVncmVlcyA9IGZhYnJpYy51dGlsLnJhZGlhbnNUb0RlZ3JlZXMsXG4gICAgICBzaWduID0gKE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4OyB9KTtcblxuICAvKipcbiAgICogQ29tYmluZSBjb250cm9sIHBvc2l0aW9uIGFuZCBvYmplY3QgYW5nbGUgdG8gZmluZCB0aGUgY29udHJvbCBkaXJlY3Rpb24gY29tcGFyZWRcbiAgICogdG8gdGhlIG9iamVjdCBjZW50ZXIuXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgcmVuZGVyaW5nIGNvbnRyb2xzXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgY2xhc3NcbiAgICogQHJldHVybiB7TnVtYmVyfSAwIC0gNyBhIHF1YWRyYW50IG51bWJlclxuICAgKi9cbiAgZnVuY3Rpb24gZmluZENvcm5lclF1YWRyYW50KGZhYnJpY09iamVjdCwgY29udHJvbCkge1xuICAgIHZhciBjb3JuZXJBbmdsZSA9IGZhYnJpY09iamVjdC5hbmdsZSArIHJhZGlhbnNUb0RlZ3JlZXMoTWF0aC5hdGFuMihjb250cm9sLnksIGNvbnRyb2wueCkpICsgMzYwO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChjb3JuZXJBbmdsZSAlIDM2MCkgLyA0NSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIHRhcmdldCA9IG9wdGlvbnMudHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgY2FudmFzID0gdGFyZ2V0LmNhbnZhcyxcbiAgICAgICAgY2FudmFzT3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKTtcbiAgICBjYW52YXNPcHRpb25zLnRhcmdldCA9IHRhcmdldDtcbiAgICBjYW52YXMgJiYgY2FudmFzLmZpcmUoJ29iamVjdDonICsgZXZlbnROYW1lLCBjYW52YXNPcHRpb25zKTtcbiAgICB0YXJnZXQuZmlyZShldmVudE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgZXZlbnQgYW5kIGZhYnJpY09iamVjdCBwcm9wZXJ0aWVzIHRvIHVuZGVyc3RhbmQgaWYgdGhlIHNjYWxpbmcgYWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBmcm9tIHRoZSB1c2VyIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBhYm91dCB0byBzY2FsZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNjYWxlIGlzIHByb3BvcnRpb25hbFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVJc1Byb3BvcnRpb25hbChldmVudERhdGEsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBjYW52YXMgPSBmYWJyaWNPYmplY3QuY2FudmFzLCB1bmlTY2FsZUtleSA9IGNhbnZhcy51bmlTY2FsZUtleSxcbiAgICAgICAgdW5pZm9ybUlzVG9nZ2xlZCA9IGV2ZW50RGF0YVt1bmlTY2FsZUtleV07XG4gICAgcmV0dXJuIChjYW52YXMudW5pZm9ybVNjYWxpbmcgJiYgIXVuaWZvcm1Jc1RvZ2dsZWQpIHx8XG4gICAgKCFjYW52YXMudW5pZm9ybVNjYWxpbmcgJiYgdW5pZm9ybUlzVG9nZ2xlZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRyYW5zZm9ybSBpcyBjZW50ZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIHRyYW5zZm9ybSBkYXRhXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdHJhbnNmb3JtIGlzIGNlbnRlcmVkXG4gICAqL1xuICBmdW5jdGlvbiBpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gQ0VOVEVSICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBDRU5URVI7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCBmYWJyaWNPYmplY3QgdG8gdW5kZXJzdGFuZCBpZiB0aGUgY3VycmVudCBzY2FsaW5nIGFjdGlvbiBpcyBhbGxvd2VkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGFib3V0IHRvIHNjYWxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBieSAneCcgb3IgJ3knIG9yICcnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2NhbGVQcm9wb3J0aW9uYWxseSB0cnVlIGlmIHdlIGFyZSB0cnlpbmcgdG8gc2NhbGUgcHJvcG9ydGlvbmFsbHlcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzY2FsaW5nIGlzIG5vdCBhbGxvd2VkIGF0IGN1cnJlbnQgY29uZGl0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGluZ0lzRm9yYmlkZGVuKGZhYnJpY09iamVjdCwgYnksIHNjYWxlUHJvcG9ydGlvbmFsbHkpIHtcbiAgICB2YXIgbG9ja1ggPSBmYWJyaWNPYmplY3QubG9ja1NjYWxpbmdYLCBsb2NrWSA9IGZhYnJpY09iamVjdC5sb2NrU2NhbGluZ1k7XG4gICAgaWYgKGxvY2tYICYmIGxvY2tZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFieSAmJiAobG9ja1ggfHwgbG9ja1kpICYmIHNjYWxlUHJvcG9ydGlvbmFsbHkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobG9ja1ggJiYgYnkgPT09ICd4Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChsb2NrWSAmJiBieSA9PT0gJ3knKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgY29ycmVjdCBjdXJzb3Igc3R5bGUgZm9yIHRoZSBzY2FsZSBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgbm90QWxsb3dlZCA9ICdub3QtYWxsb3dlZCcsXG4gICAgICAgIHNjYWxlUHJvcG9ydGlvbmFsbHkgPSBzY2FsZUlzUHJvcG9ydGlvbmFsKGV2ZW50RGF0YSwgZmFicmljT2JqZWN0KSxcbiAgICAgICAgYnkgPSAnJztcbiAgICBpZiAoY29udHJvbC54ICE9PSAwICYmIGNvbnRyb2wueSA9PT0gMCkge1xuICAgICAgYnkgPSAneCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2wueCA9PT0gMCAmJiBjb250cm9sLnkgIT09IDApIHtcbiAgICAgIGJ5ID0gJ3knO1xuICAgIH1cbiAgICBpZiAoc2NhbGluZ0lzRm9yYmlkZGVuKGZhYnJpY09iamVjdCwgYnksIHNjYWxlUHJvcG9ydGlvbmFsbHkpKSB7XG4gICAgICByZXR1cm4gbm90QWxsb3dlZDtcbiAgICB9XG4gICAgdmFyIG4gPSBmaW5kQ29ybmVyUXVhZHJhbnQoZmFicmljT2JqZWN0LCBjb250cm9sKTtcbiAgICByZXR1cm4gc2NhbGVNYXBbbl0gKyAnLXJlc2l6ZSc7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBjb3JyZWN0IGN1cnNvciBzdHlsZSBmb3IgdGhlIHNrZXcgYWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgbm90QWxsb3dlZCA9ICdub3QtYWxsb3dlZCc7XG4gICAgaWYgKGNvbnRyb2wueCAhPT0gMCAmJiBmYWJyaWNPYmplY3QubG9ja1NrZXdpbmdZKSB7XG4gICAgICByZXR1cm4gbm90QWxsb3dlZDtcbiAgICB9XG4gICAgaWYgKGNvbnRyb2wueSAhPT0gMCAmJiBmYWJyaWNPYmplY3QubG9ja1NrZXdpbmdYKSB7XG4gICAgICByZXR1cm4gbm90QWxsb3dlZDtcbiAgICB9XG4gICAgdmFyIG4gPSBmaW5kQ29ybmVyUXVhZHJhbnQoZmFicmljT2JqZWN0LCBjb250cm9sKSAlIDQ7XG4gICAgcmV0dXJuIHNrZXdNYXBbbl0gKyAnLXJlc2l6ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZSBza2V3IGFuZCBzY2FsZSBzdHlsZSBoYW5kbGVycyB0byBjb3ZlciBmYWJyaWMgc3RhbmRhcmQgdXNlIGNhc2VcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVTa2V3Q3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgaWYgKGV2ZW50RGF0YVtmYWJyaWNPYmplY3QuY2FudmFzLmFsdEFjdGlvbktleV0pIHtcbiAgICAgIHJldHVybiBjb250cm9scy5za2V3Q3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xzLnNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IGV2ZW50LCBjb250cm9sIGFuZCBmYWJyaWNPYmplY3QgdG8gcmV0dXJuIHRoZSBjb3JyZWN0IGFjdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhbiBhY3Rpb24gbmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPclNrZXdBY3Rpb25OYW1lKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIGlzQWx0ZXJuYXRpdmUgPSBldmVudERhdGFbZmFicmljT2JqZWN0LmNhbnZhcy5hbHRBY3Rpb25LZXldO1xuICAgIGlmIChjb250cm9sLnggPT09IDApIHtcbiAgICAgIC8vIHRoZW4gaXMgc2NhbGVZIG9yIHNrZXdYXG4gICAgICByZXR1cm4gaXNBbHRlcm5hdGl2ZSA/ICdza2V3WCcgOiAnc2NhbGVZJztcbiAgICB9XG4gICAgaWYgKGNvbnRyb2wueSA9PT0gMCkge1xuICAgICAgLy8gdGhlbiBpcyBzY2FsZVkgb3Igc2tld1hcbiAgICAgIHJldHVybiBpc0FsdGVybmF0aXZlID8gJ3NrZXdZJyA6ICdzY2FsZVgnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjb3JyZWN0IHN0eWxlIGZvciB0aGUgY29udHJvbCB0aGF0IGlzIHVzZWQgZm9yIHJvdGF0aW9uLlxuICAgKiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2ltcGxlIGFuZCBpdCBqdXN0IHRha2UgY2FyZSBvZiBub3QtYWxsb3dlZCBvciBzdGFuZGFyZCBjdXJzb3JcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gcm90YXRpb25TdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICBpZiAoZmFicmljT2JqZWN0LmxvY2tSb3RhdGlvbikge1xuICAgICAgcmV0dXJuICdub3QtYWxsb3dlZCc7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sLmN1cnNvclN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGU6IGV2ZW50RGF0YSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgcG9pbnRlcjoge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbiBhY3Rpb24gaGFuZGxlciB3aXRoIHNhdmluZy9yZXN0b3Jpbmcgb2JqZWN0IHBvc2l0aW9uIG9uIHRoZSB0cmFuc2Zvcm0uXG4gICAqIHRoaXMgaXMgdGhlIGNvZGUgdGhhdCBwZXJtaXRzIHRvIG9iamVjdHMgdG8ga2VlcCB0aGVpciBwb3NpdGlvbiB3aGlsZSB0cmFuc2Zvcm1pbmcuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbkhhbmRsZXIgdGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAgICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gd2l0aCBhbiBhY3Rpb24gaGFuZGxlciBzaWduYXR1cmVcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBXaXRoRml4ZWRBbmNob3IoYWN0aW9uSGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGNlbnRlclBvaW50ID0gdGFyZ2V0LmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgY29uc3RyYWludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlclBvaW50LCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblkpLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGFjdGlvbkhhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgdGFyZ2V0LnNldFBvc2l0aW9uQnlPcmlnaW4oY29uc3RyYWludCwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBhY3Rpb25QZXJmb3JtZWQ7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgcG9pbnQgZGVzY3JpYmVkIGJ5IHggYW5kIHkgaW4gYSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG9iamVjdFxuICAgKiBib3VuZGluZyBib3guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbllcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7RmFicmljLlBvaW50fSB0aGUgbm9ybWFsaXplZCBwb2ludFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIG9yaWdpblgsIG9yaWdpblksIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1t0cmFuc2Zvcm0uY29ybmVyXSxcbiAgICAgICAgem9vbSA9IHRhcmdldC5jYW52YXMuZ2V0Wm9vbSgpLFxuICAgICAgICBwYWRkaW5nID0gdGFyZ2V0LnBhZGRpbmcgLyB6b29tLFxuICAgICAgICBsb2NhbFBvaW50ID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHgsIHkpLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICBpZiAobG9jYWxQb2ludC54ID49IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueCAtPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC54IDw9IC1wYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnggKz0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGxvY2FsUG9pbnQueSA+PSBwYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnkgLT0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGxvY2FsUG9pbnQueSA8PSBwYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnkgKz0gcGFkZGluZztcbiAgICB9XG4gICAgbG9jYWxQb2ludC54IC09IGNvbnRyb2wub2Zmc2V0WDtcbiAgICBsb2NhbFBvaW50LnkgLT0gY29udHJvbC5vZmZzZXRZO1xuICAgIHJldHVybiBsb2NhbFBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiB0aGUgZmFicmljIG9iamVjdCBpcyBmbGlwcGVkIG9uIG9uZSBzaWRlLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9uZSBmbGlwLCBidXQgbm90IHR3by5cbiAgICovXG4gIGZ1bmN0aW9uIHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5mbGlwWCAhPT0gdGFyZ2V0LmZsaXBZO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29tcGVuc2F0ZSB0aGUgc2NhbGUgZmFjdG9yIHdoZW4gc2tldyBpcyBhcHBsaWVkIG9uIGJvdGggYXhlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGVuc2F0ZVNjYWxlRm9yU2tldyh0YXJnZXQsIG9wcG9zaXRlU2tldywgc2NhbGVUb0NvbXBlbnNhdGUsIGF4aXMsIHJlZmVyZW5jZSkge1xuICAgIGlmICh0YXJnZXRbb3Bwb3NpdGVTa2V3XSAhPT0gMCkge1xuICAgICAgdmFyIG5ld0RpbSA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKClbYXhpc107XG4gICAgICB2YXIgbmV3VmFsdWUgPSByZWZlcmVuY2UgLyBuZXdEaW0gKiB0YXJnZXRbc2NhbGVUb0NvbXBlbnNhdGVdO1xuICAgICAgdGFyZ2V0LnNldChzY2FsZVRvQ29tcGVuc2F0ZSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWCBheGlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBza2V3T2JqZWN0WChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAvLyBmaW5kIGhvdyBiaWcgdGhlIG9iamVjdCB3b3VsZCBiZSwgaWYgdGhlcmUgd2FzIG5vIHNrZXdYLiB0YWtlcyBpbiBhY2NvdW50IHNjYWxpbmdcbiAgICAgICAgZGltTm9Ta2V3ID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoMCwgdGFyZ2V0LnNrZXdZKSxcbiAgICAgICAgbG9jYWxQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpLFxuICAgICAgICAvLyB0aGUgbW91c2UgaXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0LCBhbmQgd2Ugd2FudCBpdCB0byBzdGF5IHRoZXJlLlxuICAgICAgICAvLyBzbyB0aGUgb2JqZWN0IHdpbGwgZ3JvdyB0d2ljZSBhcyBtdWNoIGFzIHRoZSBtb3VzZS5cbiAgICAgICAgLy8gdGhpcyBtYWtlcyB0aGUgc2tldyBncm93dGggdG8gbG9jYWxQb2ludCAqIDIgLSBkaW1Ob1NrZXcuXG4gICAgICAgIHRvdGFsU2tld1NpemUgPSBNYXRoLmFicyhsb2NhbFBvaW50LnggKiAyKSAtIGRpbU5vU2tldy54LFxuICAgICAgICBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WCwgbmV3U2tldztcbiAgICBpZiAodG90YWxTa2V3U2l6ZSA8IDIpIHtcbiAgICAgIC8vIGxldCdzIG1ha2UgaXQgZWFzeSB0byBnbyBiYWNrIHRvIHBvc2l0aW9uIDAuXG4gICAgICBuZXdTa2V3ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXdTa2V3ID0gcmFkaWFuc1RvRGVncmVlcyhcbiAgICAgICAgTWF0aC5hdGFuMigodG90YWxTa2V3U2l6ZSAvIHRhcmdldC5zY2FsZVgpLCAoZGltTm9Ta2V3LnkgLyB0YXJnZXQuc2NhbGVZKSlcbiAgICAgICk7XG4gICAgICAvLyBub3cgd2UgaGF2ZSB0byBmaW5kIHRoZSBzaWduIG9mIHRoZSBza2V3LlxuICAgICAgLy8gaXQgbW9zdGx5IGRlcGVuZCBvbiB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBMRUZUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBCT1RUT00pIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBSSUdIVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gVE9QKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFzU2tld2VkID0gY3VycmVudFNrZXcgIT09IG5ld1NrZXc7XG4gICAgaWYgKGhhc1NrZXdlZCkge1xuICAgICAgdmFyIGRpbUJlZm9yZVNrZXdpbmcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLnk7XG4gICAgICB0YXJnZXQuc2V0KCdza2V3WCcsIG5ld1NrZXcpO1xuICAgICAgY29tcGVuc2F0ZVNjYWxlRm9yU2tldyh0YXJnZXQsICdza2V3WScsICdzY2FsZVknLCAneScsIGRpbUJlZm9yZVNrZXdpbmcpO1xuICAgICAgZmlyZUV2ZW50KCdza2V3aW5nJywgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNTa2V3ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2tld09iamVjdFkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgLy8gZmluZCBob3cgYmlnIHRoZSBvYmplY3Qgd291bGQgYmUsIGlmIHRoZXJlIHdhcyBubyBza2V3WC4gdGFrZXMgaW4gYWNjb3VudCBzY2FsaW5nXG4gICAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHRhcmdldC5za2V3WCwgMCksXG4gICAgICAgIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgLy8gdGhlIG1vdXNlIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCwgYW5kIHdlIHdhbnQgaXQgdG8gc3RheSB0aGVyZS5cbiAgICAgICAgLy8gc28gdGhlIG9iamVjdCB3aWxsIGdyb3cgdHdpY2UgYXMgbXVjaCBhcyB0aGUgbW91c2UuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgdGhlIHNrZXcgZ3Jvd3RoIHRvIGxvY2FsUG9pbnQgKiAyIC0gZGltTm9Ta2V3LlxuICAgICAgICB0b3RhbFNrZXdTaXplID0gTWF0aC5hYnMobG9jYWxQb2ludC55ICogMikgLSBkaW1Ob1NrZXcueSxcbiAgICAgICAgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1ksIG5ld1NrZXc7XG4gICAgaWYgKHRvdGFsU2tld1NpemUgPCAyKSB7XG4gICAgICAvLyBsZXQncyBtYWtlIGl0IGVhc3kgdG8gZ28gYmFjayB0byBwb3NpdGlvbiAwLlxuICAgICAgbmV3U2tldyA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV3U2tldyA9IHJhZGlhbnNUb0RlZ3JlZXMoXG4gICAgICAgIE1hdGguYXRhbjIoKHRvdGFsU2tld1NpemUgLyB0YXJnZXQuc2NhbGVZKSwgKGRpbU5vU2tldy54IC8gdGFyZ2V0LnNjYWxlWCkpXG4gICAgICApO1xuICAgICAgLy8gbm93IHdlIGhhdmUgdG8gZmluZCB0aGUgc2lnbiBvZiB0aGUgc2tldy5cbiAgICAgIC8vIGl0IG1vc3RseSBkZXBlbmQgb24gdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gTEVGVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gQk9UVE9NKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gUklHSFQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IFRPUCkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhc1NrZXdlZCA9IGN1cnJlbnRTa2V3ICE9PSBuZXdTa2V3O1xuICAgIGlmIChoYXNTa2V3ZWQpIHtcbiAgICAgIHZhciBkaW1CZWZvcmVTa2V3aW5nID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS54O1xuICAgICAgdGFyZ2V0LnNldCgnc2tld1knLCBuZXdTa2V3KTtcbiAgICAgIGNvbXBlbnNhdGVTY2FsZUZvclNrZXcodGFyZ2V0LCAnc2tld1gnLCAnc2NhbGVYJywgJ3gnLCBkaW1CZWZvcmVTa2V3aW5nKTtcbiAgICAgIGZpcmVFdmVudCgnc2tld2luZycsIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzU2tld2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZWQgQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpcywgdGFrZXMgY2FyZSBvZiB0aGVcbiAgICogc2tldyBkaXJlY3Rpb24gYW5kIGRldGVybWluZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gb3JpZ2luIGZvciB0aGUgYW5jaG9yIHBvaW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0hhbmRsZXJYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gc3RlcDEgZmlndXJlIG91dCBhbmQgY2hhbmdlIHRyYW5zZm9ybSBvcmlnaW4uXG4gICAgLy8gaWYgc2tld1ggPiAwIGFuZCBvcmlnaW5ZIGJvdHRvbSB3ZSBhbmNob3Igb24gcmlnaHRcbiAgICAvLyBpZiBza2V3WCA+IDAgYW5kIG9yaWdpblkgdG9wIHdlIGFuY2hvciBvbiBsZWZ0XG4gICAgLy8gaWYgc2tld1ggPCAwIGFuZCBvcmlnaW5ZIGJvdHRvbSB3ZSBhbmNob3Igb24gbGVmdFxuICAgIC8vIGlmIHNrZXdYIDwgMCBhbmQgb3JpZ2luWSB0b3Agd2UgYW5jaG9yIG9uIHJpZ2h0XG4gICAgLy8gaWYgc2tld1ggaXMgMCwgd2UgbG9vayBmb3IgbW91c2UgcG9zaXRpb24gdG8gdW5kZXJzdGFuZCB3aGVyZSBhcmUgd2UgZ29pbmcuXG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdYLCBvcmlnaW5YLCBvcmlnaW5ZID0gdHJhbnNmb3JtLm9yaWdpblk7XG4gICAgaWYgKHRhcmdldC5sb2NrU2tld2luZ1gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRTa2V3ID09PSAwKSB7XG4gICAgICB2YXIgbG9jYWxQb2ludEZyb21DZW50ZXIgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgQ0VOVEVSLCBDRU5URVIsIHgsIHkpO1xuICAgICAgaWYgKGxvY2FsUG9pbnRGcm9tQ2VudGVyLnggPiAwKSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHJpZ2h0LCBhbmNob3IgbGVmdDtcbiAgICAgICAgb3JpZ2luWCA9IExFRlQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgcmlnaHQsIGFuY2hvciByaWdodFxuICAgICAgICBvcmlnaW5YID0gUklHSFQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnRTa2V3ID4gMCkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWSA9PT0gVE9QID8gTEVGVCA6IFJJR0hUO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRTa2V3IDwgMCkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWSA9PT0gVE9QID8gUklHSFQgOiBMRUZUO1xuICAgICAgfVxuICAgICAgLy8gaXMgdGhlIG9iamVjdCBmbGlwcGVkIG9uIG9uZSBzaWRlIG9ubHk/IHN3YXAgdGhlIG9yaWdpbi5cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgb3JpZ2luWCA9IG9yaWdpblggPT09IExFRlQgPyBSSUdIVCA6IExFRlQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb25jZSB3ZSBoYXZlIHRoZSBvcmlnaW4sIHdlIGZpbmQgdGhlIGFuY2hvciBwb2ludFxuICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gb3JpZ2luWDtcbiAgICB2YXIgZmluYWxIYW5kbGVyID0gd3JhcFdpdGhGaXhlZEFuY2hvcihza2V3T2JqZWN0WCk7XG4gICAgcmV0dXJuIGZpbmFsSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlZCBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzLCB0YWtlcyBjYXJlIG9mIHRoZVxuICAgKiBza2V3IGRpcmVjdGlvbiBhbmQgZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4gZm9yIHRoZSBhbmNob3IgcG9pbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBza2V3SGFuZGxlclkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBzdGVwMSBmaWd1cmUgb3V0IGFuZCBjaGFuZ2UgdHJhbnNmb3JtIG9yaWdpbi5cbiAgICAvLyBpZiBza2V3WSA+IDAgYW5kIG9yaWdpblggbGVmdCB3ZSBhbmNob3Igb24gdG9wXG4gICAgLy8gaWYgc2tld1kgPiAwIGFuZCBvcmlnaW5YIHJpZ2h0IHdlIGFuY2hvciBvbiBib3R0b21cbiAgICAvLyBpZiBza2V3WSA8IDAgYW5kIG9yaWdpblggbGVmdCB3ZSBhbmNob3Igb24gYm90dG9tXG4gICAgLy8gaWYgc2tld1kgPCAwIGFuZCBvcmlnaW5YIHJpZ2h0IHdlIGFuY2hvciBvbiB0b3BcbiAgICAvLyBpZiBza2V3WSBpcyAwLCB3ZSBsb29rIGZvciBtb3VzZSBwb3NpdGlvbiB0byB1bmRlcnN0YW5kIHdoZXJlIGFyZSB3ZSBnb2luZy5cbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1ksIG9yaWdpblksIG9yaWdpblggPSB0cmFuc2Zvcm0ub3JpZ2luWDtcbiAgICBpZiAodGFyZ2V0LmxvY2tTa2V3aW5nWSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFNrZXcgPT09IDApIHtcbiAgICAgIHZhciBsb2NhbFBvaW50RnJvbUNlbnRlciA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCBDRU5URVIsIENFTlRFUiwgeCwgeSk7XG4gICAgICBpZiAobG9jYWxQb2ludEZyb21DZW50ZXIueSA+IDApIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgZG93biwgYW5jaG9yIHVwO1xuICAgICAgICBvcmlnaW5ZID0gVE9QO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHVwLCBhbmNob3IgZG93blxuICAgICAgICBvcmlnaW5ZID0gQk9UVE9NO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50U2tldyA+IDApIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblggPT09IExFRlQgPyBUT1AgOiBCT1RUT007XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFNrZXcgPCAwKSB7XG4gICAgICAgIG9yaWdpblkgPSBvcmlnaW5YID09PSBMRUZUID8gQk9UVE9NIDogVE9QO1xuICAgICAgfVxuICAgICAgLy8gaXMgdGhlIG9iamVjdCBmbGlwcGVkIG9uIG9uZSBzaWRlIG9ubHk/IHN3YXAgdGhlIG9yaWdpbi5cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblkgPT09IFRPUCA/IEJPVFRPTSA6IFRPUDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmNlIHdlIGhhdmUgdGhlIG9yaWdpbiwgd2UgZmluZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdHJhbnNmb3JtLm9yaWdpblkgPSBvcmlnaW5ZO1xuICAgIHZhciBmaW5hbEhhbmRsZXIgPSB3cmFwV2l0aEZpeGVkQW5jaG9yKHNrZXdPYmplY3RZKTtcbiAgICByZXR1cm4gZmluYWxIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igcm90YXRpb24gYW5kIHNuYXBwaW5nLCB3aXRob3V0IGFuY2hvciBwb2ludC5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByb3RhdGlvbldpdGhTbmFwcGluZyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0ID0gdHJhbnNmb3JtLFxuICAgICAgICB0YXJnZXQgPSB0LnRhcmdldCxcbiAgICAgICAgcGl2b3RQb2ludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG5cbiAgICBpZiAodGFyZ2V0LmxvY2tSb3RhdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsYXN0QW5nbGUgPSBNYXRoLmF0YW4yKHQuZXkgLSBwaXZvdFBvaW50LnksIHQuZXggLSBwaXZvdFBvaW50LngpLFxuICAgICAgICBjdXJBbmdsZSA9IE1hdGguYXRhbjIoeSAtIHBpdm90UG9pbnQueSwgeCAtIHBpdm90UG9pbnQueCksXG4gICAgICAgIGFuZ2xlID0gcmFkaWFuc1RvRGVncmVlcyhjdXJBbmdsZSAtIGxhc3RBbmdsZSArIHQudGhldGEpLFxuICAgICAgICBoYXNSb3RhdGVkID0gdHJ1ZTtcblxuICAgIGlmICh0YXJnZXQuc25hcEFuZ2xlID4gMCkge1xuICAgICAgdmFyIHNuYXBBbmdsZSAgPSB0YXJnZXQuc25hcEFuZ2xlLFxuICAgICAgICAgIHNuYXBUaHJlc2hvbGQgID0gdGFyZ2V0LnNuYXBUaHJlc2hvbGQgfHwgc25hcEFuZ2xlLFxuICAgICAgICAgIHJpZ2h0QW5nbGVMb2NrZWQgPSBNYXRoLmNlaWwoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlLFxuICAgICAgICAgIGxlZnRBbmdsZUxvY2tlZCA9IE1hdGguZmxvb3IoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoYW5nbGUgLSBsZWZ0QW5nbGVMb2NrZWQpIDwgc25hcFRocmVzaG9sZCkge1xuICAgICAgICBhbmdsZSA9IGxlZnRBbmdsZUxvY2tlZDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGFuZ2xlIC0gcmlnaHRBbmdsZUxvY2tlZCkgPCBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIGFuZ2xlID0gcmlnaHRBbmdsZUxvY2tlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgYW5nbGUgdG8gcG9zaXRpdmUgdmFsdWVcbiAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICBhbmdsZSA9IDM2MCArIGFuZ2xlO1xuICAgIH1cbiAgICBhbmdsZSAlPSAzNjA7XG5cbiAgICBoYXNSb3RhdGVkID0gdGFyZ2V0LmFuZ2xlICE9PSBhbmdsZTtcbiAgICB0YXJnZXQuYW5nbGUgPSBhbmdsZTtcbiAgICBpZiAoaGFzUm90YXRlZCkge1xuICAgICAgZmlyZUV2ZW50KCdyb3RhdGluZycsIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUm90YXRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNpYyBzY2FsaW5nIGxvZ2ljLCByZXVzZWQgd2l0aCBkaWZmZXJlbnQgY29uc3RyYWluIGZvciBzY2FsaW5nIFgsWSwgZnJlZWx5IG9yIGVxdWFsbHkuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3Igc2NhbGluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ieSAneCcsICd5JywgJ2VxdWFsbHknIG9yICcnIHRvIGluZGljYXRlIHR5cGUgb2Ygc2NhbGluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBsb2NrU2NhbGluZ1ggPSB0YXJnZXQubG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1kgPSB0YXJnZXQubG9ja1NjYWxpbmdZLFxuICAgICAgICBieSA9IG9wdGlvbnMuYnksIG5ld1BvaW50LCBzY2FsZVgsIHNjYWxlWSwgZGltLFxuICAgICAgICBzY2FsZVByb3BvcnRpb25hbGx5ID0gc2NhbGVJc1Byb3BvcnRpb25hbChldmVudERhdGEsIHRhcmdldCksXG4gICAgICAgIGZvcmJpZFNjYWxpbmcgPSBzY2FsaW5nSXNGb3JiaWRkZW4odGFyZ2V0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSksXG4gICAgICAgIHNpZ25YLCBzaWduWSwgZ2VzdHVyZVNjYWxlID0gdHJhbnNmb3JtLmdlc3R1cmVTY2FsZTtcblxuICAgIGlmIChmb3JiaWRTY2FsaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChnZXN0dXJlU2NhbGUpIHtcbiAgICAgIHNjYWxlWCA9IHRyYW5zZm9ybS5zY2FsZVggKiBnZXN0dXJlU2NhbGU7XG4gICAgICBzY2FsZVkgPSB0cmFuc2Zvcm0uc2NhbGVZICogZ2VzdHVyZVNjYWxlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld1BvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSk7XG4gICAgICAvLyB1c2Ugb2Ygc2lnbjogV2UgdXNlIHNpZ24gdG8gZGV0ZWN0IGNoYW5nZSBvZiBkaXJlY3Rpb24gb2YgYW4gYWN0aW9uLiBzaWduIHVzdWFsbHkgY2hhbmdlIHdoZW5cbiAgICAgIC8vIHdlIGNyb3NzIHRoZSBvcmlnaW4gcG9pbnQgd2l0aCB0aGUgbW91c2UuIFNvIGEgc2NhbGUgZmxpcCBmb3IgZXhhbXBsZS4gVGhlcmUgaXMgYW4gaXNzdWUgd2hlbiBzY2FsaW5nXG4gICAgICAvLyBieSBjZW50ZXIgYW5kIHNjYWxpbmcgdXNpbmcgb25lIG1pZGRsZSBjb250cm9sICggZGVmYXVsdDogbXIsIG10LCBtbCwgbWIpLCB0aGUgbW91c2UgbW92ZW1lbnQgY2FuIGVhc2lseVxuICAgICAgLy8gY3Jvc3MgbWFueSB0aW1lIHRoZSBvcmlnaW4gcG9pbnQgYW5kIGZsaXAgdGhlIG9iamVjdC4gc28gd2UgbmVlZCBhIHdheSB0byBmaWx0ZXIgb3V0IHRoZSBub2lzZS5cbiAgICAgIC8vIFRoaXMgdGVybmFyeSBoZXJlIHNob3VsZCBiZSBvayB0byBmaWx0ZXIgb3V0IFggc2NhbGluZyB3aGVuIHdlIHdhbnQgWSBvbmx5IGFuZCB2aWNlIHZlcnNhLlxuICAgICAgc2lnblggPSBieSAhPT0gJ3knID8gc2lnbihuZXdQb2ludC54KSA6IDE7XG4gICAgICBzaWduWSA9IGJ5ICE9PSAneCcgPyBzaWduKG5ld1BvaW50LnkpIDogMTtcbiAgICAgIGlmICghdHJhbnNmb3JtLnNpZ25YKSB7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWCA9IHNpZ25YO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc2Zvcm0uc2lnblkpIHtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25ZID0gc2lnblk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQubG9ja1NjYWxpbmdGbGlwICYmXG4gICAgICAgICh0cmFuc2Zvcm0uc2lnblggIT09IHNpZ25YIHx8IHRyYW5zZm9ybS5zaWduWSAhPT0gc2lnblkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBkaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgLy8gbWlzc2luZyBkZXRlY3Rpb24gb2YgZmxpcCBhbmQgbG9naWMgdG8gc3dpdGNoIHRoZSBvcmlnaW5cbiAgICAgIGlmIChzY2FsZVByb3BvcnRpb25hbGx5ICYmICFieSkge1xuICAgICAgICAvLyB1bmlmb3JtIHNjYWxpbmdcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMobmV3UG9pbnQueCkgKyBNYXRoLmFicyhuZXdQb2ludC55KSxcbiAgICAgICAgICAgIG9yaWdpbmFsID0gdHJhbnNmb3JtLm9yaWdpbmFsLFxuICAgICAgICAgICAgb3JpZ2luYWxEaXN0YW5jZSA9IE1hdGguYWJzKGRpbS54ICogb3JpZ2luYWwuc2NhbGVYIC8gdGFyZ2V0LnNjYWxlWCkgK1xuICAgICAgICAgICAgICBNYXRoLmFicyhkaW0ueSAqIG9yaWdpbmFsLnNjYWxlWSAvIHRhcmdldC5zY2FsZVkpLFxuICAgICAgICAgICAgc2NhbGUgPSBkaXN0YW5jZSAvIG9yaWdpbmFsRGlzdGFuY2UsIGhhc1NjYWxlZDtcbiAgICAgICAgc2NhbGVYID0gb3JpZ2luYWwuc2NhbGVYICogc2NhbGU7XG4gICAgICAgIHNjYWxlWSA9IG9yaWdpbmFsLnNjYWxlWSAqIHNjYWxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNjYWxlWCA9IE1hdGguYWJzKG5ld1BvaW50LnggKiB0YXJnZXQuc2NhbGVYIC8gZGltLngpO1xuICAgICAgICBzY2FsZVkgPSBNYXRoLmFicyhuZXdQb2ludC55ICogdGFyZ2V0LnNjYWxlWSAvIGRpbS55KTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGFyZSBzY2FsaW5nIGJ5IGNlbnRlciwgd2UgbmVlZCB0byBkb3VibGUgdGhlIHNjYWxlXG4gICAgICBpZiAoaXNUcmFuc2Zvcm1DZW50ZXJlZCh0cmFuc2Zvcm0pKSB7XG4gICAgICAgIHNjYWxlWCAqPSAyO1xuICAgICAgICBzY2FsZVkgKj0gMjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0uc2lnblggIT09IHNpZ25YICYmIGJ5ICE9PSAneScpIHtcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblggPSBvcHBvc2l0ZVt0cmFuc2Zvcm0ub3JpZ2luWF07XG4gICAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25YID0gc2lnblg7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLnNpZ25ZICE9PSBzaWduWSAmJiBieSAhPT0gJ3gnKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gb3Bwb3NpdGVbdHJhbnNmb3JtLm9yaWdpblldO1xuICAgICAgICBzY2FsZVkgKj0gLTE7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWSA9IHNpZ25ZO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBtaW5TY2FsZSBpcyB0YWtlbiBhcmUgaW4gdGhlIHNldHRlci5cbiAgICB2YXIgb2xkU2NhbGVYID0gdGFyZ2V0LnNjYWxlWCwgb2xkU2NhbGVZID0gdGFyZ2V0LnNjYWxlWTtcbiAgICBpZiAoIWJ5KSB7XG4gICAgICAhbG9ja1NjYWxpbmdYICYmIHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCk7XG4gICAgICAhbG9ja1NjYWxpbmdZICYmIHRhcmdldC5zZXQoJ3NjYWxlWScsIHNjYWxlWSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZm9yYmlkZGVuIGNhc2VzIGFscmVhZHkgaGFuZGxlZCBvbiB0b3AgaGVyZS5cbiAgICAgIGJ5ID09PSAneCcgJiYgdGFyZ2V0LnNldCgnc2NhbGVYJywgc2NhbGVYKTtcbiAgICAgIGJ5ID09PSAneScgJiYgdGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKTtcbiAgICB9XG4gICAgaGFzU2NhbGVkID0gb2xkU2NhbGVYICE9PSB0YXJnZXQuc2NhbGVYIHx8IG9sZFNjYWxlWSAhPT0gdGFyZ2V0LnNjYWxlWTtcbiAgICBpZiAoaGFzU2NhbGVkKSB7XG4gICAgICBmaXJlRXZlbnQoJ3NjYWxpbmcnLCBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1NjYWxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmljIHNjYWxpbmcgbG9naWMsIHRvIHNjYWxlIGZyb20gY29ybmVycyBlaXRoZXIgZXF1YWxseSBvciBmcmVlbHkuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RGcm9tQ29ybmVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsaW5nIGxvZ2ljIGZvciB0aGUgWCBheGlzLlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0WChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSAsIHsgYnk6ICd4JyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsaW5nIGxvZ2ljIGZvciB0aGUgWSBheGlzLlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0WShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSAsIHsgYnk6ICd5JyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wb3NlZCBhY3Rpb24gaGFuZGxlciB0byBlaXRoZXIgc2NhbGUgWSBvciBza2V3IFhcbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsaW5nWU9yU2tld2luZ1goZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBvayBzb21lIHNhZmV0eSBuZWVkZWQgaGVyZS5cbiAgICBpZiAoZXZlbnREYXRhW3RyYW5zZm9ybS50YXJnZXQuY2FudmFzLmFsdEFjdGlvbktleV0pIHtcbiAgICAgIHJldHVybiBjb250cm9scy5za2V3SGFuZGxlclgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbHMuc2NhbGluZ1koZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2VkIGFjdGlvbiBoYW5kbGVyIHRvIGVpdGhlciBzY2FsZSBYIG9yIHNrZXcgWVxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdYT3JTa2V3aW5nWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIG9rIHNvbWUgc2FmZXR5IG5lZWRlZCBoZXJlLlxuICAgIGlmIChldmVudERhdGFbdHJhbnNmb3JtLnRhcmdldC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdIYW5kbGVyWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsaW5nWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgdG8gY2hhbmdlIHRleHRib3ggd2lkdGhcbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBjaGFuZ2VXaWR0aChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBsb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSksXG4gICAgICAgIHN0cm9rZVBhZGRpbmcgPSB0YXJnZXQuc3Ryb2tlV2lkdGggLyAodGFyZ2V0LnN0cm9rZVVuaWZvcm0gPyB0YXJnZXQuc2NhbGVYIDogMSksXG4gICAgICAgIG11bHRpcGxpZXIgPSBpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkgPyAyIDogMSxcbiAgICAgICAgb2xkV2lkdGggPSB0YXJnZXQud2lkdGgsIGhhc1Jlc2l6ZWQsXG4gICAgICAgIG5ld1dpZHRoID0gTWF0aC5hYnMobG9jYWxQb2ludC54ICogbXVsdGlwbGllciAvIHRhcmdldC5zY2FsZVgpIC0gc3Ryb2tlUGFkZGluZztcbiAgICB0YXJnZXQuc2V0KCd3aWR0aCcsIE1hdGgubWF4KG5ld1dpZHRoLCAwKSk7XG4gICAgaGFzUmVzaXplZCA9IG9sZFdpZHRoICE9PSBuZXdXaWR0aDtcbiAgICBpZiAoaGFzUmVzaXplZCkge1xuICAgICAgZmlyZUV2ZW50KCdyZXNpemluZycsIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUmVzaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zbGF0aW9uIG9jY3VycmVkXG4gICAqL1xuICBmdW5jdGlvbiBkcmFnSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBuZXdMZWZ0ID0geCAtIHRyYW5zZm9ybS5vZmZzZXRYLFxuICAgICAgICBuZXdUb3AgPSB5IC0gdHJhbnNmb3JtLm9mZnNldFksXG4gICAgICAgIG1vdmVYID0gIXRhcmdldC5nZXQoJ2xvY2tNb3ZlbWVudFgnKSAmJiB0YXJnZXQubGVmdCAhPT0gbmV3TGVmdCxcbiAgICAgICAgbW92ZVkgPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WScpICYmIHRhcmdldC50b3AgIT09IG5ld1RvcDtcbiAgICBtb3ZlWCAmJiB0YXJnZXQuc2V0KCdsZWZ0JywgbmV3TGVmdCk7XG4gICAgbW92ZVkgJiYgdGFyZ2V0LnNldCgndG9wJywgbmV3VG9wKTtcbiAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgIGZpcmVFdmVudCgnbW92aW5nJywgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlWCB8fCBtb3ZlWTtcbiAgfVxuXG4gIGNvbnRyb2xzLnNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyID0gc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnNrZXdDdXJzb3JTdHlsZUhhbmRsZXIgPSBza2V3Q3Vyc29yU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5zY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIgPSBzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnJvdGF0aW9uV2l0aFNuYXBwaW5nID0gd3JhcFdpdGhGaXhlZEFuY2hvcihyb3RhdGlvbldpdGhTbmFwcGluZyk7XG4gIGNvbnRyb2xzLnNjYWxpbmdFcXVhbGx5ID0gd3JhcFdpdGhGaXhlZEFuY2hvcihzY2FsZU9iamVjdEZyb21Db3JuZXIpO1xuICBjb250cm9scy5zY2FsaW5nWCA9IHdyYXBXaXRoRml4ZWRBbmNob3Ioc2NhbGVPYmplY3RYKTtcbiAgY29udHJvbHMuc2NhbGluZ1kgPSB3cmFwV2l0aEZpeGVkQW5jaG9yKHNjYWxlT2JqZWN0WSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdZT3JTa2V3aW5nWCA9IHNjYWxpbmdZT3JTa2V3aW5nWDtcbiAgY29udHJvbHMuc2NhbGluZ1hPclNrZXdpbmdZID0gc2NhbGluZ1hPclNrZXdpbmdZO1xuICBjb250cm9scy5jaGFuZ2VXaWR0aCA9IHdyYXBXaXRoRml4ZWRBbmNob3IoY2hhbmdlV2lkdGgpO1xuICBjb250cm9scy5za2V3SGFuZGxlclggPSBza2V3SGFuZGxlclg7XG4gIGNvbnRyb2xzLnNrZXdIYW5kbGVyWSA9IHNrZXdIYW5kbGVyWTtcbiAgY29udHJvbHMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgY29udHJvbHMuc2NhbGVPclNrZXdBY3Rpb25OYW1lID0gc2NhbGVPclNrZXdBY3Rpb25OYW1lO1xuICBjb250cm9scy5yb3RhdGlvblN0eWxlSGFuZGxlciA9IHJvdGF0aW9uU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5maXJlRXZlbnQgPSBmaXJlRXZlbnQ7XG4gIGNvbnRyb2xzLndyYXBXaXRoRml4ZWRBbmNob3IgPSB3cmFwV2l0aEZpeGVkQW5jaG9yO1xuICBjb250cm9scy5nZXRMb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludDtcbiAgZmFicmljLmNvbnRyb2xzVXRpbHMgPSBjb250cm9scztcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBjb250cm9scyA9IGZhYnJpYy5jb250cm9sc1V0aWxzO1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSByb3VuZCBjb250cm9sLCBhcyBwZXIgZmFicmljIGZlYXR1cmVzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gdG8gcmVzcGVjdCBvYmplY3QgcHJvcGVydGllcyBsaWtlIHRyYW5zcGFyZW50Q29ybmVycywgY29ybmVyU2l6ZVxuICAgKiBjb3JuZXJDb2xvciwgY29ybmVyU3Ryb2tlQ29sb3JcbiAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG92ZXJyaWRlIGZvciBmYWJyaWMuT2JqZWN0IGNvbnRyb2xzIHN0eWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgcmVuZGVyaW5nIGNvbnRyb2xzXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJDaXJjbGVDb250cm9sIChjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgdmFyIHhTaXplID0gdGhpcy5zaXplWCB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHlTaXplID0gdGhpcy5zaXplWSB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzIDogdGhpcy50cmFuc3BhcmVudENvcm5lcnMsXG4gICAgICAgIG1ldGhvZE5hbWUgPSB0cmFuc3BhcmVudENvcm5lcnMgPyAnc3Ryb2tlJyA6ICdmaWxsJyxcbiAgICAgICAgc3Ryb2tlID0gIXRyYW5zcGFyZW50Q29ybmVycyAmJiAoc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3IpLFxuICAgICAgICBteUxlZnQgPSBsZWZ0LFxuICAgICAgICBteVRvcCA9IHRvcCwgc2l6ZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lckNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAvLyBhcyBzb29uIGFzIGZhYnJpYyByZWFjdCB2NSwgcmVtb3ZlIGllMTEsIHVzZSBwcm9wZXIgZWxsaXBzZSBjb2RlLlxuICAgIGlmICh4U2l6ZSA+IHlTaXplKSB7XG4gICAgICBzaXplID0geFNpemU7XG4gICAgICBjdHguc2NhbGUoMS4wLCB5U2l6ZSAvIHhTaXplKTtcbiAgICAgIG15VG9wID0gdG9wICogeFNpemUgLyB5U2l6ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeVNpemUgPiB4U2l6ZSkge1xuICAgICAgc2l6ZSA9IHlTaXplO1xuICAgICAgY3R4LnNjYWxlKHhTaXplIC8geVNpemUsIDEuMCk7XG4gICAgICBteUxlZnQgPSBsZWZ0ICogeVNpemUgLyB4U2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzaXplID0geFNpemU7XG4gICAgfVxuICAgIC8vIHRoaXMgaXMgc3RpbGwgd3JvbmdcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhteUxlZnQsIG15VG9wLCBzaXplIC8gMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBjdHhbbWV0aG9kTmFtZV0oKTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgc3F1YXJlIGNvbnRyb2wsIGFzIHBlciBmYWJyaWMgZmVhdHVyZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgd3JpdHRlbiB0byByZXNwZWN0IG9iamVjdCBwcm9wZXJ0aWVzIGxpa2UgdHJhbnNwYXJlbnRDb3JuZXJzLCBjb3JuZXJTaXplXG4gICAqIGNvcm5lckNvbG9yLCBjb3JuZXJTdHJva2VDb2xvclxuICAgKiBwbHVzIHRoZSBhZGRpdGlvbiBvZiBvZmZzZXRZIGFuZCBvZmZzZXRYLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb3ZlcnJpZGUgZm9yIGZhYnJpYy5PYmplY3QgY29udHJvbHMgc3R5bGVcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlclNxdWFyZUNvbnRyb2woY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCkge1xuICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgIHZhciB4U2l6ZSA9IHRoaXMuc2l6ZVggfHwgc3R5bGVPdmVycmlkZS5jb3JuZXJTaXplIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTaXplLFxuICAgICAgICB5U2l6ZSA9IHRoaXMuc2l6ZVkgfHwgc3R5bGVPdmVycmlkZS5jb3JuZXJTaXplIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTaXplLFxuICAgICAgICB0cmFuc3BhcmVudENvcm5lcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyA6IGZhYnJpY09iamVjdC50cmFuc3BhcmVudENvcm5lcnMsXG4gICAgICAgIG1ldGhvZE5hbWUgPSB0cmFuc3BhcmVudENvcm5lcnMgPyAnc3Ryb2tlJyA6ICdmaWxsJyxcbiAgICAgICAgc3Ryb2tlID0gIXRyYW5zcGFyZW50Q29ybmVycyAmJiAoXG4gICAgICAgICAgc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3JcbiAgICAgICAgKSwgeFNpemVCeTIgPSB4U2l6ZSAvIDIsIHlTaXplQnkyID0geVNpemUgLyAyO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lckNvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuc3Ryb2tlQ29ybmVyQ29sb3IgfHwgZmFicmljT2JqZWN0LnN0cm9rZUNvcm5lckNvbG9yO1xuICAgIC8vIHRoaXMgaXMgc3RpbGwgd3JvbmdcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHgudHJhbnNsYXRlKGxlZnQsIHRvcCk7XG4gICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKGZhYnJpY09iamVjdC5hbmdsZSkpO1xuICAgIC8vIHRoaXMgZG9lcyBub3Qgd29yaywgYW5kIGZpeGVkIHdpdGggKCAmJiApIGRvZXMgbm90IG1ha2Ugc2Vuc2UuXG4gICAgLy8gdG8gaGF2ZSByZWFsIHRyYW5zcGFyZW50IGNvcm5lcnMgd2UgbmVlZCB0aGUgY29udHJvbHMgb24gdXBwZXJDYW52YXNcbiAgICAvLyB0cmFuc3BhcmVudENvcm5lcnMgfHwgY3R4LmNsZWFyUmVjdCgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICBjdHhbbWV0aG9kTmFtZSArICdSZWN0J10oLXhTaXplQnkyLCAteVNpemVCeTIsIHhTaXplLCB5U2l6ZSk7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY3R4LnN0cm9rZVJlY3QoLXhTaXplQnkyLCAteVNpemVCeTIsIHhTaXplLCB5U2l6ZSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBjb250cm9scy5yZW5kZXJDaXJjbGVDb250cm9sID0gcmVuZGVyQ2lyY2xlQ29udHJvbDtcbiAgY29udHJvbHMucmVuZGVyU3F1YXJlQ29udHJvbCA9IHJlbmRlclNxdWFyZUNvbnRyb2w7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBmdW5jdGlvbiBDb250cm9sKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXNbaV0gPSBvcHRpb25zW2ldO1xuICAgIH1cbiAgfVxuXG4gIGZhYnJpYy5Db250cm9sID0gQ29udHJvbDtcblxuICBmYWJyaWMuQ29udHJvbC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Db250cm9sLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBrZWVwIHRyYWNrIG9mIGNvbnRyb2wgdmlzaWJpbGl0eS5cbiAgICAgKiBtYWlubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICogaWYgeW91IGRvIG5vdCB3YW50IHRvIHNlZSBhIGNvbnRyb2wsIHlvdSBjYW4gcmVtb3ZlIGl0XG4gICAgICogZnJvbSB0aGUgY29udHJvbHNldC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdmlzaWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGFjdGlvbiB0aGF0IHRoZSBjb250cm9sIHdpbGwgbGlrZWx5IGV4ZWN1dGUuXG4gICAgICogVGhpcyBpcyBvcHRpb25hbC4gRmFicmljSlMgdXNlcyB0byBpZGVudGlmeSB3aGF0IHRoZSB1c2VyIGlzIGRvaW5nIGZvciBzb21lXG4gICAgICogZXh0cmEgb3B0aW1pemF0aW9ucy4gSWYgeW91IGFyZSB3cml0aW5nIGEgY3VzdG9tIGNvbnRyb2wgYW5kIHlvdSB3YW50IHRvIGtub3dcbiAgICAgKiBzb21ld2hlcmUgZWxzZSBpbiB0aGUgY29kZSB3aGF0IGlzIGdvaW5nIG9uLCB5b3UgY2FuIHVzZSB0aGlzIHN0cmluZyBoZXJlLlxuICAgICAqIHlvdSBjYW4gYWxzbyBwcm92aWRlIGEgY3VzdG9tIGdldEFjdGlvbk5hbWUgaWYgeW91ciBjb250cm9sIHJ1biBtdWx0aXBsZSBhY3Rpb25zXG4gICAgICogZGVwZW5kaW5nIG9uIHNvbWUgZXh0ZXJuYWwgc3RhdGUuXG4gICAgICogZGVmYXVsdCB0byBzY2FsZSBzaW5jZSBpcyB0aGUgbW9zdCBjb21tb24sIHVzZWQgb24gNCBjb3JuZXJzIGJ5IGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdzY2FsZSdcbiAgICAgKi9cbiAgICBhY3Rpb25OYW1lOiAnc2NhbGUnLFxuXG4gICAgLyoqXG4gICAgICogRHJhd2luZyBhbmdsZSBvZiB0aGUgY29udHJvbC5cbiAgICAgKiBOT1QgdXNlZCBmb3Igbm93LCBidXQgbmFtZSBtYXJrZWQgYXMgbmVlZGVkIGZvciBpbnRlcm5hbCBsb2dpY1xuICAgICAqIGV4YW1wbGU6IHRvIHJldXNlIHRoZSBzYW1lIGRyYXdpbmcgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCByb3RhdGVkIGNvbnRyb2xzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgYW5nbGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC4gWFxuICAgICAqIDAsMCBpcyB0aGUgY2VudGVyIG9mIHRoZSBPYmplY3QsIHdoaWxlIC0wLjUgKGxlZnQpIG9yIDAuNSAocmlnaHQpIGFyZSB0aGUgZXh0cmVtaXRpZXNcbiAgICAgKiBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC4gWVxuICAgICAqIDAsMCBpcyB0aGUgY2VudGVyIG9mIHRoZSBPYmplY3QsIHdoaWxlIC0wLjUgKHRvcCkgb3IgMC41IChib3R0b20pIGFyZSB0aGUgZXh0cmVtaXRpZXNcbiAgICAgKiBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIG9mZnNldCBvZiB0aGUgY29udHJvbCBmcm9tIHRoZSBkZWZpbmVkIHBvc2l0aW9uLiBJbiBwaXhlbHNcbiAgICAgKiBQb3NpdGl2ZSBvZmZzZXQgbW92ZXMgdGhlIGNvbnRyb2wgdG8gdGhlIHJpZ2h0LCBuZWdhdGl2ZSB0byB0aGUgbGVmdC5cbiAgICAgKiBJdCB1c2VkIHdoZW4geW91IHdhbnQgdG8gaGF2ZSBwb3NpdGlvbiBvZiBjb250cm9sIHRoYXQgZG9lcyBub3Qgc2NhbGUgd2l0aFxuICAgICAqIHRoZSBib3VuZGluZyBib3guIEV4YW1wbGU6IHJvdGF0aW9uIGNvbnRyb2wgaXMgcGxhY2VkIGF0IHg6MCwgeTogMC41IG9uXG4gICAgICogdGhlIGJvdW5kaW5kYm94LCB3aXRoIGFuIG9mZnNldCBvZiAzMCBwaXhlbHMgdmVydGljYWxseS4gVGhvc2UgMzAgcGl4ZWxzIHdpbGxcbiAgICAgKiBzdGF5IDMwIHBpeGVscyBubyBtYXR0ZXIgaG93IHRoZSBvYmplY3QgaXMgYmlnLiBBbm90aGVyIGV4YW1wbGUgaXMgaGF2aW5nIDJcbiAgICAgKiBjb250cm9scyBpbiB0aGUgY29ybmVyLCB0aGF0IHN0YXkgaW4gdGhlIHNhbWUgcG9zaXRpb24gd2hlbiB0aGUgb2JqZWN0IHNjYWxlLlxuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9mZnNldCBvZiB0aGUgY29udHJvbCBmcm9tIHRoZSBkZWZpbmVkIHBvc2l0aW9uLiBJbiBwaXhlbHNcbiAgICAgKiBQb3NpdGl2ZSBvZmZzZXQgbW92ZXMgdGhlIGNvbnRyb2wgdG8gdGhlIGJvdHRvbSwgbmVnYXRpdmUgdG8gdGhlIHRvcC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyBjb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCBzaXplWCBhbmQgc2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBzaXplWDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgY29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggc2l6ZVggYW5kIHNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgc2l6ZVk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZW5ndGggb2YgdGhlIHRvdWNoIGFyZWEgb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIHRvdWNoQ29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggdG91Y2hTaXplWCBhbmQgdG91Y2hTaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRvdWNoU2l6ZVg6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHRvdWNoIGFyZWEgb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIHRvdWNoQ29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggdG91Y2hTaXplWCBhbmQgdG91Y2hTaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRvdWNoU2l6ZVk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDc3MgY3Vyc29yIHN0eWxlIHRvIGRpc3BsYXkgd2hlbiB0aGUgY29udHJvbCBpcyBob3ZlcmVkLlxuICAgICAqIGlmIHRoZSBtZXRob2QgYGN1cnNvclN0eWxlSGFuZGxlcmAgaXMgcHJvdmlkZWQsIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdjcm9zc2hhaXInXG4gICAgICovXG4gICAgY3Vyc29yU3R5bGU6ICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogSWYgY29udHJvbHMgaGFzIGFuIG9mZnNldFkgb3Igb2Zmc2V0WCwgZHJhdyBhIGxpbmUgdGhhdCBjb25uZWN0c1xuICAgICAqIHRoZSBjb250cm9sIHRvIHRoZSBib3VuZGluZyBib3hcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHdpdGhDb25uZWN0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sIGFjdGlvbkhhbmRsZXIsIHByb3ZpZGUgb25lIHRvIGhhbmRsZSBhY3Rpb24gKCBjb250cm9sIGJlaW5nIG1vdmVkIClcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1EYXRhIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aW9uL2V2ZW50IG1vZGlmaWVkIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIHRyYW5zZm9ybURhdGEsIHgsIHkgKi8pIHsgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sIGhhbmRsZXIgZm9yIG1vdXNlIGRvd24sIHByb3ZpZGUgb25lIHRvIGhhbmRsZSBtb3VzZSBkb3duIG9uIGNvbnRyb2xcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1EYXRhIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aW9uL2V2ZW50IG1vZGlmaWVkIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBtb3VzZURvd25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIHRyYW5zZm9ybURhdGEsIHgsIHkgKi8pIHsgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sIG1vdXNlVXBIYW5kbGVyLCBwcm92aWRlIG9uZSB0byBoYW5kbGUgYW4gZWZmZWN0IG9uIG1vdXNlIHVwLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIG1vdXNlVXBIYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIHRyYW5zZm9ybURhdGEsIHgsIHkgKi8pIHsgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBhY3Rpb25IYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIGNvbnRyb2wgZm9yIHdoaWNoIHRoZSBhY3Rpb24gaGFuZGxlciBpcyBiZWluZyBhc2tlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgKi9cbiAgICBnZXRBY3Rpb25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIGZhYnJpY09iamVjdCwgY29udHJvbCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIG1vdXNlRG93biBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIGNvbnRyb2wgZm9yIHdoaWNoIHRoZSBhY3Rpb24gaGFuZGxlciBpcyBiZWluZyBhc2tlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgKi9cbiAgICBnZXRNb3VzZURvd25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIGZhYnJpY09iamVjdCwgY29udHJvbCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIG1vdXNlVXAgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCBjb250cm9sIGZvciB3aGljaCB0aGUgYWN0aW9uIGhhbmRsZXIgaXMgYmVpbmcgYXNrZWRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGFjdGlvbiBoYW5kbGVyXG4gICAgICovXG4gICAgZ2V0TW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZVVwSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIGN1cnNvclN0eWxlIGZvciBjc3MgdXNpbmcgY3Vyc29yU3R5bGUuIElmIHlvdSBuZWVkIGEgbW9yZSBlbGFib3JhdGVcbiAgICAgKiBmdW5jdGlvbiB5b3UgY2FuIHBhc3Mgb25lIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqIHRoZSBjdXJzb3JTdHlsZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY3VycmVudCBjb250cm9sICggbGlrZWx5IHRoaXMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogZnVuY3Rpb24oZXZlbnREYXRhLCBjb250cm9sIC8qIGZhYnJpY09iamVjdCAqLykge1xuICAgICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdGlvbiBuYW1lLiBUaGUgYmFzaWMgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm4gdGhlIGFjdGlvbk5hbWUgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjdXJyZW50IGNvbnRyb2wgKCBsaWtlbHkgdGhpcylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0QWN0aW9uTmFtZTogZnVuY3Rpb24oZXZlbnREYXRhLCBjb250cm9sIC8qIGZhYnJpY09iamVjdCAqLykge1xuICAgICAgcmV0dXJuIGNvbnRyb2wuYWN0aW9uTmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9scyB2aXNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xLZXkga2V5IHdoZXJlIHRoZSBjb250cm9sIGlzIG1lbW9yaXplZCBvbiB0aGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldFZpc2liaWxpdHk6IGZ1bmN0aW9uKGZhYnJpY09iamVjdCwgY29udHJvbEtleSkge1xuICAgICAgdmFyIG9iamVjdFZpc2liaWxpdHkgPSBmYWJyaWNPYmplY3QuX2NvbnRyb2xzVmlzaWJpbGl0eTtcbiAgICAgIGlmIChvYmplY3RWaXNpYmlsaXR5ICYmIHR5cGVvZiBvYmplY3RWaXNpYmlsaXR5W2NvbnRyb2xLZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb2JqZWN0VmlzaWJpbGl0eVtjb250cm9sS2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29udHJvbHMgdmlzaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJpbGl0eSBmb3IgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2V0VmlzaWJpbGl0eTogZnVuY3Rpb24odmlzaWJpbGl0eSAvKiBuYW1lLCBmYWJyaWNPYmplY3QgKi8pIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2liaWxpdHk7XG4gICAgfSxcblxuXG4gICAgcG9zaXRpb25IYW5kbGVyOiBmdW5jdGlvbihkaW0sIGZpbmFsTWF0cml4IC8qLCBmYWJyaWNPYmplY3QsIGN1cnJlbnRDb250cm9sICovKSB7XG4gICAgICB2YXIgcG9pbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh7XG4gICAgICAgIHg6IHRoaXMueCAqIGRpbS54ICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiB0aGlzLnkgKiBkaW0ueSArIHRoaXMub2Zmc2V0WSB9LCBmaW5hbE1hdHJpeCk7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkcyBmb3IgdGhpcyBjb250cm9sIGJhc2VkIG9uIG9iamVjdCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9iamVjdEFuZ2xlIGFuZ2xlIGZyb20gdGhlIGZhYnJpYyBvYmplY3QgaG9sZGluZyB0aGUgY29udHJvbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvYmplY3RDb3JuZXJTaXplIGNvcm5lclNpemUgZnJvbSB0aGUgZmFicmljIG9iamVjdCBob2xkaW5nIHRoZSBjb250cm9sIChvciB0b3VjaENvcm5lclNpemUgaWZcbiAgICAgKiAgIGlzVG91Y2ggaXMgdHJ1ZSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2VudGVyWCB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXJZIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1RvdWNoIHRydWUgaWYgdG91Y2ggY29ybmVyLCBmYWxzZSBpZiBub3JtYWwgY29ybmVyXG4gICAgICovXG4gICAgY2FsY0Nvcm5lckNvb3JkczogZnVuY3Rpb24ob2JqZWN0QW5nbGUsIG9iamVjdENvcm5lclNpemUsIGNlbnRlclgsIGNlbnRlclksIGlzVG91Y2gpIHtcbiAgICAgIHZhciBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHNpbkhhbGZPZmZzZXQsXG4gICAgICAgICAgY29zSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgc2luSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgeFNpemUgPSAoaXNUb3VjaCkgPyB0aGlzLnRvdWNoU2l6ZVggOiB0aGlzLnNpemVYLFxuICAgICAgICAgIHlTaXplID0gKGlzVG91Y2gpID8gdGhpcy50b3VjaFNpemVZIDogdGhpcy5zaXplWTtcbiAgICAgIGlmICh4U2l6ZSAmJiB5U2l6ZSAmJiB4U2l6ZSAhPT0geVNpemUpIHtcbiAgICAgICAgLy8gaGFuZGxlIHJlY3Rhbmd1bGFyIGNvcm5lcnNcbiAgICAgICAgdmFyIGNvbnRyb2xUcmlhbmdsZUFuZ2xlID0gTWF0aC5hdGFuMih5U2l6ZSwgeFNpemUpO1xuICAgICAgICB2YXIgY29ybmVySHlwb3RlbnVzZSA9IE1hdGguc3FydCh4U2l6ZSAqIHhTaXplICsgeVNpemUgKiB5U2l6ZSkgLyAyO1xuICAgICAgICB2YXIgbmV3VGhldGEgPSBjb250cm9sVHJpYW5nbGVBbmdsZSAtIGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMob2JqZWN0QW5nbGUpO1xuICAgICAgICB2YXIgbmV3VGhldGFDb21wID0gTWF0aC5QSSAvIDIgLSBjb250cm9sVHJpYW5nbGVBbmdsZSAtIGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMob2JqZWN0QW5nbGUpO1xuICAgICAgICBjb3NIYWxmT2Zmc2V0ID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLmNvcyhuZXdUaGV0YSk7XG4gICAgICAgIHNpbkhhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhKTtcbiAgICAgICAgLy8gdXNlIGNvbXBsZW1lbnRhcnkgYW5nbGUgZm9yIHR3byBjb3JuZXJzXG4gICAgICAgIGNvc0hhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLmNvcyhuZXdUaGV0YUNvbXApO1xuICAgICAgICBzaW5IYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5zaW4obmV3VGhldGFDb21wKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgc3F1YXJlIGNvcm5lcnNcbiAgICAgICAgLy8gdXNlIGRlZmF1bHQgb2JqZWN0IGNvcm5lciBzaXplIHVubGVzcyBzaXplIGlzIGRlZmluZWRcbiAgICAgICAgdmFyIGNvcm5lclNpemUgPSAoeFNpemUgJiYgeVNpemUpID8geFNpemUgOiBvYmplY3RDb3JuZXJTaXplO1xuICAgICAgICAvKiAwLjcwNzEwNjc4MTIgc3RhbmRzIGZvciBzcXJ0KDIpLzIgKi9cbiAgICAgICAgY29ybmVySHlwb3RlbnVzZSA9IGNvcm5lclNpemUgKiAwLjcwNzEwNjc4MTI7XG4gICAgICAgIC8vIGNvbXBsZW1lbnRhcnkgYW5nbGVzIGFyZSBlcXVhbCBzaW5jZSB0aGV5J3JlIGJvdGggNDUgZGVncmVlc1xuICAgICAgICB2YXIgbmV3VGhldGEgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKDQ1IC0gb2JqZWN0QW5nbGUpO1xuICAgICAgICBjb3NIYWxmT2Zmc2V0ID0gY29zSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhKTtcbiAgICAgICAgc2luSGFsZk9mZnNldCA9IHNpbkhhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRsOiB7XG4gICAgICAgICAgeDogY2VudGVyWCAtIHNpbkhhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHk6IGNlbnRlclkgLSBjb3NIYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgfSxcbiAgICAgICAgdHI6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYICsgY29zSGFsZk9mZnNldCxcbiAgICAgICAgICB5OiBjZW50ZXJZIC0gc2luSGFsZk9mZnNldCxcbiAgICAgICAgfSxcbiAgICAgICAgYmw6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYIC0gY29zSGFsZk9mZnNldCxcbiAgICAgICAgICB5OiBjZW50ZXJZICsgc2luSGFsZk9mZnNldCxcbiAgICAgICAgfSxcbiAgICAgICAgYnI6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYICsgc2luSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgeTogY2VudGVyWSArIGNvc0hhbGZPZmZzZXRDb21wLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSBjb250cm9sLlxuICAgICogV2hlbiB0aGlzIGZ1bmN0aW9uIHJ1bnMgdGhlIGNvbnRleHQgaXMgdW5zY2FsZWQuIHVucm90YXRlLiBKdXN0IHJldGluYSBzY2FsZWQuXG4gICAgKiBhbGwgdGhlIGZ1bmN0aW9ucyB3aWxsIGhhdmUgdG8gdHJhbnNsYXRlIHRvIHRoZSBwb2ludCBsZWZ0LHRvcCBiZWZvcmUgc3RhcnRpbmcgRHJhd2luZ1xuICAgICogaWYgdGhleSB3YW50IHRvIGRyYXcgYSBjb250cm9sIHdoZXJlIHRoZSBwb3NpdGlvbiBpcyBkZXRlY3RlZC5cbiAgICAqIGxlZnQgYW5kIHRvcCBhcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9zaXRpb25IYW5kbGVyIGZ1bmN0aW9uXG4gICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRoZSBjb250ZXh0IHdoZXJlIHRoZSBjb250cm9sIHdpbGwgYmUgZHJhd25cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBjYW52YXMgd2hlcmUgd2UgYXJlIGFib3V0IHRvIHJlbmRlciB0aGUgY29udHJvbC5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgcG9zaXRpb24gb2YgdGhlIGNhbnZhcyB3aGVyZSB3ZSBhcmUgYWJvdXQgdG8gcmVuZGVyIHRoZSBjb250cm9sLlxuICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGVcbiAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBvYmplY3Qgd2hlcmUgdGhlIGNvbnRyb2wgaXMgYWJvdXQgdG8gYmUgcmVuZGVyZWRcbiAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICBzd2l0Y2ggKHN0eWxlT3ZlcnJpZGUuY29ybmVyU3R5bGUgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0eWxlKSB7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgZmFicmljLmNvbnRyb2xzVXRpbHMucmVuZGVyQ2lyY2xlQ29udHJvbC5jYWxsKHRoaXMsIGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZhYnJpYy5jb250cm9sc1V0aWxzLnJlbmRlclNxdWFyZUNvbnRyb2wuY2FsbCh0aGlzLCBjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgZnVuY3Rpb24gZ2V0Q29sb3JTdG9wKGVsLCBtdWx0aXBsaWVyKSB7XG4gICAgdmFyIHN0eWxlID0gZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpLFxuICAgICAgICBvZmZzZXQgPSBlbC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpIHx8IDAsXG4gICAgICAgIGNvbG9yLCBjb2xvckFscGhhLCBvcGFjaXR5LCBpO1xuXG4gICAgLy8gY29udmVydCBwZXJjZW50cyB0byBhYnNvbHV0ZSB2YWx1ZXNcbiAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCkgLyAoLyUkLy50ZXN0KG9mZnNldCkgPyAxMDAgOiAxKTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPCAwID8gMCA6IG9mZnNldCA+IDEgPyAxIDogb2Zmc2V0O1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgdmFyIGtleVZhbHVlUGFpcnMgPSBzdHlsZS5zcGxpdCgvXFxzKjtcXHMqLyk7XG5cbiAgICAgIGlmIChrZXlWYWx1ZVBhaXJzW2tleVZhbHVlUGFpcnMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgIGtleVZhbHVlUGFpcnMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGtleVZhbHVlUGFpcnMubGVuZ3RoOyBpLS07ICkge1xuXG4gICAgICAgIHZhciBzcGxpdCA9IGtleVZhbHVlUGFpcnNbaV0uc3BsaXQoL1xccyo6XFxzKi8pLFxuICAgICAgICAgICAga2V5ID0gc3BsaXRbMF0udHJpbSgpLFxuICAgICAgICAgICAgdmFsdWUgPSBzcGxpdFsxXS50cmltKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ3N0b3AtY29sb3InKSB7XG4gICAgICAgICAgY29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdG9wLW9wYWNpdHknKSB7XG4gICAgICAgICAgb3BhY2l0eSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgY29sb3IgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKSB8fCAncmdiKDAsMCwwKSc7XG4gICAgfVxuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgb3BhY2l0eSA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1vcGFjaXR5Jyk7XG4gICAgfVxuXG4gICAgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKTtcbiAgICBjb2xvckFscGhhID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICBvcGFjaXR5ID0gaXNOYU4ocGFyc2VGbG9hdChvcGFjaXR5KSkgPyAxIDogcGFyc2VGbG9hdChvcGFjaXR5KTtcbiAgICBvcGFjaXR5ICo9IGNvbG9yQWxwaGEgKiBtdWx0aXBsaWVyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmVhckNvb3JkcyhlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogZWwuZ2V0QXR0cmlidXRlKCd4MScpIHx8IDAsXG4gICAgICB5MTogZWwuZ2V0QXR0cmlidXRlKCd5MScpIHx8IDAsXG4gICAgICB4MjogZWwuZ2V0QXR0cmlidXRlKCd4MicpIHx8ICcxMDAlJyxcbiAgICAgIHkyOiBlbC5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYWRpYWxDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgnZngnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MTogZWwuZ2V0QXR0cmlidXRlKCdmeScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnNTAlJyxcbiAgICAgIHIxOiAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnNTAlJyxcbiAgICAgIHkyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMjogZWwuZ2V0QXR0cmlidXRlKCdyJykgfHwgJzUwJSdcbiAgICB9O1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIC8qKlxuICAgKiBHcmFkaWVudCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyYWRpZW50XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2dyYWRpZW50c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyYWRpZW50I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JhZGllbnQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5HcmFkaWVudC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9mZnNldCBmb3IgYWxpZ25pbmcgZ3JhZGllbnRzIGNvbWluZyBmcm9tIFNWRyB3aGVuIG91dHNpZGUgcGF0aGdyb3Vwc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFuc2Zvcm0gbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBncmFkaWVudCBiZWZvcmUgcGFpbnRpbmcuXG4gICAgICogSW1wb3J0ZWQgZnJvbSBzdmcgZ3JhZGllbnRzLCBpcyBub3QgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybSBpbiB0aGUgY2VudGVyLlxuICAgICAqIEJlZm9yZSB0aGlzIHRyYW5zZm9ybSBpcyBhcHBsaWVkLCB0aGUgb3JpZ2luIHBvaW50IGlzIGF0IHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG9iamVjdFxuICAgICAqIHBsdXMgdGhlIGFkZGl0aW9uIG9mIG9mZnNldFkgYW5kIG9mZnNldFguXG4gICAgICogQHR5cGUgTnVtYmVyW11cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBjb29yZGluYXRlcyB1bml0cyBmb3IgY29vcmRzLlxuICAgICAqIElmIGBwaXhlbHNgLCB0aGUgbnVtYmVyIG9mIGNvb3JkcyBhcmUgaW4gdGhlIHNhbWUgdW5pdCBvZiB3aWR0aCAvIGhlaWdodC5cbiAgICAgKiBJZiBzZXQgYXMgYHBlcmNlbnRhZ2VgIHRoZSBjb29yZHMgYXJlIHN0aWxsIGEgbnVtYmVyLCBidXQgMSBtZWFucyAxMDAlIG9mIHdpZHRoXG4gICAgICogZm9yIHRoZSBYIGFuZCAxMDAlIG9mIHRoZSBoZWlnaHQgZm9yIHRoZSB5LiBJdCBjYW4gYmUgYmlnZ2VyIHRoYW4gMSBhbmQgbmVnYXRpdmUuXG4gICAgICogYWxsb3dlZCB2YWx1ZXMgcGl4ZWxzIG9yIHBlcmNlbnRhZ2UuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ3BpeGVscydcbiAgICAgKi9cbiAgICBncmFkaWVudFVuaXRzOiAncGl4ZWxzJyxcblxuICAgIC8qKlxuICAgICAqIEdyYWRpZW50IHR5cGUgbGluZWFyIG9yIHJhZGlhbFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdwaXhlbHMnXG4gICAgICovXG4gICAgdHlwZTogJ2xpbmVhcicsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0IHdpdGggdHlwZSwgY29vcmRzLCBncmFkaWVudFVuaXRzIGFuZCBjb2xvclN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnR5cGVdIGdyYWRpZW50IHR5cGUgbGluZWFyIG9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ncmFkaWVudFVuaXRzXSBncmFkaWVudCB1bml0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vZmZzZXRYXSBTVkcgaW1wb3J0IGNvbXBhdGliaWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub2Zmc2V0WV0gU1ZHIGltcG9ydCBjb21wYXRpYmlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucy5jb2xvclN0b3BzIGNvbnRhaW5zIHRoZSBjb2xvcnN0b3BzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmNvb3JkcyBjb250YWlucyB0aGUgY29vcmRzIG9mIHRoZSBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueDFdIFggY29vcmRpYW50ZSBvZiB0aGUgZmlyc3QgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgZm9jYWwgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueTFdIFkgY29vcmRpYW50ZSBvZiB0aGUgZmlyc3QgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgZm9jYWwgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueDJdIFggY29vcmRpYW50ZSBvZiB0aGUgc2Vjb25kIHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGNlbnRlciBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy55Ml0gWSBjb29yZGlhbnRlIG9mIHRoZSBzZWNvbmQgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgY2VudGVyIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnIxXSBvbmx5IGZvciByYWRpYWwgZ3JhZGllbnQsIHJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy5yMl0gb25seSBmb3IgcmFkaWFsIGdyYWRpZW50LCByYWRpdXMgb2YgdGhlIGV4dGVybmFsIGNpcmNsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgb3B0aW9ucy5jb29yZHMgfHwgKG9wdGlvbnMuY29vcmRzID0geyB9KTtcblxuICAgICAgdmFyIGNvb3JkcywgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBzZXRzIGV2ZXJ5dGhpbmcsIHRoZW4gY29vcmRzIGFuZCBjb2xvcnN0b3BzIGdldCBzZXRzIGFnYWluXG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICBfdGhpc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICAgIHRoaXMuaWQgKz0gJ18nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB9XG5cbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDE6IG9wdGlvbnMuY29vcmRzLngxIHx8IDAsXG4gICAgICAgIHkxOiBvcHRpb25zLmNvb3Jkcy55MSB8fCAwLFxuICAgICAgICB4Mjogb3B0aW9ucy5jb29yZHMueDIgfHwgMCxcbiAgICAgICAgeTI6IG9wdGlvbnMuY29vcmRzLnkyIHx8IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGNvb3Jkcy5yMSA9IG9wdGlvbnMuY29vcmRzLnIxIHx8IDA7XG4gICAgICAgIGNvb3Jkcy5yMiA9IG9wdGlvbnMuY29vcmRzLnIyIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgICAgdGhpcy5jb2xvclN0b3BzID0gb3B0aW9ucy5jb2xvclN0b3BzLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBjb2xvclN0b3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29sb3JTdG9wIE9iamVjdCB3aXRoIG9mZnNldCBhbmQgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uKGNvbG9yU3RvcHMpIHtcbiAgICAgIGZvciAodmFyIHBvc2l0aW9uIGluIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvclN0b3BzW3Bvc2l0aW9uXSk7XG4gICAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IHBhcnNlRmxvYXQocG9zaXRpb24pLFxuICAgICAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgICAgIG9wYWNpdHk6IGNvbG9yLmdldEFscGhhKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29vcmRzOiB0aGlzLmNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogdGhpcy5jb2xvclN0b3BzLFxuICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgZ3JhZGllbnRVbml0czogdGhpcy5ncmFkaWVudFVuaXRzLFxuICAgICAgICBncmFkaWVudFRyYW5zZm9ybTogdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA/IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0uY29uY2F0KCkgOiB0aGlzLmdyYWRpZW50VHJhbnNmb3JtXG4gICAgICB9O1xuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JhZGllbnQgZm9yXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gZ3JhZGllbnQgKGxpbmVhci9yYWRpYWwpXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNvb3JkcyA9IGNsb25lKHRoaXMuY29vcmRzLCB0cnVlKSwgaSwgbGVuLCBvcHRpb25zID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICBtYXJrdXAsIGNvbW1vbkF0dHJpYnV0ZXMsIGNvbG9yU3RvcHMgPSBjbG9uZSh0aGlzLmNvbG9yU3RvcHMsIHRydWUpLFxuICAgICAgICAgIG5lZWRzU3dhcCA9IGNvb3Jkcy5yMSA+IGNvb3Jkcy5yMixcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLmdyYWRpZW50VHJhbnNmb3JtID8gdGhpcy5ncmFkaWVudFRyYW5zZm9ybS5jb25jYXQoKSA6IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuICAgICAgICAgIG9mZnNldFggPSAtdGhpcy5vZmZzZXRYLCBvZmZzZXRZID0gLXRoaXMub2Zmc2V0WSxcbiAgICAgICAgICB3aXRoVmlld3BvcnQgPSAhIW9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSxcbiAgICAgICAgICBncmFkaWVudFVuaXRzID0gdGhpcy5ncmFkaWVudFVuaXRzID09PSAncGl4ZWxzJyA/ICd1c2VyU3BhY2VPblVzZScgOiAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgICAgLy8gY29sb3JTdG9wcyBtdXN0IGJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIGNvbG9yU3RvcHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnKSB7XG4gICAgICAgIG9mZnNldFggLz0gb2JqZWN0LndpZHRoO1xuICAgICAgICBvZmZzZXRZIC89IG9iamVjdC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0WCArPSBvYmplY3Qud2lkdGggLyAyO1xuICAgICAgICBvZmZzZXRZICs9IG9iamVjdC5oZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC50eXBlID09PSAncGF0aCcgJiYgdGhpcy5ncmFkaWVudFVuaXRzICE9PSAncGVyY2VudGFnZScpIHtcbiAgICAgICAgb2Zmc2V0WCAtPSBvYmplY3QucGF0aE9mZnNldC54O1xuICAgICAgICBvZmZzZXRZIC09IG9iamVjdC5wYXRoT2Zmc2V0Lnk7XG4gICAgICB9XG5cblxuICAgICAgdHJhbnNmb3JtWzRdIC09IG9mZnNldFg7XG4gICAgICB0cmFuc2Zvcm1bNV0gLT0gb2Zmc2V0WTtcblxuICAgICAgY29tbW9uQXR0cmlidXRlcyA9ICdpZD1cIlNWR0lEXycgKyB0aGlzLmlkICtcbiAgICAgICAgICAgICAgICAgICAgICdcIiBncmFkaWVudFVuaXRzPVwiJyArIGdyYWRpZW50VW5pdHMgKyAnXCInO1xuICAgICAgY29tbW9uQXR0cmlidXRlcyArPSAnIGdyYWRpZW50VHJhbnNmb3JtPVwiJyArICh3aXRoVmlld3BvcnQgP1xuICAgICAgICBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm0gKyAnICcgOiAnJykgKyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyh0cmFuc2Zvcm0pICsgJ1wiICc7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPGxpbmVhckdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIHgxPVwiJywgY29vcmRzLngxLFxuICAgICAgICAgICdcIiB5MT1cIicsIGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCIgeDI9XCInLCBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIHkyPVwiJywgY29vcmRzLnkyLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIC8vIHN2ZyByYWRpYWwgZ3JhZGllbnQgaGFzIGp1c3QgMSByYWRpdXMuIHRoZSBiaWdnZXN0LlxuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJzxyYWRpYWxHcmFkaWVudCAnLFxuICAgICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgJyBjeD1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy54MSA6IGNvb3Jkcy54MixcbiAgICAgICAgICAnXCIgY3k9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueTEgOiBjb29yZHMueTIsXG4gICAgICAgICAgJ1wiIHI9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMucjEgOiBjb29yZHMucjIsXG4gICAgICAgICAgJ1wiIGZ4PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLngyIDogY29vcmRzLngxLFxuICAgICAgICAgICdcIiBmeT1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy55MiA6IGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCI+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBpZiAobmVlZHNTd2FwKSB7XG4gICAgICAgICAgLy8gc3ZnIGdvZXMgZnJvbSBpbnRlcm5hbCB0byBleHRlcm5hbCByYWRpdXMuIGlmIHJhZGl1cyBhcmUgaW52ZXJ0ZWQsIHN3YXAgY29sb3Igc3RvcHMuXG4gICAgICAgICAgY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMuY29uY2F0KCk7XG4gICAgICAgICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQgPSAxIC0gY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5SYWRpdXMgPSBNYXRoLm1pbihjb29yZHMucjEsIGNvb3Jkcy5yMik7XG4gICAgICAgIGlmIChtaW5SYWRpdXMgPiAwKSB7XG4gICAgICAgICAgLy8gaSBoYXZlIHRvIHNoaWZ0IGFsbCBjb2xvclN0b3BzIGFuZCBhZGQgbmV3IG9uZSBpbiAwLlxuICAgICAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1heChjb29yZHMucjEsIGNvb3Jkcy5yMiksXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VTaGlmdCA9IG1pblJhZGl1cyAvIG1heFJhZGl1cztcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCArPSBwZXJjZW50YWdlU2hpZnQgKiAoMSAtIGNvbG9yU3RvcHNbaV0ub2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29sb3JTdG9wID0gY29sb3JTdG9wc1tpXTtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxzdG9wICcsXG4gICAgICAgICAgJ29mZnNldD1cIicsIChjb2xvclN0b3Aub2Zmc2V0ICogMTAwKSArICclJyxcbiAgICAgICAgICAnXCIgc3R5bGU9XCJzdG9wLWNvbG9yOicsIGNvbG9yU3RvcC5jb2xvcixcbiAgICAgICAgICAodHlwZW9mIGNvbG9yU3RvcC5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/ICc7c3RvcC1vcGFjaXR5OiAnICsgY29sb3JTdG9wLm9wYWNpdHkgOiAnOycpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaCgodGhpcy50eXBlID09PSAnbGluZWFyJyA/ICc8L2xpbmVhckdyYWRpZW50PlxcbicgOiAnPC9yYWRpYWxHcmFkaWVudD5cXG4nKSk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgQ2FudmFzR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7Q2FudmFzR3JhZGllbnR9XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBncmFkaWVudCwgY29vcmRzID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMuY29vcmRzKSwgaSwgbGVuO1xuXG4gICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMueDIsIGNvb3Jkcy55Mik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMucjEsIGNvb3Jkcy54MiwgY29vcmRzLnkyLCBjb29yZHMucjIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvclN0b3BzW2ldLmNvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eSA9IHRoaXMuY29sb3JTdG9wc1tpXS5vcGFjaXR5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5jb2xvclN0b3BzW2ldLm9mZnNldDtcblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKS5zZXRBbHBoYShvcGFjaXR5KS50b1JnYmEoKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aob2Zmc2V0LCBjb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gIH0pO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkdyYWRpZW50LCB7XG5cbiAgICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyYWRpZW50fSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge1NWR0dyYWRpZW50RWxlbWVudH0gZWwgU1ZHIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wYWNpdHlBdHRyIEEgZmlsbC1vcGFjaXR5IG9yIHN0cm9rZS1vcGFjaXR5IGF0dHJpYnV0ZSB0byBtdWx0aXBseSB0byBlYWNoIHN0b3AncyBvcGFjaXR5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdmdPcHRpb25zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzaXplIG9mIHRoZSBTVkcgaW4gb3JkZXIgdG8gcGFyc2UgY29ycmVjdGx5IGdyYWRpZW50c1xuICAgICAqIHRoYXQgdXNlcyBncmFkaWVudFVuaXRzIGFzICd1c2VyU3BhY2VPblVzZScgYW5kIHBlcmNlbnRhZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gdmlld0JveFdpZHRoIHdpZHRoIHBhcnQgb2YgdGhlIHZpZXdCb3ggYXR0cmlidXRlIG9uIHN2Z1xuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gdmlld0JveEhlaWdodCBoZWlnaHQgcGFydCBvZiB0aGUgdmlld0JveCBhdHRyaWJ1dGUgb24gc3ZnXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB3aWR0aCB3aWR0aCBwYXJ0IG9mIHRoZSBzdmcgdGFnIGlmIHZpZXdCb3ggaXMgbm90IHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gaGVpZ2h0IGhlaWdodCBwYXJ0IG9mIHRoZSBzdmcgdGFnIGlmIHZpZXdCb3ggaXMgbm90IHNwZWNpZmllZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gR3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI0xpbmVhckdyYWRpZW50RWxlbWVudFxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjUmFkaWFsR3JhZGllbnRFbGVtZW50XG4gICAgICovXG4gICAgZnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKGVsLCBpbnN0YW5jZSwgb3BhY2l0eUF0dHIsIHN2Z09wdGlvbnMpIHtcbiAgICAgIC8qKlxuICAgICAgICogIEBleGFtcGxlOlxuICAgICAgICpcbiAgICAgICAqICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXJHcmFkMVwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIi8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cImJsYWNrXCIvPlxuICAgICAgICogIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxsaW5lYXJHcmFkaWVudCBpZD1cImxpbmVhckdyYWQyXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3R5bGU9XCJzdG9wLWNvbG9yOnJnYigyNTUsMjU1LDI1NSlcIi8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3R5bGU9XCJzdG9wLWNvbG9yOnJnYigwLDAsMClcIi8+XG4gICAgICAgKiAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPHJhZGlhbEdyYWRpZW50IGlkPVwicmFkaWFsR3JhZDFcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIgc3RvcC1vcGFjaXR5PVwiMVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCI1MCVcIiBzdG9wLWNvbG9yPVwiYmxhY2tcIiBzdG9wLW9wYWNpdHk9XCIwLjVcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiIHN0b3Atb3BhY2l0eT1cIjFcIiAvPlxuICAgICAgICogIDwvcmFkaWFsR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxyYWRpYWxHcmFkaWVudCBpZD1cInJhZGlhbEdyYWQyXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3RvcC1jb2xvcj1cInJnYigyNTUsMjU1LDI1NSlcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMC41XCIgc3RvcC1jb2xvcj1cInJnYigwLDAsMClcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0b3AtY29sb3I9XCJyZ2IoMjU1LDI1NSwyNTUpXCIgLz5cbiAgICAgICAqICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICB2YXIgbXVsdGlwbGllciA9IHBhcnNlRmxvYXQob3BhY2l0eUF0dHIpIC8gKC8lJC8udGVzdChvcGFjaXR5QXR0cikgPyAxMDAgOiAxKTtcbiAgICAgIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyIDwgMCA/IDAgOiBtdWx0aXBsaWVyID4gMSA/IDEgOiBtdWx0aXBsaWVyO1xuICAgICAgaWYgKGlzTmFOKG11bHRpcGxpZXIpKSB7XG4gICAgICAgIG11bHRpcGxpZXIgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JTdG9wRWxzID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0b3AnKSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGdyYWRpZW50VW5pdHMgPSBlbC5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKSA9PT0gJ3VzZXJTcGFjZU9uVXNlJyA/XG4gICAgICAgICAgICAncGl4ZWxzJyA6ICdwZXJjZW50YWdlJyxcbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybSA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKSB8fCAnJyxcbiAgICAgICAgICBjb2xvclN0b3BzID0gW10sXG4gICAgICAgICAgY29vcmRzLCBpLCBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDAsXG4gICAgICAgICAgdHJhbnNmb3JtTWF0cml4O1xuICAgICAgaWYgKGVsLm5vZGVOYW1lID09PSAnbGluZWFyR3JhZGllbnQnIHx8IGVsLm5vZGVOYW1lID09PSAnTElORUFSR1JBRElFTlQnKSB7XG4gICAgICAgIHR5cGUgPSAnbGluZWFyJztcbiAgICAgICAgY29vcmRzID0gZ2V0TGluZWFyQ29vcmRzKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0eXBlID0gJ3JhZGlhbCc7XG4gICAgICAgIGNvb3JkcyA9IGdldFJhZGlhbENvb3JkcyhlbCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGNvbG9yU3RvcEVscy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGNvbG9yU3RvcHMucHVzaChnZXRDb2xvclN0b3AoY29sb3JTdG9wRWxzW2ldLCBtdWx0aXBsaWVyKSk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZShncmFkaWVudFRyYW5zZm9ybSk7XG5cbiAgICAgIF9fY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKGluc3RhbmNlLCBjb29yZHMsIHN2Z09wdGlvbnMsIGdyYWRpZW50VW5pdHMpO1xuXG4gICAgICBpZiAoZ3JhZGllbnRVbml0cyA9PT0gJ3BpeGVscycpIHtcbiAgICAgICAgb2Zmc2V0WCA9IC1pbnN0YW5jZS5sZWZ0O1xuICAgICAgICBvZmZzZXRZID0gLWluc3RhbmNlLnRvcDtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IGZhYnJpYy5HcmFkaWVudCh7XG4gICAgICAgIGlkOiBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyksXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICBjb2xvclN0b3BzOiBjb2xvclN0b3BzLFxuICAgICAgICBncmFkaWVudFVuaXRzOiBncmFkaWVudFVuaXRzLFxuICAgICAgICBncmFkaWVudFRyYW5zZm9ybTogdHJhbnNmb3JtTWF0cml4LFxuICAgICAgICBvZmZzZXRYOiBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZOiBvZmZzZXRZLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gICAgLyogX0ZST01fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhpbnN0YW5jZSwgb3B0aW9ucywgc3ZnT3B0aW9ucywgZ3JhZGllbnRVbml0cykge1xuICAgIHZhciBwcm9wVmFsdWUsIGZpbmFsVmFsdWU7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICBwcm9wVmFsdWUgPSBvcHRpb25zW3Byb3BdO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgICBmaW5hbFZhbHVlID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3BWYWx1ZSA9PT0gJy1JbmZpbml0eScpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9uc1twcm9wXSwgMTApO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3N0cmluZycgJiYgL14oXFxkK1xcLlxcZCspJXwoXFxkKyklJC8udGVzdChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgZmluYWxWYWx1ZSAqPSAwLjAxO1xuICAgICAgICAgIGlmIChncmFkaWVudFVuaXRzID09PSAncGl4ZWxzJykge1xuICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIGZpeCB0aG9zZSBwZXJjZW50YWdlcyBoZXJlIGluIHN2ZyBwYXJzaW5nXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3gxJyB8fCBwcm9wID09PSAneDInIHx8IHByb3AgPT09ICdyMicpIHtcbiAgICAgICAgICAgICAgZmluYWxWYWx1ZSAqPSBzdmdPcHRpb25zLnZpZXdCb3hXaWR0aCB8fCBzdmdPcHRpb25zLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICd5MScgfHwgcHJvcCA9PT0gJ3kyJykge1xuICAgICAgICAgICAgICBmaW5hbFZhbHVlICo9IHN2Z09wdGlvbnMudmlld0JveEhlaWdodCB8fCBzdmdPcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnNbcHJvcF0gPSBmaW5hbFZhbHVlO1xuICAgIH0pO1xuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIC8qKlxuICAgKiBQYXR0ZXJuIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0dGVyblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3BhdHRlcm5zfFBhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9keW5hbWljLXBhdHRlcm5zfER5bmFtaWNQYXR0ZXJuIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXR0ZXJuI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuXG5cbiAgZmFicmljLlBhdHRlcm4gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5QYXR0ZXJuLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXQgcHJvcGVydHkgb2YgYSBwYXR0ZXJuIChvbmUgb2YgcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXkgb3Igbm8tcmVwZWF0KVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVwZWF0OiAncmVwZWF0JyxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gaG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuIHZlcnRpY2FsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIGNyb3NzT3JpZ2luIHZhbHVlIChvbmUgb2YgXCJcIiwgXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIilcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3NzT3JpZ2luOiAnJyxcblxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSBtYXRyaXggdG8gY2hhbmdlIHRoZSBwYXR0ZXJuLCBpbXBvcnRlZCBmcm9tIHN2Z3MuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdHRlcm5UcmFuc2Zvcm06IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBjYWxsYmFjayBpbml0LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXR0ZXJufSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNvdXJjZSB8fCAob3B0aW9ucy5zb3VyY2UgJiYgdHlwZW9mIG9wdGlvbnMuc291cmNlICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpbWcgc3JjIHN0cmluZ1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShvcHRpb25zLnNvdXJjZSwgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICAgICAgX3RoaXMuc291cmNlID0gaW1nO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKF90aGlzLCBpc0Vycm9yKTtcbiAgICAgICAgfSwgbnVsbCwgdGhpcy5jcm9zc09yaWdpbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG4gICAgICAgICAgc291cmNlLCBvYmplY3Q7XG5cbiAgICAgIC8vIDxpbWc+IGVsZW1lbnRcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2Uuc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS5zcmM7XG4gICAgICB9XG4gICAgICAvLyA8Y2FudmFzPiBlbGVtZW50XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdvYmplY3QnICYmIHRoaXMuc291cmNlLnRvRGF0YVVSTCkge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0ID0ge1xuICAgICAgICB0eXBlOiAncGF0dGVybicsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICByZXBlYXQ6IHRoaXMucmVwZWF0LFxuICAgICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcbiAgICAgICAgb2Zmc2V0WDogdG9GaXhlZCh0aGlzLm9mZnNldFgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICBvZmZzZXRZOiB0b0ZpeGVkKHRoaXMub2Zmc2V0WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgIHBhdHRlcm5UcmFuc2Zvcm06IHRoaXMucGF0dGVyblRyYW5zZm9ybSA/IHRoaXMucGF0dGVyblRyYW5zZm9ybS5jb25jYXQoKSA6IG51bGxcbiAgICAgIH07XG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcGF0dGVyblNvdXJjZSA9IHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuc291cmNlKCkgOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICBwYXR0ZXJuV2lkdGggPSBwYXR0ZXJuU291cmNlLndpZHRoIC8gb2JqZWN0LndpZHRoLFxuICAgICAgICAgIHBhdHRlcm5IZWlnaHQgPSBwYXR0ZXJuU291cmNlLmhlaWdodCAvIG9iamVjdC5oZWlnaHQsXG4gICAgICAgICAgcGF0dGVybk9mZnNldFggPSB0aGlzLm9mZnNldFggLyBvYmplY3Qud2lkdGgsXG4gICAgICAgICAgcGF0dGVybk9mZnNldFkgPSB0aGlzLm9mZnNldFkgLyBvYmplY3QuaGVpZ2h0LFxuICAgICAgICAgIHBhdHRlcm5JbWdTcmMgPSAnJztcbiAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCB0aGlzLnJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgICAgcGF0dGVybkhlaWdodCA9IDE7XG4gICAgICAgIGlmIChwYXR0ZXJuT2Zmc2V0WSkge1xuICAgICAgICAgIHBhdHRlcm5IZWlnaHQgKz0gTWF0aC5hYnMocGF0dGVybk9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteScgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICAgIHBhdHRlcm5XaWR0aCA9IDE7XG4gICAgICAgIGlmIChwYXR0ZXJuT2Zmc2V0WCkge1xuICAgICAgICAgIHBhdHRlcm5XaWR0aCArPSBNYXRoLmFicyhwYXR0ZXJuT2Zmc2V0WCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgaWYgKHBhdHRlcm5Tb3VyY2Uuc3JjKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwYXR0ZXJuIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeD1cIicgKyBwYXR0ZXJuT2Zmc2V0WCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB5PVwiJyArIHBhdHRlcm5PZmZzZXRZICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHdpZHRoPVwiJyArIHBhdHRlcm5XaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVybkhlaWdodCArICdcIj5cXG4nICtcbiAgICAgICAgICAgICAgICc8aW1hZ2UgeD1cIjBcIiB5PVwiMFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyB3aWR0aD1cIicgKyBwYXR0ZXJuU291cmNlLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5Tb3VyY2UuaGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgeGxpbms6aHJlZj1cIicgKyBwYXR0ZXJuSW1nU3JjICtcbiAgICAgICAgICAgICAgICdcIj48L2ltYWdlPlxcbicgK1xuICAgICAgICAgICAgICc8L3BhdHRlcm4+XFxuJztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc1BhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY3JlYXRlIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAvLyBpZiB0aGUgaW1hZ2UgZmFpbGVkIHRvIGxvYWQsIHJldHVybiwgYW5kIGFsbG93IHJlc3QgdG8gY29udGludWUgbG9hZGluZ1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbiBpbWFnZVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2Uuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLm5hdHVyYWxXaWR0aCA9PT0gMCB8fCBzb3VyY2UubmF0dXJhbEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHNvdXJjZSwgdGhpcy5yZXBlYXQpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5TaGFkb3cpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlNoYWRvdyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYWRvdyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlNoYWRvd1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3NoYWRvd3N8U2hhZG93IGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5TaGFkb3cjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5TaGFkb3cgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5TaGFkb3cucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBjb2xvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBibHVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgYmx1cjogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBob3Jpem9udGFsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyB2ZXJ0aWNhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzaGFkb3cgc2hvdWxkIGFmZmVjdCBzdHJva2Ugb3BlcmF0aW9uc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFmZmVjdFN0cm9rZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdCBzaG91bGQgaW5jbHVkZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgZmFsc2VgLCB0aGUgc2hhZG93IHdpbGwgc2NhbGUgd2l0aCB0aGUgb2JqZWN0LlxuICAgICAqIFdoZW4gYHRydWVgLCB0aGUgc2hhZG93J3Mgb2Zmc2V0WCwgb2Zmc2V0WSwgYW5kIGJsdXIgd2lsbCBub3QgYmUgYWZmZWN0ZWQgYnkgdGhlIG9iamVjdCdzIHNjYWxlLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub25TY2FsaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgd2l0aCBhbnkgb2YgY29sb3IsIGJsdXIsIG9mZnNldFgsIG9mZnNldFkgcHJvcGVydGllcyBvciBzdHJpbmcgKGUuZy4gXCJyZ2JhKDAsMCwwLDAuMikgMnB4IDJweCAxMHB4XCIpXG4gICAgICogQHJldHVybiB7ZmFicmljLlNoYWRvd30gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fcGFyc2VTaGFkb3cob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2hhZG93IFNoYWRvdyB2YWx1ZSB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gU2hhZG93IG9iamVjdCB3aXRoIGNvbG9yLCBvZmZzZXRYLCBvZmZzZXRZIGFuZCBibHVyXG4gICAgICovXG4gICAgX3BhcnNlU2hhZG93OiBmdW5jdGlvbihzaGFkb3cpIHtcbiAgICAgIHZhciBzaGFkb3dTdHIgPSBzaGFkb3cudHJpbSgpLFxuICAgICAgICAgIG9mZnNldHNBbmRCbHVyID0gZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLmV4ZWMoc2hhZG93U3RyKSB8fCBbXSxcbiAgICAgICAgICBjb2xvciA9IHNoYWRvd1N0ci5yZXBsYWNlKGZhYnJpYy5TaGFkb3cucmVPZmZzZXRzQW5kQmx1ciwgJycpIHx8ICdyZ2IoMCwwLDApJztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLnRyaW0oKSxcbiAgICAgICAgb2Zmc2V0WDogcGFyc2VJbnQob2Zmc2V0c0FuZEJsdXJbMV0sIDEwKSB8fCAwLFxuICAgICAgICBvZmZzZXRZOiBwYXJzZUludChvZmZzZXRzQW5kQmx1clsyXSwgMTApIHx8IDAsXG4gICAgICAgIGJsdXI6IHBhcnNlSW50KG9mZnNldHNBbmRCbHVyWzNdLCAxMCkgfHwgMFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzLXRleHQtZGVjb3ItMy8jdGV4dC1zaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgQ1NTMyB0ZXh0LXNoYWRvdyBkZWNsYXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy5vZmZzZXRYLCB0aGlzLm9mZnNldFksIHRoaXMuYmx1ciwgdGhpcy5jb2xvcl0uam9pbigncHggJyk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93XG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGZCb3hYID0gNDAsIGZCb3hZID0gNDAsIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG4gICAgICAgICAgb2Zmc2V0ID0gZmFicmljLnV0aWwucm90YXRlVmVjdG9yKFxuICAgICAgICAgICAgeyB4OiB0aGlzLm9mZnNldFgsIHk6IHRoaXMub2Zmc2V0WSB9LFxuICAgICAgICAgICAgZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucygtb2JqZWN0LmFuZ2xlKSksXG4gICAgICAgICAgQkxVUl9CT1ggPSAyMCwgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpO1xuXG4gICAgICBpZiAob2JqZWN0LndpZHRoICYmIG9iamVjdC5oZWlnaHQpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvZmlsdGVycy5odG1sI0ZpbHRlckVmZmVjdHNSZWdpb25cbiAgICAgICAgLy8gd2UgYWRkIHNvbWUgZXh0cmEgc3BhY2UgdG8gZmlsdGVyIGJveCB0byBjb250YWluIHRoZSBibHVyICggMjAgKVxuICAgICAgICBmQm94WCA9IHRvRml4ZWQoKE1hdGguYWJzKG9mZnNldC54KSArIHRoaXMuYmx1cikgLyBvYmplY3Qud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICAgIGZCb3hZID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LnkpICsgdGhpcy5ibHVyKSAvIG9iamVjdC5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBYKSB7XG4gICAgICAgIG9mZnNldC54ICo9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mbGlwWSkge1xuICAgICAgICBvZmZzZXQueSAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgJzxmaWx0ZXIgaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArICdcIiB5PVwiLScgKyBmQm94WSArICclXCIgaGVpZ2h0PVwiJyArICgxMDAgKyAyICogZkJveFkpICsgJyVcIiAnICtcbiAgICAgICAgICAneD1cIi0nICsgZkJveFggKyAnJVwiIHdpZHRoPVwiJyArICgxMDAgKyAyICogZkJveFgpICsgJyVcIiAnICsgJz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlR2F1c3NpYW5CbHVyIGluPVwiU291cmNlQWxwaGFcIiBzdGREZXZpYXRpb249XCInICtcbiAgICAgICAgICAgIHRvRml4ZWQodGhpcy5ibHVyID8gdGhpcy5ibHVyIC8gMiA6IDAsIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiPjwvZmVHYXVzc2lhbkJsdXI+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZU9mZnNldCBkeD1cIicgKyB0b0ZpeGVkKG9mZnNldC54LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgJ1wiIGR5PVwiJyArIHRvRml4ZWQob2Zmc2V0LnksIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiIHJlc3VsdD1cIm9CbHVyXCIgPjwvZmVPZmZzZXQ+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUZsb29kIGZsb29kLWNvbG9yPVwiJyArIGNvbG9yLnRvUmdiKCkgKyAnXCIgZmxvb2Qtb3BhY2l0eT1cIicgKyBjb2xvci5nZXRBbHBoYSgpICsgJ1wiLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlQ29tcG9zaXRlIGluMj1cIm9CbHVyXCIgb3BlcmF0b3I9XCJpblwiIC8+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZU1lcmdlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZT48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIj48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICdcXHQ8L2ZlTWVyZ2U+XFxuJyArXG4gICAgICAgICc8L2ZpbHRlcj5cXG4nKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvdyBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgYmx1cjogdGhpcy5ibHVyLFxuICAgICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZOiB0aGlzLm9mZnNldFksXG4gICAgICAgICAgYWZmZWN0U3Ryb2tlOiB0aGlzLmFmZmVjdFN0cm9rZSxcbiAgICAgICAgICBub25TY2FsaW5nOiB0aGlzLm5vblNjYWxpbmdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB7IH0sIHByb3RvID0gZmFicmljLlNoYWRvdy5wcm90b3R5cGU7XG5cbiAgICAgIFsnY29sb3InLCAnYmx1cicsICdvZmZzZXRYJywgJ29mZnNldFknLCAnYWZmZWN0U3Ryb2tlJywgJ25vblNjYWxpbmcnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IHByb3RvW3Byb3BdKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgc2hhZG93IG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXIgKGV4OiBcIjJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMilcIiwgXCJyZ2IoMCwyNTUsMCkgMnB4IDJweFwiKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLlNoYWRvd1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyID0gLyg/Olxcc3xeKSgtP1xcZCsoPzpweCk/KD86XFxzP3wkKSk/KC0/XFxkKyg/OnB4KT8oPzpcXHM/fCQpKT8oXFxkKyg/OnB4KT8pPyg/Olxccz98JCkoPzokfFxccykvO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlN0YXRpY0NhbnZhcyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYWxpYXNlcyBmb3IgZmFzdGVyIHJlc29sdXRpb25cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBnZXRFbGVtZW50T2Zmc2V0ID0gZmFicmljLnV0aWwuZ2V0RWxlbWVudE9mZnNldCxcbiAgICAgIHJlbW92ZUZyb21BcnJheSA9IGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgdHJhbnNmb3JtUG9pbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCxcbiAgICAgIGludmVydFRyYW5zZm9ybSA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSxcbiAgICAgIGdldE5vZGVDYW52YXMgPSBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzLFxuICAgICAgY3JlYXRlQ2FudmFzRWxlbWVudCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQsXG5cbiAgICAgIENBTlZBU19JTklUX0VSUk9SID0gbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBgY2FudmFzYCBlbGVtZW50Jyk7XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBjYW52YXMgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5TdGF0aWNDYW52YXNcbiAgICogQG1peGVzIGZhYnJpYy5Db2xsZWN0aW9uXG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3N0YXRpY19jYW52YXN8U3RhdGljQ2FudmFzIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQGZpcmVzIGJlZm9yZTpyZW5kZXJcbiAgICogQGZpcmVzIGFmdGVyOnJlbmRlclxuICAgKiBAZmlyZXMgY2FudmFzOmNsZWFyZWRcbiAgICogQGZpcmVzIG9iamVjdDphZGRlZFxuICAgKiBAZmlyZXMgb2JqZWN0OnJlbW92ZWRcbiAgICovXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnJlbmRlckFuZFJlc2V0Qm91bmQgPSB0aGlzLnJlbmRlckFuZFJlc2V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZCA9IHRoaXMucmVxdWVzdFJlbmRlckFsbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5faW5pdFN0YXRpYyhlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIFNob3VsZCBiZSBzZXQgdmlhIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI3NldEJhY2tncm91bmRDb2xvcn0uXG4gICAgICogQHR5cGUgeyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgaW1hZ2Ugb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIHNpbmNlIDIuNC4wIGltYWdlIGNhY2hpbmcgaXMgYWN0aXZlLCBwbGVhc2Ugd2hlbiBwdXR0aW5nIGFuIGltYWdlIGFzIGJhY2tncm91bmQsIGFkZCB0byB0aGVcbiAgICAgKiBjYW52YXMgcHJvcGVydHkgYSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyBpdCBpcyBvbi4gT3RoZXJ3aXNlIHRoZSBpbWFnZSBjYW5ub3QgZGV0ZWN0IHRoZSB6b29tXG4gICAgICogdmFsZS4gQXMgYW4gYWx0ZXJuYXRpdmUgeW91IGNhbiBkaXNhYmxlIGltYWdlIG9iamVjdENhY2hpbmdcbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXkgY29sb3Igb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIFNob3VsZCBiZSBzZXQgdmlhIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI3NldE92ZXJsYXlDb2xvcn1cbiAgICAgKiBAc2luY2UgMS4zLjlcbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5Q29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogc2luY2UgMi40LjAgaW1hZ2UgY2FjaGluZyBpcyBhY3RpdmUsIHBsZWFzZSB3aGVuIHB1dHRpbmcgYW4gaW1hZ2UgYXMgb3ZlcmxheSwgYWRkIHRvIHRoZVxuICAgICAqIGNhbnZhcyBwcm9wZXJ0eSBhIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzIGl0IGlzIG9uLiBPdGhlcndpc2UgdGhlIGltYWdlIGNhbm5vdCBkZXRlY3QgdGhlIHpvb21cbiAgICAgKiB2YWxlLiBBcyBhbiBhbHRlcm5hdGl2ZSB5b3UgY2FuIGRpc2FibGUgaW1hZ2Ugb2JqZWN0Q2FjaGluZ1xuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheUltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG9PYmplY3QvdG9EYXRhbGVzc09iamVjdCBzaG91bGQgaW5jbHVkZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIGlmIHNldCB0byBmYWxzZSwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBvYmplY3QgdmFsdWUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzJyBzdGF0ZSBzaG91bGQgYmUgc2F2ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdGF0ZWZ1bDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uYWRkfSwge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLmluc2VydEF0fSBhbmQge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLnJlbW92ZX0sXG4gICAgICoge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMubW92ZVRvfSwge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMuY2xlYXJ9IGFuZCBtYW55IG1vcmUsIHNob3VsZCBhbHNvIHJlLXJlbmRlciBjYW52YXMuXG4gICAgICogRGlzYWJsaW5nIHRoaXMgb3B0aW9uIHdpbGwgbm90IGdpdmUgYSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIGFkZGluZy9yZW1vdmluZyBhIGxvdCBvZiBvYmplY3RzIHRvL2Zyb20gY2FudmFzIGF0IG9uY2VcbiAgICAgKiBzaW5jZSB0aGUgcmVuZGVycyBhcmUgcXVlcXVlZCBhbmQgZXhlY3V0ZWQgb25lIHBlciBmcmFtZS5cbiAgICAgKiBEaXNhYmxpbmcgaXMgc3VnZ2VzdGVkIGFueXdheSBhbmQgbWFuYWdpbmcgdGhlIHJlbmRlcnMgb2YgdGhlIGFwcCBtYW51YWxseSBpcyBub3QgYSBiaWcgZWZmb3J0ICggY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKSApXG4gICAgICogTGVmdCBkZWZhdWx0IHRvIHRydWUgdG8gZG8gbm90IGJyZWFrIGRvY3VtZW50YXRpb24gYW5kIG9sZCBhcHAsIGZpZGRsZXMuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVuZGVyT25BZGRSZW1vdmU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3QgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpIGFyZSByZW5kZXJlZCBhYm92ZSBvdmVybGF5IGltYWdlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udHJvbHNBYm92ZU92ZXJsYXk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGJlIHNjcm9sbGVkIHdoZW4gdXNpbmcgYSB0b3VjaHNjcmVlbiBhbmQgZHJhZ2dpbmcgb24gdGhlIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsbG93VG91Y2hTY3JvbGxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nLCB0aGlzIGlzIG9uIGJ5IGRlZmF1bHQgaW4gYnJvd3NlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtYXRpb24gKGluIHRoZSBmb3JtYXQgb2YgQ2FudmFzIHRyYW5zZm9ybSkgd2hpY2ggZm9jdXNlcyB0aGUgdmlld3BvcnRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlld3BvcnRUcmFuc2Zvcm06IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIGJhY2tncm91bmQgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2Ugb3Zlcmx5YSBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheVZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgY2FudmFzIGlzIHNjYWxlZCBieSBkZXZpY2VQaXhlbFJhdGlvIGZvciBiZXR0ZXIgcmVuZGVyaW5nIG9uIHJldGluYSBzY3JlZW5zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZW5hYmxlUmV0aW5hU2NhbGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGNhbnZhcyBlbGVtZW50IGV4dGVuc2lvbiBvdmVyIGRlc2lnblxuICAgICAqIHByb3BlcnRpZXMgYXJlIHRsLHRyLGJsLGJyLlxuICAgICAqIGlmIGNhbnZhcyBpcyBub3Qgem9vbWVkL3Bhbm5lZCB0aG9zZSBwb2ludHMgYXJlIHRoZSBmb3VyIGNvcm5lciBvZiBjYW52YXNcbiAgICAgKiBpZiBjYW52YXMgaXMgdmlld3BvcnRUcmFuc2Zvcm1lZCB5b3UgdGhvc2UgcG9pbnRzIGluZGljYXRlIHRoZSBleHRlbnNpb25cbiAgICAgKiBvZiBjYW52YXMgZWxlbWVudCBpbiBwbGFpbiB1bnRyYXNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIGNhbGNWaWV3cG9ydEJvdW5kYXJpZXMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlXG4gICAgICovXG4gICAgdnB0Q29vcmRzOiB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB2cHRDb29yZHMgYW5kIG9iamVjdC5hQ29vcmRzLCBza2lwIHJlbmRlcmluZyBvZiBvYmplY3RzIHRoYXRcbiAgICAgKiBhcmUgbm90IGluY2x1ZGVkIGluIGN1cnJlbnQgdmlld3BvcnQuXG4gICAgICogTWF5IGdyZWF0bHkgaGVscCBpbiBhcHBsaWNhdGlvbnMgd2l0aCBjcm93ZGVkIGNhbnZhcyBhbmQgdXNlIG9mIHpvb20vcGFuXG4gICAgICogSWYgT25lIG9mIHRoZSBjb3JuZXIgb2YgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb2JqZWN0IGlzIG9uIHRoZSBjYW52YXNcbiAgICAgKiB0aGUgb2JqZWN0cyBnZXQgcmVuZGVyZWQuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tpcE9mZnNjcmVlbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGEgZmFicmljT2JqZWN0IHRoYXQsIHdpdGhvdXQgc3Ryb2tlIGRlZmluZSBhIGNsaXBwaW5nIGFyZWEgd2l0aCB0aGVpciBzaGFwZS4gZmlsbGVkIGluIGJsYWNrXG4gICAgICogdGhlIGNsaXBQYXRoIG9iamVjdCBnZXRzIHVzZWQgd2hlbiB0aGUgY2FudmFzIGhhcyByZW5kZXJlZCwgYW5kIHRoZSBjb250ZXh0IGlzIHBsYWNlZCBpbiB0aGVcbiAgICAgKiB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBjbGlwUGF0aCB3aWxsIGNsaXAgYXdheSBjb250cm9scywgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgdG8gaGFwcGVuIHVzZSBjb250cm9sc0Fib3ZlT3ZlcmxheSA9IHRydWVcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgY2xpcFBhdGg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0U3RhdGljOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNiID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQ7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB0aGlzLl9jcmVhdGVMb3dlckNhbnZhcyhlbCk7XG4gICAgICB0aGlzLl9pbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIC8vIG9ubHkgaW5pdGlhbGl6ZSByZXRpbmEgc2NhbGluZyBvbmNlXG4gICAgICBpZiAoIXRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3ZlcmxheUltYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0T3ZlcmxheUltYWdlKG9wdGlvbnMub3ZlcmxheUltYWdlLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kSW1hZ2Uob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvciwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0T3ZlcmxheUNvbG9yKG9wdGlvbnMub3ZlcmxheUNvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZmFicmljLmRldmljZVBpeGVsUmF0aW8gIT09IDEgJiYgdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJldGluYVNjYWxpbmcgaWYgYXBwbGllZCwgb3RoZXJ3aXNlIDE7XG4gICAgICovXG4gICAgZ2V0UmV0aW5hU2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNSZXRpbmFTY2FsaW5nKCkgPyBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjYWxlUmF0aW8gPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuX19pbml0UmV0aW5hU2NhbGluZyhzY2FsZVJhdGlvLCB0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMuX19pbml0UmV0aW5hU2NhbGluZyhzY2FsZVJhdGlvLCB0aGlzLnVwcGVyQ2FudmFzRWwsIHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9faW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKHNjYWxlUmF0aW8sIGNhbnZhcywgY29udGV4dCkge1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoICogc2NhbGVSYXRpbyk7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCAqIHNjYWxlUmF0aW8pO1xuICAgICAgY29udGV4dC5zY2FsZShzY2FsZVJhdGlvLCBzY2FsZVJhdGlvKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGNhbnZhcyBlbGVtZW50IG9mZnNldCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF0dGFjaGVkIGFzIFwicmVzaXplXCIgZXZlbnQgaGFuZGxlciBvZiB3aW5kb3dcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSBnZXRFbGVtZW50T2Zmc2V0KHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheSBpbWFnZX0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoZmFicmljLkltYWdlfFN0cmluZyl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSBvciBVUkwgb2YgYW4gaW1hZ2UgdG8gc2V0IG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBhbiBvdmVybGF5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIHRvIHNldCBmb3IgdGhlIHtAbGluayBmYWJyaWMuSW1hZ2V8b3ZlcmxheSBpbWFnZX0uXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL01uekhUL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBvdmVybGF5SW1hZ2Ugd2l0aCBsZWZ0L3RvcCA9IDA8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSB3aXRoIGRpZmZlcmVudCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIG92ZXJsYXlJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAqICAgIGltZy5zZXQoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCwgb3JpZ2luWDogJ2xlZnQnLCBvcmlnaW5ZOiAndG9wJ30pO1xuICAgICAqICAgIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoaW1nLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIG92ZXJsYXlJbWFnZSAjMiAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICogICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gb3ZlcmxheUltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5vdmVybGF5SW1hZ2UgbG9hZGVkIGZyb20gY3Jvc3Mtb3JpZ2luPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3ZlcmxheUltYWdlOiBmdW5jdGlvbiAoaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUltYWdlKCdvdmVybGF5SW1hZ2UnLCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRJbWFnZXxiYWNrZ3JvdW5kIGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgYmFja2dyb3VuZCB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGJhY2tncm91bmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxiYWNrZ3JvdW5kIGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZGpucjhvN2EvMjgvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIGJhY2tncm91bmRJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSB3aXRoIGRpZmZlcmVudCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzEgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGZhYnJpYy5JbWFnZS5mcm9tVVJMKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldEJhY2tncm91bmRJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgYmFja2dyb3VuZEltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICogICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gYmFja2dyb3VuZEltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5iYWNrZ3JvdW5kSW1hZ2UgbG9hZGVkIGZyb20gY3Jvc3Mtb3JpZ2luPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJyxcbiAgICAgKiAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIC8vIFRPRE86IGZpeCBzdHJldGNoZWQgZXhhbXBsZXNcbiAgICBzZXRCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ2JhY2tncm91bmRJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUNvbG9yfGZvcmVncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IG92ZXJsYXlDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gZm9yZWdyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvcEI1NWgvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldE92ZXJsYXlDb2xvcjogZnVuY3Rpb24ob3ZlcmxheUNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignb3ZlcmxheUNvbG9yJywgb3ZlcmxheUNvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IGJhY2tncm91bmRDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYmFja2dyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvaFh6dmsvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIGJhY2tncm91bmRDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignYmFja2dyb3VuZENvbG9yJywgYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmRJbWFnZX1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheUltYWdlfSlcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nfG51bGwpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2UsIFVSTCBvZiBhbiBpbWFnZSBvciBudWxsIHRvIHNldCBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgY3JlYXRlZCBpbWFnZSwgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVycm9yIG9jY3VycmVkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxpbWFnZX0uXG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24ocHJvcGVydHksIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGltYWdlLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgICAgICBpZiAoaW1nKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgZmFicmljLkltYWdlKGltZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaW5zdGFuY2UuY2FudmFzID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1nLCBpc0Vycm9yKTtcbiAgICAgICAgfSwgdGhpcywgb3B0aW9ucyAmJiBvcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zICYmIGltYWdlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW1hZ2U7XG4gICAgICAgIGltYWdlICYmIChpbWFnZS5jYW52YXMgPSB0aGlzKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1hZ2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmRDb2xvcn1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8b3ZlcmxheUNvbG9yfSlcbiAgICAgKiBAcGFyYW0geyhPYmplY3R8U3RyaW5nfG51bGwpfSBjb2xvciBPYmplY3Qgd2l0aCBwYXR0ZXJuIGluZm9ybWF0aW9uLCBjb2xvciB2YWx1ZSBvciBudWxsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gY29sb3IgaXMgc2V0XG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlDb2xvcjogZnVuY3Rpb24ocHJvcGVydHksIGNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpc1twcm9wZXJ0eV0gPSBjb2xvcjtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChjb2xvciwgcHJvcGVydHkpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4oY29sb3IsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBDQU5WQVNfSU5JVF9FUlJPUjtcbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldENvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsO1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQobG93ZXJDYW52YXNFbC53aWR0aCwgMTApIHx8IDA7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IHBhcnNlSW50KGxvd2VyQ2FudmFzRWwuaGVpZ2h0LCAxMCkgfHwgMDtcblxuICAgICAgaWYgKCF0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIGxvd2VyQ2FudmFzRWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICAvLyBjYW52YXNFbCA9PT0gJ0hUTUxDYW52YXNFbGVtZW50JyBkb2VzIG5vdCB3b3JrIG9uIGpzZG9tL25vZGVcbiAgICAgIGlmIChjYW52YXNFbCAmJiBjYW52YXNFbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGZhYnJpYy51dGlsLmdldEJ5SWQoY2FudmFzRWwpIHx8IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG5cbiAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5sb3dlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHdpZHRoIChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyBoZWlnaHQgKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aWR0aCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IHdpZHRoIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBoZWlnaHQgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCBoZWlnaHQgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IGhlaWdodDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZGltZW5zaW9ucyAod2lkdGgsIGhlaWdodCkgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UuIHdoZW4gb3B0aW9ucy5jc3NPbmx5IGZsYWcgYWN0aXZlIHlvdSBzaG91bGQgYWxzbyBzdXBwbHkgdGhlIHVuaXQgb2YgbWVhc3VyZSAocHgvJS9lbSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRpbWVuc2lvbnMgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy53aWR0aF0gICAgICAgICAgICBXaWR0aCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMuaGVpZ2h0XSAgICAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjc3NWYWx1ZTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBjc3NWYWx1ZSA9IGRpbWVuc2lvbnNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24ocHJvcCwgZGltZW5zaW9uc1twcm9wXSk7XG4gICAgICAgICAgY3NzVmFsdWUgKz0gJ3B4JztcbiAgICAgICAgICB0aGlzLmhhc0xvc3RDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iYWNrc3RvcmVPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q3NzRGltZW5zaW9uKHByb3AsIGNzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9zZXRCcnVzaFN0eWxlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuY3NzT25seSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldEJhY2tzdG9yZURpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FjaGVDYW52YXNFbCkge1xuICAgICAgICB0aGlzLmNhY2hlQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpc1twcm9wXSA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBzZXR0aW5nIGNzcyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldENzc0RpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3JhcHBlckVsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlckVsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyB6b29tIGxldmVsXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZpZXdwb3J0IHRyYW5zZm9ybSBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZwdCB0aGUgdHJhbnNmb3JtIGluIHRoZSBmb3JtIG9mIGNvbnRleHQudHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24gKHZwdCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBiYWNrZ3JvdW5kT2JqZWN0ID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgICAgb3ZlcmxheU9iamVjdCA9IHRoaXMub3ZlcmxheUltYWdlLFxuICAgICAgICAgIG9iamVjdCwgaSwgbGVuO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IHZwdDtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwIHx8IG9iamVjdC5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrZ3JvdW5kT2JqZWN0KSB7XG4gICAgICAgIGJhY2tncm91bmRPYmplY3Quc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXlPYmplY3QpIHtcbiAgICAgICAgb3ZlcmxheU9iamVjdC5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB6b29tIGxldmVsIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlLCB0aGUgem9vbSBjZW50ZXJlZCBhcm91bmQgcG9pbnRcbiAgICAgKiBtZWFuaW5nIHRoYXQgZm9sbG93aW5nIHpvb20gdG8gcG9pbnQgd2l0aCB0aGUgc2FtZSBwb2ludCB3aWxsIGhhdmUgdGhlIHZpc3VhbFxuICAgICAqIGVmZmVjdCBvZiB0aGUgem9vbSBvcmlnaW5hdGluZyBmcm9tIHRoYXQgcG9pbnQuIFRoZSBwb2ludCB3b24ndCBtb3ZlLlxuICAgICAqIEl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggY2FudmFzIGNlbnRlciBvciB2aXN1YWwgY2VudGVyIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gem9vbSB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgem9vbVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgdmFsdWUpIHtcbiAgICAgIC8vIFRPRE86IGp1c3QgY2hhbmdlIHRoZSBzY2FsZSwgcHJlc2VydmUgb3RoZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICB2YXIgYmVmb3JlID0gcG9pbnQsIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSkpO1xuICAgICAgdnB0WzBdID0gdmFsdWU7XG4gICAgICB2cHRbM10gPSB2YWx1ZTtcbiAgICAgIHZhciBhZnRlciA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCB2cHQpO1xuICAgICAgdnB0WzRdICs9IGJlZm9yZS54IC0gYWZ0ZXIueDtcbiAgICAgIHZwdFs1XSArPSBiZWZvcmUueSAtIGFmdGVyLnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnpvb21Ub1BvaW50KG5ldyBmYWJyaWMuUG9pbnQoMCwgMCksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdmlld3BvcnQgc28gYXMgdG8gcGxhY2UgcG9pbnQgYXQgdG9wIGxlZnQgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHZwdFs0XSA9IC1wb2ludC54O1xuICAgICAgdnB0WzVdID0gLXBvaW50Lnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIHZpZXdwb2ludCByZWxhdGl2ZWx5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IChwb3NpdGlvbiB2ZWN0b3IpIHRvIG1vdmUgYnlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHJlbGF0aXZlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic29sdXRlUGFuKG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIC1wb2ludC54IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs0XSxcbiAgICAgICAgLXBvaW50LnkgLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdXG4gICAgICApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIGFkZGVkXG4gICAgICovXG4gICAgX29uT2JqZWN0QWRkZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiBvYmouc2V0dXBTdGF0ZSgpO1xuICAgICAgb2JqLl9zZXQoJ2NhbnZhcycsIHRoaXMpO1xuICAgICAgb2JqLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6YWRkZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ2FkZGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnJlbW92ZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ3JlbW92ZWQnKTtcbiAgICAgIGRlbGV0ZSBvYmouY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc3BlY2lmaWVkIGNvbnRleHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY2xlYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdHMgYXJlIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgdGhpcy5vdmVybGF5Q29sb3IgPSAnJztcbiAgICAgIGlmICh0aGlzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZTp1cCcsIHRoaXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB0aGlzLmZpcmUoJ2NhbnZhczpjbGVhcmVkJyk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX29iamVjdHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNyZWF0ZWQgdG8gYmUgaW5zdGFuY2UgYm91bmQgYXQgaW5pdGlhbGl6YXRpb25cbiAgICAgKiB1c2VkIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSByZW5kZXJpbmdcbiAgICAgKiBMZXQgdGhlIGZhYnJpY0pTIGNhbGwgaXQuIElmIHlvdSBjYWxsIGl0IG1hbnVhbGx5IHlvdSBjb3VsZCBoYXZlIG1vcmVcbiAgICAgKiBhbmltYXRpb25GcmFtZSBzdGFja2luZyBvbiB0byBvZiBlYWNoIG90aGVyXG4gICAgICogZm9yIGFuIGltcGVyYXRpdmUgcmVuZGVyaW5nLCB1c2UgY2FudmFzLnJlbmRlckFsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQW5kUmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSByZW5kZXJBbGwgcmVxdWVzdCB0byBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKiB1bmxlc3Mgb25lIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIGluIHRoYXQgY2FzZSBub3RoaW5nIGlzIGRvbmVcbiAgICAgKiBhIGJvb2xlYW4gZmxhZyB3aWxsIGF2b2lkIGFwcGVuZGluZyBtb3JlLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlcXVlc3RSZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFicmljLnV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLnJlbmRlckFuZFJlc2V0Qm91bmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIDQgY29ybmVyIG9mIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm0uXG4gICAgICogaGVscHMgdG8gZGV0ZXJtaW5hdGUgd2hlbiBhbiBvYmplY3QgaXMgaW4gdGhlIGN1cnJlbnQgcmVuZGVyaW5nIHZpZXdwb3J0IHVzaW5nXG4gICAgICogb2JqZWN0IGFic29sdXRlIGNvb3JkaW5hdGVzICggYUNvb3JkcyApXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludHMudGxcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2FsY1ZpZXdwb3J0Qm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzID0geyB9LCB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICBwb2ludHMudGwgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IDAsIHk6IDAgfSwgaVZwdCk7XG4gICAgICBwb2ludHMuYnIgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSwgaVZwdCk7XG4gICAgICBwb2ludHMudHIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50cy5ici54LCBwb2ludHMudGwueSk7XG4gICAgICBwb2ludHMuYmwgPSBuZXcgZmFicmljLlBvaW50KHBvaW50cy50bC54LCBwb2ludHMuYnIueSk7XG4gICAgICB0aGlzLnZwdENvb3JkcyA9IHBvaW50cztcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcblxuICAgIGNhbmNlbFJlcXVlc3RlZFJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5pc1JlbmRlcmluZyk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJhY2tncm91bmQsIG9iamVjdHMsIG92ZXJsYXkgYW5kIGNvbnRyb2xzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckNhbnZhczogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgdGhpcy5jYW5jZWxSZXF1ZXN0ZWRSZW5kZXIoKTtcbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIGZhYnJpYy51dGlsLnNldEltYWdlU21vb3RoaW5nKGN0eCwgdGhpcy5pbWFnZVNtb290aGluZ0VuYWJsZWQpO1xuICAgICAgdGhpcy5maXJlKCdiZWZvcmU6cmVuZGVyJywgeyBjdHg6IGN0eCwgfSk7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvL2FwcGx5IHZpZXdwb3J0IHRyYW5zZm9ybSBvbmNlIGZvciBhbGwgcmVuZGVyaW5nIHByb2Nlc3NcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0aGlzLl9yZW5kZXJPYmplY3RzKGN0eCwgb2JqZWN0cyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHBhdGguY2FudmFzID0gdGhpcztcbiAgICAgICAgLy8gbmVlZGVkIHRvIHNldHVwIGEgY291cGxlIG9mIHZhcmlhYmxlc1xuICAgICAgICBwYXRoLnNob3VsZENhY2hlKCk7XG4gICAgICAgIHBhdGguX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgICBwYXRoLnJlbmRlckNhY2hlKHsgZm9yQ2xpcHBpbmc6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZHJhd0NsaXBQYXRoT25DYW52YXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlck92ZXJsYXkoY3R4KTtcbiAgICAgIGlmICh0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJywgeyBjdHg6IGN0eCwgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY2xpcFBhdGggb24gdGhlIGxvd2VyQ2FudmFzRWxcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NsaXBQYXRoT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgLy8gREVCVUc6IHVuY29tbWVudCB0aGlzIGxpbmUsIGNvbW1lbnQgdGhlIGZvbGxvd2luZ1xuICAgICAgLy8gY3R4Lmdsb2JhbEFscGhhID0gMC40O1xuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgICBwYXRoLnRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyBwYXRoLnpvb21YLCAxIC8gcGF0aC56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHBhdGguX2NhY2hlQ2FudmFzLCAtcGF0aC5jYWNoZVRyYW5zbGF0aW9uWCwgLXBhdGguY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyT2JqZWN0czogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICB2YXIgaSwgbGVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmplY3RzW2ldICYmIG9iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAnYmFja2dyb3VuZCcgb3IgJ292ZXJsYXknXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWxsID0gdGhpc1twcm9wZXJ0eSArICdDb2xvciddLCBvYmplY3QgPSB0aGlzW3Byb3BlcnR5ICsgJ0ltYWdlJ10sXG4gICAgICAgICAgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIG5lZWRzVnB0ID0gdGhpc1twcm9wZXJ0eSArICdWcHQnXTtcbiAgICAgIGlmICghZmlsbCAmJiAhb2JqZWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLndpZHRoLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvTGl2ZVxuICAgICAgICAgID8gZmlsbC50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogZmlsbDtcbiAgICAgICAgaWYgKG5lZWRzVnB0KSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIDEsIGZpbGwub2Zmc2V0WCB8fCAwLCBmaWxsLm9mZnNldFkgfHwgMCk7XG4gICAgICAgIHZhciBtID0gZmlsbC5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsLnBhdHRlcm5UcmFuc2Zvcm07XG4gICAgICAgIG0gJiYgY3R4LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKG5lZWRzVnB0KSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucmVuZGVyKGN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnYmFja2dyb3VuZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyT3ZlcmxheTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KGN0eCwgJ292ZXJsYXknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIGNlbnRlciBvZiBjYW52YXMuXG4gICAgICogUmV0dXJuZWQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdG9wIGFuZCBsZWZ0IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIFwidG9wXCIgYW5kIFwibGVmdFwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBsZWZ0OiB0aGlzLndpZHRoIC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3RIOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmdldENlbnRlcigpLmxlZnQsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS54LCB0aGlzLmdldENlbnRlcigpLnRvcCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KGNlbnRlci5sZWZ0LCBjZW50ZXIudG9wKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgdnBDZW50ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgaW4gdGhlIHZpZXdwb3J0LCBvYmplY3QudG9wIGlzIHVuY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdEg6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuICAgICAgdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludCh2cENlbnRlci54LCBvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgVmVydGljYWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0VjogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLngsIHZwQ2VudGVyLnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludCBpbiBjYW52YXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBjZW50ZXIgb2YgYWN0dWFsIHZpZXdwb3J0LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdnBDZW50ZXIsIHZpZXdwb3J0IGNlbnRlclxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBnZXRWcENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcbiAgICAgICAgICBpVnB0ID0gaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybVBvaW50KHsgeDogY2VudGVyLmxlZnQsIHk6IGNlbnRlci50b3AgfSwgaVZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIgQ2VudGVyIHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfY2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGNlbnRlcikge1xuICAgICAgb2JqZWN0LnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIEpTT04gcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30ganNvbiBzdHJpbmdcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzSlNPTjogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvRGF0YWxlc3NPYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0TWV0aG9kKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0TWV0aG9kKCd0b0RhdGFsZXNzT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0TWV0aG9kOiBmdW5jdGlvbiAobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuXG4gICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoLCBkYXRhID0ge1xuICAgICAgICB2ZXJzaW9uOiBmYWJyaWMudmVyc2lvbixcbiAgICAgICAgb2JqZWN0czogdGhpcy5fdG9PYmplY3RzKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpLFxuICAgICAgfTtcbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBkYXRhLmNsaXBQYXRoID0gdGhpcy5fdG9PYmplY3QodGhpcy5jbGlwUGF0aCwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG4gICAgICBleHRlbmQoZGF0YSwgdGhpcy5fX3NlcmlhbGl6ZUJnT3ZlcmxheShtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG5cbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgZGF0YSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdHM6IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmZpbHRlcihmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuICFvYmplY3QuZXhjbHVkZUZyb21FeHBvcnQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0KGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0ID0gaW5zdGFuY2VbbWV0aG9kTmFtZV0ocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3NlcmlhbGl6ZUJnT3ZlcmxheTogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGRhdGEgPSB7IH0sIGJnSW1hZ2UgPSB0aGlzLmJhY2tncm91bmRJbWFnZSwgb3ZlcmxheSA9IHRoaXMub3ZlcmxheUltYWdlO1xuXG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9PYmplY3RcbiAgICAgICAgICA/IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICAgOiB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGRhdGEub3ZlcmxheSA9IHRoaXMub3ZlcmxheUNvbG9yLnRvT2JqZWN0XG4gICAgICAgICAgPyB0aGlzLm92ZXJsYXlDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgICAgIDogdGhpcy5vdmVybGF5Q29sb3I7XG4gICAgICB9XG4gICAgICBpZiAoYmdJbWFnZSAmJiAhYmdJbWFnZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KGJnSW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXkgJiYgIW92ZXJsYXkuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5SW1hZ2UgPSB0aGlzLl90b09iamVjdChvdmVybGF5LCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBnZXRTdmdUcmFuc2Zvcm0oKSB3aWxsIGFwcGx5IHRoZSBTdGF0aWNDYW52YXMudmlld3BvcnRUcmFuc2Zvcm0gdG8gdGhlIFNWRyB0cmFuc2Zvcm1hdGlvbi4gV2hlbiB0cnVlLFxuICAgICAqIGEgem9vbWVkIGNhbnZhcyB3aWxsIHRoZW4gcHJvZHVjZSB6b29tZWQgU1ZHIG91dHB1dC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBmb3IgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VwcHJlc3NQcmVhbWJsZT1mYWxzZV0gSWYgdHJ1ZSB4bWwgdGFnIGlzIG5vdCBpbmNsdWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy52aWV3Qm94XSBTVkcgdmlld2JveCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC54XSB4LWNvb3JkaW5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnldIHktY29vcmRpbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gud2lkdGhdIFdpZHRoIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC5oZWlnaHRdIEhlaWdodCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPVVURi04XSBFbmNvZGluZyBvZiBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpZHRoXSBkZXNpcmVkIHdpZHRoIG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGVpZ2h0XSBkZXNpcmVkIGhlaWdodCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjb252ZXJ0ZWQgaW50byBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgc3RyaW5nXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2pRM1paL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBTVkcgb3V0cHV0PC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGhvdXQgcHJlYW1ibGUgKHdpdGhvdXQgJmx0Oz94bWwgLi4vPik8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7c3VwcHJlc3NQcmVhbWJsZTogdHJ1ZX0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCB2aWV3Qm94IGF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtcbiAgICAgKiAgIHZpZXdCb3g6IHtcbiAgICAgKiAgICAgeDogMTAwLFxuICAgICAqICAgICB5OiAxMDAsXG4gICAgICogICAgIHdpZHRoOiAyMDAsXG4gICAgICogICAgIGhlaWdodDogMzAwXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIGRpZmZlcmVudCBlbmNvZGluZyAoZGVmYXVsdDogVVRGLTgpPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe2VuY29kaW5nOiAnSVNPLTg4NTktMSd9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Nb2RpZnkgU1ZHIG91dHB1dCB3aXRoIHJldml2ZXIgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyhudWxsLCBmdW5jdGlvbihzdmcpIHtcbiAgICAgKiAgIHJldHVybiBzdmcucmVwbGFjZSgnc3Ryb2tlLWRhc2hhcnJheTogOyBzdHJva2UtbGluZWNhcDogYnV0dDsgc3Ryb2tlLWxpbmVqb2luOiBtaXRlcjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyAnLCAnJyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9wdGlvbnMsIHJldml2ZXIpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgb3B0aW9ucy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgICAgIHZhciBtYXJrdXAgPSBbXTtcblxuICAgICAgdGhpcy5fc2V0U1ZHUHJlYW1ibGUobWFya3VwLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFNWR0hlYWRlcihtYXJrdXAsIG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goJzxnIGNsaXAtcGF0aD1cInVybCgjJyArIHRoaXMuY2xpcFBhdGguY2xpcFBhdGhJZCArICcpXCIgPlxcbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnYmFja2dyb3VuZCcpO1xuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5SW1hZ2UobWFya3VwLCAnYmFja2dyb3VuZEltYWdlJywgcmV2aXZlcik7XG4gICAgICB0aGlzLl9zZXRTVkdPYmplY3RzKG1hcmt1cCwgcmV2aXZlcik7XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaCgnPC9nPlxcbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnb3ZlcmxheScpO1xuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5SW1hZ2UobWFya3VwLCAnb3ZlcmxheUltYWdlJywgcmV2aXZlcik7XG5cbiAgICAgIG1hcmt1cC5wdXNoKCc8L3N2Zz4nKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHUHJlYW1ibGU6IGZ1bmN0aW9uKG1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuc3VwcHJlc3NQcmVhbWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIicsIChvcHRpb25zLmVuY29kaW5nIHx8ICdVVEYtOCcpLCAnXCIgc3RhbmRhbG9uZT1cIm5vXCIgPz5cXG4nLFxuICAgICAgICAnPCFET0NUWVBFIHN2ZyBQVUJMSUMgXCItLy9XM0MvL0RURCBTVkcgMS4xLy9FTlwiICcsXG4gICAgICAgICdcImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZFwiPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0hlYWRlcjogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgdnB0LCB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCIwIDAgJyArIHRoaXMud2lkdGggKyAnICcgKyB0aGlzLmhlaWdodCArICdcIiAnLFxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG5cbiAgICAgIGlmIChvcHRpb25zLnZpZXdCb3gpIHtcbiAgICAgICAgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnggKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC55ICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gud2lkdGggKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC5oZWlnaHQgKyAnXCIgJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQoLXZwdFs0XSAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzVdIC8gdnB0WzNdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMud2lkdGggLyB2cHRbMF0sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQgLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiICc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8c3ZnICcsXG4gICAgICAgICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyxcbiAgICAgICAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcsXG4gICAgICAgICd2ZXJzaW9uPVwiMS4xXCIgJyxcbiAgICAgICAgJ3dpZHRoPVwiJywgd2lkdGgsICdcIiAnLFxuICAgICAgICAnaGVpZ2h0PVwiJywgaGVpZ2h0LCAnXCIgJyxcbiAgICAgICAgdmlld0JveCxcbiAgICAgICAgJ3htbDpzcGFjZT1cInByZXNlcnZlXCI+XFxuJyxcbiAgICAgICAgJzxkZXNjPkNyZWF0ZWQgd2l0aCBGYWJyaWMuanMgJywgZmFicmljLnZlcnNpb24sICc8L2Rlc2M+XFxuJyxcbiAgICAgICAgJzxkZWZzPlxcbicsXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHRm9udEZhY2VzTWFya3VwKCksXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHUmVmRWxlbWVudHNNYXJrdXAoKSxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdDbGlwUGF0aE1hcmt1cChvcHRpb25zKSxcbiAgICAgICAgJzwvZGVmcz5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTVkdDbGlwUGF0aE1hcmt1cDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBjbGlwUGF0aC5jbGlwUGF0aElkID0gJ0NMSVBQQVRIXycgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICAgIHJldHVybiAgJzxjbGlwUGF0aCBpZD1cIicgKyBjbGlwUGF0aC5jbGlwUGF0aElkICsgJ1wiID5cXG4nICtcbiAgICAgICAgICB0aGlzLmNsaXBQYXRoLnRvQ2xpcFBhdGhTVkcob3B0aW9ucy5yZXZpdmVyKSArXG4gICAgICAgICAgJzwvY2xpcFBhdGg+XFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgcmVmZXJlbmNlZCBlbGVtZW50cyBsaWtlIHBhdHRlcm5zLCBncmFkaWVudHMgZXRjLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIG1hcmt1cCA9IFsnYmFja2dyb3VuZCcsICdvdmVybGF5J10ubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gX3RoaXNbcHJvcCArICdDb2xvciddO1xuICAgICAgICAgICAgaWYgKGZpbGwgJiYgZmlsbC50b0xpdmUpIHtcbiAgICAgICAgICAgICAgdmFyIHNob3VsZFRyYW5zZm9ybSA9IF90aGlzW3Byb3AgKyAnVnB0J10sIHZwdCA9IF90aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogX3RoaXMud2lkdGggLyAoc2hvdWxkVHJhbnNmb3JtID8gdnB0WzBdIDogMSksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogX3RoaXMuaGVpZ2h0IC8gKHNob3VsZFRyYW5zZm9ybSA/IHZwdFszXSA6IDEpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gZmlsbC50b1NWRyhcbiAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgeyBhZGRpdGlvbmFsVHJhbnNmb3JtOiBzaG91bGRUcmFuc2Zvcm0gPyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyh2cHQpIDogJycgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgZm9udCBmYWNlcyxcbiAgICAgKiBmb250IFVSTHMgZm9yIGZvbnQgZmFjZXMgbXVzdCBiZSBjb2xsZWN0ZWQgYnkgZGV2ZWxvcGVyc1xuICAgICAqIGFuZCBhcmUgbm90IGV4dHJhY3RlZCBmcm9tIHRoZSBET00gYnkgZmFicmljanNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIEFycmF5IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya3VwID0gJycsIGZvbnRMaXN0ID0geyB9LCBvYmosIGZvbnRGYW1pbHksXG4gICAgICAgICAgc3R5bGUsIHJvdywgcm93SW5kZXgsIF9jaGFyLCBjaGFySW5kZXgsIGksIGxlbixcbiAgICAgICAgICBmb250UGF0aHMgPSBmYWJyaWMuZm9udFBhdGhzLCBvYmplY3RzID0gW107XG5cbiAgICAgIHRoaXMuX29iamVjdHMuZm9yRWFjaChmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0Ll9vYmplY3RzKSB7XG4gICAgICAgICAgb2JqZWN0Ll9vYmplY3RzLmZvckVhY2goYWRkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2JqID0gb2JqZWN0c1tpXTtcbiAgICAgICAgZm9udEZhbWlseSA9IG9iai5mb250RmFtaWx5O1xuICAgICAgICBpZiAob2JqLnR5cGUuaW5kZXhPZigndGV4dCcpID09PSAtMSB8fCBmb250TGlzdFtmb250RmFtaWx5XSB8fCAhZm9udFBhdGhzW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9udExpc3RbZm9udEZhbWlseV0gPSB0cnVlO1xuICAgICAgICBpZiAoIW9iai5zdHlsZXMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZSA9IG9iai5zdHlsZXM7XG4gICAgICAgIGZvciAocm93SW5kZXggaW4gc3R5bGUpIHtcbiAgICAgICAgICByb3cgPSBzdHlsZVtyb3dJbmRleF07XG4gICAgICAgICAgZm9yIChjaGFySW5kZXggaW4gcm93KSB7XG4gICAgICAgICAgICBfY2hhciA9IHJvd1tjaGFySW5kZXhdO1xuICAgICAgICAgICAgZm9udEZhbWlseSA9IF9jaGFyLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICBpZiAoIWZvbnRMaXN0W2ZvbnRGYW1pbHldICYmIGZvbnRQYXRoc1tmb250RmFtaWx5XSkge1xuICAgICAgICAgICAgICBmb250TGlzdFtmb250RmFtaWx5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogaW4gZm9udExpc3QpIHtcbiAgICAgICAgbWFya3VwICs9IFtcbiAgICAgICAgICAnXFx0XFx0QGZvbnQtZmFjZSB7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0XFx0Zm9udC1mYW1pbHk6IFxcJycsIGosICdcXCc7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0XFx0c3JjOiB1cmwoXFwnJywgZm9udFBhdGhzW2pdLCAnXFwnKTtcXG4nLFxuICAgICAgICAgICdcXHRcXHR9XFxuJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnXFx0PHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPicsXG4gICAgICAgICAgJzwhW0NEQVRBW1xcbicsXG4gICAgICAgICAgbWFya3VwLFxuICAgICAgICAgICddXT4nLFxuICAgICAgICAgICc8L3N0eWxlPlxcbidcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0czogZnVuY3Rpb24obWFya3VwLCByZXZpdmVyKSB7XG4gICAgICB2YXIgaW5zdGFuY2UsIGksIGxlbiwgb2JqZWN0cyA9IHRoaXMuX29iamVjdHM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGluc3RhbmNlID0gb2JqZWN0c1tpXTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0U1ZHT2JqZWN0KG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3Q6IGZ1bmN0aW9uKG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpIHtcbiAgICAgIG1hcmt1cC5wdXNoKGluc3RhbmNlLnRvU1ZHKHJldml2ZXIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHksIHJldml2ZXIpIHtcbiAgICAgIGlmICh0aGlzW3Byb3BlcnR5XSAmJiAhdGhpc1twcm9wZXJ0eV0uZXhjbHVkZUZyb21FeHBvcnQgJiYgdGhpc1twcm9wZXJ0eV0udG9TVkcpIHtcbiAgICAgICAgbWFya3VwLnB1c2godGhpc1twcm9wZXJ0eV0udG9TVkcocmV2aXZlcikpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlDb2xvcjogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGZpbGxlciA9IHRoaXNbcHJvcGVydHkgKyAnQ29sb3InXSwgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgZmluYWxXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgZmluYWxIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIGlmICghZmlsbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBmaWxsZXIucmVwZWF0LCBpVnB0ID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHZwdCksIHNob3VsZEludmVydCA9IHRoaXNbcHJvcGVydHkgKyAnVnB0J10sXG4gICAgICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID0gc2hvdWxkSW52ZXJ0ID8gZmFicmljLnV0aWwubWF0cml4VG9TVkcoaVZwdCkgOiAnJztcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHRyYW5zZm9ybT1cIicgKyBhZGRpdGlvbmFsVHJhbnNmb3JtICsgJyB0cmFuc2xhdGUoJywgZmluYWxXaWR0aCAvIDIsICcsJywgZmluYWxIZWlnaHQgLyAyLCAnKVwiJyxcbiAgICAgICAgICAnIHg9XCInLCBmaWxsZXIub2Zmc2V0WCAtIGZpbmFsV2lkdGggLyAyLFxuICAgICAgICAgICdcIiB5PVwiJywgZmlsbGVyLm9mZnNldFkgLSBmaW5hbEhlaWdodCAvIDIsICdcIiAnLFxuICAgICAgICAgICd3aWR0aD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2Uud2lkdGhcbiAgICAgICAgICAgIDogZmluYWxXaWR0aCApLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgIChyZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgcmVwZWF0ID09PSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgPyBmaWxsZXIuc291cmNlLmhlaWdodFxuICAgICAgICAgICAgOiBmaW5hbEhlaWdodCksXG4gICAgICAgICAgJ1wiIGZpbGw9XCJ1cmwoI1NWR0lEXycgKyBmaWxsZXIuaWQgKyAnKVwiJyxcbiAgICAgICAgICAnPjwvcmVjdD5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgJyxcbiAgICAgICAgICAnZmlsbD1cIicsIGZpbGxlciwgJ1wiJyxcbiAgICAgICAgICAnPjwvcmVjdD5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciB0aGUgb2JqZWN0cyBvZiBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAqIHRvIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZCB0byBiYWNrXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZW5kVG9CYWNrOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBvYmpzO1xuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSBvYmpzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy51bnNoaWZ0KG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgdGhpcy5fb2JqZWN0cy51bnNoaWZ0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciB0aGUgb2JqZWN0cyBvZiBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAqIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBvYmpzO1xuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgdGhpcy5fb2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiBkb3duIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIsIGludGVyc2VjdGluZyBhbGxvd3MgdG8gbW92ZSB0aGUgb2JqZWN0IGluIGJlaGluZFxuICAgICAqIHRoZSBmaXJzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0LiBXaGVyZSBpbnRlcnNlY3Rpb24gaXMgY2FsY3VsYXRlZCB3aXRoXG4gICAgICogYm91bmRpbmcgYm94LiBJZiBubyBpbnRlcnNlY3Rpb24gaXMgZm91bmQsIHRoZXJlIHdpbGwgbm90IGJlIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBzdGFjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBiZWhpbmQgbmV4dCBsb3dlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZW5kQmFja3dhcmRzOiBmdW5jdGlvbiAob2JqZWN0LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzLCBvYmpzTW92ZWQgPSAwO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4ID4gMCArIG9ianNNb3ZlZCkge1xuICAgICAgICAgICAgbmV3SWR4ID0gaWR4IC0gMTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpzTW92ZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICBpZiAoaWR4ICE9PSAwKSB7XG4gICAgICAgICAgLy8gaWYgb2JqZWN0IGlzIG5vdCBvbiB0aGUgYm90dG9tIG9mIHN0YWNrXG4gICAgICAgICAgbmV3SWR4ID0gdGhpcy5fZmluZE5ld0xvd2VySW5kZXgob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZyk7XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmROZXdMb3dlckluZGV4OiBmdW5jdGlvbihvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICB2YXIgbmV3SWR4LCBpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeDtcblxuICAgICAgICAvLyB0cmF2ZXJzZSBkb3duIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAoaSA9IGlkeCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cbiAgICAgICAgICB2YXIgaXNJbnRlcnNlY3RpbmcgPSBvYmplY3QuaW50ZXJzZWN0c1dpdGhPYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdJZHggPSBpZHggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SWR4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEFuIG9wdGlvbmFsIHBhcmFtZXRlciwgaW50ZXJzZWN0aW5nIGFsbG93cyB0byBtb3ZlIHRoZSBvYmplY3QgaW4gZnJvbnRcbiAgICAgKiBvZiB0aGUgZmlyc3QgaW50ZXJzZWN0aW5nIG9iamVjdC4gV2hlcmUgaW50ZXJzZWN0aW9uIGlzIGNhbGN1bGF0ZWQgd2l0aFxuICAgICAqIGJvdW5kaW5nIGJveC4gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIGZvdW5kLCB0aGVyZSB3aWxsIG5vdCBiZSBjaGFuZ2UgaW4gdGhlXG4gICAgICogc3RhY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianMsIG9ianNNb3ZlZCA9IDA7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gb2Jqcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggPCB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEgLSBvYmpzTW92ZWQpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Jqc01vdmVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gaWYgb2JqZWN0IGlzIG5vdCBvbiB0b3Agb2Ygc3RhY2sgKGxhc3QgaXRlbSBpbiBhbiBhcnJheSlcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3VXBwZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld1VwcGVySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHgsIGksIGxlbjtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgdXAgdGhlIHN0YWNrIGxvb2tpbmcgZm9yIHRoZSBuZWFyZXN0IGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgICAgZm9yIChpID0gaWR4ICsgMSwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggUG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCkge1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSBjYW52YXMgZWxlbWVudCBhbmQgZGlzcG9zZSBvYmplY3RzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjYW5jZWwgZXZlbnR1YWxseSBvbmdvaW5nIHJlbmRlcnNcbiAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLmlzUmVuZGVyaW5nKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmZvckVhY2hPYmplY3QoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5kaXNwb3NlICYmIG9iamVjdC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZSAmJiB0aGlzLmJhY2tncm91bmRJbWFnZS5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm92ZXJsYXlJbWFnZSAmJiB0aGlzLm92ZXJsYXlJbWFnZS5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheUltYWdlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3ZlcmxheUltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dENvbnRhaW5lciA9IG51bGw7XG4gICAgICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQ2FudmFzICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKTogJyArXG4gICAgICAgICAgICAgICAneyBvYmplY3RzOiAnICsgdGhpcy5fb2JqZWN0cy5sZW5ndGggKyAnIH0+JztcbiAgICB9XG4gIH0pO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5Db2xsZWN0aW9uKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuRGF0YVVSTEV4cG9ydGVyKTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzICovIHtcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIEVNUFRZX0pTT046ICd7XCJvYmplY3RzXCI6IFtdLCBcImJhY2tncm91bmRcIjogXCJ3aGl0ZVwifScsXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHdheSB0byBjaGVjayBzdXBwb3J0IG9mIHNvbWUgb2YgdGhlIGNhbnZhcyBtZXRob2RzXG4gICAgICogKGVpdGhlciB0aG9zZSBvZiBIVE1MQ2FudmFzRWxlbWVudCBpdHNlbGYsIG9yIHJlbmRlcmluZyBjb250ZXh0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgTWV0aG9kIHRvIGNoZWNrIHN1cHBvcnQgZm9yO1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvdWxkIGJlIG9uZSBvZiBcInNldExpbmVEYXNoXCJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFuIHwgbnVsbH0gYHRydWVgIGlmIG1ldGhvZCBpcyBzdXBwb3J0ZWQgKG9yIGF0IGxlYXN0IGV4aXN0cyksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGBudWxsYCBpZiBjYW52YXMgZWxlbWVudCBvciBjb250ZXh0IGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBzdXBwb3J0czogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBlbCA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgICAgaWYgKCFlbCB8fCAhZWwuZ2V0Q29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IGVsLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChtZXRob2ROYW1lKSB7XG5cbiAgICAgICAgY2FzZSAnc2V0TGluZURhc2gnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgKiB0aGlzIGFsaWFzIGlzIHByb3ZpZGVkIGJlY2F1c2UgaWYgeW91IGNhbGwgSlNPTi5zdHJpbmdpZnkgb24gYW4gaW5zdGFuY2UsXG4gICAqIHRoZSB0b0pTT04gb2JqZWN0IHdpbGwgYmUgaW52b2tlZCBpZiBpdCBleGlzdHMuXG4gICAqIEhhdmluZyBhIHRvSlNPTiBtZXRob2QgbWVhbnMgeW91IGNhbiBkbyBKU09OLnN0cmluZ2lmeShteUNhbnZhcylcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICogQHJldHVybiB7T2JqZWN0fSBKU09OIGNvbXBhdGlibGUgb2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI3NlcmlhbGl6YXRpb259XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvcGVjODYvfGpzRmlkZGxlIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aG91dCBhZGRpdGlvbmFsIHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTigpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGluY2x1ZGVkPC9jYXB0aW9uPlxuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oWydsb2NrTW92ZW1lbnRYJywgJ2xvY2tNb3ZlbWVudFknLCAnbG9ja1JvdGF0aW9uJywgJ2xvY2tTY2FsaW5nWCcsICdsb2NrU2NhbGluZ1knXSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aG91dCBkZWZhdWx0IHZhbHVlczwvY2FwdGlvbj5cbiAgICogY2FudmFzLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTigpO1xuICAgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUudG9KU09OID0gZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUudG9PYmplY3Q7XG5cbiAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVQTkdTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbXBsID0gZ2V0Tm9kZUNhbnZhcyh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIGltcGwgJiYgaW1wbC5jcmVhdGVQTkdTdHJlYW0oKTtcbiAgICB9O1xuICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmNyZWF0ZUpQRUdTdHJlYW0gPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICB2YXIgaW1wbCA9IGdldE5vZGVDYW52YXModGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiBpbXBsICYmIGltcGwuY3JlYXRlSlBFR1N0cmVhbShvcHRzKTtcbiAgICB9O1xuICB9XG59KSgpO1xuXG5cbi8qKlxuICogQmFzZUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLkJhc2VCcnVzaFxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mcmVlZHJhd2luZ3xGcmVlZHJhd2luZyBkZW1vfVxuICovXG5mYWJyaWMuQmFzZUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuQmFzZUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIENvbG9yIG9mIGEgYnJ1c2hcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBjb2xvcjogJ3JnYigwLCAwLCAwKScsXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgYnJ1c2gsIGhhcyB0byBiZSBhIE51bWJlciwgbm8gc3RyaW5nIGxpdGVyYWxzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwic2hhZG93Q29sb3JcIiAoU3RyaW5nKSwgXCJzaGFkb3dPZmZzZXRYXCIgKE51bWJlciksXG4gICAqIFwic2hhZG93T2Zmc2V0WVwiIChOdW1iZXIpIGFuZCBcInNoYWRvd0JsdXJcIiAoTnVtYmVyKSBzaW5jZSB2MS4yLjEyXG4gICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHNoYWRvdzogbnVsbCxcblxuICAvKipcbiAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVDYXA6ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIENvcm5lciBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJiZXZlbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lSm9pbjogJ3JvdW5kJyxcblxuICAvKipcbiAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhIGJydXNoJ3NcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBTdHJva2UgRGFzaCBBcnJheS5cbiAgICogQHR5cGUgQXJyYXlcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZURhc2hBcnJheTogbnVsbCxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjdHgubGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcDtcbiAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICBjdHgubGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luO1xuICAgIGlmIChmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpKSB7XG4gICAgICBjdHguc2V0TGluZURhc2godGhpcy5zdHJva2VEYXNoQXJyYXkgfHwgW10pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtYXRpb24gb24gZ2l2ZW4gY29udGV4dFxuICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZUFuZFRyYW5zZm9ybTogZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcyxcbiAgICAgICAgc2hhZG93ID0gdGhpcy5zaGFkb3csXG4gICAgICAgIGN0eCA9IGNhbnZhcy5jb250ZXh0VG9wLFxuICAgICAgICB6b29tID0gY2FudmFzLmdldFpvb20oKTtcbiAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgIHpvb20gKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gc2hhZG93LmNvbG9yO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIgKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFggKiB6b29tO1xuICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFkgKiB6b29tO1xuICB9LFxuXG4gIG5lZWRzRnVsbFJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKTtcbiAgICByZXR1cm4gY29sb3IuZ2V0QWxwaGEoKSA8IDEgfHwgISF0aGlzLnNoYWRvdztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuXG4gICAgY3R4LnNoYWRvd0NvbG9yID0gJyc7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogUGVuY2lsQnJ1c2ggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QZW5jaWxCcnVzaFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gICAqL1xuICBmYWJyaWMuUGVuY2lsQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5QZW5jaWxCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZCBwb2ludHMgdGhhdCBhcmUgbGVzcyB0aGFuIGBkZWNpbWF0ZWAgcGl4ZWwgZGlzdGFudCBmcm9tIGVhY2ggb3RoZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjRcbiAgICAgKi9cbiAgICBkZWNpbWF0ZTogMC40LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QZW5jaWxCcnVzaH0gSW5zdGFuY2Ugb2YgYSBwZW5jaWwgYnJ1c2hcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fcG9pbnRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIF9kcmF3U2VnbWVudDogZnVuY3Rpb24gKGN0eCwgcDEsIHAyKSB7XG4gICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSk7XG4gICAgICByZXR1cm4gbWlkUG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHJlcGFyZUZvckRyYXdpbmcocG9pbnRlcik7XG4gICAgICAvLyBjYXB0dXJlIGNvb3JkaW5hdGVzIGltbWVkaWF0ZWx5XG4gICAgICAvLyB0aGlzIGFsbG93cyB0byBkcmF3IGRvdHMgKHdoZW4gbW92ZW1lbnQgbmV2ZXIgb2NjdXJzKVxuICAgICAgdGhpcy5fY2FwdHVyZURyYXdpbmdQYXRoKHBvaW50ZXIpO1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NhcHR1cmVEcmF3aW5nUGF0aChwb2ludGVyKSAmJiB0aGlzLl9wb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc0Z1bGxSZW5kZXIoKSkge1xuICAgICAgICAgIC8vIHJlZHJhdyBjdXJ2ZVxuICAgICAgICAgIC8vIGNsZWFyIHRvcCBjYW52YXNcbiAgICAgICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cywgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCwgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgICAgICAvLyBkcmF3IHRoZSBjdXJ2ZSB1cGRhdGVcbiAgICAgICAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgICAgICAgaWYgKHRoaXMub2xkRW5kKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMub2xkRW5kLngsIHRoaXMub2xkRW5kLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9sZEVuZCA9IHRoaXMuX2RyYXdTZWdtZW50KGN0eCwgcG9pbnRzW2xlbmd0aCAtIDJdLCBwb2ludHNbbGVuZ3RoIC0gMV0sIHRydWUpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICAgKi9cbiAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLm9sZEVuZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5kQWRkUGF0aCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX3ByZXBhcmVGb3JEcmF3aW5nOiBmdW5jdGlvbihwb2ludGVyKSB7XG5cbiAgICAgIHZhciBwID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwKTtcbiAgICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubW92ZVRvKHAueCwgcC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gYmUgYWRkZWQgdG8gcG9pbnRzIGFycmF5XG4gICAgICovXG4gICAgX2FkZFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPiAxICYmIHBvaW50LmVxKHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBwb2ludHMgYXJyYXkgYW5kIHNldCBjb250ZXh0VG9wIGNhbnZhcyBzdHlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9wb2ludHMgPSBbXTtcbiAgICAgIHRoaXMuX3NldEJydXNoU3R5bGVzKCk7XG4gICAgICB0aGlzLl9zZXRTaGFkb3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBBY3R1YWwgbW91c2UgcG9zaXRpb24gcmVsYXRlZCB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIF9jYXB0dXJlRHJhd2luZ1BhdGg6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludGVyUG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRQb2ludChwb2ludGVyUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc21vb3RoIHBhdGggb24gdGhlIHRvcENhbnZhcyB1c2luZyBxdWFkcmF0aWNDdXJ2ZVRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuLFxuICAgICAgICAgIHAxID0gdGhpcy5fcG9pbnRzWzBdLFxuICAgICAgICAgIHAyID0gdGhpcy5fcG9pbnRzWzFdO1xuXG4gICAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAvL2lmIHdlIG9ubHkgaGF2ZSAyIHBvaW50cyBpbiB0aGUgcGF0aCBhbmQgdGhleSBhcmUgdGhlIHNhbWVcbiAgICAgIC8vaXQgbWVhbnMgdGhhdCB0aGUgdXNlciBvbmx5IGNsaWNrZWQgdGhlIGNhbnZhcyB3aXRob3V0IG1vdmluZyB0aGUgbW91c2VcbiAgICAgIC8vdGhlbiB3ZSBzaG91bGQgYmUgZHJhd2luZyBhIGRvdC4gQSBwYXRoIGlzbid0IGRyYXduIGJldHdlZW4gdHdvIGlkZW50aWNhbCBkb3RzXG4gICAgICAvL3RoYXQncyB3aHkgd2Ugc2V0IHRoZW0gYXBhcnQgYSBiaXRcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID09PSAyICYmIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueSkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIC8gMTAwMDtcbiAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHAxLngsIHAxLnkpO1xuICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocDIueCwgcDIueSk7XG4gICAgICAgIHAxLnggLT0gd2lkdGg7XG4gICAgICAgIHAyLnggKz0gd2lkdGg7XG4gICAgICB9XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuXG4gICAgICBmb3IgKGkgPSAxLCBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gd2UgcGljayB0aGUgcG9pbnQgYmV0d2VlbiBwaSArIDEgJiBwaSArIDIgYXMgdGhlXG4gICAgICAgIC8vIGVuZCBwb2ludCBhbmQgcDEgYXMgb3VyIGNvbnRyb2wgcG9pbnQuXG4gICAgICAgIHRoaXMuX2RyYXdTZWdtZW50KGN0eCwgcDEsIHAyKTtcbiAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbaV07XG4gICAgICAgIHAyID0gdGhpcy5fcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIERyYXcgbGFzdCBsaW5lIGFzIGEgc3RyYWlnaHQgbGluZSB3aGlsZVxuICAgICAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgcG9pbnQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGVcbiAgICAgIC8vIHRoZSBiZXppZXIgY29udHJvbCBwb2ludFxuICAgICAgY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHBvaW50cyB0byBTVkcgcGF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyBwYXRoXG4gICAgICovXG4gICAgY29udmVydFBvaW50c1RvU1ZHUGF0aDogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICB2YXIgcGF0aCA9IFtdLCBpLCB3aWR0aCA9IHRoaXMud2lkdGggLyAxMDAwLFxuICAgICAgICAgIHAxID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpLFxuICAgICAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpLFxuICAgICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsIG11bHRTaWduWCA9IDEsIG11bHRTaWduWSA9IDAsIG1hbnlQb2ludHMgPSBsZW4gPiAyO1xuXG4gICAgICBpZiAobWFueVBvaW50cykge1xuICAgICAgICBtdWx0U2lnblggPSBwb2ludHNbMl0ueCA8IHAyLnggPyAtMSA6IHBvaW50c1syXS54ID09PSBwMi54ID8gMCA6IDE7XG4gICAgICAgIG11bHRTaWduWSA9IHBvaW50c1syXS55IDwgcDIueSA/IC0xIDogcG9pbnRzWzJdLnkgPT09IHAyLnkgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHBhdGgucHVzaCgnTSAnLCBwMS54IC0gbXVsdFNpZ25YICogd2lkdGgsICcgJywgcDEueSAtIG11bHRTaWduWSAqIHdpZHRoLCAnICcpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghcDEuZXEocDIpKSB7XG4gICAgICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgICAgICAvLyBwMSBpcyBvdXIgYmV6aWVyIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAvLyBtaWRwb2ludCBpcyBvdXIgZW5kcG9pbnRcbiAgICAgICAgICAvLyBzdGFydCBwb2ludCBpcyBwKGktMSkgdmFsdWUuXG4gICAgICAgICAgcGF0aC5wdXNoKCdRICcsIHAxLngsICcgJywgcDEueSwgJyAnLCBtaWRQb2ludC54LCAnICcsIG1pZFBvaW50LnksICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcDEgPSBwb2ludHNbaV07XG4gICAgICAgIGlmICgoaSArIDEpIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHAyID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hbnlQb2ludHMpIHtcbiAgICAgICAgbXVsdFNpZ25YID0gcDEueCA+IHBvaW50c1tpIC0gMl0ueCA/IDEgOiBwMS54ID09PSBwb2ludHNbaSAtIDJdLnggPyAwIDogLTE7XG4gICAgICAgIG11bHRTaWduWSA9IHAxLnkgPiBwb2ludHNbaSAtIDJdLnkgPyAxIDogcDEueSA9PT0gcG9pbnRzW2kgLSAyXS55ID8gMCA6IC0xO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKCdMICcsIHAxLnggKyBtdWx0U2lnblggKiB3aWR0aCwgJyAnLCBwMS55ICsgbXVsdFNpZ25ZICogd2lkdGgpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZmFicmljLlBhdGggb2JqZWN0IHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aERhdGEgUGF0aCBkYXRhXG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGh9IFBhdGggdG8gYWRkIG9uIGNhbnZhc1xuICAgICAqL1xuICAgIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgICB2YXIgcGF0aCA9IG5ldyBmYWJyaWMuUGF0aChwYXRoRGF0YSwge1xuICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICBzdHJva2U6IHRoaXMuY29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBzdHJva2VMaW5lQ2FwOiB0aGlzLnN0cm9rZUxpbmVDYXAsXG4gICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCxcbiAgICAgICAgc3Ryb2tlTGluZUpvaW46IHRoaXMuc3Ryb2tlTGluZUpvaW4sXG4gICAgICAgIHN0cm9rZURhc2hBcnJheTogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICB0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UgPSB0cnVlO1xuICAgICAgICBwYXRoLnNoYWRvdyA9IG5ldyBmYWJyaWMuU2hhZG93KHRoaXMuc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2ltYXRlIHBvaW50cyBhcnJheSB3aXRoIHRoZSBkZWNpbWF0ZSB2YWx1ZVxuICAgICAqL1xuICAgIGRlY2ltYXRlUG9pbnRzOiBmdW5jdGlvbihwb2ludHMsIGRpc3RhbmNlKSB7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICB9XG4gICAgICB2YXIgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKSwgYWRqdXN0ZWREaXN0YW5jZSA9IE1hdGgucG93KGRpc3RhbmNlIC8gem9vbSwgMiksXG4gICAgICAgICAgaSwgbCA9IHBvaW50cy5sZW5ndGggLSAxLCBsYXN0UG9pbnQgPSBwb2ludHNbMF0sIG5ld1BvaW50cyA9IFtsYXN0UG9pbnRdLFxuICAgICAgICAgIGNEaXN0YW5jZTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY0Rpc3RhbmNlID0gTWF0aC5wb3cobGFzdFBvaW50LnggLSBwb2ludHNbaV0ueCwgMikgKyBNYXRoLnBvdyhsYXN0UG9pbnQueSAtIHBvaW50c1tpXS55LCAyKTtcbiAgICAgICAgaWYgKGNEaXN0YW5jZSA+PSBhZGp1c3RlZERpc3RhbmNlKSB7XG4gICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIG5ld1BvaW50cy5wdXNoKGxhc3RQb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdQb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ldyBmYWJyaWMuUG9pbnQobmV3UG9pbnRzWzBdLngsIG5ld1BvaW50c1swXS55KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UG9pbnRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZXVwIGFmdGVyIGRyYXdpbmcgdGhlIHBhdGggb24gY29udGV4dFRvcCBjYW52YXNcbiAgICAgKiB3ZSB1c2UgdGhlIHBvaW50cyBjYXB0dXJlZCB0byBjcmVhdGUgYW4gbmV3IGZhYnJpYyBwYXRoIG9iamVjdFxuICAgICAqIGFuZCBhZGQgaXQgdG8gdGhlIGZhYnJpYyBjYW52YXMuXG4gICAgICovXG4gICAgX2ZpbmFsaXplQW5kQWRkUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGlmICh0aGlzLmRlY2ltYXRlKSB7XG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHRoaXMuZGVjaW1hdGVQb2ludHModGhpcy5fcG9pbnRzLCB0aGlzLmRlY2ltYXRlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMuY29udmVydFBvaW50c1RvU1ZHUGF0aCh0aGlzLl9wb2ludHMpLmpvaW4oJycpO1xuICAgICAgaWYgKHBhdGhEYXRhID09PSAnTSAwIDAgUSAwIDAgMCAwIEwgMCAwJykge1xuICAgICAgICAvLyBkbyBub3QgY3JlYXRlIDAgd2lkdGgvaGVpZ2h0IHBhdGhzLCBhcyB0aGV5IGFyZVxuICAgICAgICAvLyByZW5kZXJlZCBpbmNvbnNpc3RlbnRseSBhY3Jvc3MgYnJvd3NlcnNcbiAgICAgICAgLy8gRmlyZWZveCA0LCBmb3IgZXhhbXBsZSwgcmVuZGVycyBhIGRvdCxcbiAgICAgICAgLy8gd2hlcmVhcyBDaHJvbWUgMTAgcmVuZGVycyBub3RoaW5nXG4gICAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IHRoaXMuY3JlYXRlUGF0aChwYXRoRGF0YSk7XG4gICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBwYXRoIH0pO1xuICAgICAgdGhpcy5jYW52YXMuYWRkKHBhdGgpO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcGF0aC5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG5cblxuICAgICAgLy8gZmlyZSBldmVudCAncGF0aCcgY3JlYXRlZFxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBwYXRoIH0pO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbi8qKlxuICogQ2lyY2xlQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuQ2lyY2xlQnJ1c2hcbiAqL1xuZmFicmljLkNpcmNsZUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBicnVzaFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxMCxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZUJydXNofSBJbnN0YW5jZSBvZiBhIGNpcmNsZSBicnVzaFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBpbnNpZGUgb24gbW91c2UgZG93biBhbmQgbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgZHJhd0RvdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBwb2ludCA9IHRoaXMuYWRkUG9pbnQocG9pbnRlciksXG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgIHRoaXMuZG90KGN0eCwgcG9pbnQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgZG90OiBmdW5jdGlvbihjdHgsIHBvaW50KSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBvaW50LmZpbGw7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcG9pbnQucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGZ1bGwgc3RhdGUgb2YgdGhlIGJydXNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ICA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGxlbixcbiAgICAgICAgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5kb3QoY3R4LCBwb2ludHNbaV0pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgaWYgKHRoaXMubmVlZHNGdWxsUmVuZGVyKCkpIHtcbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuYWRkUG9pbnQocG9pbnRlcik7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmRyYXdEb3QocG9pbnRlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUsIGksIGxlbjtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGNpcmNsZXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1tpXSxcbiAgICAgICAgICBjaXJjbGUgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICAgICAgICByYWRpdXM6IHBvaW50LnJhZGl1cyxcbiAgICAgICAgICAgIGxlZnQ6IHBvaW50LngsXG4gICAgICAgICAgICB0b3A6IHBvaW50LnksXG4gICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgICAgZmlsbDogcG9pbnQuZmlsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNoYWRvdyAmJiAoY2lyY2xlLnNoYWRvdyA9IG5ldyBmYWJyaWMuU2hhZG93KHRoaXMuc2hhZG93KSk7XG5cbiAgICAgIGNpcmNsZXMucHVzaChjaXJjbGUpO1xuICAgIH1cbiAgICB2YXIgZ3JvdXAgPSBuZXcgZmFicmljLkdyb3VwKGNpcmNsZXMpO1xuICAgIGdyb3VwLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgdGhpcy5jYW52YXMuZmlyZSgnYmVmb3JlOnBhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkKGdyb3VwKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBKdXN0IGFkZGVkIHBvaW50ZXIgcG9pbnRcbiAgICovXG4gIGFkZFBvaW50OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ZXJQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpLFxuXG4gICAgICAgIGNpcmNsZVJhZGl1cyA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChcbiAgICAgICAgICBNYXRoLm1heCgwLCB0aGlzLndpZHRoIC0gMjApLCB0aGlzLndpZHRoICsgMjApIC8gMixcblxuICAgICAgICBjaXJjbGVDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcilcbiAgICAgICAgICAuc2V0QWxwaGEoZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KDAsIDEwMCkgLyAxMDApXG4gICAgICAgICAgLnRvUmdiYSgpO1xuXG4gICAgcG9pbnRlclBvaW50LnJhZGl1cyA9IGNpcmNsZVJhZGl1cztcbiAgICBwb2ludGVyUG9pbnQuZmlsbCA9IGNpcmNsZUNvbG9yO1xuXG4gICAgdGhpcy5wb2ludHMucHVzaChwb2ludGVyUG9pbnQpO1xuXG4gICAgcmV0dXJuIHBvaW50ZXJQb2ludDtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBTcHJheUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLlNwcmF5QnJ1c2hcbiAqL1xuZmFicmljLlNwcmF5QnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyggZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuU3ByYXlCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIHNwcmF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6ICAgICAgICAgICAgICAxMCxcblxuICAvKipcbiAgICogRGVuc2l0eSBvZiBhIHNwcmF5IChudW1iZXIgb2YgZG90cyBwZXIgY2h1bmspXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZGVuc2l0eTogICAgICAgICAgICAyMCxcblxuICAvKipcbiAgICogV2lkdGggb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoOiAgICAgICAgICAgMSxcblxuICAvKipcbiAgICogV2lkdGggdmFyaWFuY2Ugb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoVmFyaWFuY2U6ICAgMSxcblxuICAvKipcbiAgICogV2hldGhlciBvcGFjaXR5IG9mIGEgZG90IHNob3VsZCBiZSByYW5kb21cbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgcmFuZG9tT3BhY2l0eTogICAgICAgIGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG92ZXJsYXBwaW5nIGRvdHMgKHJlY3RhbmdsZXMpIHNob3VsZCBiZSByZW1vdmVkIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucylcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgb3B0aW1pemVPdmVybGFwcGluZzogIHRydWUsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5TcHJheUJydXNofSBJbnN0YW5jZSBvZiBhIHNwcmF5IGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNwcmF5Q2h1bmtzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuXG4gICAgdGhpcy5hZGRTcHJheUNodW5rKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua1BvaW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgKi9cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgcmVjdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhciBzcHJheUNodW5rID0gdGhpcy5zcHJheUNodW5rc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KHtcbiAgICAgICAgICB3aWR0aDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNwcmF5Q2h1bmtbal0ud2lkdGgsXG4gICAgICAgICAgbGVmdDogc3ByYXlDaHVua1tqXS54ICsgMSxcbiAgICAgICAgICB0b3A6IHNwcmF5Q2h1bmtbal0ueSArIDEsXG4gICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgZmlsbDogdGhpcy5jb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpbWl6ZU92ZXJsYXBwaW5nKSB7XG4gICAgICByZWN0cyA9IHRoaXMuX2dldE9wdGltaXplZFJlY3RzKHJlY3RzKTtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSBuZXcgZmFicmljLkdyb3VwKHJlY3RzKTtcbiAgICB0aGlzLnNoYWRvdyAmJiBncm91cC5zZXQoJ3NoYWRvdycsIG5ldyBmYWJyaWMuU2hhZG93KHRoaXMuc2hhZG93KSk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgnYmVmb3JlOnBhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkKGdyb3VwKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmVjdHNcbiAgICovXG4gIF9nZXRPcHRpbWl6ZWRSZWN0czogZnVuY3Rpb24ocmVjdHMpIHtcblxuICAgIC8vIGF2b2lkIGNyZWF0aW5nIGR1cGxpY2F0ZSByZWN0cyBhdCB0aGUgc2FtZSBjb29yZGluYXRlc1xuICAgIHZhciB1bmlxdWVSZWN0cyA9IHsgfSwga2V5LCBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0gcmVjdHNbaV0ubGVmdCArICcnICsgcmVjdHNbaV0udG9wO1xuICAgICAgaWYgKCF1bmlxdWVSZWN0c1trZXldKSB7XG4gICAgICAgIHVuaXF1ZVJlY3RzW2tleV0gPSByZWN0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVuaXF1ZVJlY3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKGtleSBpbiB1bmlxdWVSZWN0cykge1xuICAgICAgdW5pcXVlUmVjdHNBcnJheS5wdXNoKHVuaXF1ZVJlY3RzW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVSZWN0c0FycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgbmV3IGNodW5rIG9mIHNwcmF5IGJydXNoXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKHNwcmF5Q2h1bmspIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc3ByYXlDaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gc3ByYXlDaHVua1tpXTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnQub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcG9pbnQub3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsUmVjdChwb2ludC54LCBwb2ludC55LCBwb2ludC53aWR0aCwgcG9pbnQud2lkdGgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHNwcmF5IGNodW5rc1xuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGlsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua3NbaV0pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgYWRkU3ByYXlDaHVuazogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cyA9IFtdO1xuXG4gICAgdmFyIHgsIHksIHdpZHRoLCByYWRpdXMgPSB0aGlzLndpZHRoIC8gMiwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbnNpdHk7IGkrKykge1xuXG4gICAgICB4ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KHBvaW50ZXIueCAtIHJhZGl1cywgcG9pbnRlci54ICsgcmFkaXVzKTtcbiAgICAgIHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci55IC0gcmFkaXVzLCBwb2ludGVyLnkgKyByYWRpdXMpO1xuXG4gICAgICBpZiAodGhpcy5kb3RXaWR0aFZhcmlhbmNlKSB7XG4gICAgICAgIHdpZHRoID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIC8vIGJvdHRvbSBjbGFtcCB3aWR0aCB0byAxXG4gICAgICAgICAgTWF0aC5tYXgoMSwgdGhpcy5kb3RXaWR0aCAtIHRoaXMuZG90V2lkdGhWYXJpYW5jZSksXG4gICAgICAgICAgdGhpcy5kb3RXaWR0aCArIHRoaXMuZG90V2lkdGhWYXJpYW5jZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmRvdFdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgICAgcG9pbnQud2lkdGggPSB3aWR0aDtcblxuICAgICAgaWYgKHRoaXMucmFuZG9tT3BhY2l0eSkge1xuICAgICAgICBwb2ludC5vcGFjaXR5ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KDAsIDEwMCkgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnNwcmF5Q2h1bmtzLnB1c2godGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBQYXR0ZXJuQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuUGF0dGVybkJydXNoXG4gKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gKi9cbmZhYnJpYy5QYXR0ZXJuQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuUGVuY2lsQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm5CcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIGdldFBhdHRlcm5TcmM6IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGRvdFdpZHRoID0gMjAsXG4gICAgICAgIGRvdERpc3RhbmNlID0gNSxcbiAgICAgICAgcGF0dGVybkNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHBhdHRlcm5DYW52YXMud2lkdGggPSBwYXR0ZXJuQ2FudmFzLmhlaWdodCA9IGRvdFdpZHRoICsgZG90RGlzdGFuY2U7XG5cbiAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgcGF0dGVybkN0eC5iZWdpblBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmFyYyhkb3RXaWR0aCAvIDIsIGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIHBhdHRlcm5DdHguY2xvc2VQYXRoKCk7XG4gICAgcGF0dGVybkN0eC5maWxsKCk7XG5cbiAgICByZXR1cm4gcGF0dGVybkNhbnZhcztcbiAgfSxcblxuICBnZXRQYXR0ZXJuU3JjRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRQYXR0ZXJuU3JjKS5yZXBsYWNlKCd0aGlzLmNvbG9yJywgJ1wiJyArIHRoaXMuY29sb3IgKyAnXCInKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBcInBhdHRlcm5cIiBpbnN0YW5jZSBwcm9wZXJ0eVxuICAgKi9cbiAgZ2V0UGF0dGVybjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuY3JlYXRlUGF0dGVybih0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmMoKSwgJ3JlcGVhdCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHN0eWxlc1xuICAgKi9cbiAgX3NldEJydXNoU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbGxTdXBlcignX3NldEJydXNoU3R5bGVzJyk7XG4gICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0UGF0dGVybigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHBhdGhcbiAgICovXG4gIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgdmFyIHBhdGggPSB0aGlzLmNhbGxTdXBlcignY3JlYXRlUGF0aCcsIHBhdGhEYXRhKSxcbiAgICAgICAgdG9wTGVmdCA9IHBhdGguX2dldExlZnRUb3BDb29yZHMoKS5zY2FsYXJBZGQocGF0aC5zdHJva2VXaWR0aCAvIDIpO1xuXG4gICAgcGF0aC5zdHJva2UgPSBuZXcgZmFicmljLlBhdHRlcm4oe1xuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSB8fCB0aGlzLmdldFBhdHRlcm5TcmNGdW5jdGlvbigpLFxuICAgICAgb2Zmc2V0WDogLXRvcExlZnQueCxcbiAgICAgIG9mZnNldFk6IC10b3BMZWZ0LnlcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBnZXRQb2ludGVyID0gZmFicmljLnV0aWwuZ2V0UG9pbnRlcixcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICBzdXBwb3J0TGluZURhc2ggPSBmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpLFxuICAgICAgaXNUb3VjaEV2ZW50ID0gZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50LFxuICAgICAgU1RST0tFX09GRlNFVCA9IDAuNTtcblxuICAvKipcbiAgICogQ2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQ2FudmFzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXNcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjY2FudmFzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBvYmplY3Q6bW9kaWZpZWQgYXQgdGhlIGVuZCBvZiBhIHRyYW5zZm9ybSBvciBhbnkgY2hhbmdlIHdoZW4gc3RhdGVmdWxsIGlzIHRydWVcbiAgICogQGZpcmVzIG9iamVjdDpyb3RhdGluZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgcm90YXRlZCBmcm9tIHRoZSBjb250cm9sXG4gICAqIEBmaXJlcyBvYmplY3Q6c2NhbGluZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgc2NhbGVkIGJ5IGNvbnRyb2xzXG4gICAqIEBmaXJlcyBvYmplY3Q6bW92aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBkcmFnZ2VkXG4gICAqIEBmaXJlcyBvYmplY3Q6c2tld2luZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgc2tld2VkIGZyb20gdGhlIGNvbnRyb2xzXG4gICAqXG4gICAqIEBmaXJlcyBiZWZvcmU6dHJhbnNmb3JtIGJlZm9yZSBhIHRyYW5zZm9ybSBpcyBpcyBzdGFydGVkXG4gICAqIEBmaXJlcyBiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246dXBkYXRlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNyZWF0ZWRcbiAgICpcbiAgICogQGZpcmVzIHBhdGg6Y3JlYXRlZCBhZnRlciBhIGRyYXdpbmcgb3BlcmF0aW9uIGVuZHMgYW5kIHRoZSBwYXRoIGlzIGFkZGVkXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlXG4gICAqIEBmaXJlcyBtb3VzZTp1cFxuICAgKiBAZmlyZXMgbW91c2U6ZG93bjpiZWZvcmUgIG9uIG1vdXNlIGRvd24sIGJlZm9yZSB0aGUgaW5uZXIgZmFicmljIGxvZ2ljIHJ1bnNcbiAgICogQGZpcmVzIG1vdXNlOm1vdmU6YmVmb3JlIG9uIG1vdXNlIG1vdmUsIGJlZm9yZSB0aGUgaW5uZXIgZmFicmljIGxvZ2ljIHJ1bnNcbiAgICogQGZpcmVzIG1vdXNlOnVwOmJlZm9yZSBvbiBtb3VzZSB1cCwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6b3ZlclxuICAgKiBAZmlyZXMgbW91c2U6b3V0XG4gICAqIEBmaXJlcyBtb3VzZTpkYmxjbGljayB3aGVuZXZlciBhIG5hdGl2ZSBkYmwgY2xpY2sgZXZlbnQgZmlyZXMgb24gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQGZpcmVzIGRyYWdvdmVyXG4gICAqIEBmaXJlcyBkcmFnZW50ZXJcbiAgICogQGZpcmVzIGRyYWdsZWF2ZVxuICAgKiBAZmlyZXMgZHJvcFxuICAgKiBAZmlyZXMgYWZ0ZXI6cmVuZGVyIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlciBwcm9jZXNzLCByZWNlaXZlcyB0aGUgY29udGV4dCBpbiB0aGUgY2FsbGJhY2tcbiAgICogQGZpcmVzIGJlZm9yZTpyZW5kZXIgYXQgc3RhcnQgdGhlIHJlbmRlciBwcm9jZXNzLCByZWNlaXZlcyB0aGUgY29udGV4dCBpbiB0aGUgY2FsbGJhY2tcbiAgICpcbiAgICogdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIGRlcHJlY2F0ZWQ6XG4gICAqIEBmaXJlcyBvYmplY3Q6cm90YXRlZCBhdCB0aGUgZW5kIG9mIGEgcm90YXRpb24gdHJhbnNmb3JtXG4gICAqIEBmaXJlcyBvYmplY3Q6c2NhbGVkIGF0IHRoZSBlbmQgb2YgYSBzY2FsZSB0cmFuc2Zvcm1cbiAgICogQGZpcmVzIG9iamVjdDptb3ZlZCBhdCB0aGUgZW5kIG9mIHRyYW5zbGF0aW9uIHRyYW5zZm9ybVxuICAgKiBAZmlyZXMgb2JqZWN0OnNrZXdlZCBhdCB0aGUgZW5kIG9mIGEgc2tldyB0cmFuc2Zvcm1cbiAgICovXG4gIGZhYnJpYy5DYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRJbnRlcmFjdGl2ZSgpO1xuICAgICAgdGhpcy5fY3JlYXRlQ2FjaGVDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIGNhbiBiZSB0cmFuc2Zvcm1lZCBieSBvbmUgc2lkZSAodW5wcm9wb3J0aW9uYWxseSlcbiAgICAgKiB3aGVuIGRyYWdnZWQgb24gdGhlIGNvcm5lcnMgdGhhdCBub3JtYWxseSB3b3VsZCBub3QgZG8gdGhhdC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAc2luY2UgZmFicmljIDQuMCAvLyBjaGFuZ2VkIG5hbWUgYW5kIGRlZmF1bHQgdmFsdWVcbiAgICAgKi9cbiAgICB1bmlmb3JtU2NhbGluZzogICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBzd2l0Y2hlcyB1bmlmb3JtIHNjYWxpbmcuXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogdG90YWxseSB3cm9uZyBuYW1lZC4gdGhpcyBzb3VuZHMgbGlrZSBgdW5pZm9ybSBzY2FsaW5nYFxuICAgICAqIGlmIENhbnZhcy51bmlmb3JtU2NhbGluZyBpcyB0cnVlLCBwcmVzc2luZyB0aGlzIHdpbGwgc2V0IGl0IHRvIGZhbHNlXG4gICAgICogYW5kIHZpY2V2ZXJzYS5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2Ygc2NhbGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2Ygcm90YXRlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBjZW50ZXJlZCBUcmFuc2Zvcm1cbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZCBmZWF0dXJlIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRLZXk6ICAgICAgICAgICAnYWx0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0ZSBhY3Rpb24gb24gY29ybmVyXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsdEFjdGlvbktleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBjYW52YXMgaXMgaW50ZXJhY3RpdmUuIFRoaXMgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGludGVyYWN0aXZlOiAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBncm91cCBzZWxlY3Rpb24gc2hvdWxkIGJlIGVuYWJsZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb246ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBvciBrZXlzIGVuYWJsZSBtdWx0aXBsZSBjbGljayBzZWxlY3Rpb25cbiAgICAgKiBQYXNzIHZhbHVlIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yIGVtcHR5IG9yIGNvbnRhaW5pbmcgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nfEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgYWx0ZXJuYXRpdmUgc2VsZWN0aW9uXG4gICAgICogaW4gY2FzZSBvZiB0YXJnZXQgb3ZlcmxhcHBpbmcgd2l0aCBhY3RpdmUgb2JqZWN0XG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIEZvciBhIHNlcmllcyBvZiByZWFzb24gdGhhdCBjb21lIGZyb20gdGhlIGdlbmVyYWwgZXhwZWN0YXRpb25zIG9uIGhvd1xuICAgICAqIHRoaW5ncyBzaG91bGQgd29yaywgdGhpcyBmZWF0dXJlIHdvcmtzIG9ubHkgZm9yIHByZXNlcnZlT2JqZWN0U3RhY2tpbmcgdHJ1ZS5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEB0eXBlIG51bGx8U3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRTZWxlY3Rpb25LZXk6ICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygc2VsZWN0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Db2xvcjogICAgICAgICAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjMpJywgLy8gYmx1ZVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKiBJZiBub3QgZW1wdHkgdGhlIHNlbGVjdGlvbiBib3JkZXIgaXMgZGFzaGVkXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25EYXNoQXJyYXk6ICAgICBbXSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRoZSBib3JkZXIgb2Ygc2VsZWN0aW9uICh1c3VhbGx5IHNsaWdodGx5IGRhcmtlciB0aGFuIGNvbG9yIG9mIHNlbGVjdGlvbiBpdHNlbGYpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Cb3JkZXJDb2xvcjogICAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgbGluZSB1c2VkIGluIG9iamVjdC9ncm91cCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkxpbmVXaWR0aDogICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgb25seSBzaGFwZXMgdGhhdCBhcmUgZnVsbHkgY29udGFpbmVkIGluIHRoZSBkcmFnZ2VkIHNlbGVjdGlvbiByZWN0YW5nbGUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRnVsbHlDb250YWluZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyBhbiBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yOiAgICAgICAgICAgICAnbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIGZvciB0aGUgZW50aXJlIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVmYXVsdEN1cnNvcjogICAgICAgICAgJ2RlZmF1bHQnLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZHVyaW5nIGZyZWUgZHJhd2luZ1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZnJlZURyYXdpbmdDdXJzb3I6ICAgICAgJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBmb3Igcm90YXRpb24gcG9pbnRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJvdGF0aW9uQ3Vyc29yOiAgICAgICAgICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZm9yIGRpc2FibGVkIGVsZW1lbnRzICggY29ybmVycyB3aXRoIGRpc2FibGVkIGFjdGlvbiApXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub3RBbGxvd2VkQ3Vyc29yOiAgICAgICAgICdub3QtYWxsb3dlZCcsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGVsZW1lbnQgY2xhc3MgdGhhdCdzIGdpdmVuIHRvIHdyYXBwZXIgKGRpdikgZWxlbWVudCBvZiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbnRhaW5lckNsYXNzOiAgICAgICAgICdjYW52YXMtY29udGFpbmVyJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0IGRldGVjdGlvbiBoYXBwZW5zIG9uIHBlci1waXhlbCBiYXNpcyByYXRoZXIgdGhhbiBvbiBwZXItYm91bmRpbmctYm94XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGVyUGl4ZWxUYXJnZXRGaW5kOiAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGFyb3VuZCB0YXJnZXQgcGl4ZWwgdG8gdG9sZXJhdGUgKGNvbnNpZGVyIGFjdGl2ZSkgZHVyaW5nIG9iamVjdCBkZXRlY3Rpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRhcmdldEZpbmRUb2xlcmFuY2U6ICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRhcmdldCBkZXRlY3Rpb24gaXMgc2tpcHBlZC4gVGFyZ2V0IGRldGVjdGlvbiB3aWxsIHJldHVybiBhbHdheXMgdW5kZWZpbmVkLlxuICAgICAqIGNsaWNrIHNlbGVjdGlvbiB3b24ndCB3b3JrIGFueW1vcmUsIGV2ZW50cyB3aWxsIGZpcmUgd2l0aCBubyB0YXJnZXRzLlxuICAgICAqIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCBiZWZvcmUgc2V0dGluZyBpdCB0byB0cnVlLCBpdCB3aWxsIGJlIGRlc2VsZWN0ZWQgYXQgdGhlIGZpcnN0IGNsaWNrLlxuICAgICAqIGFyZWEgc2VsZWN0aW9uIHdpbGwgc3RpbGwgd29yay4gY2hlY2sgdGhlIGBzZWxlY3Rpb25gIHByb3BlcnR5IHRvby5cbiAgICAgKiBpZiB5b3UgZGVhY3RpdmF0ZSBib3RoLCB5b3Ugc2hvdWxkIGxvb2sgaW50byBzdGF0aWNDYW52YXMuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tpcFRhcmdldEZpbmQ6ICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG1vdXNlIGV2ZW50cyBvbiBjYW52YXMgKG1vdXNlZG93bi9tb3VzZW1vdmUvbW91c2V1cCkgcmVzdWx0IGluIGZyZWUgZHJhd2luZy5cbiAgICAgKiBBZnRlciBtb3VzZWRvd24sIG1vdXNlbW92ZSBjcmVhdGVzIGEgc2hhcGUsXG4gICAgICogYW5kIHRoZW4gbW91c2V1cCBmaW5hbGl6ZXMgaXQgYW5kIGFkZHMgYW4gaW5zdGFuY2Ugb2YgYGZhYnJpYy5QYXRoYCBvbnRvIGNhbnZhcy5cbiAgICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtNCNmcmVlX2RyYXdpbmd9XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaXNEcmF3aW5nTW9kZTogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzIHNob3VsZCByZW1haW4gaW4gY3VycmVudCBzdGFjayBwb3NpdGlvbiB3aGVuIHNlbGVjdGVkLlxuICAgICAqIFdoZW4gZmFsc2Ugb2JqZWN0cyBhcmUgYnJvdWdodCB0byB0b3AgYW5kIHJlbmRlcmVkIGFzIHBhcnQgb2YgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHByZXNlcnZlT2JqZWN0U3RhY2tpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBhbmdsZSB0aGF0IGFuIG9iamVjdCB3aWxsIGxvY2sgdG8gd2hpbGUgcm90YXRpbmcuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHNpbmNlIDEuNi43XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzbmFwQW5nbGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHNuYXBBbmdsZSB0aGUgcm90YXRpb24gd2lsbCBsb2NrIHRvIHRoZSBzbmFwQW5nbGUuXG4gICAgICogV2hlbiBgbnVsbGAsIHRoZSBzbmFwVGhyZXNob2xkIHdpbGwgZGVmYXVsdCB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIEB0eXBlIG51bGx8TnVtYmVyXG4gICAgICogQHNpbmNlIDEuNi43XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzbmFwVGhyZXNob2xkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSByaWdodCBjbGljayBvbiBjYW52YXMgY2FuIG91dHB1dCB0aGUgY29udGV4dCBtZW51IG9yIG5vdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0b3BDb250ZXh0TWVudTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNhbnZhcyBjYW4gZmlyZSByaWdodCBjbGljayBldmVudHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaXJlUmlnaHRDbGljazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNhbnZhcyBjYW4gZmlyZSBtaWRkbGUgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjcuOFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZU1pZGRsZUNsaWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEtlZXAgdHJhY2sgb2YgdGhlIHN1YlRhcmdldHMgZm9yIE1vdXNlIEV2ZW50c1xuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RbXVxuICAgICAqL1xuICAgIHRhcmdldHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiB0aGUgaG92ZXJlZCB0YXJnZXRcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaG92ZXJlZFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGhvbGQgdGhlIGxpc3Qgb2YgbmVzdGVkIHRhcmdldHMgaG92ZXJlZFxuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RbXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hvdmVyZWRUYXJnZXRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRJbnRlcmFjdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5faW5pdFdyYXBwZXJFbGVtZW50KCk7XG4gICAgICB0aGlzLl9jcmVhdGVVcHBlckNhbnZhcygpO1xuICAgICAgdGhpcy5faW5pdEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG5cbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCA9IGZhYnJpYy5QZW5jaWxCcnVzaCAmJiBuZXcgZmFicmljLlBlbmNpbEJydXNoKHRoaXMpO1xuXG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvYmplY3RzIGluIHR3byBncm91cHMsIG9uZSB0byByZW5kZXIgaW1tZWRpYXRlbHlcbiAgICAgKiBhbmQgb25lIHRvIHJlbmRlciBhcyBhY3RpdmVHcm91cC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXIgaW1tZWRpYXRlbHkgYW5kIHB1c2hlcyB0aGUgb3RoZXIgaW4gdGhlIGFjdGl2ZUdyb3VwLlxuICAgICAqL1xuICAgIF9jaG9vc2VPYmplY3RzVG9SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBvYmplY3QsIG9ianNUb1JlbmRlciwgYWN0aXZlR3JvdXBPYmplY3RzO1xuXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAwICYmICF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgb2Jqc1RvUmVuZGVyID0gW107XG4gICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgICAgaWYgKGFjdGl2ZU9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSApIHtcbiAgICAgICAgICAgIG9ianNUb1JlbmRlci5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlR3JvdXBPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5fb2JqZWN0cyA9IGFjdGl2ZUdyb3VwT2JqZWN0cztcbiAgICAgICAgfVxuICAgICAgICBvYmpzVG9SZW5kZXIucHVzaC5hcHBseShvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Jqc1RvUmVuZGVyID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpzVG9SZW5kZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYm90aCB0aGUgdG9wIGNhbnZhcyBhbmQgdGhlIHNlY29uZGFyeSBjb250YWluZXIgY2FudmFzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFRvcERpcnR5ICYmICF0aGlzLl9ncm91cFNlbGVjdG9yICYmICF0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0xvc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyVG9wTGF5ZXIodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNUb0RyYXdPbiA9IHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc1RvRHJhd09uLCB0aGlzLl9jaG9vc2VPYmplY3RzVG9SZW5kZXIoKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyVG9wTGF5ZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3JlbmRlcigpO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyB3ZSByZW5kZXIgdGhlIHRvcCBjb250ZXh0IC0gbGFzdCBvYmplY3RcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiB0aGlzLl9ncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2RyYXdTZWxlY3Rpb24oY3R4KTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHJlbmRlciBvbmx5IHRoZSB0b3AgY2FudmFzLlxuICAgICAqIEFsc28gdXNlZCB0byByZW5kZXIgdGhlIGdyb3VwIHNlbGVjdGlvbiBib3guXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJUb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5yZW5kZXJUb3BMYXllcihjdHgpO1xuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ub3JtYWxpemVQb2ludGVyOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludGVyKSB7XG4gICAgICB2YXIgbSA9IG9iamVjdC5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgaW52ZXJ0ZWRNID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG0pLFxuICAgICAgICAgIHZwdFBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZwdFBvaW50ZXIsIGludmVydGVkTSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgdHJhbnNwYXJlbnQgYXQgYSBjZXJ0YWluIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgT2JqZWN0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGFyZ2V0VHJhbnNwYXJlbnQ6IGZ1bmN0aW9uICh0YXJnZXQsIHgsIHkpIHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIHRhcmdldCBpcyB0aGUgYWN0aXZlT2JqZWN0LCB3ZSBjYW5ub3QgZXhlY3V0ZSB0aGlzIG9wdGltaXphdGlvblxuICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGRyYXcgY29udHJvbHMgdG9vLlxuICAgICAgaWYgKHRhcmdldC5zaG91bGRDYWNoZSgpICYmIHRhcmdldC5fY2FjaGVDYW52YXMgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQb2ludGVyID0gdGhpcy5fbm9ybWFsaXplUG9pbnRlcih0YXJnZXQsIHt4OiB4LCB5OiB5fSksXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVggPSBNYXRoLm1heCh0YXJnZXQuY2FjaGVUcmFuc2xhdGlvblggKyAobm9ybWFsaXplZFBvaW50ZXIueCAqIHRhcmdldC56b29tWCksIDApLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVZID0gTWF0aC5tYXgodGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25ZICsgKG5vcm1hbGl6ZWRQb2ludGVyLnkgKiB0YXJnZXQuem9vbVkpLCAwKTtcblxuICAgICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IGZhYnJpYy51dGlsLmlzVHJhbnNwYXJlbnQoXG4gICAgICAgICAgdGFyZ2V0Ll9jYWNoZUNvbnRleHQsIE1hdGgucm91bmQodGFyZ2V0UmVsYXRpdmVYKSwgTWF0aC5yb3VuZCh0YXJnZXRSZWxhdGl2ZVkpLCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0Q2FjaGUsXG4gICAgICAgICAgb3JpZ2luYWxDb2xvciA9IHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IsIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gJyc7XG5cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGFyZ2V0LnJlbmRlcihjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGFyZ2V0Ll9yZW5kZXJDb250cm9scyhjdHgsIHtcbiAgICAgICAgaGFzQm9yZGVyczogZmFsc2UsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVyczogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgaGFzQm9yZGVyczogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9IG9yaWdpbmFsQ29sb3I7XG5cbiAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgY3R4LCB4LCB5LCB0aGlzLnRhcmdldEZpbmRUb2xlcmFuY2UpO1xuXG4gICAgICByZXR1cm4gaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgYW4gZXZlbnQgYW5kIGRldGVybWluZXMgaWYgc2VsZWN0aW9uIGtleSBoYXMgYmVlbiBwcmVzc2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9pc1NlbGVjdGlvbktleVByZXNzZWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBzZWxlY3Rpb25LZXlQcmVzc2VkID0gZmFsc2U7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5zZWxlY3Rpb25LZXkpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSAhIXRoaXMuc2VsZWN0aW9uS2V5LmZpbmQoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBlW2tleV0gPT09IHRydWU7IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSBlW3RoaXMuc2VsZWN0aW9uS2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGlvbktleVByZXNzZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhclNlbGVjdGlvbjogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICF0YXJnZXRcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMuaW5kZXhPZih0YXJnZXQpID09PSAtMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0ICYmXG4gICAgICAgICAgIXRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSlcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJiAhdGFyZ2V0LmV2ZW50ZWQpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICAhdGFyZ2V0LnNlbGVjdGFibGUgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNlbnRlcmVkU2NhbGluZyBmcm9tIG9iamVjdCBjYW4ndCBvdmVycmlkZSBjZW50ZXJlZFNjYWxpbmcgZnJvbSBjYW52YXMuXG4gICAgICogdGhpcyBzaG91bGQgYmUgZml4ZWQsIHNpbmNlIG9iamVjdCBzZXR0aW5nIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBjYW52YXMuXG4gICAgICogYWxzbyB0aGlzIHNob3VsZCBiZSBzb21ldGhpbmcgdGhhdCB3aWxsIGJlIG1pZ3JhdGVkIGluIHRoZSBjb250cm9sIHByb3BlcnRpZXMuXG4gICAgICogYXMgYWJpbGl0eSB0byBkZWZpbmUgdGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCB0aGUgY29udHJvbCBwcm92aWRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHRLZXlcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2VudGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0LCBhY3Rpb24sIGFsdEtleSkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VudGVyVHJhbnNmb3JtO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAnc2NhbGUnIHx8IGFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgYWN0aW9uID09PSAnc2NhbGVZJyB8fCBhY3Rpb24gPT09ICdyZXNpemluZycpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFNjYWxpbmcgfHwgdGFyZ2V0LmNlbnRlcmVkU2NhbGluZztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFJvdGF0aW9uIHx8IHRhcmdldC5jZW50ZXJlZFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VudGVyVHJhbnNmb3JtID8gIWFsdEtleSA6IGFsdEtleTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2hvdWxkIGRpc2FwcGVhciBiZWZvcmUgcmVsZWFzZSA0LjBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRPcmlnaW5Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lcikge1xuICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgeDogdGFyZ2V0Lm9yaWdpblgsXG4gICAgICAgIHk6IHRhcmdldC5vcmlnaW5ZXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29ybmVyID09PSAnbWwnIHx8IGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdibCcpIHtcbiAgICAgICAgb3JpZ2luLnggPSAncmlnaHQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbXInIHx8IGNvcm5lciA9PT0gJ3RyJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnggPSAnbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICd0bCcgfHwgY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ3RyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnYmwnIHx8IGNvcm5lciA9PT0gJ21iJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnkgPSAndG9wJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHJlYWR5U2VsZWN0ZWQgdHJ1ZSBpZiB0YXJnZXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb3JuZXIgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXIgbWwsIG1yLCB0bCAuLi5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW3RhcmdldF0gaW5zZXJ0ZWQgYmFjayB0byBoZWxwIG92ZXJyaWRpbmcuIFVudXNlZFxuICAgICAqL1xuICAgIF9nZXRBY3Rpb25Gcm9tQ29ybmVyOiBmdW5jdGlvbihhbHJlYWR5U2VsZWN0ZWQsIGNvcm5lciwgZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIWNvcm5lciB8fCAhYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiAnZHJhZyc7XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdO1xuICAgICAgcmV0dXJuIGNvbnRyb2wuZ2V0QWN0aW9uTmFtZShlLCBjb250cm9sLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksIGNvcm5lciA9IHRhcmdldC5fX2Nvcm5lcixcbiAgICAgICAgICBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgYWN0aW9uSGFuZGxlciA9IChhbHJlYWR5U2VsZWN0ZWQgJiYgY29ybmVyKSA/XG4gICAgICAgICAgICBjb250cm9sLmdldEFjdGlvbkhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKSA6IGZhYnJpYy5jb250cm9sc1V0aWxzLmRyYWdIYW5kbGVyLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuX2dldEFjdGlvbkZyb21Db3JuZXIoYWxyZWFkeVNlbGVjdGVkLCBjb3JuZXIsIGUsIHRhcmdldCksXG4gICAgICAgICAgb3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luRnJvbUNvcm5lcih0YXJnZXQsIGNvcm5lciksXG4gICAgICAgICAgYWx0S2V5ID0gZVt0aGlzLmNlbnRlcmVkS2V5XSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcjogYWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgICAgICAvLyB1c2VkIGJ5IHRyYW5zYXRpb25cbiAgICAgICAgICAgIG9mZnNldFg6IHBvaW50ZXIueCAtIHRhcmdldC5sZWZ0LFxuICAgICAgICAgICAgb2Zmc2V0WTogcG9pbnRlci55IC0gdGFyZ2V0LnRvcCxcbiAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbi54LFxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luLnksXG4gICAgICAgICAgICBleDogcG9pbnRlci54LFxuICAgICAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgICAgIGxhc3RYOiBwb2ludGVyLngsXG4gICAgICAgICAgICBsYXN0WTogcG9pbnRlci55LFxuICAgICAgICAgICAgLy8gdW5zdXJlIHRoZXkgYXJlIHVzZWZ1bCBhbnltb3JlLlxuICAgICAgICAgICAgLy8gbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgICAgICAvLyB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgICAgICB0aGV0YTogZGVncmVlc1RvUmFkaWFucyh0YXJnZXQuYW5nbGUpLFxuICAgICAgICAgICAgLy8gZW5kIG9mIHVuc3VyZVxuICAgICAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCAqIHRhcmdldC5zY2FsZVgsXG4gICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGFsdEtleTogYWx0S2V5LFxuICAgICAgICAgICAgb3JpZ2luYWw6IGZhYnJpYy51dGlsLnNhdmVPYmplY3RUcmFuc2Zvcm0odGFyZ2V0KSxcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2VudGVyVHJhbnNmb3JtKHRhcmdldCwgYWN0aW9uLCBhbHRLZXkpKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ub3JpZ2luYWwub3JpZ2luWCA9IG9yaWdpbi54O1xuICAgICAgdHJhbnNmb3JtLm9yaWdpbmFsLm9yaWdpblkgPSBvcmlnaW4ueTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLl9iZWZvcmVUcmFuc2Zvcm0oZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdWkvI2N1cnNvclxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGUuY3Vyc29yID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBkcmF3IHRoZSBzZWxlY3Rpb24gb25cbiAgICAgKi9cbiAgICBfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgdmFyIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLFxuICAgICAgICAgIGxlZnQgPSBncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgdG9wID0gZ3JvdXBTZWxlY3Rvci50b3AsXG4gICAgICAgICAgYWxlZnQgPSBhYnMobGVmdCksXG4gICAgICAgICAgYXRvcCA9IGFicyh0b3ApO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Db2xvcikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcblxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgZ3JvdXBTZWxlY3Rvci5leCAtICgobGVmdCA+IDApID8gMCA6IC1sZWZ0KSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yLmV5IC0gKCh0b3AgPiAwKSA/IDAgOiAtdG9wKSxcbiAgICAgICAgICBhbGVmdCxcbiAgICAgICAgICBhdG9wXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGggfHwgIXRoaXMuc2VsZWN0aW9uQm9yZGVyQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcjtcblxuICAgICAgLy8gc2VsZWN0aW9uIGJvcmRlclxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5Lmxlbmd0aCA+IDEgJiYgIXN1cHBvcnRMaW5lRGFzaCkge1xuXG4gICAgICAgIHZhciBweCA9IGdyb3VwU2VsZWN0b3IuZXggKyBTVFJPS0VfT0ZGU0VUIC0gKChsZWZ0ID4gMCkgPyAwIDogYWxlZnQpLFxuICAgICAgICAgICAgcHkgPSBncm91cFNlbGVjdG9yLmV5ICsgU1RST0tFX09GRlNFVCAtICgodG9wID4gMCkgPyAwIDogYXRvcCk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5LCBweCArIGFsZWZ0LCBweSwgdGhpcy5zZWxlY3Rpb25EYXNoQXJyYXkpO1xuICAgICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHB4LCBweSArIGF0b3AgLSAxLCBweCArIGFsZWZ0LCBweSArIGF0b3AgLSAxLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHgsIHB5LCBweCwgcHkgKyBhdG9wLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcHggKyBhbGVmdCAtIDEsIHB5LCBweCArIGFsZWZ0IC0gMSwgcHkgKyBhdG9wLCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG5cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldExpbmVEYXNoLmNhbGwodGhpcywgY3R4LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXggKyBTVFJPS0VfT0ZGU0VUIC0gKChsZWZ0ID4gMCkgPyAwIDogYWxlZnQpLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IuZXkgKyBTVFJPS0VfT0ZGU0VUIC0gKCh0b3AgPiAwKSA/IDAgOiBhdG9wKSxcbiAgICAgICAgICBhbGVmdCxcbiAgICAgICAgICBhdG9wXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRldGVybWluZXMgd2hhdCBvYmplY3Qgd2UgYXJlIGNsaWNraW5nIG9uXG4gICAgICogdGhlIHNraXBHcm91cCBwYXJhbWV0ZXIgaXMgZm9yIGludGVybmFsIHVzZSwgaXMgbmVlZGVkIGZvciBzaGlmdCtjbGljayBhY3Rpb25cbiAgICAgKiAxMS8wOS8yMDE4IFRPRE86IHdvdWxkIGJlIGNvb2wgaWYgZmluZFRhcmdldCBjb3VsZCBkaXNjZXJuIGJldHdlZW4gYmVpbmcgYSBmdWxsIHRhcmdldFxuICAgICAqIG9yIHRoZSBvdXRzaWRlIHBhcnQgb2YgdGhlIGNvcm5lci5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwR3JvdXAgd2hlbiB0cnVlLCBhY3RpdmVHcm91cCBpcyBza2lwcGVkIGFuZCBvbmx5IG9iamVjdHMgYXJlIHRyYXZlcnNlZCB0aHJvdWdoXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhlIHRhcmdldCBmb3VuZFxuICAgICAqL1xuICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uIChlLCBza2lwR3JvdXApIHtcbiAgICAgIGlmICh0aGlzLnNraXBUYXJnZXRGaW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLFxuICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSwgaWdub3JlWm9vbSksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGFPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgYWN0aXZlVGFyZ2V0LCBhY3RpdmVUYXJnZXRTdWJzLFxuICAgICAgICAgIGlzVG91Y2ggPSBpc1RvdWNoRXZlbnQoZSk7XG5cbiAgICAgIC8vIGZpcnN0IGNoZWNrIGN1cnJlbnQgZ3JvdXAgKGlmIG9uZSBleGlzdHMpXG4gICAgICAvLyBhY3RpdmUgZ3JvdXAgZG9lcyBub3QgY2hlY2sgc3ViIHRhcmdldHMgbGlrZSBub3JtYWwgZ3JvdXBzLlxuICAgICAgLy8gaWYgYWN0aXZlIGdyb3VwIGp1c3QgZXhpdHMuXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA+IDEgJiYgIXNraXBHcm91cCAmJiBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGhpdCB0aGUgY29ybmVyIG9mIGFuIGFjdGl2ZU9iamVjdCwgbGV0J3MgcmV0dXJuIHRoYXQuXG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID09PSAxICYmIGFjdGl2ZU9iamVjdC5fZmluZFRhcmdldENvcm5lcihwb2ludGVyLCBpc1RvdWNoKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZVRhcmdldCA9IGFjdGl2ZU9iamVjdDtcbiAgICAgICAgICBhY3RpdmVUYXJnZXRTdWJzID0gdGhpcy50YXJnZXRzO1xuICAgICAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHRoaXMuX29iamVjdHMsIHBvaW50ZXIpO1xuICAgICAgaWYgKGVbdGhpcy5hbHRTZWxlY3Rpb25LZXldICYmIHRhcmdldCAmJiBhY3RpdmVUYXJnZXQgJiYgdGFyZ2V0ICE9PSBhY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0O1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBhY3RpdmVUYXJnZXRTdWJzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyB3ZSB3YW50IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dsb2JhbFBvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzIHVzZWQgdG8gc2VhcmNoIHBlciBwaXhlbCB0YXJnZXQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGFuIGFyZWEgb2YgZ2l2ZW4gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tUYXJnZXQ6IGZ1bmN0aW9uKHBvaW50ZXIsIG9iaiwgZ2xvYmFsUG9pbnRlcikge1xuICAgICAgaWYgKG9iaiAmJlxuICAgICAgICAgIG9iai52aXNpYmxlICYmXG4gICAgICAgICAgb2JqLmV2ZW50ZWQgJiZcbiAgICAgICAgICAvLyBodHRwOi8vd3d3Lmdlb2cudWJjLmNhL2NvdXJzZXMva2xpbmsvZ2lzLm5vdGVzL25jZ2lhL3UzMi5odG1sXG4gICAgICAgICAgLy8gaHR0cDovL2lkYXYudWNkYXZpcy5lZHUvfm9rcmV5bG9zL1RBc2hpcC9TcHJpbmcyMDAwL1BvaW50SW5Qb2x5Z29uLmh0bWxcbiAgICAgICAgICAob2JqLmNvbnRhaW5zUG9pbnQocG9pbnRlcikgfHwgISFvYmouX2ZpbmRUYXJnZXRDb3JuZXIocG9pbnRlcikpXG4gICAgICApIHtcbiAgICAgICAgaWYgKCh0aGlzLnBlclBpeGVsVGFyZ2V0RmluZCB8fCBvYmoucGVyUGl4ZWxUYXJnZXRGaW5kKSAmJiAhb2JqLmlzRWRpdGluZykge1xuICAgICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gdGhpcy5pc1RhcmdldFRyYW5zcGFyZW50KG9iaiwgZ2xvYmFsUG9pbnRlci54LCBnbG9iYWxQb2ludGVyLnkpO1xuICAgICAgICAgIGlmICghaXNUcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoIGluc2lkZSBvYmplY3RzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvaW50ZXIgaW4gYm91bmRpbmcgYm94IG9yIHRoYXQgY29udGFpbnMgcG9pbnRlck9uQ2FudmFzIHdoZW4gcGFpbnRlZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvYmplY3RzXSBvYmplY3RzIGFycmF5IHRvIGxvb2sgaW50b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyB3ZSB3YW50IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCB0aGF0IGNvbnRhaW5zIHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWFyY2hQb3NzaWJsZVRhcmdldHM6IGZ1bmN0aW9uKG9iamVjdHMsIHBvaW50ZXIpIHtcbiAgICAgIC8vIENhY2hlIGFsbCB0YXJnZXRzIHdoZXJlIHRoZWlyIGJvdW5kaW5nIGJveCBjb250YWlucyBwb2ludC5cbiAgICAgIHZhciB0YXJnZXQsIGkgPSBvYmplY3RzLmxlbmd0aCwgc3ViVGFyZ2V0O1xuICAgICAgLy8gRG8gbm90IGNoZWNrIGZvciBjdXJyZW50bHkgZ3JvdXBlZCBvYmplY3RzLCBzaW5jZSB3ZSBjaGVjayB0aGUgcGFyZW50IGdyb3VwIGl0c2VsZi5cbiAgICAgIC8vIHVudGlsIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiBzcGVjaWZpY2FsbHkgdG8gc2VhcmNoIGluc2lkZSB0aGUgYWN0aXZlR3JvdXBcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIG9ialRvQ2hlY2sgPSBvYmplY3RzW2ldO1xuICAgICAgICB2YXIgcG9pbnRlclRvVXNlID0gb2JqVG9DaGVjay5ncm91cCA/XG4gICAgICAgICAgdGhpcy5fbm9ybWFsaXplUG9pbnRlcihvYmpUb0NoZWNrLmdyb3VwLCBwb2ludGVyKSA6IHBvaW50ZXI7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1RhcmdldChwb2ludGVyVG9Vc2UsIG9ialRvQ2hlY2ssIHBvaW50ZXIpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gb2JqZWN0c1tpXTtcbiAgICAgICAgICBpZiAodGFyZ2V0LnN1YlRhcmdldENoZWNrICYmIHRhcmdldCBpbnN0YW5jZW9mIGZhYnJpYy5Hcm91cCkge1xuICAgICAgICAgICAgc3ViVGFyZ2V0ID0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHRhcmdldC5fb2JqZWN0cywgcG9pbnRlcik7XG4gICAgICAgICAgICBzdWJUYXJnZXQgJiYgdGhpcy50YXJnZXRzLnB1c2goc3ViVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyB3aXRob3V0IHRoZSBlZmZlY3Qgb2YgdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICByZXN0b3JlUG9pbnRlclZwdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KFxuICAgICAgICBwb2ludGVyLFxuICAgICAgICBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcG9pbnRlciBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjYW52YXMuXG4gICAgICogQ2FuIHJldHVybiBjb29yZGluYXRlcyB3aXRoIG9yIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm0uXG4gICAgICogaWdub3JlWm9vbSBmYWxzZSBnaXZlcyBiYWNrIGNvb3JkaW5hdGVzIHRoYXQgcmVwcmVzZW50XG4gICAgICogdGhlIHBvaW50IGNsaWNrZWQgb24gY2FudmFzIGVsZW1lbnQuXG4gICAgICogaWdub3JlWm9vbSB0cnVlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgYWZ0ZXIgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICogYnkgdGhlIHZpZXdwb3J0VHJhbnNmb3JtICggc29ydCBvZiBjb29yZGluYXRlcyBvZiB3aGF0IGlzIGRpc3BsYXllZFxuICAgICAqIG9uIHRoZSBjYW52YXMgd2hlcmUgeW91IGFyZSBjbGlja2luZy5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgPSBIVE1MRWxlbWVudCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0b3AsbGVmdFxuICAgICAqIGlnbm9yZVpvb20gZmFsc2UsIGRlZmF1bHQgPSBmYWJyaWMgc3BhY2UgY29vcmRpbmF0ZXMsIHRoZSBzYW1lIHVzZWQgZm9yIHNoYXBlIHBvc2l0aW9uXG4gICAgICogVG8gaW50ZXJhY3Qgd2l0aCB5b3VyIHNoYXBlcyB0b3AgYW5kIGxlZnQgeW91IHdhbnQgdG8gdXNlIGlnbm9yZVpvb20gdHJ1ZVxuICAgICAqIG1vc3Qgb2YgdGhlIHRpbWUsIHdoaWxlIGlnbm9yZVpvb20gZmFsc2Ugd2lsbCBnaXZlIHlvdSBjb29yZGluYXRlc1xuICAgICAqIGNvbXBhdGlibGUgd2l0aCB0aGUgb2JqZWN0Lm9Db29yZHMgc3lzdGVtLlxuICAgICAqIG9mIHRoZSB0aW1lLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVpvb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICovXG4gICAgZ2V0UG9pbnRlcjogZnVuY3Rpb24gKGUsIGlnbm9yZVpvb20pIHtcbiAgICAgIC8vIHJldHVybiBjYWNoZWQgdmFsdWVzIGlmIHdlIGFyZSBpbiB0aGUgZXZlbnQgcHJvY2Vzc2luZyBjaGFpblxuICAgICAgaWYgKHRoaXMuX2Fic29sdXRlUG9pbnRlciAmJiAhaWdub3JlWm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVQb2ludGVyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXIgJiYgaWdub3JlWm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBnZXRQb2ludGVyKGUpLFxuICAgICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgYm91bmRzID0gdXBwZXJDYW52YXNFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IGJvdW5kcy53aWR0aCB8fCAwLFxuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IGJvdW5kcy5oZWlnaHQgfHwgMCxcbiAgICAgICAgICBjc3NTY2FsZTtcblxuICAgICAgaWYgKCFib3VuZHNXaWR0aCB8fCAhYm91bmRzSGVpZ2h0ICkge1xuICAgICAgICBpZiAoJ3RvcCcgaW4gYm91bmRzICYmICdib3R0b20nIGluIGJvdW5kcykge1xuICAgICAgICAgIGJvdW5kc0hlaWdodCA9IE1hdGguYWJzKCBib3VuZHMudG9wIC0gYm91bmRzLmJvdHRvbSApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgncmlnaHQnIGluIGJvdW5kcyAmJiAnbGVmdCcgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzV2lkdGggPSBNYXRoLmFicyggYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICAgIHBvaW50ZXIueCA9IHBvaW50ZXIueCAtIHRoaXMuX29mZnNldC5sZWZ0O1xuICAgICAgcG9pbnRlci55ID0gcG9pbnRlci55IC0gdGhpcy5fb2Zmc2V0LnRvcDtcbiAgICAgIGlmICghaWdub3JlWm9vbSkge1xuICAgICAgICBwb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdChwb2ludGVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldGluYVNjYWxpbmcgPSB0aGlzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgIGlmIChyZXRpbmFTY2FsaW5nICE9PSAxKSB7XG4gICAgICAgIHBvaW50ZXIueCAvPSByZXRpbmFTY2FsaW5nO1xuICAgICAgICBwb2ludGVyLnkgLz0gcmV0aW5hU2NhbGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kc1dpZHRoID09PSAwIHx8IGJvdW5kc0hlaWdodCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgKGkuZS4gbm90IHZpc2libGUpLCBkbyBub3QgYXBwbHkgc2NhbGUuXG4gICAgICAgIGNzc1NjYWxlID0geyB3aWR0aDogMSwgaGVpZ2h0OiAxIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3NzU2NhbGUgPSB7XG4gICAgICAgICAgd2lkdGg6IHVwcGVyQ2FudmFzRWwud2lkdGggLyBib3VuZHNXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHVwcGVyQ2FudmFzRWwuaGVpZ2h0IC8gYm91bmRzSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50ZXIueCAqIGNzc1NjYWxlLndpZHRoLFxuICAgICAgICB5OiBwb2ludGVyLnkgKiBjc3NTY2FsZS5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHRocm93cyB7Q0FOVkFTX0lOSVRfRVJST1J9IElmIGNhbnZhcyBjYW4gbm90IGJlIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgX2NyZWF0ZVVwcGVyQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG93ZXJDYW52YXNDbGFzcyA9IHRoaXMubG93ZXJDYW52YXNFbC5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmxvd2VyLWNhbnZhc1xccyovLCAnJyksXG4gICAgICAgICAgbG93ZXJDYW52YXNFbCA9IHRoaXMubG93ZXJDYW52YXNFbCwgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbDtcblxuICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgdXBwZXJDYW52YXMgZWxlbWVudCBpZiB3ZSBoYXZlIGFscmVhZHkgb25lLlxuICAgICAgaWYgKHVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdXBwZXJDYW52YXNFbC5jbGFzc05hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB1cHBlckNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwgPSB1cHBlckNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModXBwZXJDYW52YXNFbCwgJ3VwcGVyLWNhbnZhcyAnICsgbG93ZXJDYW52YXNDbGFzcyk7XG5cbiAgICAgIHRoaXMud3JhcHBlckVsLmFwcGVuZENoaWxkKHVwcGVyQ2FudmFzRWwpO1xuXG4gICAgICB0aGlzLl9jb3B5Q2FudmFzU3R5bGUobG93ZXJDYW52YXNFbCwgdXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLl9hcHBseUNhbnZhc1N0eWxlKHVwcGVyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gdXBwZXJDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsID0gdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoKTtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gdGhpcy5jYWNoZUNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy53cmFwcGVyRWwgPSBmYWJyaWMudXRpbC53cmFwRWxlbWVudCh0aGlzLmxvd2VyQ2FudmFzRWwsICdkaXYnLCB7XG4gICAgICAgICdjbGFzcyc6IHRoaXMuY29udGFpbmVyQ2xhc3NcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUodGhpcy53cmFwcGVyRWwsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0pO1xuICAgICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUodGhpcy53cmFwcGVyRWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgY2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgc3R5bGVzIG9uXG4gICAgICovXG4gICAgX2FwcGx5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKGVsZW1lbnQsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJ3B4JyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICAndG91Y2gtYWN0aW9uJzogdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nID8gJ21hbmlwdWxhdGlvbicgOiAnbm9uZScsXG4gICAgICAgICctbXMtdG91Y2gtYWN0aW9uJzogdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nID8gJ21hbmlwdWxhdGlvbicgOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29weSB0aGUgZW50aXJlIGlubGluZSBzdHlsZSBmcm9tIG9uZSBlbGVtZW50IChmcm9tRWwpIHRvIGFub3RoZXIgKHRvRWwpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21FbCBFbGVtZW50IHN0eWxlIGlzIGNvcGllZCBmcm9tXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0b0VsIEVsZW1lbnQgY29waWVkIHN0eWxlIGlzIGFwcGxpZWQgdG9cbiAgICAgKi9cbiAgICBfY29weUNhbnZhc1N0eWxlOiBmdW5jdGlvbiAoZnJvbUVsLCB0b0VsKSB7XG4gICAgICB0b0VsLnN0eWxlLmNzc1RleHQgPSBmcm9tRWwuc3R5bGUuY3NzVGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIGNhbnZhcyB3aGVyZSBvYmplY3Qgc2VsZWN0aW9uIGlzIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IG9uIHdoaWNoIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25FbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cHBlckNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBhY3RpdmUgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gYWN0aXZlIG9iamVjdFxuICAgICAqL1xuICAgIGdldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSBjdXJyZW50IHNlbGVjdGVkIG9iamVjdHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZS50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyAmJiBhY3RpdmUuX29iamVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlLl9vYmplY3RzLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbYWN0aXZlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAvLyByZW1vdmluZyBhY3RpdmUgb2JqZWN0IHNob3VsZCBmaXJlIFwic2VsZWN0aW9uOmNsZWFyZWRcIiBldmVudHNcbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoKTtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICAgIG9iai5maXJlKCdkZXNlbGVjdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAob2JqID09PSB0aGlzLl9ob3ZlcmVkVGFyZ2V0KXtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcignX29uT2JqZWN0UmVtb3ZlZCcsIG9iaik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQ29tcGFyZXMgdGhlIG9sZCBhY3RpdmVPYmplY3Qgd2l0aCB0aGUgY3VycmVudCBvbmUgYW5kIGZpcmVzIGNvcnJlY3QgZXZlbnRzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogb2xkIGFjdGl2ZU9iamVjdFxuICAgICAqL1xuICAgIF9maXJlU2VsZWN0aW9uRXZlbnRzOiBmdW5jdGlvbihvbGRPYmplY3RzLCBlKSB7XG4gICAgICB2YXIgc29tZXRoaW5nQ2hhbmdlZCA9IGZhbHNlLCBvYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgYWRkZWQgPSBbXSwgcmVtb3ZlZCA9IFtdLCBvcHQgPSB7IGU6IGUgfTtcbiAgICAgIG9sZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvbGRPYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdHMuaW5kZXhPZihvbGRPYmplY3QpID09PSAtMSkge1xuICAgICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIG9sZE9iamVjdC5maXJlKCdkZXNlbGVjdGVkJywgb3B0KTtcbiAgICAgICAgICByZW1vdmVkLnB1c2gob2xkT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvbGRPYmplY3RzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgICBzb21ldGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBvYmplY3QuZmlyZSgnc2VsZWN0ZWQnLCBvcHQpO1xuICAgICAgICAgIGFkZGVkLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAob2xkT2JqZWN0cy5sZW5ndGggPiAwICYmIG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBvcHQuc2VsZWN0ZWQgPSBhZGRlZDtcbiAgICAgICAgb3B0LmRlc2VsZWN0ZWQgPSByZW1vdmVkO1xuICAgICAgICAvLyBhZGRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICBvcHQudXBkYXRlZCA9IGFkZGVkWzBdIHx8IHJlbW92ZWRbMF07XG4gICAgICAgIG9wdC50YXJnZXQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgJiYgdGhpcy5maXJlKCdzZWxlY3Rpb246dXBkYXRlZCcsIG9wdCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3B0LnNlbGVjdGVkID0gYWRkZWQ7XG4gICAgICAgIC8vIGFkZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIG9wdC50YXJnZXQgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNyZWF0ZWQnLCBvcHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2xkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wdC5kZXNlbGVjdGVkID0gcmVtb3ZlZDtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIG9wdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZ2l2ZW4gb2JqZWN0IGFzIHRoZSBvbmx5IGFjdGl2ZSBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNldCBhcyBhbiBhY3RpdmUgb25lXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKG9iamVjdCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCk7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3Qob2JqZWN0LCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzZWxlY3Rpb24gaGFwcGVuZWRcbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVPYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm9uU2VsZWN0KHsgZTogZSB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBvYmplY3Q7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24oZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICAvLyBvbkRlc2VsZWN0IHJldHVybiBUUlVFIHRvIGNhbmNlbCBzZWxlY3Rpb247XG4gICAgICAgIGlmIChvYmoub25EZXNlbGVjdCh7IGU6IGUsIG9iamVjdDogb2JqZWN0IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZHMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3QgYW5kIGZpcmUgZXZlbnRzLiBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGZhYnJpY1xuICAgICAqIGFzIGEgY29uc2VxdWVuY2Ugb2YgYSBtb3VzZSBldmVudCwgdGhlIGV2ZW50IGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBhbmRcbiAgICAgKiBzZW50IHRvIHRoZSBmaXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VzdG9tIGV2ZW50cy4gV2hlbiB1c2VkIGFzIGEgbWV0aG9kIHRoZVxuICAgICAqIGUgcGFyYW0gZG9lcyBub3QgaGF2ZSBhbnkgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLCBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBhY3RpdmVPYmplY3QsIGU6IGUgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIHJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMudXBwZXJDYW52YXNFbCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgWyd1cHBlckNhbnZhc0VsJywgJ2NhY2hlQ2FudmFzRWwnXS5mb3JFYWNoKChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpc1tlbGVtZW50XSk7XG4gICAgICAgIHRoaXNbZWxlbWVudF0gPSB1bmRlZmluZWQ7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgIGlmICh3cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMud3JhcHBlckVsKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRleHRzIChiYWNrZ3JvdW5kLCBtYWluLCB0b3ApIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdGhpcy5kaXNjYXJkQWN0aXZlR3JvdXAoKTtcbiAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignY2xlYXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3Mgb2JqZWN0cycgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBjb250cm9scyBvblxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5fcmVuZGVyQ29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgcGFydCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gZ3JvdXAsIGl0IHNob3VsZFxuICAgICAgLy9iZSB0cmFuc2Zvcm1lZCBhcHByb3ByaWF0ZWx5XG4gICAgICAvL2kuZS4gaXQgc2hvdWxkIGJlIHNlcmlhbGlzZWQgYXMgaXQgd291bGQgYXBwZWFyIGlmIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgIC8vd2VyZSB0byBiZSBkZXN0cm95ZWQuXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpLFxuICAgICAgICAgIG9iamVjdCA9IHRoaXMuY2FsbFN1cGVyKCdfdG9PYmplY3QnLCBpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAvL1VuZG8gdGhlIGRhbWFnZSB3ZSBkaWQgYnkgY2hhbmdpbmcgYWxsIG9mIGl0cyBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlLCBvcmlnaW5hbFByb3BlcnRpZXMpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgYW4gb2JqZWN0J3MgZ3JvdXAgdHJhbnNmb3JtYXRpb24gb24gaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW2luc3RhbmNlXSB0aGUgb2JqZWN0IHRvIHRyYW5zZm9ybSAoZ2V0cyBtdXRhdGVkKVxuICAgICAqIEByZXR1cm5zIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgaW5zdGFuY2Ugd2hpY2ggd2VyZSBjaGFuZ2VkXG4gICAgICovXG4gICAgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgaWYgKGluc3RhbmNlLmdyb3VwICYmIGluc3RhbmNlLmdyb3VwLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gaW5zdGFuY2UuZ3JvdXApIHtcbiAgICAgICAgdmFyIGxheW91dFByb3BzID0gWydhbmdsZScsICdmbGlwWCcsICdmbGlwWScsICdsZWZ0JywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2tld1gnLCAnc2tld1knLCAndG9wJ107XG4gICAgICAgIC8vQ29weSBhbGwgdGhlIHBvc2l0aW9uYWxseSByZWxldmFudCBwcm9wZXJ0aWVzIGFjcm9zcyBub3dcbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWVzID0ge307XG4gICAgICAgIGxheW91dFByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIG9yaWdpbmFsVmFsdWVzW3Byb3BdID0gaW5zdGFuY2VbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QucmVhbGl6ZVRyYW5zZm9ybShpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIGNoYW5nZWQgcHJvcGVydGllcyBvZiBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdW4tdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcmlnaW5hbFZhbHVlc10gdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSwgYXMgcmV0dXJuZWQgYnkgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0XG4gICAgICovXG4gICAgX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBvcmlnaW5hbFZhbHVlcykge1xuICAgICAgaWYgKG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldChvcmlnaW5hbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgLy9JZiB0aGUgb2JqZWN0IGlzIGluIGEgc2VsZWN0aW9uIGdyb3VwLCBzaW11bGF0ZSB3aGF0IHdvdWxkIGhhcHBlbiB0byB0aGF0XG4gICAgICAvL29iamVjdCB3aGVuIHRoZSBncm91cCBpcyBkZXNlbGVjdGVkXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXRTVkdPYmplY3QnLCBtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKTtcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbiAodnB0KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZykge1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB9XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZXRWaWV3cG9ydFRyYW5zZm9ybS5jYWxsKHRoaXMsIHZwdCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBjb3B5aW5nIHN0YXRpYyBwcm9wZXJ0aWVzIG1hbnVhbGx5IHRvIHdvcmsgYXJvdW5kIE9wZXJhJ3MgYnVnLFxuICAvLyB3aGVyZSBcInByb3RvdHlwZVwiIHByb3BlcnR5IGlzIGVudW1lcmFibGUgYW5kIG92ZXJyaWRlcyBleGlzdGluZyBwcm90b3R5cGVcbiAgZm9yICh2YXIgcHJvcCBpbiBmYWJyaWMuU3RhdGljQ2FudmFzKSB7XG4gICAgaWYgKHByb3AgIT09ICdwcm90b3R5cGUnKSB7XG4gICAgICBmYWJyaWMuQ2FudmFzW3Byb3BdID0gZmFicmljLlN0YXRpY0NhbnZhc1twcm9wXTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhZGRMaXN0ZW5lciA9IGZhYnJpYy51dGlsLmFkZExpc3RlbmVyLFxuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBmYWJyaWMudXRpbC5yZW1vdmVMaXN0ZW5lcixcbiAgICAgIFJJR0hUX0NMSUNLID0gMywgTUlERExFX0NMSUNLID0gMiwgTEVGVF9DTElDSyA9IDEsXG4gICAgICBhZGRFdmVudE9wdGlvbnMgPSB7IHBhc3NpdmU6IGZhbHNlIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGljayhlLCB2YWx1ZSkge1xuICAgIHJldHVybiBlLmJ1dHRvbiAmJiAoZS5idXR0b24gPT09IHZhbHVlIC0gMSk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHRoZSBpZCBvZiB0aGUgdG91Y2ggZXZlbnQgdGhhdCBvd25zIHRoZSBmYWJyaWMgdHJhbnNmb3JtXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWluVG91Y2hJZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbW91c2UgbGlzdGVuZXJzIHRvIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaW4gY2FzZSB3ZSBpbml0aWFsaXplZCB0aGUgY2xhc3MgdHdpY2UuIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gbm9ybWFsbHlcbiAgICAgIC8vIGJ1dCBpbiBzb21lIGtpbmQgb2YgYXBwbGljYXRpb25zIHdoZXJlIHRoZSBjYW52YXMgZWxlbWVudCBtYXkgYmUgY2hhbmdlZFxuICAgICAgLy8gdGhpcyBpcyBhIHdvcmthcm91bmQgdG8gaGF2aW5nIGRvdWJsZSBsaXN0ZW5lcnMuXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5hZGRPclJlbW92ZShhZGRMaXN0ZW5lciwgJ2FkZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYW4gZXZlbnQgcHJlZml4IHBvaW50ZXIgb3IgbW91c2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RXZlbnRQcmVmaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMgPyAncG9pbnRlcicgOiAnbW91c2UnO1xuICAgIH0sXG5cbiAgICBhZGRPclJlbW92ZTogZnVuY3Rpb24oZnVuY3RvciwgZXZlbnRqc0Z1bmN0b3IpIHtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBmdW5jdG9yKGZhYnJpYy53aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnb3V0JywgdGhpcy5fb25Nb3VzZU91dCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRoaXMuX29uTW91c2VFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICd3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdvdmVyJywgdGhpcy5fb25EcmFnT3Zlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnbGVhdmUnLCB0aGlzLl9vbkRyYWdMZWF2ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcm9wJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIGlmICghdGhpcy5lbmFibGVQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmIGV2ZW50anNGdW5jdG9yIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2dlc3R1cmUnLCB0aGlzLl9vbkdlc3R1cmUpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnc2hha2UnLCB0aGlzLl9vblNoYWtlKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2xvbmdwcmVzcycsIHRoaXMuX29uTG9uZ1ByZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkT3JSZW1vdmUocmVtb3ZlTGlzdGVuZXIsICdyZW1vdmUnKTtcbiAgICAgIC8vIGlmIHlvdSBkaXNwb3NlIG9uIGEgbW91c2VEb3duLCBiZWZvcmUgbW91c2UgdXAsIHlvdSBuZWVkIHRvIGNsZWFuIGRvY3VtZW50IHRvLi4uXG4gICAgICB2YXIgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50c0JvdW5kKSB7XG4gICAgICAgIC8vIGZvciBhbnkgcmVhc29uIHdlIHBhc3MgaGVyZSB0d2ljZSB3ZSBkbyBub3Qgd2FudCB0byBiaW5kIGV2ZW50cyB0d2ljZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fb25Nb3VzZURvd24gPSB0aGlzLl9vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uVG91Y2hFbmQgPSB0aGlzLl9vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkdlc3R1cmUgPSB0aGlzLl9vbkdlc3R1cmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25TaGFrZSA9IHRoaXMuX29uU2hha2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTG9uZ1ByZXNzID0gdGhpcy5fb25Mb25nUHJlc3MuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlV2hlZWwgPSB0aGlzLl9vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VPdXQgPSB0aGlzLl9vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlRW50ZXIgPSB0aGlzLl9vbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uQ29udGV4dE1lbnUgPSB0aGlzLl9vbkNvbnRleHRNZW51LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRvdWJsZUNsaWNrID0gdGhpcy5fb25Eb3VibGVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnT3ZlciA9IHRoaXMuX29uRHJhZ092ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZ0VudGVyID0gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyLmJpbmQodGhpcywgJ2RyYWdlbnRlcicpO1xuICAgICAgdGhpcy5fb25EcmFnTGVhdmUgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2xlYXZlJyk7XG4gICAgICB0aGlzLl9vbkRyb3AgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJvcCcpO1xuICAgICAgdGhpcy5ldmVudHNCb3VuZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBnZXN0dXJlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkdlc3R1cmU6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vblRyYW5zZm9ybUdlc3R1cmUgJiYgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGRyYWdcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uRHJhZzogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uRHJhZyAmJiB0aGlzLl9fb25EcmFnKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gd2hlZWwgZXZlbnRcbiAgICAgKi9cbiAgICBfb25Nb3VzZVdoZWVsOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVdoZWVsKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5faG92ZXJlZFRhcmdldDtcbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3V0JywgeyB0YXJnZXQ6IHRhcmdldCwgZTogZSB9KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZW91dCcsIHsgZTogZSB9KTtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24oX3RhcmdldCl7XG4gICAgICAgIF90aGlzLmZpcmUoJ21vdXNlOm91dCcsIHsgdGFyZ2V0OiB0YXJnZXQsIGU6IGUgfSk7XG4gICAgICAgIF90YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICBpZiAob2JqLmlzRWRpdGluZykge1xuICAgICAgICAgICAgb2JqLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWVudGVyXG4gICAgICovXG4gICAgX29uTW91c2VFbnRlcjogZnVuY3Rpb24oZSkge1xuICAgICAgLy8gVGhpcyBmaW5kIHRhcmdldCBhbmQgY29uc2VxdWVudCAnbW91c2U6b3ZlcicgaXMgdXNlZCB0b1xuICAgICAgLy8gY2xlYXIgb2xkIGluc3RhbmNlcyBvbiBob3ZlcmVkIHRhcmdldC5cbiAgICAgIC8vIGNhbGxpbmcgZmluZFRhcmdldCBoYXMgdGhlIHNpZGUgZWZmZWN0IG9mIGtpbGxpbmcgdGFyZ2V0Ll9fY29ybmVyLlxuICAgICAgLy8gYXMgYSBzaG9ydCB0ZXJtIGZpeCB3ZSBhcmUgbm90IGZpcmluZyB0aGlzIGlmIHdlIGFyZSBjdXJyZW50bHkgdHJhbnNmb3JtaW5nLlxuICAgICAgLy8gYXMgYSBsb25nIHRlcm0gZml4IHdlIG5lZWQgdG8gc2VwYXJhdGUgdGhlIGFjdGlvbiBvZiBmaW5kaW5nIGEgdGFyZ2V0IHdpdGggdGhlXG4gICAgICAvLyBzaWRlIGVmZmVjdHMgd2UgYWRkZWQgdG8gaXQuXG4gICAgICBpZiAoIXRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gJiYgIXRoaXMuZmluZFRhcmdldChlKSkge1xuICAgICAgICB0aGlzLmZpcmUoJ21vdXNlOm92ZXInLCB7IHRhcmdldDogbnVsbCwgZTogZSB9KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBvcmllbnRhdGlvbiBjaGFuZ2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbk9yaWVudGF0aW9uQ2hhbmdlICYmIHRoaXMuX19vbk9yaWVudGF0aW9uQ2hhbmdlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uU2hha2U6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vblNoYWtlICYmIHRoaXMuX19vblNoYWtlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uTG9uZ1ByZXNzOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25Mb25nUHJlc3MgJiYgdGhpcy5fX29uTG9uZ1ByZXNzKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcmV2ZW50IGRlZmF1bHQgdG8gYWxsb3cgZHJvcCBldmVudCB0byBiZSBmaXJlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqL1xuICAgIF9vbkRyYWdPdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyKCdkcmFnb3ZlcicsIGUpO1xuICAgICAgdGhpcy5fZmlyZUVudGVyTGVhdmVFdmVudHModGFyZ2V0LCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Db250ZXh0TWVudTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzLnN0b3BDb250ZXh0TWVudSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkYmxjbGljaycpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHRoZSBpZCBvZiBhbiBldmVudC5cbiAgICAgKiByZXR1cm5zIGVpdGhlciB0aGUgcG9pbnRlcklkIG9yIHRoZSBpZGVudGlmaWVyIG9yIDAgZm9yIHRoZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZ0IEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIGdldFBvaW50ZXJJZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBldnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmIChjaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlZFRvdWNoZXNbMF0gJiYgY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW5hYmxlUG9pbnRlckV2ZW50cykge1xuICAgICAgICByZXR1cm4gZXZ0LnBvaW50ZXJJZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGFuIGV2ZW50IGhhcyB0aGUgaWQgb2YgdGhlIGV2ZW50IHRoYXQgaXMgY29uc2lkZXJlZCBtYWluXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2V2dH0gZXZlbnQgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2lzTWFpbkV2ZW50OiBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmIChldnQuaXNQcmltYXJ5ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC5pc1ByaW1hcnkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQudHlwZSA9PT0gJ3RvdWNoZW5kJyAmJiBldnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHJldHVybiBldnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllciA9PT0gdGhpcy5tYWluVG91Y2hJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLm1haW5Ub3VjaElkID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubWFpblRvdWNoSWQgPSB0aGlzLmdldFBvaW50ZXJJZChlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vbk1vdXNlRG93bihlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICAvLyBVbmJpbmQgbW91c2Vkb3duIHRvIHByZXZlbnQgZG91YmxlIHRyaWdnZXJzIGZyb20gdG91Y2ggZGV2aWNlc1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ2Rvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VEb3duKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgYWRkTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vblRvdWNoRW5kOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgc3RvcCBoZXJlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vbk1vdXNlVXAoZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdGhpcy5tYWluVG91Y2hJZCA9IG51bGw7XG4gICAgICB2YXIgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl93aWxsQWRkTW91c2VEb3duKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl93aWxsQWRkTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dpbGxBZGRNb3VzZURvd24gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXYWl0IDQwMG1zIGJlZm9yZSByZWJpbmRpbmcgbW91c2Vkb3duIHRvIHByZXZlbnQgZG91YmxlIHRyaWdnZXJzXG4gICAgICAgIC8vIGZyb20gdG91Y2ggZGV2aWNlc1xuICAgICAgICBhZGRMaXN0ZW5lcihfdGhpcy51cHBlckNhbnZhc0VsLCBldmVudFR5cGVQcmVmaXggKyAnZG93bicsIF90aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICAgIF90aGlzLl93aWxsQWRkTW91c2VEb3duID0gMDtcbiAgICAgIH0sIDQwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBpZiAodGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGFkZExpc3RlbmVyKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgIXRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZyAmJiBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX19vbk1vdXNlTW92ZShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGVzIHdoZXRoZXIgdGhlIGNhbnZhcyBzaG91bGQgYmUgcmVkcmF3biBpbiBtb3VzZXVwIGFuZCBtb3VzZWRvd24gZXZlbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zaG91bGRSZW5kZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcblxuICAgICAgaWYgKFxuICAgICAgICAhIWFjdGl2ZU9iamVjdCAhPT0gISF0YXJnZXQgfHxcbiAgICAgICAgKGFjdGl2ZU9iamVjdCAmJiB0YXJnZXQgJiYgKGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0KSlcbiAgICAgICkge1xuICAgICAgICAvLyB0aGlzIGNvdmVyczogc3dpdGNoIG9mIHRhcmdldCwgZnJvbSB0YXJnZXQgdG8gbm8gdGFyZ2V0LCBzZWxlY3Rpb24gb2YgdGFyZ2V0XG4gICAgICAgIC8vIG11bHRpU2VsZWN0aW9uIHdpdGgga2V5IGFuZCBtb3VzZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIC8vIGlmIHdlIG1vdXNlIHVwL2Rvd24gb3ZlciBhIGVkaXRpbmcgdGV4dGJveCBhIGN1cnNvciBjaGFuZ2UsXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmUgcmVuZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWV0aG9kIHJlc2V0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzLCBzdG9yZSB0aGUgaW1hZ2UgY29ybmVyXG4gICAgICogcG9zaXRpb24gaW4gdGhlIGltYWdlIG9iamVjdCBhbmQgcmVuZGVyIHRoZSBjYW52YXMgb24gdG9wLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRhcmdldCwgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3Rvciwgc2hvdWxkUmVuZGVyID0gZmFsc2UsXG4gICAgICAgICAgaXNDbGljayA9ICghZ3JvdXBTZWxlY3RvciB8fCAoZ3JvdXBTZWxlY3Rvci5sZWZ0ID09PSAwICYmIGdyb3VwU2VsZWN0b3IudG9wID09PSAwKSk7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cDpiZWZvcmUnKTtcbiAgICAgIC8vIGlmIHJpZ2h0L21pZGRsZSBjbGljayBqdXN0IGZpcmUgZXZlbnRzIGFuZCByZXR1cm5cbiAgICAgIC8vIHRhcmdldCB1bmRlZmluZWQgd2lsbCBtYWtlIHRoZSBfaGFuZGxlRXZlbnQgc2VhcmNoIHRoZSB0YXJnZXRcbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIFJJR0hUX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlUmlnaHRDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIFJJR0hUX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIE1JRERMRV9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZU1pZGRsZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgTUlERExFX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUgJiYgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VVcEluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybShlKTtcbiAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNDbGljaykge1xuICAgICAgICB2YXIgdGFyZ2V0V2FzQWN0aXZlID0gdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIHRoaXMuX21heWJlR3JvdXBPYmplY3RzKGUpO1xuICAgICAgICBpZiAoIXNob3VsZFJlbmRlcikge1xuICAgICAgICAgIHNob3VsZFJlbmRlciA9IChcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQpIHx8XG4gICAgICAgICAgICAoIXRhcmdldFdhc0FjdGl2ZSAmJiB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIoXG4gICAgICAgICAgdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpLFxuICAgICAgICAgIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudChlKVxuICAgICAgICApO1xuICAgICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdLFxuICAgICAgICAgICAgbW91c2VVcEhhbmRsZXIgPSBjb250cm9sICYmIGNvbnRyb2wuZ2V0TW91c2VVcEhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKTtcbiAgICAgICAgaWYgKG1vdXNlVXBIYW5kbGVyKSB7XG4gICAgICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgICAgbW91c2VVcEhhbmRsZXIoZSwgdHJhbnNmb3JtLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmlzTW92aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRDdXJzb3JGcm9tRXZlbnQoZSwgdGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIExFRlRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIC8vIHJlc2V0IHRoZSB0YXJnZXQgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2ggY29ybmVyIGlzIHNlbGVjdGVkXG4gICAgICB0YXJnZXQgJiYgKHRhcmdldC5fX2Nvcm5lciA9IDApO1xuICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc0NsaWNrKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSGFuZGxlIGV2ZW50IGZpcmluZyBmb3IgdGFyZ2V0IGFuZCBzdWJ0YXJnZXRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqIEByZXR1cm4ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCByZXR1cm4gdGhlIHRoZSB0YXJnZXQgZm91bmQsIGZvciBpbnRlcm5hbCByZWFzb25zLlxuICAgICAqL1xuICAgIF9zaW1wbGVFdmVudEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKSxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgIH07XG4gICAgICB0aGlzLmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgaWYgKCF0YXJnZXRzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldE9iaiByZWNlaXZpbmcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2J1dHRvbl0gYnV0dG9uIHVzZWQgaW4gdGhlIGV2ZW50IDEgPSBsZWZ0LCAyID0gbWlkZGxlLCAzID0gcmlnaHRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xpY2sgZm9yIGxlZnQgYnV0dG9uIG9ubHksIGluZGljYXRlcyB0aGF0IHRoZSBtb3VzZSB1cCBoYXBwZW5lZCB3aXRob3V0IG1vdmUuXG4gICAgICovXG4gICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbihlLCBldmVudFR5cGUsIGJ1dHRvbiwgaXNDbGljaykge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCxcbiAgICAgICAgICB0YXJnZXRzID0gdGhpcy50YXJnZXRzIHx8IFtdLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBzdWJUYXJnZXRzOiB0YXJnZXRzLFxuICAgICAgICAgICAgYnV0dG9uOiBidXR0b24gfHwgTEVGVF9DTElDSyxcbiAgICAgICAgICAgIGlzQ2xpY2s6IGlzQ2xpY2sgfHwgZmFsc2UsXG4gICAgICAgICAgICBwb2ludGVyOiB0aGlzLl9wb2ludGVyLFxuICAgICAgICAgICAgYWJzb2x1dGVQb2ludGVyOiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm1cbiAgICAgICAgICB9O1xuICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3VwJykge1xuICAgICAgICBvcHRpb25zLmN1cnJlbnRUYXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSk7XG4gICAgICAgIG9wdGlvbnMuY3VycmVudFN1YlRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoJ21vdXNlOicgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZSgnbW91c2UnICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHNlbmQgdGhlIG1vdXNlIGV2ZW50IHRoYXQgZ2VuZXJhdGUgdGhlIGZpbmFsaXplIGRvd24sIHNvIGl0IGNhbiBiZSB1c2VkIGluIHRoZSBldmVudFxuICAgICAqL1xuICAgIF9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgYWN0aW9uOiB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0YXJnZXQuX3NjYWxpbmcpIHtcbiAgICAgICAgdGFyZ2V0Ll9zY2FsaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5zZXRDb29yZHMoKTtcblxuICAgICAgaWYgKHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgKHRoaXMuc3RhdGVmdWwgJiYgdGFyZ2V0Lmhhc1N0YXRlQ2hhbmdlZCgpKSkge1xuICAgICAgICBpZiAodHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGZyaWVuZGx5IHRvIHRoZSBuZXcgY29udHJvbCBhcGkuXG4gICAgICAgICAgLy8gaXMgZGVwcmVjYXRlZC5cbiAgICAgICAgICBldmVudE5hbWUgPSB0aGlzLl9hZGRFdmVudE9wdGlvbnMob3B0aW9ucywgdHJhbnNmb3JtKTtcbiAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZSgnbW9kaWZpZWQnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXV0YXRlIG9wdGlvbiBvYmplY3QgaW4gb3JkZXIgdG8gYWRkIGJ5IHByb3BlcnR5IGFuZCBnaXZlIGJhY2sgdGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSA0LjIuMFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIG11dGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gdG8gaW5zcGVjdCBhY3Rpb24gZnJvbVxuICAgICAqL1xuICAgIF9hZGRFdmVudE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMsIHRyYW5zZm9ybSkge1xuICAgICAgLy8gd2UgY2FuIHByb2JhYmx5IGFkZCBtb3JlIGRldGFpbHMgYXQgbG93IGNvc3RcbiAgICAgIC8vIHNjYWxlIGNoYW5nZSwgcm90YXRpb24gY2hhbmdlcywgdHJhbnNsYXRpb24gY2hhbmdlc1xuICAgICAgdmFyIGV2ZW50TmFtZSwgYnk7XG4gICAgICBzd2l0Y2ggKHRyYW5zZm9ybS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnc2NhbGVYJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnc2NhbGVkJztcbiAgICAgICAgICBieSA9ICd4JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2NhbGVZJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnc2NhbGVkJztcbiAgICAgICAgICBieSA9ICd5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2tld1gnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdza2V3ZWQnO1xuICAgICAgICAgIGJ5ID0gJ3gnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdza2V3WSc6XG4gICAgICAgICAgZXZlbnROYW1lID0gJ3NrZXdlZCc7XG4gICAgICAgICAgYnkgPSAneSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAnc2NhbGVkJztcbiAgICAgICAgICBieSA9ICdlcXVhbGx5JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICBldmVudE5hbWUgPSAncm90YXRlZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RyYWcnOlxuICAgICAgICAgIGV2ZW50TmFtZSA9ICdtb3ZlZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmJ5ID0gYnk7XG4gICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbk1vdXNlRG93bkluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5nZXRBY3RpdmVPYmplY3QoKSkge1xuICAgICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoZSkucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZURvd24ocG9pbnRlciwgeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZU1vdmUocG9pbnRlciwgeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5mcmVlRHJhd2luZ0N1cnNvcik7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfb25Nb3VzZVVwSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZVVwKHsgZTogZSwgcG9pbnRlcjogcG9pbnRlciB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgY2xpY2tlZCBvbiBjYW52YXMuXG4gICAgICogVGhlIG1ldGhvZCBpbml0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzIGFuZCByZW5kZXJzIGFsbCB0aGVcbiAgICAgKiBjYW52YXMgc28gdGhlIGN1cnJlbnQgaW1hZ2UgY2FuIGJlIHBsYWNlZCBvbiB0aGUgdG9wIGNhbnZhcyBhbmQgdGhlIHJlc3RcbiAgICAgKiBpbiBvbiB0aGUgY29udGFpbmVyIG9uZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9fb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duOmJlZm9yZScpO1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgIC8vIGlmIHJpZ2h0IGNsaWNrIGp1c3QgZmlyZSBldmVudHNcbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIFJJR0hUX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlUmlnaHRDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgUklHSFRfQ0xJQ0spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicsIE1JRERMRV9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWdub3JlIGlmIHNvbWUgb2JqZWN0IGlzIGJlaW5nIHRyYW5zZm9ybWVkIGF0IHRoaXMgbW9tZW50XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5fcG9pbnRlcjtcbiAgICAgIC8vIHNhdmUgcG9pbnRlciBmb3IgY2hlY2sgaW4gX19vbk1vdXNlVXAgZXZlbnRcbiAgICAgIHRoaXMuX3ByZXZpb3VzUG9pbnRlciA9IHBvaW50ZXI7XG4gICAgICB2YXIgc2hvdWxkUmVuZGVyID0gdGhpcy5fc2hvdWxkUmVuZGVyKHRhcmdldCksXG4gICAgICAgICAgc2hvdWxkR3JvdXAgPSB0aGlzLl9zaG91bGRHcm91cChlLCB0YXJnZXQpO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyU2VsZWN0aW9uKGUsIHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2hvdWxkR3JvdXApIHtcbiAgICAgICAgdGhpcy5faGFuZGxlR3JvdXBpbmcoZSwgdGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgKCF0YXJnZXQgfHxcbiAgICAgICAgKCF0YXJnZXQuc2VsZWN0YWJsZSAmJiAhdGFyZ2V0LmlzRWRpdGluZyAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkpKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSB7XG4gICAgICAgICAgZXg6IHBvaW50ZXIueCxcbiAgICAgICAgICBleTogcG9pbnRlci55LFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICBpZiAodGFyZ2V0LnNlbGVjdGFibGUpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdCh0YXJnZXQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3JuZXIgPSB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIoXG4gICAgICAgICAgdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpLFxuICAgICAgICAgIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudChlKVxuICAgICAgICApO1xuICAgICAgICB0YXJnZXQuX19jb3JuZXIgPSBjb3JuZXI7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiAoY29ybmVyIHx8ICFzaG91bGRHcm91cCkpIHtcbiAgICAgICAgICB0aGlzLl9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0oZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpO1xuICAgICAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksXG4gICAgICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIgPSBjb250cm9sICYmIGNvbnRyb2wuZ2V0TW91c2VEb3duSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpO1xuICAgICAgICAgIGlmIChtb3VzZURvd25IYW5kbGVyKSB7XG4gICAgICAgICAgICBtb3VzZURvd25IYW5kbGVyKGUsIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sIHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJyk7XG4gICAgICAvLyB3ZSBtdXN0IHJlbmRlckFsbCBzbyB0aGF0IHdlIHVwZGF0ZSB0aGUgdmlzdWFsc1xuICAgICAgKHNob3VsZFJlbmRlciB8fCBzaG91bGRHcm91cCkgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0IGNhY2hlIGZvcm0gY29tbW9uIGluZm9ybWF0aW9uIG5lZWRlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9wb2ludGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2Fic29sdXRlUG9pbnRlciA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhY2hlIGNvbW1vbiBpbmZvcm1hdGlvbiBuZWVkZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIGV2ZW50XG4gICAgICovXG4gICAgX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhOiBmdW5jdGlvbihlKSB7XG4gICAgICAvLyByZXNldCBpbiBvcmRlciB0byBhdm9pZCBzdGFsZSBjYWNoaW5nXG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdGhpcy5fcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKTtcbiAgICAgIHRoaXMuX2Fic29sdXRlUG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQodGhpcy5fcG9pbnRlcik7XG4gICAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID8gdGhpcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQgOiB0aGlzLmZpbmRUYXJnZXQoZSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYmVmb3JlVHJhbnNmb3JtOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG4gICAgICB0aGlzLnN0YXRlZnVsICYmIHQudGFyZ2V0LnNhdmVTdGF0ZSgpO1xuICAgICAgdGhpcy5maXJlKCdiZWZvcmU6dHJhbnNmb3JtJywge1xuICAgICAgICBlOiBlLFxuICAgICAgICB0cmFuc2Zvcm06IHQsXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGhvdmVyaW5nIHRoZSBjYW52YXMuXG4gICAgICogVGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVyIHdpbGwgZGVmaW5lIHdoZXRoZXIgdGhlIHVzZXIgaXMgcm90YXRpbmcvc2NhbGluZy90cmFuc2xhdGluZ1xuICAgICAqIGFuIGltYWdlIG9yIG5laXRoZXIgb2YgdGhlbSAob25seSBob3ZlcmluZykuIEEgZ3JvdXAgc2VsZWN0aW9uIGlzIGFsc28gcG9zc2libGUgYW5kIHdvdWxkIGNhbmNlbFxuICAgICAqIGFsbCBhbnkgb3RoZXIgdHlwZSBvZiBhY3Rpb24uXG4gICAgICogSW4gY2FzZSBvZiBhbiBpbWFnZSB0cmFuc2Zvcm1hdGlvbiBvbmx5IHRoZSB0b3AgY2FudmFzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmU6YmVmb3JlJyk7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHZhciB0YXJnZXQsIHBvaW50ZXI7XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3I7XG5cbiAgICAgIC8vIFdlIGluaXRpYWxseSBjbGlja2VkIGluIGFuIGVtcHR5IGFyZWEsIHNvIHdlIGRyYXcgYSBib3ggZm9yIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAgaWYgKGdyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMuX3BvaW50ZXI7XG5cbiAgICAgICAgZ3JvdXBTZWxlY3Rvci5sZWZ0ID0gcG9pbnRlci54IC0gZ3JvdXBTZWxlY3Rvci5leDtcbiAgICAgICAgZ3JvdXBTZWxlY3Rvci50b3AgPSBwb2ludGVyLnkgLSBncm91cFNlbGVjdG9yLmV5O1xuXG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghdGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSkgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgbW91c2VvdXQsIG1vdXNlb3ZlciBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0IG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZU92ZXJPdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIF9ob3ZlcmVkVGFyZ2V0ID0gdGhpcy5faG92ZXJlZFRhcmdldCxcbiAgICAgICAgICBfaG92ZXJlZFRhcmdldHMgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0cywgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heChfaG92ZXJlZFRhcmdldHMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0LFxuICAgICAgICBldnRPdXQ6ICdtb3VzZW91dCcsXG4gICAgICAgIGNhbnZhc0V2dE91dDogJ21vdXNlOm91dCcsXG4gICAgICAgIGV2dEluOiAnbW91c2VvdmVyJyxcbiAgICAgICAgY2FudmFzRXZ0SW46ICdtb3VzZTpvdmVyJyxcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldHNbaV0sIGUsIHtcbiAgICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0c1tpXSxcbiAgICAgICAgICBldnRPdXQ6ICdtb3VzZW91dCcsXG4gICAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBkcmFnRW50ZXIsIGRyYWdMZWF2ZSBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0cyBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIG9uRHJhZyBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG9uZHJhZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVFbnRlckxlYXZlRXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBfZHJhZ2dlZG92ZXJUYXJnZXQgPSB0aGlzLl9kcmFnZ2Vkb3ZlclRhcmdldCxcbiAgICAgICAgICBfaG92ZXJlZFRhcmdldHMgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0cywgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heChfaG92ZXJlZFRhcmdldHMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICBvbGRUYXJnZXQ6IF9kcmFnZ2Vkb3ZlclRhcmdldCxcbiAgICAgICAgZXZ0T3V0OiAnZHJhZ2xlYXZlJyxcbiAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldHNbaV0sIGUsIHtcbiAgICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0c1tpXSxcbiAgICAgICAgICBldnRPdXQ6ICdkcmFnbGVhdmUnLFxuICAgICAgICAgIGV2dEluOiAnZHJhZ2VudGVyJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmFnZ2Vkb3ZlclRhcmdldCA9IHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBzeW50aGV0aWMgaW4vb3V0IGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgc3VwcG9ydGVkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gdG8gd29ya1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGFyZ2V0TmFtZSBwcm9wZXJ0eSBvbiB0aGUgY2FudmFzIHdoZXJlIHRoZSBvbGQgdGFyZ2V0IGlzIHN0b3JlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dE91dF0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBhdCBjYW52YXMgbGV2ZWwgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0T3V0IG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dEluXSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3IgaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2dEluIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIGluXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljSW5PdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSwgY29uZmlnKSB7XG4gICAgICB2YXIgaW5PcHQsIG91dE9wdCwgb2xkVGFyZ2V0ID0gY29uZmlnLm9sZFRhcmdldCwgb3V0RmlyZXMsIGluRmlyZXMsXG4gICAgICAgICAgdGFyZ2V0Q2hhbmdlZCA9IG9sZFRhcmdldCAhPT0gdGFyZ2V0LCBjYW52YXNFdnRJbiA9IGNvbmZpZy5jYW52YXNFdnRJbiwgY2FudmFzRXZ0T3V0ID0gY29uZmlnLmNhbnZhc0V2dE91dDtcbiAgICAgIGlmICh0YXJnZXRDaGFuZ2VkKSB7XG4gICAgICAgIGluT3B0ID0geyBlOiBlLCB0YXJnZXQ6IHRhcmdldCwgcHJldmlvdXNUYXJnZXQ6IG9sZFRhcmdldCB9O1xuICAgICAgICBvdXRPcHQgPSB7IGU6IGUsIHRhcmdldDogb2xkVGFyZ2V0LCBuZXh0VGFyZ2V0OiB0YXJnZXQgfTtcbiAgICAgIH1cbiAgICAgIGluRmlyZXMgPSB0YXJnZXQgJiYgdGFyZ2V0Q2hhbmdlZDtcbiAgICAgIG91dEZpcmVzID0gb2xkVGFyZ2V0ICYmIHRhcmdldENoYW5nZWQ7XG4gICAgICBpZiAob3V0RmlyZXMpIHtcbiAgICAgICAgY2FudmFzRXZ0T3V0ICYmIHRoaXMuZmlyZShjYW52YXNFdnRPdXQsIG91dE9wdCk7XG4gICAgICAgIG9sZFRhcmdldC5maXJlKGNvbmZpZy5ldnRPdXQsIG91dE9wdCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5GaXJlcykge1xuICAgICAgICBjYW52YXNFdnRJbiAmJiB0aGlzLmZpcmUoY2FudmFzRXZ0SW4sIGluT3B0KTtcbiAgICAgICAgdGFyZ2V0LmZpcmUoY29uZmlnLmV2dEluLCBpbk9wdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgYWN0aW9ucyB3aGVuIGFuIEV2ZW50IE1vdXNlIFdoZWVsXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVdoZWVsOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd3aGVlbCcpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF90cmFuc2Zvcm1PYmplY3Q6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHRyYW5zZm9ybS5yZXNldCA9IGZhbHNlO1xuICAgICAgdHJhbnNmb3JtLnRhcmdldC5pc01vdmluZyA9IHRydWU7XG4gICAgICB0cmFuc2Zvcm0uc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuICAgICAgdHJhbnNmb3JtLmFsdEtleSA9IGVbdGhpcy5jZW50ZXJlZEtleV07XG5cbiAgICAgIHRoaXMuX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24oZSwgdHJhbnNmb3JtLCBwb2ludGVyKTtcbiAgICAgIHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb246IGZ1bmN0aW9uKGUsIHRyYW5zZm9ybSwgcG9pbnRlcikge1xuICAgICAgdmFyIHggPSBwb2ludGVyLngsXG4gICAgICAgICAgeSA9IHBvaW50ZXIueSxcbiAgICAgICAgICBhY3Rpb24gPSB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGZhbHNlLFxuICAgICAgICAgIGFjdGlvbkhhbmRsZXIgPSB0cmFuc2Zvcm0uYWN0aW9uSGFuZGxlcjtcbiAgICAgICAgICAvLyB0aGlzIG9iamVjdCBjb3VsZCBiZSBjcmVhdGVkIGZyb20gdGhlIGZ1bmN0aW9uIGluIHRoZSBjb250cm9sIGhhbmRsZXJzXG5cblxuICAgICAgaWYgKGFjdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihlLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2RyYWcnICYmIGFjdGlvblBlcmZvcm1lZCkge1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0cmFuc2Zvcm0udGFyZ2V0Lm1vdmVDdXJzb3IgfHwgdGhpcy5tb3ZlQ3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgPSB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkIHx8IGFjdGlvblBlcmZvcm1lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZTogZmFicmljLmNvbnRyb2xzVXRpbHMuZmlyZUV2ZW50LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3Vyc29yIGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgY2FudmFzIGlzIGJlaW5nIGhvdmVyZWQuXG4gICAgICogTm90ZTogdmVyeSBidWdneSBpbiBPcGVyYVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgdGhhdCB0aGUgbW91c2UgaXMgaG92ZXJpbmcsIGlmIHNvLlxuICAgICAqL1xuICAgIF9zZXRDdXJzb3JGcm9tRXZlbnQ6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBob3ZlckN1cnNvciA9IHRhcmdldC5ob3ZlckN1cnNvciB8fCB0aGlzLmhvdmVyQ3Vyc29yLFxuICAgICAgICAgIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0aGlzLl9hY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgP1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0IDogbnVsbCxcbiAgICAgICAgICAvLyBvbmx5IHNob3cgcHJvcGVyIGNvcm5lciB3aGVuIGdyb3VwIHNlbGVjdGlvbiBpcyBub3QgYWN0aXZlXG4gICAgICAgICAgY29ybmVyID0gKCFhY3RpdmVTZWxlY3Rpb24gfHwgIWFjdGl2ZVNlbGVjdGlvbi5jb250YWlucyh0YXJnZXQpKVxuICAgICAgICAgIC8vIGhlcmUgd2UgY2FsbCBmaW5kVGFyZ2V0Q29ybmVyIGFsd2F5cyB3aXRoIHVuZGVmaW5lZCBmb3IgdGhlIHRvdWNoIHBhcmFtZXRlci5cbiAgICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCBpZiB5b3UgYXJlIHVzaW5nIGEgY3Vyc29yIHlvdSBkbyBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoXG4gICAgICAgICAgLy8gdGhlIGJpZ2dlciB0b3VjaCBhcmVhLlxuICAgICAgICAgICAgICAgICAgICAmJiB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIodGhpcy5nZXRQb2ludGVyKGUsIHRydWUpKTtcblxuICAgICAgaWYgKCFjb3JuZXIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5zdWJUYXJnZXRDaGVjayl7XG4gICAgICAgICAgLy8gaG92ZXJDdXJzb3Igc2hvdWxkIGNvbWUgZnJvbSB0b3AtbW9zdCBzdWJUYXJnZXQsXG4gICAgICAgICAgLy8gc28gd2Ugd2FsayB0aGUgYXJyYXkgYmFja3dhcmRzXG4gICAgICAgICAgdGhpcy50YXJnZXRzLmNvbmNhdCgpLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24oX3RhcmdldCl7XG4gICAgICAgICAgICBob3ZlckN1cnNvciA9IF90YXJnZXQuaG92ZXJDdXJzb3IgfHwgaG92ZXJDdXJzb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoaG92ZXJDdXJzb3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZ2V0Q29ybmVyQ3Vyc29yKGNvcm5lciwgdGFyZ2V0LCBlKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0Q29ybmVyQ3Vyc29yOiBmdW5jdGlvbihjb3JuZXIsIHRhcmdldCwgZSkge1xuICAgICAgdmFyIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXTtcbiAgICAgIHJldHVybiBjb250cm9sLmN1cnNvclN0eWxlSGFuZGxlcihlLCBjb250cm9sLCB0YXJnZXQpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgbWluID0gTWF0aC5taW4sXG4gICAgICBtYXggPSBNYXRoLm1heDtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgX3Nob3VsZEdyb3VwOiBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICByZXR1cm4gYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUgJiYgdGhpcy5zZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChhY3RpdmVPYmplY3QgIT09IHRhcmdldCB8fCBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpICYmICF0YXJnZXQub25TZWxlY3QoeyBlOiBlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfaGFuZGxlR3JvdXBpbmc6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAvLyBhdm9pZCBtdWx0aSBzZWxlY3Qgd2hlbiBzaGlmdCBjbGljayBvbiBhIGNvcm5lclxuICAgICAgaWYgKGFjdGl2ZU9iamVjdC5fX2Nvcm5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0ID09PSBhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgLy8gaWYgaXQncyBhIGdyb3VwLCBmaW5kIHRhcmdldCBhZ2FpbiwgdXNpbmcgYWN0aXZlR3JvdXAgb2JqZWN0c1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSwgdHJ1ZSk7XG4gICAgICAgIC8vIGlmIGV2ZW4gb2JqZWN0IGlzIG5vdCBmb3VuZCBvciB3ZSBhcmUgb24gYWN0aXZlT2JqZWN0Q29ybmVyLCBiYWlsIG91dFxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNlbGVjdGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbih0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbih0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBjdXJyZW50QWN0aXZlT2JqZWN0cyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cy5zbGljZSgwKTtcbiAgICAgIGlmIChhY3RpdmVTZWxlY3Rpb24uY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24ucmVtb3ZlV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICAgICAgaWYgKGFjdGl2ZVNlbGVjdGlvbi5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAvLyBhY3RpdmF0ZSBsYXN0IHJlbWFpbmluZyBvYmplY3RcbiAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3QoYWN0aXZlU2VsZWN0aW9uLml0ZW0oMCksIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLmFkZFdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVPYmplY3RzLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLCBncm91cCA9IHRoaXMuX2NyZWF0ZUdyb3VwKHRhcmdldCk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gZ3JvdXA7XG4gICAgICAvLyBJU1NVRSA0MTE1OiBzaG91bGQgd2UgY29uc2lkZXIgc3ViVGFyZ2V0cyBoZXJlP1xuICAgICAgLy8gdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIC8vIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KGdyb3VwLCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfY3JlYXRlR3JvdXA6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICAgIGlzQWN0aXZlTG93ZXIgPSBvYmplY3RzLmluZGV4T2YodGhpcy5fYWN0aXZlT2JqZWN0KSA8IG9iamVjdHMuaW5kZXhPZih0YXJnZXQpLFxuICAgICAgICAgIGdyb3VwT2JqZWN0cyA9IGlzQWN0aXZlTG93ZXJcbiAgICAgICAgICAgID8gW3RoaXMuX2FjdGl2ZU9iamVjdCwgdGFyZ2V0XVxuICAgICAgICAgICAgOiBbdGFyZ2V0LCB0aGlzLl9hY3RpdmVPYmplY3RdO1xuICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZyAmJiB0aGlzLl9hY3RpdmVPYmplY3QuZXhpdEVkaXRpbmcoKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihncm91cE9iamVjdHMsIHtcbiAgICAgICAgY2FudmFzOiB0aGlzXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICovXG4gICAgX2dyb3VwU2VsZWN0ZWRPYmplY3RzOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jb2xsZWN0T2JqZWN0cyhlKSxcbiAgICAgICAgICBhR3JvdXA7XG5cbiAgICAgIC8vIGRvIG5vdCBjcmVhdGUgZ3JvdXAgZm9yIDEgZWxlbWVudCBvbmx5XG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGdyb3VwWzBdLCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYUdyb3VwID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oZ3JvdXAucmV2ZXJzZSgpLCB7XG4gICAgICAgICAgY2FudmFzOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChhR3JvdXAsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb2xsZWN0T2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGdyb3VwID0gW10sXG4gICAgICAgICAgY3VycmVudE9iamVjdCxcbiAgICAgICAgICB4MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXgsXG4gICAgICAgICAgeTEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV5LFxuICAgICAgICAgIHgyID0geDEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgeTIgPSB5MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IudG9wLFxuICAgICAgICAgIHNlbGVjdGlvblgxWTEgPSBuZXcgZmFicmljLlBvaW50KG1pbih4MSwgeDIpLCBtaW4oeTEsIHkyKSksXG4gICAgICAgICAgc2VsZWN0aW9uWDJZMiA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KHgxLCB4MiksIG1heCh5MSwgeTIpKSxcbiAgICAgICAgICBhbGxvd0ludGVyc2VjdCA9ICF0aGlzLnNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkLFxuICAgICAgICAgIGlzQ2xpY2sgPSB4MSA9PT0geDIgJiYgeTEgPT09IHkyO1xuICAgICAgLy8gd2UgaXRlcmF0ZSByZXZlcnNlIG9yZGVyIHRvIGNvbGxlY3QgdG9wIGZpcnN0IGluIGNhc2Ugb2YgY2xpY2suXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuXG4gICAgICAgIGlmICghY3VycmVudE9iamVjdCB8fCAhY3VycmVudE9iamVjdC5zZWxlY3RhYmxlIHx8ICFjdXJyZW50T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5pbnRlcnNlY3RzV2l0aFJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMikpIHx8XG4gICAgICAgICAgICBjdXJyZW50T2JqZWN0LmlzQ29udGFpbmVkV2l0aGluUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMVkxKSkgfHxcbiAgICAgICAgICAgIChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDJZMikpXG4gICAgICAgICkge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VycmVudE9iamVjdCk7XG4gICAgICAgICAgLy8gb25seSBhZGQgb25lIG9iamVjdCBpZiBpdCdzIGEgY2xpY2tcbiAgICAgICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXAuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiAhb2JqZWN0Lm9uU2VsZWN0KHsgZTogZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWF5YmVHcm91cE9iamVjdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiB0aGlzLl9ncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0ZWRPYmplY3RzKGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5kZWZhdWx0Q3Vyc29yKTtcbiAgICAgIC8vIGNsZWFyIHNlbGVjdGlvbiBhbmQgY3VycmVudCB0cmFuc2Zvcm1hdGlvblxuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICB9KTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgY2FudmFzIGVsZW1lbnQgdG8gYSBkYXRhdXJsIGltYWdlLiBOb3RlIHRoYXQgd2hlbiBtdWx0aXBsaWVyIGlzIHVzZWQsIGNyb3BwaW5nIGlzIHNjYWxlZCBhcHByb3ByaWF0ZWx5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9cG5nXSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQgaW1hZ2UuIEVpdGhlciBcImpwZWdcIiBvciBcInBuZ1wiXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9MV0gUXVhbGl0eSBsZXZlbCAoMC4uMSkuIE9ubHkgdXNlZCBmb3IganBlZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5LCB0byBoYXZlIGNvbnNpc3RlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBkYXRhOiBVUkwgY29udGFpbmluZyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgb3B0aW9ucy5mb3JtYXRcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL05mWlZiL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGpwZWcgZGF0YVVSTCB3aXRoIGxvd2VyIHF1YWxpdHk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAqICAgcXVhbGl0eTogMC44XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgY3JvcHBlZCBwbmcgZGF0YVVSTCAoY2xpcHBpbmcgb2YgY2FudmFzKTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwLFxuICAgICAqICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgZG91YmxlIHNjYWxlZCBwbmcgZGF0YVVSTDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIG11bHRpcGxpZXI6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8ICdwbmcnLFxuICAgICAgICAgIHF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgfHwgMSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gKG9wdGlvbnMubXVsdGlwbGllciB8fCAxKSAqIChvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmcgPyB0aGlzLmdldFJldGluYVNjYWxpbmcoKSA6IDEpLFxuICAgICAgICAgIGNhbnZhc0VsID0gdGhpcy50b0NhbnZhc0VsZW1lbnQobXVsdGlwbGllciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudG9EYXRhVVJMKGNhbnZhc0VsLCBmb3JtYXQsIHF1YWxpdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSFRNTENhbnZhcyBlbGVtZW50IHBhaW50ZWQgd2l0aCB0aGUgY3VycmVudCBjYW52YXMgY29udGVudC5cbiAgICAgKiBObyBuZWVkIHRvIHJlc2l6ZSB0aGUgYWN0dWFsIG9uZSBvciByZXBhaW50IGl0LlxuICAgICAqIFdpbGwgdHJhbnNmZXIgb2JqZWN0IG93bmVyc2hpcCB0byBhIG5ldyBjYW52YXMsIHBhaW50IGl0LCBhbmQgc2V0IGV2ZXJ5dGhpbmcgYmFjay5cbiAgICAgKiBUaGlzIGlzIGFuIGludGVybWVkaWFyeSBzdGVwIHVzZWQgdG8gZ2V0IHRvIGEgZGF0YVVybCBidXQgYWxzbyBpdCBpcyB1c2VmdWwgdG9cbiAgICAgKiBjcmVhdGUgcXVpY2sgaW1hZ2UgY29waWVzIG9mIGEgY2FudmFzIHdpdGhvdXQgcGFzc2luZyBmb3IgdGhlIGRhdGFVcmwgc3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttdWx0aXBsaWVyXSBhIHpvb20gZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3JvcHBpbmddIENyb3BwaW5nIGluZm9ybWF0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC5cbiAgICAgKi9cbiAgICB0b0NhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKG11bHRpcGxpZXIsIGNyb3BwaW5nKSB7XG4gICAgICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciB8fCAxO1xuICAgICAgY3JvcHBpbmcgPSBjcm9wcGluZyB8fCB7IH07XG4gICAgICB2YXIgc2NhbGVkV2lkdGggPSAoY3JvcHBpbmcud2lkdGggfHwgdGhpcy53aWR0aCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHNjYWxlZEhlaWdodCA9IChjcm9wcGluZy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQpICogbXVsdGlwbGllcixcbiAgICAgICAgICB6b29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBuZXdab29tID0gem9vbSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdnAgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgIHRyYW5zbGF0ZVggPSAodnBbNF0gLSAoY3JvcHBpbmcubGVmdCB8fCAwKSkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRyYW5zbGF0ZVkgPSAodnBbNV0gLSAoY3JvcHBpbmcudG9wIHx8IDApKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgb3JpZ2luYWxJbnRlcmFjdGl2ZSA9IHRoaXMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgbmV3VnAgPSBbbmV3Wm9vbSwgMCwgMCwgbmV3Wm9vbSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV0sXG4gICAgICAgICAgb3JpZ2luYWxSZXRpbmEgPSB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcsXG4gICAgICAgICAgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgb3JpZ2luYWxDb250ZXh0VG9wID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgY2FudmFzRWwud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IG51bGw7XG4gICAgICB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSBuZXdWcDtcbiAgICAgIHRoaXMud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLCB0aGlzLl9vYmplY3RzKTtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cDtcbiAgICAgIHRoaXMud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IG9yaWdpbmFsSW50ZXJhY3RpdmU7XG4gICAgICB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcgPSBvcmlnaW5hbFJldGluYTtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IG9yaWdpbmFsQ29udGV4dFRvcDtcbiAgICAgIHJldHVybiBjYW52YXNFbDtcbiAgICB9LFxuICB9KTtcblxufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIFBvcHVsYXRlcyBjYW52YXMgd2l0aCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCBKU09OLlxuICAgKiBKU09OIGZvcm1hdCBtdXN0IGNvbmZvcm0gdG8gdGhlIG9uZSBvZiB7QGxpbmsgZmFicmljLkNhbnZhcyN0b0pTT059XG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiBKU09OIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2ssIGludm9rZWQgd2hlbiBqc29uIGlzIHBhcnNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29ycmVzcG9uZGluZyBvYmplY3RzIChlLmc6IHtAbGluayBmYWJyaWMuSW1hZ2V9KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgaW5pdGlhbGl6ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIEpTT04gZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICogQGNoYWluYWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNkZXNlcmlhbGl6YXRpb259XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvZm1nWHQvfGpzRmlkZGxlIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmxvYWRGcm9tSlNPTjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmxvYWRGcm9tSlNPTiB3aXRoIHJldml2ZXI8L2NhcHRpb24+XG4gICAqIGNhbnZhcy5sb2FkRnJvbUpTT04oanNvbiwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIGZ1bmN0aW9uKG8sIG9iamVjdCkge1xuICAgKiAgIC8vIGBvYCA9IGpzb24gb2JqZWN0XG4gICAqICAgLy8gYG9iamVjdGAgPSBmYWJyaWMuT2JqZWN0IGluc3RhbmNlXG4gICAqICAgLy8gLi4uIGRvIHNvbWUgc3R1ZmYgLi4uXG4gICAqIH0pO1xuICAgKi9cbiAgbG9hZEZyb21KU09OOiBmdW5jdGlvbiAoanNvbiwgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXJpYWxpemUgaWYgaXQgd2Fzbid0IGFscmVhZHlcbiAgICB2YXIgc2VyaWFsaXplZCA9ICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpXG4gICAgICA/IEpTT04ucGFyc2UoanNvbilcbiAgICAgIDogZmFicmljLnV0aWwub2JqZWN0LmNsb25lKGpzb24pO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgY2xpcFBhdGggPSBzZXJpYWxpemVkLmNsaXBQYXRoLFxuICAgICAgICByZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMucmVuZGVyT25BZGRSZW1vdmU7XG5cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICBkZWxldGUgc2VyaWFsaXplZC5jbGlwUGF0aDtcblxuICAgIHRoaXMuX2VubGl2ZW5PYmplY3RzKHNlcmlhbGl6ZWQub2JqZWN0cywgZnVuY3Rpb24gKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIF90aGlzLmNsZWFyKCk7XG4gICAgICBfdGhpcy5fc2V0QmdPdmVybGF5KHNlcmlhbGl6ZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgX3RoaXMuX2VubGl2ZW5PYmplY3RzKFtjbGlwUGF0aF0sIGZ1bmN0aW9uIChlbmxpdmVuZWRDYW52YXNDbGlwKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGlwUGF0aCA9IGVubGl2ZW5lZENhbnZhc0NsaXBbMF07XG4gICAgICAgICAgICBfdGhpcy5fX3NldHVwQ2FudmFzLmNhbGwoX3RoaXMsIHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX19zZXR1cENhbnZhcy5jYWxsKF90aGlzLCBzZXJpYWxpemVkLCBlbmxpdmVuZWRPYmplY3RzLCByZW5kZXJPbkFkZFJlbW92ZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCByZXZpdmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGl6ZWQgT2JqZWN0IHdpdGggYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSByZXN0b3JlZCBjYW52YXMgb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWNoZWQgcmVuZGVyT25BZGRSZW1vdmUgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCBhZnRlciBhbGwgYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbWFnZXMvcGF0dGVybnMgbG9hZGVkXG4gICAqL1xuICBfX3NldHVwQ2FudmFzOiBmdW5jdGlvbihzZXJpYWxpemVkLCBlbmxpdmVuZWRPYmplY3RzLCByZW5kZXJPbkFkZFJlbW92ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGVubGl2ZW5lZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmosIGluZGV4KSB7XG4gICAgICAvLyB3ZSBzcGxpY2UgdGhlIGFycmF5IGp1c3QgaW4gY2FzZSBzb21lIGN1c3RvbSBjbGFzc2VzIHJlc3RvcmVkIGZyb20gSlNPTlxuICAgICAgLy8gd2lsbCBhZGQgbW9yZSBvYmplY3QgdG8gY2FudmFzIGF0IGNhbnZhcyBpbml0LlxuICAgICAgX3RoaXMuaW5zZXJ0QXQob2JqLCBpbmRleCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IHJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIC8vIHJlbW92ZSBwYXJ0cyBpIGNhbm5vdCBzZXQgYXMgb3B0aW9uc1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLm9iamVjdHM7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLm92ZXJsYXlJbWFnZTtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLm92ZXJsYXk7XG4gICAgLy8gdGhpcy5faW5pdE9wdGlvbnMgZG9lcyB0b28gbWFueSB0aGluZ3MgdG8ganVzdFxuICAgIC8vIGNhbGwgaXQuIE5vcm1hbGx5IGxvYWRpbmcgYW4gT2JqZWN0IGZyb20gSlNPTlxuICAgIC8vIGNyZWF0ZSB0aGUgT2JqZWN0IGluc3RhbmNlLiBIZXJlIHRoZSBDYW52YXMgaXNcbiAgICAvLyBhbHJlYWR5IGFuIGluc3RhbmNlIGFuZCB3ZSBhcmUganVzdCBsb2FkaW5nIHRoaW5ncyBvdmVyIGl0XG4gICAgdGhpcy5fc2V0T3B0aW9ucyhzZXJpYWxpemVkKTtcbiAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpemVkIE9iamVjdCB3aXRoIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCBhZnRlciBhbGwgYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbWFnZXMvcGF0dGVybnMgbG9hZGVkXG4gICAqL1xuICBfc2V0QmdPdmVybGF5OiBmdW5jdGlvbihzZXJpYWxpemVkLCBjYWxsYmFjaykge1xuICAgIHZhciBsb2FkZWQgPSB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhbHNlLFxuICAgICAgb3ZlcmxheUNvbG9yOiBmYWxzZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZTogZmFsc2UsXG4gICAgICBvdmVybGF5SW1hZ2U6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheUltYWdlICYmICFzZXJpYWxpemVkLmJhY2tncm91bmQgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2JJZkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsb2FkZWQuYmFja2dyb3VuZEltYWdlICYmIGxvYWRlZC5vdmVybGF5SW1hZ2UgJiYgbG9hZGVkLmJhY2tncm91bmRDb2xvciAmJiBsb2FkZWQub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRJbWFnZScsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlJbWFnZScsIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRDb2xvcicsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZCwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5Q29sb3InLCBzZXJpYWxpemVkLm92ZXJsYXksIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKGJhY2tncm91bmRJbWFnZSwgb3ZlcmxheUltYWdlLCBiYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvcilcbiAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZyl9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9hZGVkIFNldCBsb2FkZWQgcHJvcGVydHkgdG8gdHJ1ZSBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBwcm9wZXJ0eSBpcyBzZXRcbiAgICovXG4gIF9fc2V0QmdPdmVybGF5OiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUsIGxvYWRlZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcGVydHkgPT09ICdvdmVybGF5SW1hZ2UnKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbdmFsdWVdLCBmdW5jdGlvbihlbmxpdmVkT2JqZWN0KXtcbiAgICAgICAgX3RoaXNbcHJvcGVydHldID0gZW5saXZlZE9iamVjdFswXTtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzWydzZXQnICsgZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUocHJvcGVydHksIHRydWUpXSh2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXVxuICAgKi9cbiAgX2VubGl2ZW5PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIW9iamVjdHMgfHwgb2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICB9LCBudWxsLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTDogZnVuY3Rpb24gKGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMKGZvcm1hdCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgbXVsdGlwbGllcikpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzXSBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lZCBjYW52YXMgYW5kIGNoaWxkcmVuXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTihwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5jbG9uZVdpdGhvdXREYXRhKGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICBjbG9uZS5sb2FkRnJvbUpTT04oZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlIHdpdGhvdXQgY2xvbmluZyBleGlzdGluZyBkYXRhLlxuICAgKiBUaGlzIGVzc2VudGlhbGx5IGNvcGllcyBjYW52YXMgZGltZW5zaW9ucywgY2xpcHBpbmcgcHJvcGVydGllcywgZXRjLlxuICAgKiBidXQgbGVhdmVzIGRhdGEgZW1wdHkgKHNvIHRoYXQgeW91IGNhbiBwb3B1bGF0ZSBpdCB3aXRoIHlvdXIgb3duKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgY2xvbmVXaXRob3V0RGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICBlbC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgZWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB2YXIgY2xvbmUgPSBuZXcgZmFicmljLkNhbnZhcyhlbCk7XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICBjbG9uZS5zZXRCYWNrZ3JvdW5kSW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2Uuc3JjLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xvbmUucmVuZGVyQWxsKCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlT3BhY2l0eSA9IHRoaXMuYmFja2dyb3VuZEltYWdlT3BhY2l0eTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZVN0cmV0Y2ggPSB0aGlzLmJhY2tncm91bmRJbWFnZVN0cmV0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIGNhcGl0YWxpemUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZSxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgc3VwcG9ydHNMaW5lRGFzaCA9IGZhYnJpYy5TdGF0aWNDYW52YXMuc3VwcG9ydHMoJ3NldExpbmVEYXNoJyksXG4gICAgICBvYmplY3RDYWNoaW5nID0gIWZhYnJpYy5pc0xpa2VseU5vZGUsXG4gICAgICBBTElBU0lOR19MSU1JVCA9IDI7XG5cbiAgaWYgKGZhYnJpYy5PYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUm9vdCBvYmplY3QgY2xhc3MgZnJvbSB3aGljaCBhbGwgMmQgc2hhcGUgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAgICogQGNsYXNzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjb2JqZWN0c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgYWRkZWRcbiAgICogQGZpcmVzIHJlbW92ZWRcbiAgICpcbiAgICogQGZpcmVzIHNlbGVjdGVkXG4gICAqIEBmaXJlcyBkZXNlbGVjdGVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIG1vdmVkXG4gICAqIEBmaXJlcyBzY2FsZWRcbiAgICogQGZpcmVzIHJvdGF0ZWRcbiAgICogQGZpcmVzIHNrZXdlZFxuICAgKlxuICAgKiBAZmlyZXMgcm90YXRpbmdcbiAgICogQGZpcmVzIHNjYWxpbmdcbiAgICogQGZpcmVzIG1vdmluZ1xuICAgKiBAZmlyZXMgc2tld2luZ1xuICAgKlxuICAgKiBAZmlyZXMgbW91c2Vkb3duXG4gICAqIEBmaXJlcyBtb3VzZXVwXG4gICAqIEBmaXJlcyBtb3VzZW92ZXJcbiAgICogQGZpcmVzIG1vdXNlb3V0XG4gICAqIEBmaXJlcyBtb3VzZXdoZWVsXG4gICAqIEBmaXJlcyBtb3VzZWRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICovXG4gIGZhYnJpYy5PYmplY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvMjQ0LyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgICd0b3AnLFxuXG4gICAgLyoqXG4gICAgICogVG9wIHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgdG9wLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWT17dG9wL2NlbnRlci9ib3R0b219XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3A6ICAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgbGVmdC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblg9e2xlZnQvY2VudGVyL3JpZ2h0fVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGVmdDogICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yIChob3Jpem9udGFsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAodmVydGljYWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIGhvcml6b250YWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIHZlcnRpY2FsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHJvdGF0aW9uIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geCBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geSBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU2l6ZTogICAgICAgICAgICAgICAxMyxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyB3aGVuIHRvdWNoIGludGVyYWN0aW9uIGlzIGRldGVjdGVkXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3VjaENvcm5lclNpemU6ICAgICAgICAgICAgICAgMjQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgYXJlIHJlbmRlcmVkIGFzIHRyYW5zcGFyZW50IGluc2lkZSAoaS5lLiBzdHJva2UgaW5zdGVhZCBvZiBmaWxsKVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRyYW5zcGFyZW50Q29ybmVyczogICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyB0aGlzIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vdmVDdXJzb3I6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFBhZGRpbmcgYmV0d2VlbiBvYmplY3QgYW5kIGl0cyBjb250cm9sbGluZyBib3JkZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWRkaW5nOiAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBib3JkZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlckNvbG9yOiAgICAgICAgICAgICAgJ3JnYigxNzgsMjA0LDI1NSknLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgYm9yZGVycyAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGJvcmRlckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyQ29sb3I6ICAgICAgICAgICAgICAncmdiKDE3OCwyMDQsMjU1KScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBjb3JuZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSBhbmQgdHJhbnNwYXJlbnRDb3JuZXJzIGZhbHNlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU3Ryb2tlQ29sb3I6ICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHlsZSBvZiBjb250cm9sLCAncmVjdCcgb3IgJ2NpcmNsZSdcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBjb3JuZXJTdHlsZTogICAgICAgICAgJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgY29udHJvbCAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNvcm5lckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhpcyBvYmplY3Qgd2lsbCB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb25cbiAgICAgKiB3aGVuIGJlaW5nIHNjYWxlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhpcyBvYmplY3Qgd2lsbCB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb25cbiAgICAgKiB3aGVuIGJlaW5nIHJvdGF0ZWQgdmlhIHRoZSBjb250cm9scy5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIG9iamVjdCdzIGZpbGxcbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGw6ICAgICAgICAgICAgICAgICAgICAgJ3JnYigwLDAsMCknLFxuXG4gICAgLyoqXG4gICAgICogRmlsbCBydWxlIHVzZWQgdG8gZmlsbCBhbiBvYmplY3RcbiAgICAgKiBhY2NlcHRlZCB2YWx1ZXMgYXJlIG5vbnplcm8sIGV2ZW5vZGRcbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyB1c2VkIGZvciBzZXR0aW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB1bnRpbCB2MS40LjEyICh1c2UgYGZhYnJpYy5PYmplY3QjZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uYCBpbnN0ZWFkKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICAnbm9uemVybycsXG5cbiAgICAvKipcbiAgICAgKiBDb21wb3NpdGUgcnVsZSB1c2VkIGZvciBjYW52YXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246ICdzb3VyY2Utb3ZlcicsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGFuIG9iamVjdC5cbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogICAgICAgICAgJycsXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Rpb24gQmFja2dyb3VuZCBjb2xvciBvZiBhbiBvYmplY3QuIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3Qgd2hlbiBpdCBpcyBhY3RpdmUuXG4gICAgICogZG9lcyBub3QgbWl4IGdvb2Qgd2l0aCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gbWV0aG9kcy5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjogICAgICAgICAgJycsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3JcbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZTogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgc3Ryb2tlIHVzZWQgdG8gcmVuZGVyIHRoaXMgb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBzdHJva2UgKHN0cm9rZSBtdXN0IGJlIGRlZmluZWQpXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdHJva2VEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIG9mZnNldCBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZURhc2hPZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIGVuZGluZ3Mgc3R5bGUgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChvbmUgb2YgXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZUxpbmVDYXA6ICAgICAgICAgICAgJ2J1dHQnLFxuXG4gICAgLyoqXG4gICAgICogQ29ybmVyIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYmV2ZWxcIiwgXCJyb3VuZFwiLCBcIm1pdGVyXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lSm9pbjogICAgICAgICAgICdtaXRlcicsXG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG1pdGVyIGxlbmd0aCAodXNlZCBmb3Igc3Ryb2tlTGluZUpvaW4gPSBcIm1pdGVyXCIpIG9mIGFuIG9iamVjdCdzIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICA0LFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgd2hlbiBvYmplY3QgaXMgYWN0aXZlIGFuZCBtb3ZpbmdcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAgMC40LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnNcbiAgICAgKiBiaWdnZXIgbnVtYmVyIHdpbGwgbWFrZSBhIHRoaWNrZXIgYm9yZGVyXG4gICAgICogYm9yZGVyIGlzIDEsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgYm9yZGVyIHRoaWNrbmVzc1xuICAgICAqIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBjaGFuZ2UgdGhlIGJvcmRlciBpdHNlbGYuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJTY2FsZUZhY3RvcjogICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5TY2FsZUxpbWl0OiAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBzZWxlY3RlZCBmb3IgbW9kaWZpY2F0aW9uICh1c2luZyBlaXRoZXIgcG9pbnQtY2xpY2stYmFzZWQgb3IgZ3JvdXAtYmFzZWQgc2VsZWN0aW9uKS5cbiAgICAgKiBCdXQgZXZlbnRzIHN0aWxsIGZpcmUgb24gaXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0YWJsZTogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgYSB0YXJnZXQgb2YgZXZlbnRzLiBBbGwgZXZlbnRzIHByb3BhZ2F0ZSB0aHJvdWdoIGl0LiBJbnRyb2R1Y2VkIGluIHYxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV2ZW50ZWQ6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBpcyBub3QgcmVuZGVyZWQgb24gY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbHMgYXJlIG5vdCBkaXNwbGF5ZWQgYW5kIGNhbiBub3QgYmUgdXNlZCB0byBtYW5pcHVsYXRlIG9iamVjdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0NvbnRyb2xzOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgYXJlIG5vdCByZW5kZXJlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0JvcmRlcnM6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0cyBhcmUgXCJmb3VuZFwiIG9uIGNhbnZhcyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gYWNjb3JkaW5nIHRvIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIGRlZmF1bHQgb2JqZWN0J3MgdmFsdWVzIGFyZSBub3QgaW5jbHVkZWQgaW4gaXRzIHNlcmlhbGl6YXRpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WDogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgcm90YXRpb24gaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9uOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBza2V3aW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTa2V3aW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgY2Fubm90IGJlIGZsaXBwZWQgYnkgc2NhbGluZyBpbnRvIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nRmxpcDogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGlzIG5vdCBleHBvcnRlZCBpbiBPQkpFQ1QvSlNPTlxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV4Y2x1ZGVGcm9tRXhwb3J0OiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGlzIGNhY2hlZCBvbiBhbiBhZGRpdGlvbmFsIGNhbnZhcy5cbiAgICAgKiBXaGVuIGBmYWxzZWAsIG9iamVjdCBpcyBub3QgY2FjaGVkIHVubGVzcyBuZWNlc3NhcnkgKCBjbGlwUGF0aCApXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogQHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBvYmplY3RDYWNoaW5nOiAgICAgICAgICAgIG9iamVjdENhY2hpbmcsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIGNoZWNrZWQgZm9yIGNhY2hlIGludmFsaWRhdGlvbi4gSW4gc29tZSBwYXJ0aWN1bGFyXG4gICAgICogc2l0dWF0aW9uIHlvdSBtYXkgd2FudCB0aGlzIHRvIGJlIGRpc2FibGVkICggc3ByYXkgYnJ1c2gsIHZlcnkgYmlnLCBncm91cHMpXG4gICAgICogb3IgaWYgeW91ciBhcHBsaWNhdGlvbiBkb2VzIG5vdCBhbGxvdyB5b3UgdG8gbW9kaWZ5IHByb3BlcnRpZXMgZm9yIGdyb3VwcyBjaGlsZCB5b3Ugd2FudFxuICAgICAqIHRvIGRpc2FibGUgaXQgZm9yIGdyb3Vwcy5cbiAgICAgKiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzdGF0ZWZ1bGxDYWNoZTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBjYWNoZSBkb2VzIG5vdCBnZXQgdXBkYXRlZCBkdXJpbmcgc2NhbGluZy4gVGhlIHBpY3R1cmUgd2lsbCBnZXQgYmxvY2t5IGlmIHNjYWxlZFxuICAgICAqIHRvbyBtdWNoIGFuZCB3aWxsIGJlIHJlZHJhd24gd2l0aCBjb3JyZWN0IGRldGFpbHMgYXQgdGhlIGVuZCBvZiBzY2FsaW5nLlxuICAgICAqIHRoaXMgc2V0dGluZyBpcyBwZXJmb3JtYW5jZSBhbmQgYXBwbGljYXRpb24gZGVwZW5kYW50LlxuICAgICAqIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBub1NjYWxlQ2FjaGU6ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgZmFsc2VgLCB0aGUgc3Rva2Ugd2lkdGggd2lsbCBzY2FsZSB3aXRoIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBzdHJva2Ugd2lsbCBhbHdheXMgbWF0Y2ggdGhlIGV4YWN0IHBpeGVsIHNpemUgZW50ZXJlZCBmb3Igc3Ryb2tlIHdpZHRoLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBAc2luY2UgMi42LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzdHJva2VVbmlmb3JtOiAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdCdzIGNhY2hlIHdpbGwgYmUgcmVyZW5kZXJlZCBuZXh0IHJlbmRlciBjYWxsLlxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBkaXJ0eTogICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGtlZXBzIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBob3ZlcmVkIGNvcm5lciBkdXJpbmcgbW91c2UgbW92ZS5cbiAgICAgKiAwIGlzIG5vIGNvcm5lciwgb3IgJ210JywgJ21sJywgJ210cicgZXRjLi5cbiAgICAgKiBJdCBzaG91bGQgYmUgcHJpdmF0ZSwgYnV0IHRoZXJlIGlzIG5vIGhhcm0gaW4gdXNpbmcgaXQgYXNcbiAgICAgKiBhIHJlYWQtb25seSBwcm9wZXJ0eS5cbiAgICAgKiBAdHlwZSBudW1iZXJ8c3RyaW5nfGFueVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBfX2Nvcm5lcjogMCxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGZpbGwgb3IgdGhlIHN0cm9rZSBpcyBkcmF3biBmaXJzdCAob25lIG9mIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWludEZpcnN0OiAgICAgICAgICAgJ2ZpbGwnLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgc3RhdGVcbiAgICAgKiBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWQpXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiAoXG4gICAgICAndG9wIGxlZnQgd2lkdGggaGVpZ2h0IHNjYWxlWCBzY2FsZVkgZmxpcFggZmxpcFkgb3JpZ2luWCBvcmlnaW5ZIHRyYW5zZm9ybU1hdHJpeCAnICtcbiAgICAgICdzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHN0cm9rZUxpbmVDYXAgc3Ryb2tlRGFzaE9mZnNldCBzdHJva2VMaW5lSm9pbiBzdHJva2VNaXRlckxpbWl0ICcgK1xuICAgICAgJ2FuZ2xlIG9wYWNpdHkgZmlsbCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gc2hhZG93IHZpc2libGUgYmFja2dyb3VuZENvbG9yICcgK1xuICAgICAgJ3NrZXdYIHNrZXdZIGZpbGxSdWxlIHBhaW50Rmlyc3QgY2xpcFBhdGggc3Ryb2tlVW5pZm9ybSdcbiAgICApLnNwbGl0KCcgJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogVGhvc2UgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBieSBzdGF0ZWZ1bGxDYWNoZSBPTiAoIG9yIGxhenkgbW9kZSBpZiB3ZSB3YW50ICkgb3IgZnJvbSBzaW5nbGVcbiAgICAgKiBjYWxscyB0byBPYmplY3Quc2V0KGtleSwgdmFsdWUpLiBJZiB0aGUga2V5IGlzIGluIHRoaXMgbGlzdCwgdGhlIG9iamVjdCBpcyBtYXJrZWQgYXMgZGlydHlcbiAgICAgKiBhbmQgcmVmcmVzaGVkIGF0IHRoZSBuZXh0IHJlbmRlclxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHdpZHRoIGhlaWdodCBwYWludEZpcnN0IHN0cm9rZVVuaWZvcm0nICtcbiAgICAgICcgc3Ryb2tlTGluZUNhcCBzdHJva2VEYXNoT2Zmc2V0IHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgYmFja2dyb3VuZENvbG9yIGNsaXBQYXRoJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciBmb3IgYW5pbWF0aW5nIGNvbG9ycy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNvbG9yUHJvcGVydGllczogKFxuICAgICAgJ2ZpbGwgc3Ryb2tlIGJhY2tncm91bmRDb2xvcidcbiAgICApLnNwbGl0KCcgJyksXG5cbiAgICAvKipcbiAgICAgKiBhIGZhYnJpY09iamVjdCB0aGF0LCB3aXRob3V0IHN0cm9rZSBkZWZpbmUgYSBjbGlwcGluZyBhcmVhIHdpdGggdGhlaXIgc2hhcGUuIGZpbGxlZCBpbiBibGFja1xuICAgICAqIHRoZSBjbGlwUGF0aCBvYmplY3QgZ2V0cyB1c2VkIHdoZW4gdGhlIG9iamVjdCBoYXMgcmVuZGVyZWQsIGFuZCB0aGUgY29udGV4dCBpcyBwbGFjZWQgaW4gdGhlIGNlbnRlclxuICAgICAqIG9mIHRoZSBvYmplY3QgY2FjaGVDYW52YXMuXG4gICAgICogSWYgeW91IHdhbnQgMCwwIG9mIGEgY2xpcFBhdGggdG8gYWxpZ24gd2l0aCBhbiBvYmplY3QgY2VudGVyLCB1c2UgY2xpcFBhdGgub3JpZ2luWC9ZIHRvICdjZW50ZXInXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFxuICAgICAqL1xuICAgIGNsaXBQYXRoOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBNZWFuaW5nZnVsIE9OTFkgd2hlbiB0aGUgb2JqZWN0IGlzIHVzZWQgYXMgY2xpcFBhdGguXG4gICAgICogaWYgdHJ1ZSwgdGhlIGNsaXBQYXRoIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGNsaXAgdG8gdGhlIG91dHNpZGUgb2YgdGhlIGNsaXBQYXRoXG4gICAgICogc2luY2UgMi40LjBcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBpbnZlcnRlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBNZWFuaW5nZnVsIE9OTFkgd2hlbiB0aGUgb2JqZWN0IGlzIHVzZWQgYXMgY2xpcFBhdGguXG4gICAgICogaWYgdHJ1ZSwgdGhlIGNsaXBQYXRoIHdpbGwgaGF2ZSBpdHMgdG9wIGFuZCBsZWZ0IHJlbGF0aXZlIHRvIGNhbnZhcywgYW5kIHdpbGxcbiAgICAgKiBub3QgYmUgaW5mbHVlbmNlZCBieSB0aGUgb2JqZWN0IHRyYW5zZm9ybS4gVGhpcyB3aWxsIG1ha2UgdGhlIGNsaXBQYXRoIHJlbGF0aXZlXG4gICAgICogdG8gdGhlIGNhbnZhcywgYnV0IGNsaXBwaW5nIGp1c3QgYSBwYXJ0aWN1bGFyIG9iamVjdC5cbiAgICAgKiBXQVJOSU5HIHRoaXMgaXMgYmV0YSwgdGhpcyBmZWF0dXJlIG1heSBjaGFuZ2Ugb3IgYmUgcmVuYW1lZC5cbiAgICAgKiBzaW5jZSAyLjQuMFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGFic29sdXRlUG9zaXRpb25lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRoZSBjYW52YXMgdXNlZCB0byBrZWVwIHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVQcm9wZXJ0aWVzID0ge307XG4gICAgICB0aGlzLl9jYWNoZUNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2NhY2hlQ29udGV4dCA9IHRoaXMuX2NhY2hlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpO1xuICAgICAgLy8gaWYgY2FudmFzIGdldHMgY3JlYXRlZCwgaXMgZW1wdHksIHNvIGRpcnR5LlxuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpbWl0IHRoZSBjYWNoZSBkaW1lbnNpb25zIHNvIHRoYXQgWCAqIFkgZG8gbm90IGNyb3NzIGZhYnJpYy5wZXJmTGltaXRTaXplVG90YWxcbiAgICAgKiBhbmQgZWFjaCBzaWRlIGRvIG5vdCBjcm9zcyBmYWJyaWMuY2FjaGVTaWRlTGltaXRcbiAgICAgKiB0aG9zZSBudW1iZXJzIGFyZSBjb25maWd1cmFibGUgc28gdGhhdCB5b3UgY2FuIGdldCBhcyBtdWNoIGRldGFpbCBhcyB5b3Ugd2FudFxuICAgICAqIG1ha2luZyBiYXJnYWluIHdpdGggcGVyZm9ybWFuY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfbGltaXRDYWNoZVNpemU6IGZ1bmN0aW9uKGRpbXMpIHtcbiAgICAgIHZhciBwZXJmTGltaXRTaXplVG90YWwgPSBmYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsLFxuICAgICAgICAgIHdpZHRoID0gZGltcy53aWR0aCwgaGVpZ2h0ID0gZGltcy5oZWlnaHQsXG4gICAgICAgICAgbWF4ID0gZmFicmljLm1heENhY2hlU2lkZUxpbWl0LCBtaW4gPSBmYWJyaWMubWluQ2FjaGVTaWRlTGltaXQ7XG4gICAgICBpZiAod2lkdGggPD0gbWF4ICYmIGhlaWdodCA8PSBtYXggJiYgd2lkdGggKiBoZWlnaHQgPD0gcGVyZkxpbWl0U2l6ZVRvdGFsKSB7XG4gICAgICAgIGlmICh3aWR0aCA8IG1pbikge1xuICAgICAgICAgIGRpbXMud2lkdGggPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA8IG1pbikge1xuICAgICAgICAgIGRpbXMuaGVpZ2h0ID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaW1zO1xuICAgICAgfVxuICAgICAgdmFyIGFyID0gd2lkdGggLyBoZWlnaHQsIGxpbWl0ZWREaW1zID0gZmFicmljLnV0aWwubGltaXREaW1zQnlBcmVhKGFyLCBwZXJmTGltaXRTaXplVG90YWwpLFxuICAgICAgICAgIGNhcFZhbHVlID0gZmFicmljLnV0aWwuY2FwVmFsdWUsXG4gICAgICAgICAgeCA9IGNhcFZhbHVlKG1pbiwgbGltaXRlZERpbXMueCwgbWF4KSxcbiAgICAgICAgICB5ID0gY2FwVmFsdWUobWluLCBsaW1pdGVkRGltcy55LCBtYXgpO1xuICAgICAgaWYgKHdpZHRoID4geCkge1xuICAgICAgICBkaW1zLnpvb21YIC89IHdpZHRoIC8geDtcbiAgICAgICAgZGltcy53aWR0aCA9IHg7XG4gICAgICAgIGRpbXMuY2FwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQgPiB5KSB7XG4gICAgICAgIGRpbXMuem9vbVkgLz0gaGVpZ2h0IC8geTtcbiAgICAgICAgZGltcy5oZWlnaHQgPSB5O1xuICAgICAgICBkaW1zLmNhcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnggd2lkdGggb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ueSBoZWlnaHQgb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2dldENhY2hlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqZWN0U2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIC8vIGNhY3VsYXRlIGRpbWVuc2lvbnMgd2l0aG91dCBza2V3aW5nXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKDAsIDApLFxuICAgICAgICAgIG5lZWRlZFggPSBkaW0ueCAqIG9iamVjdFNjYWxlLnNjYWxlWCAvIHRoaXMuc2NhbGVYLFxuICAgICAgICAgIG5lZWRlZFkgPSBkaW0ueSAqIG9iamVjdFNjYWxlLnNjYWxlWSAvIHRoaXMuc2NhbGVZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gZm9yIHN1cmUgdGhpcyBBTElBU0lOR19MSU1JVCBpcyBzbGlnaHRseSBjcmVhdGluZyBwcm9ibGVtXG4gICAgICAgIC8vIGluIHNpdHVhdGlvbiBpbiB3aGljaCB0aGUgY2FjaGUgY2FudmFzIGdldHMgYW4gdXBwZXIgbGltaXRcbiAgICAgICAgLy8gYWxzbyBvYmplY3RTY2FsZSBjb250YWlucyBhbHJlYWR5IHNjYWxlWCBhbmQgc2NhbGVZXG4gICAgICAgIHdpZHRoOiBuZWVkZWRYICsgQUxJQVNJTkdfTElNSVQsXG4gICAgICAgIGhlaWdodDogbmVlZGVkWSArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICB6b29tWDogb2JqZWN0U2NhbGUuc2NhbGVYLFxuICAgICAgICB6b29tWTogb2JqZWN0U2NhbGUuc2NhbGVZLFxuICAgICAgICB4OiBuZWVkZWRYLFxuICAgICAgICB5OiBuZWVkZWRZXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FudmFzIGZvciBjYWNoZVxuICAgICAqIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBjYW52YXMgbmVlZGVkIHJlc2l6ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBoYXMgYmVlbiByZXNpemVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YXJnZXRDYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGlmICh0aGlzLm5vU2NhbGVDYWNoZSAmJiB0YXJnZXRDYW52YXMgJiYgdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgICAgYWN0aW9uID0gdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtLmFjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBhY3Rpb24uc2xpY2UgJiYgYWN0aW9uLnNsaWNlKDAsIDUpID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FjaGVDYW52YXMsXG4gICAgICAgICAgZGltcyA9IHRoaXMuX2xpbWl0Q2FjaGVTaXplKHRoaXMuX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucygpKSxcbiAgICAgICAgICBtaW5DYWNoZVNpemUgPSBmYWJyaWMubWluQ2FjaGVTaWRlTGltaXQsXG4gICAgICAgICAgd2lkdGggPSBkaW1zLndpZHRoLCBoZWlnaHQgPSBkaW1zLmhlaWdodCwgZHJhd2luZ1dpZHRoLCBkcmF3aW5nSGVpZ2h0LFxuICAgICAgICAgIHpvb21YID0gZGltcy56b29tWCwgem9vbVkgPSBkaW1zLnpvb21ZLFxuICAgICAgICAgIGRpbWVuc2lvbnNDaGFuZ2VkID0gd2lkdGggIT09IHRoaXMuY2FjaGVXaWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuY2FjaGVIZWlnaHQsXG4gICAgICAgICAgem9vbUNoYW5nZWQgPSB0aGlzLnpvb21YICE9PSB6b29tWCB8fCB0aGlzLnpvb21ZICE9PSB6b29tWSxcbiAgICAgICAgICBzaG91bGRSZWRyYXcgPSBkaW1lbnNpb25zQ2hhbmdlZCB8fCB6b29tQ2hhbmdlZCxcbiAgICAgICAgICBhZGRpdGlvbmFsV2lkdGggPSAwLCBhZGRpdGlvbmFsSGVpZ2h0ID0gMCwgc2hvdWxkUmVzaXplQ2FudmFzID0gZmFsc2U7XG4gICAgICBpZiAoZGltZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy5fY2FjaGVDYW52YXMud2lkdGgsXG4gICAgICAgICAgICBjYW52YXNIZWlnaHQgPSB0aGlzLl9jYWNoZUNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBzaXplR3Jvd2luZyA9IHdpZHRoID4gY2FudmFzV2lkdGggfHwgaGVpZ2h0ID4gY2FudmFzSGVpZ2h0LFxuICAgICAgICAgICAgc2l6ZVNocmlua2luZyA9ICh3aWR0aCA8IGNhbnZhc1dpZHRoICogMC45IHx8IGhlaWdodCA8IGNhbnZhc0hlaWdodCAqIDAuOSkgJiZcbiAgICAgICAgICAgICAgY2FudmFzV2lkdGggPiBtaW5DYWNoZVNpemUgJiYgY2FudmFzSGVpZ2h0ID4gbWluQ2FjaGVTaXplO1xuICAgICAgICBzaG91bGRSZXNpemVDYW52YXMgPSBzaXplR3Jvd2luZyB8fCBzaXplU2hyaW5raW5nO1xuICAgICAgICBpZiAoc2l6ZUdyb3dpbmcgJiYgIWRpbXMuY2FwcGVkICYmICh3aWR0aCA+IG1pbkNhY2hlU2l6ZSB8fCBoZWlnaHQgPiBtaW5DYWNoZVNpemUpKSB7XG4gICAgICAgICAgYWRkaXRpb25hbFdpZHRoID0gd2lkdGggKiAwLjE7XG4gICAgICAgICAgYWRkaXRpb25hbEhlaWdodCA9IGhlaWdodCAqIDAuMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJlZHJhdykge1xuICAgICAgICBpZiAoc2hvdWxkUmVzaXplQ2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoICsgYWRkaXRpb25hbFdpZHRoKTtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCArIGFkZGl0aW9uYWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdpbmdXaWR0aCA9IGRpbXMueCAvIDI7XG4gICAgICAgIGRyYXdpbmdIZWlnaHQgPSBkaW1zLnkgLyAyO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25YID0gTWF0aC5yb3VuZChjYW52YXMud2lkdGggLyAyIC0gZHJhd2luZ1dpZHRoKSArIGRyYXdpbmdXaWR0aDtcbiAgICAgICAgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSA9IE1hdGgucm91bmQoY2FudmFzLmhlaWdodCAvIDIgLSBkcmF3aW5nSGVpZ2h0KSArIGRyYXdpbmdIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQudHJhbnNsYXRlKHRoaXMuY2FjaGVUcmFuc2xhdGlvblgsIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2NhbGUoem9vbVgsIHpvb21ZKTtcbiAgICAgICAgdGhpcy56b29tWCA9IHpvb21YO1xuICAgICAgICB0aGlzLnpvb21ZID0gem9vbVk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbnRleHQgd2hlbiByZW5kZXJpbmcgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0XG4gICAgICovXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBuZWVkRnVsbFRyYW5zZm9ybSA9ICh0aGlzLmdyb3VwICYmICF0aGlzLmdyb3VwLl90cmFuc2Zvcm1Eb25lKSB8fFxuICAgICAgICAgKHRoaXMuZ3JvdXAgJiYgdGhpcy5jYW52YXMgJiYgY3R4ID09PSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHZhciBtID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCFuZWVkRnVsbFRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcblxuICAgICAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgdmVyc2lvbjogICAgICAgICAgICAgICAgICBmYWJyaWMudmVyc2lvbixcbiAgICAgICAgICAgIG9yaWdpblg6ICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5YLFxuICAgICAgICAgICAgb3JpZ2luWTogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblksXG4gICAgICAgICAgICBsZWZ0OiAgICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5sZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHRvcDogICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgZmlsbDogICAgICAgICAgICAgICAgICAgICAodGhpcy5maWxsICYmIHRoaXMuZmlsbC50b09iamVjdCkgPyB0aGlzLmZpbGwudG9PYmplY3QoKSA6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogICAgICAgICAgICAgICAgICAgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlLnRvT2JqZWN0KSA/IHRoaXMuc3Ryb2tlLnRvT2JqZWN0KCkgOiB0aGlzLnN0cm9rZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZVdpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHN0cm9rZURhc2hBcnJheTogICAgICAgICAgdGhpcy5zdHJva2VEYXNoQXJyYXkgPyB0aGlzLnN0cm9rZURhc2hBcnJheS5jb25jYXQoKSA6IHRoaXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgICAgICAgc3Ryb2tlTGluZUNhcDogICAgICAgICAgICB0aGlzLnN0cm9rZUxpbmVDYXAsXG4gICAgICAgICAgICBzdHJva2VEYXNoT2Zmc2V0OiAgICAgICAgIHRoaXMuc3Ryb2tlRGFzaE9mZnNldCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVKb2luOiAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lSm9pbixcbiAgICAgICAgICAgIHN0cm9rZVVuaWZvcm06ICAgICAgICAgICAgdGhpcy5zdHJva2VVbmlmb3JtLFxuICAgICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzY2FsZVg6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVZOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmFuZ2xlLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGlwWSxcbiAgICAgICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLm9wYWNpdHksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICAodGhpcy5zaGFkb3cgJiYgdGhpcy5zaGFkb3cudG9PYmplY3QpID8gdGhpcy5zaGFkb3cudG9PYmplY3QoKSA6IHRoaXMuc2hhZG93LFxuICAgICAgICAgICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0aGlzLnZpc2libGUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICB0aGlzLmZpbGxSdWxlLFxuICAgICAgICAgICAgcGFpbnRGaXJzdDogICAgICAgICAgICAgICB0aGlzLnBhaW50Rmlyc3QsXG4gICAgICAgICAgICBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uLFxuICAgICAgICAgICAgc2tld1g6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1gsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2tld1k6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2tld1ksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aC5pbnZlcnRlZCA9IHRoaXMuY2xpcFBhdGguaW52ZXJ0ZWQ7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQgPSB0aGlzLmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZDtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX3JlbW92ZURlZmF1bHRWYWx1ZXMob2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAoZGF0YWxlc3MpIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgc3ViY2xhc3Nlc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqL1xuICAgIF9yZW1vdmVEZWZhdWx0VmFsdWVzOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBmYWJyaWMudXRpbC5nZXRLbGFzcyhvYmplY3QudHlwZSkucHJvdG90eXBlLFxuICAgICAgICAgIHN0YXRlUHJvcGVydGllcyA9IHByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXM7XG4gICAgICBzdGF0ZVByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnbGVmdCcgfHwgcHJvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdFtwcm9wXSA9PT0gcHJvdG90eXBlW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBcnJheSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3RbcHJvcF0pID09PSAnW29iamVjdCBBcnJheV0nICYmXG4gICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb3RvdHlwZVtwcm9wXSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgICAgLy8gYmFzaWNhbGx5IGEgY2hlY2sgZm9yIFtdID09PSBbXVxuICAgICAgICBpZiAoaXNBcnJheSAmJiBvYmplY3RbcHJvcF0ubGVuZ3RoID09PSAwICYmIHByb3RvdHlwZVtwcm9wXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLicgKyBjYXBpdGFsaXplKHRoaXMudHlwZSkgKyAnPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T2JqZWN0U2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgIHJldHVybiB7IHNjYWxlWDogTWF0aC5hYnMob3B0aW9ucy5zY2FsZVgpLCBzY2FsZVk6IE1hdGguYWJzKG9wdGlvbnMuc2NhbGVZKSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBzY2FsZSBmYWN0b3IgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgc2NhbGluZywgem9vbSBhbmQgcmV0aW5hXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0VG90YWxPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLCBzY2FsZVggPSBzY2FsZS5zY2FsZVgsIHNjYWxlWSA9IHNjYWxlLnNjYWxlWTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB2YXIgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKTtcbiAgICAgICAgdmFyIHJldGluYSA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgICAgc2NhbGVYICo9IHpvb20gKiByZXRpbmE7XG4gICAgICAgIHNjYWxlWSAqPSB6b29tICogcmV0aW5hO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IG9wYWNpdHkgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0T2JqZWN0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gdGhpcy5ncm91cC5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc2hvdWxkQ29uc3RyYWluVmFsdWUgPSAoa2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSxcbiAgICAgICAgICBpc0NoYW5nZWQgPSB0aGlzW2tleV0gIT09IHZhbHVlLCBncm91cE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRDb25zdHJhaW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2NvbnN0cmFpblNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBYID0gIXRoaXMuZmxpcFg7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2NhbGVZJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWSA9ICF0aGlzLmZsaXBZO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NoYWRvdycgJiYgdmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIGZhYnJpYy5TaGFkb3cpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IGZhYnJpYy5TaGFkb3codmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZGlydHknICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICBncm91cE5lZWRzVXBkYXRlID0gdGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgZ3JvdXBOZWVkc1VwZGF0ZSAmJiB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuc3RhdGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcGFyZW50IGdyb3VwIG9mIGFuIG9iamVjdCBldmVyeVxuICAgICAqIHRpbWUgYSBub24tZGVsZWdhdGVkIHByb3BlcnR5IGNoYW5nZXMgb24gdGhlIGdyb3VwLiBJdCBpcyBwYXNzZWQgdGhlIGtleVxuICAgICAqIGFuZCB2YWx1ZSBhcyBwYXJhbWV0ZXJzLiBOb3QgYWRkaW5nIGluIHRoaXMgZnVuY3Rpb24ncyBzaWduYXR1cmUgdG8gYXZvaWRcbiAgICAgKiBUcmF2aXMgYnVpbGQgZXJyb3IgYWJvdXQgdW51c2VkIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBzZXRPbkdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB2aWV3cG9ydFRyYW5zZm9ybSBmcm9tIE9iamVjdCdzIGNhbnZhcyBpZiBwb3NzaWJsZVxuICAgICAqIEBtZXRob2QgZ2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIGlmIHRoZSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpbiByZW5kZXJpbmdcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTm90VmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSAwIHx8XG4gICAgICAgICghdGhpcy53aWR0aCAmJiAhdGhpcy5oZWlnaHQgJiYgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgfHxcbiAgICAgICAgIXRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiB3aWR0aC9oZWlnaHQgYXJlIHplcm9zIG9yIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuaXNOb3RWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbihjdHgpO1xuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuX3NldE9wYWNpdHkoY3R4KTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdyhjdHgsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLnJlbmRlckNhY2hlKCk7XG4gICAgICAgIHRoaXMuZHJhd0NhY2hlT25DYW52YXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVDYWNoZUNhbnZhcygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdChjdHgpO1xuICAgICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nICYmIHRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyQ2FjaGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZUNhbnZhcykge1xuICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNDYWNoZURpcnR5KCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZWZ1bGxDYWNoZSAmJiB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgdGhpcy5kcmF3T2JqZWN0KHRoaXMuX2NhY2hlQ29udGV4dCwgb3B0aW9ucy5mb3JDbGlwcGluZyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNhY2hlQ2FudmFzIGFuZCBpdHMgZGltZW5zaW9ucyBmcm9tIHRoZSBvYmplY3RzXG4gICAgICovXG4gICAgX3JlbW92ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IDA7XG4gICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCB3aWxsIGRyYXcgYSBzdHJva2VcbiAgICAgKiBEb2VzIG5vdCBjb25zaWRlciB0ZXh0IHN0eWxlcy4gVGhpcyBpcyBqdXN0IGEgc2hvcnRjdXQgdXNlZCBhdCByZW5kZXJpbmcgdGltZVxuICAgICAqIFdlIHdhbnQgaXQgdG8gYmUgYW4gYXBwcm94aW1hdGlvbiBhbmQgYmUgZmFzdC5cbiAgICAgKiB3cm90ZSB0byBhdm9pZCBleHRyYSBjYWNoaW5nLCBpdCBoYXMgdG8gcmV0dXJuIHRydWUgd2hlbiBzdHJva2UgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBzdHJva2UgaXMgaW52aXNpYmxlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKi9cbiAgICBoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlICE9PSAndHJhbnNwYXJlbnQnICYmIHRoaXMuc3Ryb2tlV2lkdGggIT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZSBvYmplY3Qgd2lsbCBkcmF3IGEgZmlsbFxuICAgICAqIERvZXMgbm90IGNvbnNpZGVyIHRleHQgc3R5bGVzLiBUaGlzIGlzIGp1c3QgYSBzaG9ydGN1dCB1c2VkIGF0IHJlbmRlcmluZyB0aW1lXG4gICAgICogV2Ugd2FudCBpdCB0byBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCBiZSBmYXN0LlxuICAgICAqIHdyb3RlIHRvIGF2b2lkIGV4dHJhIGNhY2hpbmcsIGl0IGhhcyB0byByZXR1cm4gdHJ1ZSB3aGVuIGZpbGwgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBmaWxsIGlzIGludmlzaWJsZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICovXG4gICAgaGFzRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxsICYmIHRoaXMuZmlsbCAhPT0gJ3RyYW5zcGFyZW50JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBmb3JjZSB0aGUgb2JqZWN0IHRvIGhhdmUgaXRzIG93biBjYWNoZSwgZXZlbiBpZiBpdCBpcyBpbnNpZGUgYSBncm91cFxuICAgICAqIGl0IG1heSBiZSBuZWVkZWQgd2hlbiB5b3VyIG9iamVjdCBiZWhhdmUgaW4gYSBwYXJ0aWN1bGFyIHdheSBvbiB0aGUgY2FjaGUgYW5kIGFsd2F5cyBuZWVkc1xuICAgICAqIGl0cyBvd24gaXNvbGF0ZWQgY2FudmFzIHRvIHJlbmRlciBjb3JyZWN0bHkuXG4gICAgICogQ3JlYXRlZCB0byBiZSBvdmVycmlkZGVuXG4gICAgICogc2luY2UgMS43LjEyXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqL1xuICAgIG5lZWRzSXRzT3duQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScgJiZcbiAgICAgICAgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSAmJiB0eXBlb2YgdGhpcy5zaGFkb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBSZWFkIGFzOiBjYWNoZSBpZiBpcyBuZWVkZWQsIG9yIGlmIHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQgYnV0IHdlIGFyZSBub3QgYWxyZWFkeSBjYWNoaW5nLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gdGhpcy5uZWVkc0l0c093bkNhY2hlKCkgfHwgKFxuICAgICAgICB0aGlzLm9iamVjdENhY2hpbmcgJiZcbiAgICAgICAgKCF0aGlzLmdyb3VwIHx8ICF0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiB1c2VkIGJ5IEdyb3VwLnNob3VsZENhY2hlIHRvIGtub3cgaWYgY2hpbGQgaGFzIGEgc2hhZG93IHJlY3Vyc2l2ZWx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnNoYWRvdyAmJiAodGhpcy5zaGFkb3cub2Zmc2V0WCAhPT0gMCB8fCB0aGlzLnNoYWRvdy5vZmZzZXRZICE9PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBjbGlwUGF0aFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2xpcFBhdGhPbkNhY2hlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBERUJVRzogdW5jb21tZW50IHRoaXMgbGluZSwgY29tbWVudCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjRcbiAgICAgIGlmIChwYXRoLmludmVydGVkKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIH1cbiAgICAgIC8vY3R4LnNjYWxlKDEgLyAyLCAxIC8gMik7XG4gICAgICBpZiAocGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQpIHtcbiAgICAgICAgdmFyIG0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgfVxuICAgICAgcGF0aC50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gcGF0aC56b29tWCwgMSAvIHBhdGguem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZShwYXRoLl9jYWNoZUNhbnZhcywgLXBhdGguY2FjaGVUcmFuc2xhdGlvblgsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgsIGZvckNsaXBwaW5nKSB7XG4gICAgICB2YXIgb3JpZ2luYWxGaWxsID0gdGhpcy5maWxsLCBvcmlnaW5hbFN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgaWYgKGZvckNsaXBwaW5nKSB7XG4gICAgICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gJyc7XG4gICAgICAgIHRoaXMuX3NldENsaXBwaW5nUHJvcGVydGllcyhjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcihjdHgpO1xuICAgICAgdGhpcy5fZHJhd0NsaXBQYXRoKGN0eCk7XG4gICAgICB0aGlzLmZpbGwgPSBvcmlnaW5hbEZpbGw7XG4gICAgICB0aGlzLnN0cm9rZSA9IG9yaWdpbmFsU3Ryb2tlO1xuICAgIH0sXG5cbiAgICBfZHJhd0NsaXBQYXRoOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGlmICghcGF0aCkgeyByZXR1cm47IH1cbiAgICAgIC8vIG5lZWRlZCB0byBzZXR1cCBhIGNvdXBsZSBvZiB2YXJpYWJsZXNcbiAgICAgIC8vIHBhdGggY2FudmFzIGdldHMgb3ZlcnJpZGRlbiB3aXRoIHRoaXMgb25lLlxuICAgICAgLy8gVE9ETyBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgcGF0aC5jYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgIHBhdGguX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgcGF0aC5yZW5kZXJDYWNoZSh7IGZvckNsaXBwaW5nOiB0cnVlIH0pO1xuICAgICAgdGhpcy5kcmF3Q2xpcFBhdGhPbkNhY2hlKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NhY2hlT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNjYWxlKDEgLyB0aGlzLnpvb21YLCAxIC8gdGhpcy56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2NhY2hlQ2FudmFzLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcENhbnZhcyBza2lwIGNhbnZhcyBjaGVja3MgYmVjYXVzZSB0aGlzIG9iamVjdCBpcyBwYWludGVkXG4gICAgICogb24gcGFyZW50IGNhbnZhcy5cbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmlzTm90VmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcyAmJiAhc2tpcENhbnZhcyAmJiB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpKSB7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgY29udGV4dCBpcyBhbHJlYWR5IGNsZWFyZWQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5IHx8XG4gICAgICAgICAgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQpIHx8XG4gICAgICAgICAgKHRoaXMuc3RhdGVmdWxsQ2FjaGUgJiYgdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ2NhY2hlUHJvcGVydGllcycpKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMgJiYgIXNraXBDYW52YXMpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FjaGVXaWR0aCAvIHRoaXMuem9vbVg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBiYWNrZ3JvdW5kIGZvciB0aGUgb2JqZWN0IGJpZyBhcyBpdHMgdW50cmFuc2Zvcm1lZCBkaW1lbnNpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZGltID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgLWRpbS54IC8gMixcbiAgICAgICAgLWRpbS55IC8gMixcbiAgICAgICAgZGltLngsXG4gICAgICAgIGRpbS55XG4gICAgICApO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYmFja2dyb3VuZCBjb2xvciBubyBvdGhlciBzaGFkb3dzXG4gICAgICAvLyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldE9wYWNpdHk6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICB2YXIgc3Ryb2tlID0gZGVjbC5zdHJva2U7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBkZWNsLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHgubGluZUNhcCA9IGRlY2wuc3Ryb2tlTGluZUNhcDtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGVjbC5zdHJva2VEYXNoT2Zmc2V0O1xuICAgICAgICBjdHgubGluZUpvaW4gPSBkZWNsLnN0cm9rZUxpbmVKb2luO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IGRlY2wuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgICAgaWYgKHN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgICBpZiAoc3Ryb2tlLmdyYWRpZW50VW5pdHMgPT09ICdwZXJjZW50YWdlJyB8fCBzdHJva2UuZ3JhZGllbnRUcmFzbmZvcm0gfHwgc3Ryb2tlLnBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhbnNmb3JtIGdyYWRpZW50IGluIGEgcGF0dGVybi5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG93IHByb2Nlc3MuIElmIHlvdSBhcmUgaGl0dGluZyB0aGlzIGNvZGVwYXRoLCBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IHVzaW5nIGNhY2hpbmcsIHlvdSBzaG91bGQgY29uc2lkZXIgc3dpdGNoaW5nIGl0IG9uLlxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIGNhbnZhcyBhcyBiaWcgYXMgdGhlIGN1cnJlbnQgb2JqZWN0IGNhY2hpbmcgY2FudmFzLlxuICAgICAgICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudChjdHgsIHN0cm9rZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaXMgYSBzaW1wbGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCBzdHJva2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpcyBhIGNvbG9yXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZGVjbC5zdHJva2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEZpbGxTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgdmFyIGZpbGwgPSBkZWNsLmZpbGw7XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBpZiAoZmlsbC50b0xpdmUpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b0xpdmUoY3R4LCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIGRlY2wuZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldENsaXBwaW5nUHJvcGVydGllczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU2V0cyBsaW5lIGRhc2hcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gc2V0IHRoZSBkYXNoIGxpbmUgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoQXJyYXkgYXJyYXkgcmVwcmVzZW50aW5nIGRhc2hlc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFsdGVybmF0aXZlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGxpbmVEYXNoXG4gICAgICovXG4gICAgX3NldExpbmVEYXNoOiBmdW5jdGlvbihjdHgsIGRhc2hBcnJheSwgYWx0ZXJuYXRpdmUpIHtcbiAgICAgIGlmICghZGFzaEFycmF5IHx8IGRhc2hBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0d28gY29waWVzIHRoZSBkYXNoIGxpc3Qgd2hlbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIG9kZFxuICAgICAgaWYgKDEgJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGRhc2hBcnJheS5wdXNoLmFwcGx5KGRhc2hBcnJheSwgZGFzaEFycmF5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFsdGVybmF0aXZlICYmIGFsdGVybmF0aXZlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zLCBkcmF3Qm9yZGVycywgZHJhd0NvbnRyb2xzO1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwgeyB9O1xuICAgICAgZHJhd0JvcmRlcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQm9yZGVycyA6IHRoaXMuaGFzQm9yZGVycztcbiAgICAgIGRyYXdDb250cm9scyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJyA/IHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzO1xuICAgICAgbWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh2cHQsIG1hdHJpeCk7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UobWF0cml4KTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAxICogdGhpcy5ib3JkZXJTY2FsZUZhY3RvcjtcbiAgICAgIGlmICghdGhpcy5ncm91cCkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVPdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24pIHtcbiAgICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuYW5nbGUpKTtcbiAgICAgICAgZHJhd0JvcmRlcnMgJiYgdGhpcy5kcmF3Qm9yZGVyc0luR3JvdXAoY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzKGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBkcmF3Q29udHJvbHMgJiYgdGhpcy5kcmF3Q29udHJvbHMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzaGFkb3cgPSB0aGlzLnNoYWRvdywgY2FudmFzID0gdGhpcy5jYW52YXMsIHNjYWxpbmcsXG4gICAgICAgICAgbXVsdFggPSAoY2FudmFzICYmIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVswXSkgfHwgMSxcbiAgICAgICAgICBtdWx0WSA9IChjYW52YXMgJiYgY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzNdKSB8fCAxO1xuICAgICAgaWYgKHNoYWRvdy5ub25TY2FsaW5nKSB7XG4gICAgICAgIHNjYWxpbmcgPSB7IHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIG11bHRYICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBtdWx0WSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvdy5jb2xvcjtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIgKiBmYWJyaWMuYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudCAqXG4gICAgICAgIChtdWx0WCArIG11bHRZKSAqIChzY2FsaW5nLnNjYWxlWCArIHNjYWxpbmcuc2NhbGVZKSAvIDQ7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYICogbXVsdFggKiBzY2FsaW5nLnNjYWxlWDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFkgKiBtdWx0WSAqIHNjYWxpbmcuc2NhbGVZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxsZXIgZmFicmljLlBhdHRlcm4gb3IgZmFicmljLkdyYWRpZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WCBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WSBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtOiBmdW5jdGlvbihjdHgsIGZpbGxlcikge1xuICAgICAgaWYgKCFmaWxsZXIgfHwgIWZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9O1xuICAgICAgfVxuICAgICAgdmFyIHQgPSBmaWxsZXIuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZmlsbGVyLnBhdHRlcm5UcmFuc2Zvcm07XG4gICAgICB2YXIgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMiArIGZpbGxlci5vZmZzZXRYIHx8IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDIgKyBmaWxsZXIub2Zmc2V0WSB8fCAwO1xuXG4gICAgICBpZiAoZmlsbGVyLmdyYWRpZW50VW5pdHMgPT09ICdwZXJjZW50YWdlJykge1xuICAgICAgICBjdHgudHJhbnNmb3JtKHRoaXMud2lkdGgsIDAsIDAsIHRoaXMuaGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIDEsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgfVxuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0WzBdLCB0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhaW50SW5PcmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZnVuY3Rpb24gdGhhdCBhY3R1YWxseSByZW5kZXIgc29tZXRoaW5nIG9uIHRoZSBjb250ZXh0LlxuICAgICAqIGVtcHR5IGhlcmUgdG8gYWxsb3cgT2JlY3RzIHRvIHdvcmsgb24gdGVzdHMgdG8gYmVuY2htYXJrIGZhYnJpYyBmdW5jdGlvbmFsaXRlc1xuICAgICAqIG5vdCByZWxhdGVkIHRvIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigvKiBjdHggKi8pIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5maWxsUnVsZSA9PT0gJ2V2ZW5vZGQnKSB7XG4gICAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAodGhpcy5zdHJva2VVbmlmb3JtICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdmFyIHNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsaW5nLnNjYWxlWCwgMSAvIHNjYWxpbmcuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc3Ryb2tlVW5pZm9ybSkge1xuICAgICAgICBjdHguc2NhbGUoMSAvIHRoaXMuc2NhbGVYLCAxIC8gdGhpcy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSwgdGhpcy5fcmVuZGVyRGFzaGVkU3Ryb2tlKTtcbiAgICAgIHRoaXMuX3NldFN0cm9rZVN0eWxlcyhjdHgsIHRoaXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cnkgdG8gcGF0Y2ggdGhlIG1pc3NpbmcgZ3JhZGllbnRUcmFuc2Zvcm0gb24gY2FudmFzIGdyYWRpZW50cy5cbiAgICAgKiB0cmFuc2Zvcm1pbmcgYSBjb250ZXh0IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQsIGlzIGdvaW5nIHRvIHRyYW5zZm9ybSB0aGUgc3Ryb2tlIHRvby5cbiAgICAgKiB3ZSB3YW50IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQgYnV0IG5vdCB0aGUgc3Ryb2tlIG9wZXJhdGlvbiwgc28gd2UgY3JlYXRlXG4gICAgICogYSB0cmFuc2Zvcm1lZCBncmFkaWVudCBvbiBhIHBhdHRlcm4gYW5kIHRoZW4gd2UgdXNlIHRoZSBwYXR0ZXJuIGluc3RlYWQgb2YgdGhlIGdyYWRpZW50LlxuICAgICAqIHRoaXMgbWV0aG9kIGhhcyBkcndhYmFja3M6IGlzIHNsb3csIGlzIGluIGxvdyByZXNvbHV0aW9uLCBuZWVkcyBhIHBhdGNoIGZvciB3aGVuIHRoZSBzaXplXG4gICAgICogaXMgbGltaXRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5HcmFkaWVudH0gZmlsbGVyIGEgZmFicmljIGdyYWRpZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkZvclRyYW5zZm9ybWVkR3JhZGllbnQ6IGZ1bmN0aW9uKGN0eCwgZmlsbGVyKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuX2xpbWl0Q2FjaGVTaXplKHRoaXMuX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucygpKSxcbiAgICAgICAgICBwQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLCBwQ3R4LCByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpLFxuICAgICAgICAgIHdpZHRoID0gZGltcy54IC8gdGhpcy5zY2FsZVggLyByZXRpbmFTY2FsaW5nLCBoZWlnaHQgPSBkaW1zLnkgLyB0aGlzLnNjYWxlWSAvIHJldGluYVNjYWxpbmc7XG4gICAgICBwQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBwQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHBDdHggPSBwQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBwQ3R4LmJlZ2luUGF0aCgpOyBwQ3R4Lm1vdmVUbygwLCAwKTsgcEN0eC5saW5lVG8od2lkdGgsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHBDdHgubGluZVRvKDAsIGhlaWdodCk7IHBDdHguY2xvc2VQYXRoKCk7XG4gICAgICBwQ3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgcEN0eC5zY2FsZShcbiAgICAgICAgZGltcy56b29tWCAvIHRoaXMuc2NhbGVYIC8gcmV0aW5hU2NhbGluZyxcbiAgICAgICAgZGltcy56b29tWSAvIHRoaXMuc2NhbGVZIC8gcmV0aW5hU2NhbGluZ1xuICAgICAgKTtcbiAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKHBDdHgsIGZpbGxlcik7XG4gICAgICBwQ3R4LmZpbGxTdHlsZSA9IGZpbGxlci50b0xpdmUoY3R4KTtcbiAgICAgIHBDdHguZmlsbCgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy53aWR0aCAvIDIgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyKTtcbiAgICAgIGN0eC5zY2FsZShcbiAgICAgICAgcmV0aW5hU2NhbGluZyAqIHRoaXMuc2NhbGVYIC8gZGltcy56b29tWCxcbiAgICAgICAgcmV0aW5hU2NhbGluZyAqIHRoaXMuc2NhbGVZIC8gZGltcy56b29tWVxuICAgICAgKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBDdHguY3JlYXRlUGF0dGVybihwQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCBpbiB0aGUgc3ZnXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgcG9pbnQgZnJvbSBlbGVtZW50IGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgeTogdGhpcy50b3AgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IGRlY29tcG9zZSB0aGUgdHJhbnNmb3JtTWF0cml4XG4gICAgICogYW5kIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIG9iamVjdC5cbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgdGhpcy5mbGlwWCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsaXBZID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICAgIHRoaXMuc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgICB0aGlzLnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgICAgdGhpcy5za2V3WSA9IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZW1vdmVzIHRoZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICogYW5kIHNldCB0byBvYmplY3QgcHJvcGVydGllcyB0aGF0IGZhYnJpY2pzIGNhbiBoYW5kbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9uc1xuICAgICAqIEByZXR1cm4ge3RoaXNBcmd9XG4gICAgICovXG4gICAgX3JlbW92ZVRyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24ocHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9maW5kQ2VudGVyRnJvbUVsZW1lbnQoKTtcbiAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB0aGlzLl9hc3NpZ25UcmFuc2Zvcm1NYXRyaXhQcm9wcygpO1xuICAgICAgICBjZW50ZXIgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChjZW50ZXIsIHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gbnVsbDtcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucykge1xuICAgICAgICB0aGlzLnNjYWxlWCAqPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5zY2FsZVg7XG4gICAgICAgIHRoaXMuc2NhbGVZICo9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLnNjYWxlWTtcbiAgICAgICAgdGhpcy5jcm9wWCA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmNyb3BYO1xuICAgICAgICB0aGlzLmNyb3BZID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuY3JvcFk7XG4gICAgICAgIGNlbnRlci54ICs9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLm9mZnNldExlZnQ7XG4gICAgICAgIGNlbnRlci55ICs9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLm9mZnNldFRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsb25lcyBhbiBpbnN0YW5jZSwgdXNpbmcgYSBjYWxsYmFjayBtZXRob2Qgd2lsbCB3b3JrIGZvciBldmVyeSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIGEgY2xvbmUgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oY2FsbGJhY2ssIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3RGb3JtID0gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3QpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KG9iamVjdEZvcm0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdPYmplY3QnLCBvYmplY3RGb3JtLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLkltYWdlIG91dCBvZiBhbiBvYmplY3RcbiAgICAgKiBtYWtlcyB1c2Ugb2YgdG9DYW52YXNFbGVtZW50LlxuICAgICAqIE9uY2UgdGhpcyBtZXRob2Qgd2FzIGJhc2VkIG9uIHRvRGF0YVVybCBhbmQgbG9hZEltYWdlLCBzbyBpdCBhbHNvIGhhZCBhIHF1YWxpdHlcbiAgICAgKiBhbmQgZm9ybWF0IG9wdGlvbi4gdG9DYW52YXNFbGVtZW50IGlzIGZhc3RlciBhbmQgcHJvZHVjZSBubyBsb3NzIG9mIHF1YWxpdHkuXG4gICAgICogSWYgeW91IG5lZWQgdG8gZ2V0IGEgcmVhbCBKcGVnIG9yIFBuZyBmcm9tIGFuIG9iamVjdCwgdXNpbmcgdG9EYXRhVVJMIGlzIHRoZSByaWdodCB3YXkgdG8gZG8gaXQuXG4gICAgICogdG9DYW52YXNFbGVtZW50IGFuZCB0aGVuIHRvQmxvYiBmcm9tIHRoZSBvYnRhaW5lZCBjYW52YXMgaXMgYWxzbyBhIGdvb2Qgb3B0aW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHN5bmMgbm93LCBidXQgc3RpbGwgc3VwcG9ydCB0aGUgY2FsbGJhY2sgYmVjYXVzZSB3ZSBkaWQgbm90IHdhbnQgdG8gYnJlYWsuXG4gICAgICogV2hlbiBmYWJyaWNKUyA1LjAgd2lsbCBiZSBwbGFubmVkLCB0aGlzIHdpbGwgcHJvYmFibHkgYmUgY2hhbmdlZCB0byBub3QgaGF2ZSBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrLCBpbnZva2VkIHdpdGggYW4gaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZm9yIGNsb25lIGFzIGltYWdlLCBwYXNzZWQgdG8gdG9EYXRhVVJMXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBjbG9uZUFzSW1hZ2U6IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2FudmFzRWwgPSB0aGlzLnRvQ2FudmFzRWxlbWVudChvcHRpb25zKTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGNhbnZhc0VsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBIVE1MQ2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMS42LjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm1dIFJlbW92ZSBjdXJyZW50IG9iamVjdCB0cmFuc2Zvcm0gKCBubyBzY2FsZSAsIG5vIGFuZ2xlLCBubyBmbGlwLCBubyBza2V3ICkuIEludHJvZHVjZWQgaW4gMi4zLjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRTaGFkb3ddIFJlbW92ZSBjdXJyZW50IG9iamVjdCBzaGFkb3cuIEludHJvZHVjZWQgaW4gMi40LjJcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gUmV0dXJucyBET00gZWxlbWVudCA8Y2FudmFzPiB3aXRoIHRoZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgdG9DYW52YXNFbGVtZW50OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHV0aWxzID0gZmFicmljLnV0aWwsIG9yaWdQYXJhbXMgPSB1dGlscy5zYXZlT2JqZWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgIG9yaWdpbmFsR3JvdXAgPSB0aGlzLmdyb3VwLFxuICAgICAgICAgIG9yaWdpbmFsU2hhZG93ID0gdGhpcy5zaGFkb3csIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSAob3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEpICogKG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMSk7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cDtcbiAgICAgIGlmIChvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdXRpbHMucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy53aXRob3V0U2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIC8vIHNraXAgY2FudmFzIHpvb20gYW5kIGNhbGN1bGF0ZSB3aXRoIHNldENvb3JkcyBub3cuXG4gICAgICAgICAgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QodHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgc2hhZG93ID0gdGhpcy5zaGFkb3csIHNjYWxpbmcsXG4gICAgICAgICAgc2hhZG93T2Zmc2V0ID0geyB4OiAwLCB5OiAwIH0sIHNoYWRvd0JsdXIsXG4gICAgICAgICAgd2lkdGgsIGhlaWdodDtcblxuICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICBzaGFkb3dCbHVyID0gc2hhZG93LmJsdXI7XG4gICAgICAgIGlmIChzaGFkb3cubm9uU2NhbGluZykge1xuICAgICAgICAgIHNjYWxpbmcgPSB7IHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNpZGVyIG5vbiBzY2FsaW5nIHNoYWRvdy5cbiAgICAgICAgc2hhZG93T2Zmc2V0LnggPSAyICogTWF0aC5yb3VuZChhYnMoc2hhZG93Lm9mZnNldFgpICsgc2hhZG93Qmx1cikgKiAoYWJzKHNjYWxpbmcuc2NhbGVYKSk7XG4gICAgICAgIHNoYWRvd09mZnNldC55ID0gMiAqIE1hdGgucm91bmQoYWJzKHNoYWRvdy5vZmZzZXRZKSArIHNoYWRvd0JsdXIpICogKGFicyhzY2FsaW5nLnNjYWxlWSkpO1xuICAgICAgfVxuICAgICAgd2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggKyBzaGFkb3dPZmZzZXQueDtcbiAgICAgIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBzaGFkb3dPZmZzZXQueTtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHdpZHRoL2hlaWdodCBpcyBub3QgYW4gaW50ZWdlclxuICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIGl0IHNvLlxuICAgICAgZWwud2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuICAgICAgZWwuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgICB2YXIgY2FudmFzID0gbmV3IGZhYnJpYy5TdGF0aWNDYW52YXMoZWwsIHtcbiAgICAgICAgZW5hYmxlUmV0aW5hU2NhbGluZzogZmFsc2UsXG4gICAgICAgIHJlbmRlck9uQWRkUmVtb3ZlOiBmYWxzZSxcbiAgICAgICAgc2tpcE9mZnNjcmVlbjogZmFsc2UsXG4gICAgICB9KTtcbiAgICAgIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ2pwZWcnKSB7XG4gICAgICAgIGNhbnZhcy5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZic7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4obmV3IGZhYnJpYy5Qb2ludChjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiksICdjZW50ZXInLCAnY2VudGVyJyk7XG5cbiAgICAgIHZhciBvcmlnaW5hbENhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2FudmFzLmFkZCh0aGlzKTtcbiAgICAgIHZhciBjYW52YXNFbCA9IGNhbnZhcy50b0NhbnZhc0VsZW1lbnQobXVsdGlwbGllciB8fCAxLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2hhZG93ID0gb3JpZ2luYWxTaGFkb3c7XG4gICAgICB0aGlzLnNldCgnY2FudmFzJywgb3JpZ2luYWxDYW52YXMpO1xuICAgICAgaWYgKG9yaWdpbmFsR3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cCA9IG9yaWdpbmFsR3JvdXA7XG4gICAgICB9XG4gICAgICB0aGlzLnNldChvcmlnUGFyYW1zKS5zZXRDb29yZHMoKTtcbiAgICAgIC8vIGNhbnZhcy5kaXNwb3NlIHdpbGwgY2FsbCBpbWFnZS5kaXNwb3NlIHRoYXQgd2lsbCBudWxsaWZ5IHRoZSBlbGVtZW50c1xuICAgICAgLy8gc2luY2UgdGhpcyBjYW52YXMgaXMgYSBzaW1wbGUgZWxlbWVudCBmb3IgdGhlIHByb2Nlc3MsIHdlIHJlbW92ZSByZWZlcmVuY2VzXG4gICAgICAvLyB0byBvYmplY3RzIGluIHRoaXMgd2F5IGluIG9yZGVyIHRvIGF2b2lkIG9iamVjdCB0cmFzaGluZy5cbiAgICAgIGNhbnZhcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgY2FudmFzLmRpc3Bvc2UoKTtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBjYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBkYXRhLXVybC1saWtlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMS42LjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm1dIFJlbW92ZSBjdXJyZW50IG9iamVjdCB0cmFuc2Zvcm0gKCBubyBzY2FsZSAsIG5vIGFuZ2xlLCBubyBmbGlwLCBubyBza2V3ICkuIEludHJvZHVjZWQgaW4gMi4zLjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRTaGFkb3ddIFJlbW92ZSBjdXJyZW50IG9iamVjdCBzaGFkb3cuIEludHJvZHVjZWQgaW4gMi40LjJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBkYXRhOiBVUkwgY29udGFpbmluZyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgb3B0aW9ucy5mb3JtYXRcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRvRGF0YVVSTCh0aGlzLnRvQ2FudmFzRWxlbWVudChvcHRpb25zKSwgb3B0aW9ucy5mb3JtYXQgfHwgJ3BuZycsIG9wdGlvbnMucXVhbGl0eSB8fCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHNwZWNpZmllZCB0eXBlIGlzIGlkZW50aWNhbCB0byB0aGUgdHlwZSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZSAoaXMgMSB1bmxlc3Mgc3ViY2xhc3NlZClcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT05cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vIGRlbGVnYXRlLCBub3QgYWxpYXNcbiAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFwiYW5nbGVcIiBvZiBhbiBpbnN0YW5jZSB3aXRoIGNlbnRlcmVkIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIEFuZ2xlIHZhbHVlIChpbiBkZWdyZWVzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgdmFyIHNob3VsZENlbnRlck9yaWdpbiA9ICh0aGlzLm9yaWdpblggIT09ICdjZW50ZXInIHx8IHRoaXMub3JpZ2luWSAhPT0gJ2NlbnRlcicpICYmIHRoaXMuY2VudGVyZWRSb3RhdGlvbjtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9zZXRPcmlnaW5Ub0NlbnRlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCgnYW5nbGUnLCBhbmdsZSk7XG5cbiAgICAgIGlmIChzaG91bGRDZW50ZXJPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fcmVzZXRPcmlnaW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlckg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdEgodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlckg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0Vih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlclY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0Vih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgb24gY2FudmFzIHRvIHdoaWNoIGlzIHdhcyBhZGRlZCBsYXN0XG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgcmVsYXRpdmUgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCB0byBvcGVyYXRlIHVwb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIFBvaW50ZXIgdG8gb3BlcmF0ZSB1cG9uIChpbnN0ZWFkIG9mIGV2ZW50KVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBwb2ludGVyICh4LCB5KVxuICAgICAqL1xuICAgIGdldExvY2FsUG9pbnRlcjogZnVuY3Rpb24oZSwgcG9pbnRlcikge1xuICAgICAgcG9pbnRlciA9IHBvaW50ZXIgfHwgdGhpcy5jYW52YXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHZhciBwQ2xpY2tlZCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpLFxuICAgICAgICAgIG9iamVjdExlZnRUb3AgPSB0aGlzLl9nZXRMZWZ0VG9wQ29vcmRzKCk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwQ2xpY2tlZCA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KFxuICAgICAgICAgIHBDbGlja2VkLCBvYmplY3RMZWZ0VG9wLCBkZWdyZWVzVG9SYWRpYW5zKC10aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwQ2xpY2tlZC54IC0gb2JqZWN0TGVmdFRvcC54LFxuICAgICAgICB5OiBwQ2xpY2tlZC55IC0gb2JqZWN0TGVmdFRvcC55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gZm9yIHNwZWNpZmljIG9iamVjdFxuICAgICAqIGN1c3RvbSBjb21wb3NpdGlvbiBvcGVyYXRpb24gZm9yIHRoZSBwYXJ0aWN1bGFyIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIHVzaW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNhbnZhcyBjb250ZXh0XG4gICAgICovXG4gICAgX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzICYmIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuT2JqZWN0KTtcblxuICBleHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byB1c2Ugd2hlbiBzZXJpYWxpemluZyBvYmplY3QgdmFsdWVzLlxuICAgKiBZb3UgY2FuIHVzZSBpdCB0byBpbmNyZWFzZS9kZWNyZWFzZSBwcmVjaXNpb24gb2Ygc3VjaCB2YWx1ZXMgbGlrZSBsZWZ0LCB0b3AsIHNjYWxlWCwgc2NhbGVZLCBldGMuXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTID0gMjtcblxuICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0ID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBvYmplY3QsIGNhbGxiYWNrLCBleHRyYVBhcmFtKSB7XG4gICAgdmFyIGtsYXNzID0gZmFicmljW2NsYXNzTmFtZV07XG4gICAgb2JqZWN0ID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuUGF0dGVybnMoW29iamVjdC5maWxsLCBvYmplY3Quc3Ryb2tlXSwgZnVuY3Rpb24ocGF0dGVybnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5maWxsID0gcGF0dGVybnNbMF07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm5zWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3Quc3Ryb2tlID0gcGF0dGVybnNbMV07XG4gICAgICB9XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbb2JqZWN0LmNsaXBQYXRoXSwgZnVuY3Rpb24oZW5saXZlZFByb3BzKSB7XG4gICAgICAgIG9iamVjdC5jbGlwUGF0aCA9IGVubGl2ZWRQcm9wc1swXTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXh0cmFQYXJhbSA/IG5ldyBrbGFzcyhvYmplY3RbZXh0cmFQYXJhbV0sIG9iamVjdCkgOiBuZXcga2xhc3Mob2JqZWN0KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBpZCB1c2VkIGludGVybmFsbHkgd2hlbiBjcmVhdGluZyBTVkcgZWxlbWVudHNcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuX191aWQgPSAwO1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBvcmlnaW5YT2Zmc2V0ID0ge1xuICAgICAgICBsZWZ0OiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIHJpZ2h0OiAwLjVcbiAgICAgIH0sXG4gICAgICBvcmlnaW5ZT2Zmc2V0ID0ge1xuICAgICAgICB0b3A6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgYm90dG9tOiAwLjVcbiAgICAgIH07XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGEgc2V0IG9mIG9yaWdpbiB0byBhbm90aGVyIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21PcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb0dpdmVuT3JpZ2luOiBmdW5jdGlvbihwb2ludCwgZnJvbU9yaWdpblgsIGZyb21PcmlnaW5ZLCB0b09yaWdpblgsIHRvT3JpZ2luWSkge1xuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgIG9mZnNldFgsIG9mZnNldFksIGRpbTtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblggPSBvcmlnaW5YT2Zmc2V0W2Zyb21PcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblggPSBvcmlnaW5YT2Zmc2V0W3RvT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5YIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WCA9IHRvT3JpZ2luWCAtIGZyb21PcmlnaW5YO1xuXG4gICAgICBpZiAodHlwZW9mIGZyb21PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcm9tT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbZnJvbU9yaWdpblldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZyb21PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b09yaWdpblkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbdG9PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b09yaWdpblkgLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBvZmZzZXRZID0gdG9PcmlnaW5ZIC0gZnJvbU9yaWdpblk7XG5cbiAgICAgIGlmIChvZmZzZXRYIHx8IG9mZnNldFkpIHtcbiAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAgIHggPSBwb2ludC54ICsgb2Zmc2V0WCAqIGRpbS54O1xuICAgICAgICB5ID0gcG9pbnQueSArIG9mZnNldFkgKiBkaW0ueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gb3JpZ2luIHRvIGNlbnRlciBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9DZW50ZXJQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIHBvaW50LCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGNlbnRlciB0byBvcmlnaW4gY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIGNlbnRlciBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIGNlbnRlciwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVhbCBjZW50ZXIgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVmdFRvcCA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KGxlZnRUb3AsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBjZW50ZXIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICAvLyBnZXRPcmlnaW5Qb2ludDogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGFzIGlmIGl0IGhhcyBhIGRpZmZlcmVudCBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0UG9pbnRCeU9yaWdpbjogZnVuY3Rpb24ob3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdG9Mb2NhbFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBwLCBwMjtcblxuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5YICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3JpZ2luWSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHAgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgfVxuXG4gICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwMiA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAyLCBjZW50ZXIsIC1kZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwMi5zdWJ0cmFjdEVxdWFscyhwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gdG9HbG9iYWxQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAvLyAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwb2ludCwgdGhpcy5nZXRDZW50ZXJQb2ludCgpLCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKS5hZGRFcXVhbHMobmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgb2JqZWN0J3Mgb3JpZ2luXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvcyBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uQnlPcmlnaW46IGZ1bmN0aW9uKHBvcywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChwb3MsIG9yaWdpblgsIG9yaWdpblkpLFxuICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgICAgdGhpcy5zZXQoJ2xlZnQnLCBwb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuc2V0KCd0b3AnLCBwb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvIE9uZSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGh5cG90RnVsbCA9IHRoaXMuZ2V0U2NhbGVkV2lkdGgoKSxcbiAgICAgICAgICB4RnVsbCA9IGZhYnJpYy51dGlsLmNvcyhhbmdsZSkgKiBoeXBvdEZ1bGwsXG4gICAgICAgICAgeUZ1bGwgPSBmYWJyaWMudXRpbC5zaW4oYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIG9mZnNldEZyb20sIG9mZnNldFRvO1xuXG4gICAgICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29uc2lkZXIgbWl4ZWQgc2l0dWF0aW9uIGxpa2UgdG9wLCBjZW50ZXIuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IG9yaWdpblhPZmZzZXRbdGhpcy5vcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRGcm9tID0gdGhpcy5vcmlnaW5YIC0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0VG8gPSBvcmlnaW5YT2Zmc2V0W3RvXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRUbyA9IHRvIC0gMC41O1xuICAgICAgfVxuICAgICAgdGhpcy5sZWZ0ICs9IHhGdWxsICogKG9mZnNldFRvIC0gb2Zmc2V0RnJvbSk7XG4gICAgICB0aGlzLnRvcCArPSB5RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMub3JpZ2luWCA9IHRvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcmlnaW4vcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0byBpdCdzIGNlbnRlciBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gdGhpcy5vcmlnaW5YO1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZID0gdGhpcy5vcmlnaW5ZO1xuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgIHRoaXMub3JpZ2luWSA9ICdjZW50ZXInO1xuXG4gICAgICB0aGlzLmxlZnQgPSBjZW50ZXIueDtcbiAgICAgIHRoaXMudG9wID0gY2VudGVyLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBvcmlnaW5hbCBvcmlnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3Jlc2V0T3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChcbiAgICAgICAgdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblgsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSk7XG5cbiAgICAgIHRoaXMub3JpZ2luWCA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWDtcbiAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWTtcblxuICAgICAgdGhpcy5sZWZ0ID0gb3JpZ2luUG9pbnQueDtcbiAgICAgIHRoaXMudG9wID0gb3JpZ2luUG9pbnQueTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gbnVsbDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExlZnRUb3BDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0aGlzLmdldENlbnRlclBvaW50KCksICdsZWZ0JywgJ3RvcCcpO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBhcnJheUZyb21Db29yZHMoY29vcmRzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRsLngsIGNvb3Jkcy50bC55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRyLngsIGNvb3Jkcy50ci55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJyLngsIGNvb3Jkcy5ici55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJsLngsIGNvb3Jkcy5ibC55KVxuICAgIF07XG4gIH1cblxuICB2YXIgdXRpbCA9IGZhYnJpYy51dGlsLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IHV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG11bHRpcGx5TWF0cmljZXMgPSB1dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IHV0aWwudHJhbnNmb3JtUG9pbnQ7XG5cbiAgdXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgZWxlbWVudCBjb29yZGluYXRlcy5cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBkZXBlbmRpbmcgb24gY29udHJvbCBrZXlzIGFuZCBwYWRkaW5nIHRoZSBtYWluIGNvbnRyb2xzLlxuICAgICAqIGVhY2ggcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggeCwgeSBhbmQgY29ybmVyLlxuICAgICAqIFRoZSBgY29ybmVyYCBwcm9wZXJ0eSBjb250YWlucyBpbiBhIHNpbWlsYXIgbWFubmVyIHRoZSA0IHBvaW50cyBvZiB0aGVcbiAgICAgKiBpbnRlcmFjdGl2ZSBhcmVhIG9mIHRoZSBjb3JuZXIuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGRlcGVuZHMgZnJvbSB0aGUgY29udHJvbHMgcG9zaXRpb25IYW5kbGVyIGFuZCBhcmUgdXNlZFxuICAgICAqIHRvIGRyYXcgYW5kIGxvY2F0ZSBjb250cm9sc1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG9Db29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIG9iamVjdCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgICAqIHByb3BlcnRpZXMgYXJlIHRsLHRyLGJsLGJyIGFuZCBkZXNjcmliZSB0aGUgZm91ciBtYWluIGNvcm5lci5cbiAgICAgKiBlYWNoIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHgsIHksIGluc3RhbmNlIG9mIEZhYnJpYy5Qb2ludC5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZGVwZW5kcyBmcm9tIHRoaXMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodCwgc2NhbGVYLCBzY2FsZVlcbiAgICAgKiBza2V3WCwgc2tld1ksIGFuZ2xlLCBzdHJva2VXaWR0aCwgdG9wLCBsZWZ0LlxuICAgICAqIFRob3NlIGNvb3JkaW5hdGVzIGFyZSB1c2VmdWwgdG8gdW5kZXJzdGFuZCB3aGVyZSBhbiBvYmplY3QgaXMuIFRoZXkgZ2V0IHVwZGF0ZWRcbiAgICAgKiB3aXRoIG9Db29yZHMgYnV0IHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgdXBkYXRlZCB3aGVuIHpvb20gb3IgcGFubmluZyBjaGFuZ2UuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBzZXRDb29yZHMuXG4gICAgICogWW91IGNhbiBjYWxjdWxhdGUgdGhlbSB3aXRob3V0IHVwZGF0aW5nIHdpdGggQG1ldGhvZCBjYWxjQUNvb3JkcygpO1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFDb29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogaW5jbHVkZXMgcGFkZGluZy4gVXNlZCBvZiBvYmplY3QgZGV0ZWN0aW9uLlxuICAgICAqIHNldCBhbmQgcmVmcmVzaGVkIHdpdGggc2V0Q29vcmRzIGFuZCBjYWxjQ29vcmRzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxpbmVDb29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG93bk1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogc3RvcmFnZSBmb3Igb2JqZWN0IGZ1bGwgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogY3VzdG9tIGNvbnRyb2xzIGludGVyZmFjZVxuICAgICAqIGNvbnRyb2xzIGFyZSBhZGRlZCBieSBkZWZhdWx0X2NvbnRyb2xzLmpzXG4gICAgICovXG4gICAgY29udHJvbHM6IHsgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBjb3JyZWN0IHNldCBvZiBjb29yZGluYXRlcyBmb3IgaW50ZXJzZWN0aW9uXG4gICAgICogdGhpcyB3aWxsIHJldHVybiBlaXRoZXIgYUNvb3JkcyBvciBsaW5lQ29vcmRzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgd2lsbCByZXR1cm4gYUNvb3JkcyBpZiB0cnVlIG9yIGxpbmVDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0bCwgdHIsIGJyLCBibH0gcG9pbnRzXG4gICAgICovXG4gICAgX2dldENvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKGNhbGN1bGF0ZSkge1xuICAgICAgICByZXR1cm4gKGFic29sdXRlID8gdGhpcy5jYWxjQUNvb3JkcygpIDogdGhpcy5jYWxjTGluZUNvb3JkcygpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5hQ29vcmRzIHx8ICF0aGlzLmxpbmVDb29yZHMpIHtcbiAgICAgICAgdGhpcy5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGFic29sdXRlID8gdGhpcy5hQ29vcmRzIDogdGhpcy5saW5lQ29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNvcnJlY3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGZvciBpbnRlcnNlY3Rpb25cbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIGVpdGhlciBhQ29vcmRzIG9yIGxpbmVDb29yZHMuXG4gICAgICogVGhlIGNvb3JkcyBhcmUgcmV0dXJuZWQgaW4gYW4gYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFt0bCwgdHIsIGJyLCBibF0gb2YgcG9pbnRzXG4gICAgICovXG4gICAgZ2V0Q29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICByZXR1cm4gYXJyYXlGcm9tQ29vcmRzKHRoaXMuX2dldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaW50ZXJzZWN0c1dpdGhSZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKFxuICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgcG9pbnRUTCxcbiAgICAgICAgICAgIHBvaW50QlJcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbi5zdGF0dXMgPT09ICdJbnRlcnNlY3Rpb24nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBPYmplY3QgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoT2JqZWN0OiBmdW5jdGlvbihvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblBvbHlnb24oXG4gICAgICAgIHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICBvdGhlci5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJ1xuICAgICAgICB8fCBvdGhlci5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKVxuICAgICAgICB8fCB0aGlzLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpbk9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBvdGhlckNvb3JkcyA9IGFic29sdXRlID8gb3RoZXIuYUNvb3JkcyA6IG90aGVyLmxpbmVDb29yZHMsXG4gICAgICAgICAgaSA9IDAsIGxpbmVzID0gb3RoZXIuX2dldEltYWdlTGluZXMob3RoZXJDb29yZHMpO1xuICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgaWYgKCFvdGhlci5jb250YWluc1BvaW50KHBvaW50c1tpXSwgbGluZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqL1xuICAgIGlzQ29udGFpbmVkV2l0aGluUmVjdDogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlLCBjYWxjdWxhdGUpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgKyBib3VuZGluZ1JlY3Qud2lkdGggPD0gcG9pbnRCUi54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgPj0gcG9pbnRUTC55ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IDw9IHBvaW50QlIueVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpbmVzXSBvYmplY3QgcmV0dXJuZWQgZnJvbSBAbWV0aG9kIF9nZXRJbWFnZUxpbmVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBsaW5lcywgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2dldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBsaW5lcyA9IGxpbmVzIHx8IHRoaXMuX2dldEltYWdlTGluZXMoY29vcmRzKSxcbiAgICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHBvaW50LCBsaW5lcyk7XG4gICAgICAvLyBpZiB4UG9pbnRzIGlzIG9kZCB0aGVuIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICByZXR1cm4gKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiB0aGUgY2hlY2sgaXMgZG9uZSBzdG9wcGluZyBhdCBmaXJzdCBwb2ludCB0aGF0IGFwcGVhcnMgb24gc2NyZWVuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgb3IgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0Q29vcmRzKHRydWUsIGNhbGN1bGF0ZSk7XG4gICAgICAvLyBpZiBzb21lIHBvaW50IGlzIG9uIHNjcmVlbiwgdGhlIG9iamVjdCBpcyBvbiBzY3JlZW4uXG4gICAgICBpZiAocG9pbnRzLnNvbWUoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPD0gcG9pbnRCUi54ICYmIHBvaW50LnggPj0gcG9pbnRUTC54ICYmXG4gICAgICAgIHBvaW50LnkgPD0gcG9pbnRCUi55ICYmIHBvaW50LnkgPj0gcG9pbnRUTC55O1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBubyBwb2ludHMgb24gc2NyZWVuLCBjaGVjayBpbnRlcnNlY3Rpb24gd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgbWlkcG9pbnQgYmV0d2VlbiBjYW52YXMgZXh0cmVtaXRpZXNcbiAgICAgKiBEb2VzIG5vdCBtYWtlIHNlbnNlIG91dHNpZGUgdGhlIGNvbnRleHQgb2YgaXNPblNjcmVlbiBhbmQgaXNQYXJ0aWFsbHlPblNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGYWJyaWMuUG9pbnR9IHBvaW50VEwgVG9wIExlZnQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRCUiBUb3AgUmlnaHQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbGN1bGF0ZSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9jb250YWluc0NlbnRlck9mQ2FudmFzOiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpIHtcbiAgICAgIC8vIHdvcnN0IGNhc2Ugc2NlbmFyaW8gdGhlIG9iamVjdCBpcyBzbyBiaWcgdGhhdCBjb250YWlucyB0aGUgc2NyZWVuXG4gICAgICB2YXIgY2VudGVyUG9pbnQgPSB7IHg6IChwb2ludFRMLnggKyBwb2ludEJSLngpIC8gMiwgeTogKHBvaW50VEwueSArIHBvaW50QlIueSkgLyAyIH07XG4gICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KGNlbnRlclBvaW50LCBudWxsLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNQYXJ0aWFsbHlPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgYWxsUG9pbnRzQXJlT3V0c2lkZSA9IHRoaXMuZ2V0Q29vcmRzKHRydWUsIGNhbGN1bGF0ZSkuZXZlcnkoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChwb2ludC54ID49IHBvaW50QlIueCB8fCBwb2ludC54IDw9IHBvaW50VEwueCkgJiZcbiAgICAgICAgKHBvaW50LnkgPj0gcG9pbnRCUi55IHx8IHBvaW50LnkgPD0gcG9pbnRUTC55KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFsbFBvaW50c0FyZU91dHNpZGUgJiYgdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZWRnZXMgaW4gaXQsIGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9Db29yZHMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBjb3JuZXJzXG4gICAgICovXG4gICAgX2dldEltYWdlTGluZXM6IGZ1bmN0aW9uKG9Db29yZHMpIHtcblxuICAgICAgdmFyIGxpbmVzID0ge1xuICAgICAgICB0b3BsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50bCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRyXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0bGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMudHIsXG4gICAgICAgICAgZDogb0Nvb3Jkcy5iclxuICAgICAgICB9LFxuICAgICAgICBib3R0b21saW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5icixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZnRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5ibCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRsXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIC8vIGRlYnVnZ2luZ1xuICAgICAgLy8gaWYgKHRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLmQueCwgbGluZXMuYm90dG9tbGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuby54LCBsaW5lcy5ib3R0b21saW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5vLngsIGxpbmVzLmxlZnRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5vLngsIGxpbmVzLnRvcGxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLmQueCwgbGluZXMucmlnaHRsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLm8ueCwgbGluZXMucmlnaHRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgY3Jvc3MgcG9pbnRzIGFyZSBiZXR3ZWVuIHRoZSA0IG9iamVjdCBlZGdlc1xuICAgICAqIGFuZCB0aGUgaG9yaXpvbnRhbCBsaW5lIGRldGVybWluZWQgYnkgYSBwb2ludCBvbiBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lcyBDb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGJlaW5nIGV2YWx1YXRlZFxuICAgICAqL1xuICAgIC8vIHJlbW92ZSB5aSwgbm90IHVzZWQgYnV0IGxlZnQgY29kZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBfZmluZENyb3NzUG9pbnRzOiBmdW5jdGlvbihwb2ludCwgbGluZXMpIHtcbiAgICAgIHZhciBiMSwgYjIsIGExLCBhMiwgeGksIC8vIHlpLFxuICAgICAgICAgIHhjb3VudCA9IDAsXG4gICAgICAgICAgaUxpbmU7XG5cbiAgICAgIGZvciAodmFyIGxpbmVLZXkgaW4gbGluZXMpIHtcbiAgICAgICAgaUxpbmUgPSBsaW5lc1tsaW5lS2V5XTtcbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDE6IGxpbmUgYmVsb3cgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55IDwgcG9pbnQueSkgJiYgKGlMaW5lLmQueSA8IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDI6IGxpbmUgYWJvdmUgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55ID49IHBvaW50LnkpICYmIChpTGluZS5kLnkgPj0gcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMzogdmVydGljYWwgbGluZSBjYXNlXG4gICAgICAgIGlmICgoaUxpbmUuby54ID09PSBpTGluZS5kLngpICYmIChpTGluZS5vLnggPj0gcG9pbnQueCkpIHtcbiAgICAgICAgICB4aSA9IGlMaW5lLm8ueDtcbiAgICAgICAgICAvLyB5aSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gKGlMaW5lLmQueSAtIGlMaW5lLm8ueSkgLyAoaUxpbmUuZC54IC0gaUxpbmUuby54KTtcbiAgICAgICAgICBhMSA9IHBvaW50LnkgLSBiMSAqIHBvaW50Lng7XG4gICAgICAgICAgYTIgPSBpTGluZS5vLnkgLSBiMiAqIGlMaW5lLm8ueDtcblxuICAgICAgICAgIHhpID0gLShhMSAtIGEyKSAvIChiMSAtIGIyKTtcbiAgICAgICAgICAvLyB5aSA9IGExICsgYjEgKiB4aTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb250IGNvdW50IHhpIDwgcG9pbnQueCBjYXNlc1xuICAgICAgICBpZiAoeGkgPj0gcG9pbnQueCkge1xuICAgICAgICAgIHhjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiA0OiBzcGVjaWZpYyBmb3Igc3F1YXJlIGltYWdlc1xuICAgICAgICBpZiAoeGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB4Y291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICogdGhlIGJveCBpcyBpbnRlbmRlZCBhcyBhbGlnbmVkIHRvIGF4aXMgb2YgY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3JkcyAvIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpO1xuICAgICAgcmV0dXJuIHV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhjb29yZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdpZHRoIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRXaWR0aCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGggdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTY2FsZWRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWlnaHQgb2YgYW4gb2JqZWN0IGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRIZWlnaHQoKTtcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGUgc2NhbGUgaXMgdmFsaWQgYW5kIG1vZGlmaWVzIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9jb25zdHJhaW5TY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCB0aGlzLm1pblNjYWxlTGltaXQpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgIHJldHVybiAtdGhpcy5taW5TY2FsZUxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgKGVxdWFsbHkgYnkgeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgU2NhbGUgZmFjdG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldCgnc2NhbGVYJywgdmFsdWUpO1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVknLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIHdpZHRoLCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgd2lkdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIGlnbm9yZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGVUb1dpZHRoOiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLndpZHRoIC8gdGhpcy5nZXRTY2FsZWRXaWR0aCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUgLyB0aGlzLndpZHRoIC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIGhlaWdodCwgd2l0aCByZXNwZWN0IHRvIGJvdW5kaW5nIGJveCAoc2NhbGluZyBieSB4L3kgZXF1YWxseSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgTmV3IGhlaWdodCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLmhlaWdodCAvIHRoaXMuZ2V0U2NhbGVkSGVpZ2h0KCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMuaGVpZ2h0IC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgLmNvb3JkcyBvZiBhbiBvYmplY3QuXG4gICAgICogdW51c2VkIGJ5IHRoZSBsaWJyYXJ5LCBvbmx5IGZvciB0aGUgZW5kIGRldi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIHRsLCB0ciwgYnIsIGJsIC4uLi5cbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBjYWxjQ29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSkge1xuICAgICAgLy8gdGhpcyBpcyBhIGNvbXBhdGliaWxpdHkgZnVuY3Rpb24gdG8gYXZvaWQgcmVtb3ZpbmcgY2FsY0Nvb3JkcyBub3cuXG4gICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY0FDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGNPQ29vcmRzKCk7XG4gICAgfSxcblxuICAgIGNhbGNMaW5lQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgcGFkZGluZyA9IHRoaXMucGFkZGluZywgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGNvcyA9IHV0aWwuY29zKGFuZ2xlKSwgc2luID0gdXRpbC5zaW4oYW5nbGUpLFxuICAgICAgICAgIGNvc1AgPSBjb3MgKiBwYWRkaW5nLCBzaW5QID0gc2luICogcGFkZGluZywgY29zUFNpblAgPSBjb3NQICsgc2luUCxcbiAgICAgICAgICBjb3NQTWludXNTaW5QID0gY29zUCAtIHNpblAsIGFDb29yZHMgPSB0aGlzLmNhbGNBQ29vcmRzKCk7XG5cbiAgICAgIHZhciBsaW5lQ29vcmRzID0ge1xuICAgICAgICB0bDogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy50bCwgdnB0KSxcbiAgICAgICAgdHI6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMudHIsIHZwdCksXG4gICAgICAgIGJsOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLmJsLCB2cHQpLFxuICAgICAgICBicjogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy5iciwgdnB0KSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgIGxpbmVDb29yZHMudGwueCAtPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLnRsLnkgLT0gY29zUFNpblA7XG4gICAgICAgIGxpbmVDb29yZHMudHIueCArPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy50ci55IC09IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYmwueCAtPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ibC55ICs9IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYnIueCArPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJyLnkgKz0gY29zUFNpblA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lQ29vcmRzO1xuICAgIH0sXG5cbiAgICBjYWxjT0Nvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm90YXRlTWF0cml4ID0gdGhpcy5fY2FsY1JvdGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgc3RhcnRNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHZwdCwgdHJhbnNsYXRlTWF0cml4KSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMoc3RhcnRNYXRyaXgsIHJvdGF0ZU1hdHJpeCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKGZpbmFsTWF0cml4LCBbMSAvIHZwdFswXSwgMCwgMCwgMSAvIHZwdFszXSwgMCwgMF0pLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgY29vcmRzID0ge307XG4gICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgIGNvb3Jkc1trZXldID0gY29udHJvbC5wb3NpdGlvbkhhbmRsZXIoZGltLCBmaW5hbE1hdHJpeCwgZmFicmljT2JqZWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkZWJ1ZyBjb2RlXG4gICAgICAvLyB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAvLyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBjYW52YXMuY29udGV4dFRvcC5jbGVhclJlY3QoMCwgMCwgNzAwLCA3MDApO1xuICAgICAgLy8gICBjYW52YXMuY29udGV4dFRvcC5maWxsU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgLy8gICBPYmplY3Qua2V5cyhjb29yZHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAvLyAgICAgdmFyIGNvbnRyb2wgPSBjb29yZHNba2V5XTtcbiAgICAgIC8vICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChjb250cm9sLngsIGNvbnRyb2wueSwgMywgMyk7XG4gICAgICAvLyAgIH0pO1xuICAgICAgLy8gfSwgNTApO1xuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9LFxuXG4gICAgY2FsY0FDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJvdGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNSb3RhdGVNYXRyaXgoKSxcbiAgICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRyYW5zbGF0ZU1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB3ID0gZGltLnggLyAyLCBoID0gZGltLnkgLyAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gY29ybmVyc1xuICAgICAgICB0bDogdHJhbnNmb3JtUG9pbnQoeyB4OiAtdywgeTogLWggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICB0cjogdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgIGJsOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiBoIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgYnI6IHRyYW5zZm9ybVBvaW50KHsgeDogdywgeTogaCB9LCBmaW5hbE1hdHJpeClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29ybmVyIGFuZCBjb250cm9scyBwb3NpdGlvbiBjb29yZGluYXRlcyBiYXNlZCBvbiBjdXJyZW50IGFuZ2xlLCB3aWR0aCBhbmQgaGVpZ2h0LCBsZWZ0IGFuZCB0b3AuXG4gICAgICogb0Nvb3JkcyBhcmUgdXNlZCB0byBmaW5kIHRoZSBjb3JuZXJzXG4gICAgICogYUNvb3JkcyBhcmUgdXNlZCB0byBxdWlja2x5IGZpbmQgYW4gb2JqZWN0IG9uIHRoZSBjYW52YXNcbiAgICAgKiBsaW5lQ29vcmRzIGFyZSB1c2VkIHRvIHF1aWNrbHkgZmluZCBvYmplY3QgZHVyaW5nIHBvaW50ZXIgZXZlbnRzLlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvd2lraS9XaGVuLXRvLWNhbGwtc2V0Q29vcmRzfFdoZW4tdG8tY2FsbC1zZXRDb29yZHN9XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENvcm5lcnNdIHNraXAgY2FsY3VsYXRpb24gb2Ygb0Nvb3Jkcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvb3JkczogZnVuY3Rpb24oc2tpcENvcm5lcnMpIHtcbiAgICAgIHRoaXMuYUNvb3JkcyA9IHRoaXMuY2FsY0FDb29yZHMoKTtcbiAgICAgIC8vIGluIGNhc2Ugd2UgYXJlIGluIGEgZ3JvdXAsIGZvciBob3cgdGhlIGlubmVyIGdyb3VwIHRhcmdldCBjaGVjayB3b3JrcyxcbiAgICAgIC8vIGxpbmVDb29yZHMgYXJlIGV4YWN0bHkgYUNvb3Jkcy4gU2luY2UgdGhlIHZwdCBnZXRzIGFic29yYmVkIGJ5IHRoZSBub3JtYWxpemVkIHBvaW50ZXIuXG4gICAgICB0aGlzLmxpbmVDb29yZHMgPSB0aGlzLmdyb3VwID8gdGhpcy5hQ29vcmRzIDogdGhpcy5jYWxjTGluZUNvb3JkcygpO1xuICAgICAgaWYgKHNraXBDb3JuZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgdXNlZCB0byBzY2FsZS9yb3RhdGUgdGhlIGltYWdlXG4gICAgICB0aGlzLm9Db29yZHMgPSB0aGlzLmNhbGNPQ29vcmRzKCk7XG4gICAgICB0aGlzLl9zZXRDb3JuZXJDb29yZHMgJiYgdGhpcy5fc2V0Q29ybmVyQ29vcmRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHJvdGF0aW9uIG1hdHJpeCBvZiBhbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcm90YXRpb24gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgX2NhbGNSb3RhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWwuY2FsY1JvdGF0ZU1hdHJpeCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggZm9yIGFuIG9iamVjdCB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcm90YXRpb24gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgX2NhbGNUcmFuc2xhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMSwgY2VudGVyLngsIGNlbnRlci55XTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtTWF0cml4S2V5OiBmdW5jdGlvbihza2lwR3JvdXApIHtcbiAgICAgIHZhciBzZXAgPSAnXycsIHByZWZpeCA9ICcnO1xuICAgICAgaWYgKCFza2lwR3JvdXAgJiYgdGhpcy5ncm91cCkge1xuICAgICAgICBwcmVmaXggPSB0aGlzLmdyb3VwLnRyYW5zZm9ybU1hdHJpeEtleShza2lwR3JvdXApICsgc2VwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwcmVmaXggKyB0aGlzLnRvcCArIHNlcCArIHRoaXMubGVmdCArIHNlcCArIHRoaXMuc2NhbGVYICsgc2VwICsgdGhpcy5zY2FsZVkgK1xuICAgICAgICBzZXAgKyB0aGlzLnNrZXdYICsgc2VwICsgdGhpcy5za2V3WSArIHNlcCArIHRoaXMuYW5nbGUgKyBzZXAgKyB0aGlzLm9yaWdpblggKyBzZXAgKyB0aGlzLm9yaWdpblkgK1xuICAgICAgICBzZXAgKyB0aGlzLndpZHRoICsgc2VwICsgdGhpcy5oZWlnaHQgKyBzZXAgKyB0aGlzLnN0cm9rZVdpZHRoICsgdGhpcy5mbGlwWCArIHRoaXMuZmxpcFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0cmFuc2Zvcm0gbWF0cml4IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnMgZnJvbSB0aGVcbiAgICAgKiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBHcm91cF0gcmV0dXJuIHRyYW5zZm9ybSBtYXRyaXggZm9yIG9iamVjdCBub3QgY291bnRpbmcgcGFyZW50IHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIFRoZXJlIGFyZSBzb21lIHNpdHVhdGlvbiBpbiB3aGljaCB0aGlzIGlzIHVzZWZ1bCB0byBhdm9pZCB0aGUgZmFrZSByb3RhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdHJhbnNmb3JtIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY2FsY093bk1hdHJpeCgpO1xuICAgICAgaWYgKHNraXBHcm91cCB8fCAhdGhpcy5ncm91cCkge1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHNraXBHcm91cCksIGNhY2hlID0gdGhpcy5tYXRyaXhDYWNoZSB8fCAodGhpcy5tYXRyaXhDYWNoZSA9IHt9KTtcbiAgICAgIGlmIChjYWNoZS5rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeChmYWxzZSksIG1hdHJpeCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0cmFuc2Zvcm0gbWF0cml4IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnMgZnJvbSB0aGVcbiAgICAgKiBvYmplY3QncyBwcm9wZXJ0aWVzLCB0aGlzIG1hdHJpeCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBncm91cCB0cmFuc2Zvcm1hdGlvblxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0cmFuc2Zvcm0gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY093bk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkodHJ1ZSksIGNhY2hlID0gdGhpcy5vd25NYXRyaXhDYWNoZSB8fCAodGhpcy5vd25NYXRyaXhDYWNoZSA9IHt9KTtcbiAgICAgIGlmIChjYWNoZS5rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgdE1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiB0TWF0cml4WzRdLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogdE1hdHJpeFs1XSxcbiAgICAgICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICAgICAgc2tld1g6IHRoaXMuc2tld1gsXG4gICAgICAgICAgICBza2V3WTogdGhpcy5za2V3WSxcbiAgICAgICAgICAgIGZsaXBYOiB0aGlzLmZsaXBYLFxuICAgICAgICAgICAgZmxpcFk6IHRoaXMuZmxpcFksXG4gICAgICAgICAgfTtcbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIGNhY2hlLnZhbHVlID0gdXRpbC5jb21wb3NlTWF0cml4KG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSAzLjQuMCwgcGxlYXNlIHVzZSBmYWJyaWMudXRpbC5fY2FsY0RpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBub3QgaW5jbHVkaW5nIG9yIGluY2x1ZGluZyBmbGlwWCwgZmxpcFkgdG8gZW11bGF0ZSB0aGUgZmxpcHBpbmcgYm9vbGVhblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBoZWlnaHQgZGltZW5zaW9uXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihza2V3WCwgc2tld1ksIGZsaXBwaW5nKSB7XG4gICAgICByZXR1cm4gdXRpbC5jYWxjRGltZW5zaW9uc01hdHJpeCh7XG4gICAgICAgIHNrZXdYOiBza2V3WCxcbiAgICAgICAgc2tld1k6IHNrZXdZLFxuICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYICogKGZsaXBwaW5nICYmIHRoaXMuZmxpcFggPyAtMSA6IDEpLFxuICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZICogKGZsaXBwaW5nICYmIHRoaXMuZmxpcFkgPyAtMSA6IDEpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiB7IHg6IHcsIHk6IGggfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXMgc2NhbGUsIHNrZXcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYLCBhIHZhbHVlIHRvIG92ZXJyaWRlIGN1cnJlbnQgc2tld1hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tld1ksIGEgdmFsdWUgdG8gb3ZlcnJpZGUgY3VycmVudCBza2V3WVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbihza2V3WCwgc2tld1kpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2tld1ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2tld1kgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNrZXdZID0gdGhpcy5za2V3WTtcbiAgICAgIH1cbiAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCksIGRpbVgsIGRpbVksXG4gICAgICAgICAgbm9Ta2V3ID0gc2tld1ggPT09IDAgJiYgc2tld1kgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLnN0cm9rZVVuaWZvcm0pIHtcbiAgICAgICAgZGltWCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGRpbVkgPSB0aGlzLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkaW1YID0gZGltZW5zaW9ucy54O1xuICAgICAgICBkaW1ZID0gZGltZW5zaW9ucy55O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2tldykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVEaW1lbnNpb25zKGRpbVggKiB0aGlzLnNjYWxlWCwgZGltWSAqIHRoaXMuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYm94ID0gdXRpbC5zaXplQWZ0ZXJUcmFuc2Zvcm0oZGltWCwgZGltWSwge1xuICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1gsXG4gICAgICAgIHNrZXdZOiBza2V3WSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRGltZW5zaW9ucyhiYm94LngsIGJib3gueSk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBib3VuZGluZyBib3ggZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzIHNjYWxlLCBza2V3LlxuICAgICAqIEBwYXJhbSBOdW1iZXIgd2lkdGggd2lkdGggb2YgdGhlIGJib3hcbiAgICAgKiBAcGFyYW0gTnVtYmVyIGhlaWdodCBoZWlnaHQgb2YgdGhlIGJib3hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggZmluYWxpemVkIHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgZmluYWxpemVkIGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZmluYWxpemVEaW1lbnNpb25zOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJva2VVbmlmb3JtID9cbiAgICAgICAgeyB4OiB3aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsIHk6IGhlaWdodCArIHRoaXMuc3Ryb2tlV2lkdGggfVxuICAgICAgICA6XG4gICAgICAgIHsgeDogd2lkdGgsIHk6IGhlaWdodCB9O1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmb3IgY29udHJvbHMgYm94LCBpbmNsdWRpbmcgcGFkZGluZyBhbmQgY2FudmFzIHpvb20uXG4gICAgICogYW5kIGFjdGl2ZSBzZWxlY3Rpb25cbiAgICAgKiBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zOiBmdW5jdGlvbigpICB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHAgPSB0cmFuc2Zvcm1Qb2ludChkaW0sIHZwdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kVG9CYWNrLmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kVG9CYWNrKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ1RvRnJvbnQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmJyaW5nVG9Gcm9udCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCBkb3duIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGJlaGluZCBuZXh0IGxvd2VyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZW5kQmFja3dhcmRzOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuc2VuZEJhY2t3YXJkcy5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kQmFja3dhcmRzKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdGb3J3YXJkLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmJyaW5nRm9yd2FyZCh0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBOZXcgcG9zaXRpb24gb2Ygb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSAhPT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLm1vdmVUby5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLm1vdmVUbyh0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuXG4vKiBfVE9fU1ZHX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBnZXRTdmdDb2xvclN0cmluZyhwcm9wLCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogbm9uZTsgJztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUudG9MaXZlKSB7XG4gICAgICByZXR1cm4gcHJvcCArICc6IHVybCgjU1ZHSURfJyArIHZhbHVlLmlkICsgJyk7ICc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih2YWx1ZSksXG4gICAgICAgICAgc3RyID0gcHJvcCArICc6ICcgKyBjb2xvci50b1JnYigpICsgJzsgJyxcbiAgICAgICAgICBvcGFjaXR5ID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgIC8vY2hhbmdlIHRoZSBjb2xvciBpbiByZ2IgKyBvcGFjaXR5XG4gICAgICAgIHN0ciArPSBwcm9wICsgJy1vcGFjaXR5OiAnICsgb3BhY2l0eS50b1N0cmluZygpICsgJzsgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFNoYWRvdyBhIGJvb2xlYW4gdG8gc2tpcCBzaGFkb3cgZmlsdGVyIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKHNraXBTaGFkb3cpIHtcblxuICAgICAgdmFyIGZpbGxSdWxlID0gdGhpcy5maWxsUnVsZSA/IHRoaXMuZmlsbFJ1bGUgOiAnbm9uemVybycsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoID8gdGhpcy5zdHJva2VXaWR0aCA6ICcwJyxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmpvaW4oJyAnKSA6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VEYXNoT2Zmc2V0ID8gdGhpcy5zdHJva2VEYXNoT2Zmc2V0IDogJzAnLFxuICAgICAgICAgIHN0cm9rZUxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXAgPyB0aGlzLnN0cm9rZUxpbmVDYXAgOiAnYnV0dCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luID8gdGhpcy5zdHJva2VMaW5lSm9pbiA6ICdtaXRlcicsXG4gICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA/IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA6ICc0JyxcbiAgICAgICAgICBvcGFjaXR5ID0gdHlwZW9mIHRoaXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wYWNpdHkgOiAnMScsXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJsZSA/ICcnIDogJyB2aXNpYmlsaXR5OiBoaWRkZW47JyxcbiAgICAgICAgICBmaWx0ZXIgPSBza2lwU2hhZG93ID8gJycgOiB0aGlzLmdldFN2Z0ZpbHRlcigpLFxuICAgICAgICAgIGZpbGwgPSBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHRoaXMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoOiAnLCBzdHJva2VXaWR0aCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXk6ICcsIHN0cm9rZURhc2hBcnJheSwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwOiAnLCBzdHJva2VMaW5lQ2FwLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQ6ICcsIHN0cm9rZURhc2hPZmZzZXQsICc7ICcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW46ICcsIHN0cm9rZUxpbmVKb2luLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQ6ICcsIHN0cm9rZU1pdGVyTGltaXQsICc7ICcsXG4gICAgICAgIGZpbGwsXG4gICAgICAgICdmaWxsLXJ1bGU6ICcsIGZpbGxSdWxlLCAnOyAnLFxuICAgICAgICAnb3BhY2l0eTogJywgb3BhY2l0eSwgJzsnLFxuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlV2hpdGVTcGFjZSBhIGJvb2xlYW4gdG8gaW5jbHVkZSBhbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZSBpbiB0aGUgc3R5bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1NwYW5TdHlsZXM6IGZ1bmN0aW9uKHN0eWxlLCB1c2VXaGl0ZVNwYWNlKSB7XG4gICAgICB2YXIgdGVybSA9ICc7ICc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgP1xuICAgICAgICAnZm9udC1mYW1pbHk6ICcgKyAoKChzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1xcJycpID09PSAtMSAmJiBzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1wiJykgPT09IC0xKSA/XG4gICAgICAgICAgJ1xcJycgKyBzdHlsZS5mb250RmFtaWx5ICArICdcXCcnIDogc3R5bGUuZm9udEZhbWlseSkpICsgdGVybSA6ICcnO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGggPyAnc3Ryb2tlLXdpZHRoOiAnICsgc3R5bGUuc3Ryb2tlV2lkdGggKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSA/ICdmb250LXNpemU6ICcgKyBzdHlsZS5mb250U2l6ZSArICdweCcgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU6ICcgKyBzdHlsZS5mb250U3R5bGUgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ6ICcgKyBzdHlsZS5mb250V2VpZ2h0ICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZpbGwgPSBzdHlsZS5maWxsID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ2ZpbGwnLCBzdHlsZS5maWxsKSA6ICcnLFxuICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLnN0cm9rZSA/IGdldFN2Z0NvbG9yU3RyaW5nKCdzdHJva2UnLCBzdHlsZS5zdHJva2UpIDogJycsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHN0eWxlKSxcbiAgICAgICAgICBkZWx0YVkgPSBzdHlsZS5kZWx0YVkgPyAnYmFzZWxpbmUtc2hpZnQ6ICcgKyAoLXN0eWxlLmRlbHRhWSkgKyAnOyAnIDogJyc7XG4gICAgICBpZiAodGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgdGV4dERlY29yYXRpb24gPSAndGV4dC1kZWNvcmF0aW9uOiAnICsgdGV4dERlY29yYXRpb24gKyB0ZXJtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBmb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0LFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbixcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZGVsdGFZLFxuICAgICAgICB1c2VXaGl0ZVNwYWNlID8gJ3doaXRlLXNwYWNlOiBwcmU7ICcgOiAnJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZXh0LWRlY29yYXRpb24gcHJvcGVydHkgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgdGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICByZXR1cm4gWydvdmVybGluZScsICd1bmRlcmxpbmUnLCAnbGluZS10aHJvdWdoJ10uZmlsdGVyKGZ1bmN0aW9uKGRlY29yYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlW2RlY29yYXRpb24ucmVwbGFjZSgnLScsICcnKV07XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlsdGVyIGZvciBzdmcgc2hhZG93XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z0ZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFkb3cgPyAnZmlsdGVyOiB1cmwoI1NWR0lEXycgKyB0aGlzLnNoYWRvdy5pZCArICcpOycgOiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZCBhdHRyaWJ1dGUgZm9yIHN2ZyBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnQ29tbW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmlkID8gJ2lkPVwiJyArIHRoaXMuaWQgKyAnXCIgJyA6ICcnLFxuICAgICAgICB0aGlzLmNsaXBQYXRoID8gJ2NsaXAtcGF0aD1cInVybCgjJyArIHRoaXMuY2xpcFBhdGguY2xpcFBhdGhJZCArICcpXCIgJyA6ICcnLFxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cmFuc2Zvcm0tc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2UgdGhlIGZ1bGwgdHJhbnNmb3JtIG9yIHRoZSBzaW5nbGUgb2JqZWN0IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVHJhbnNmb3JtOiBmdW5jdGlvbihmdWxsLCBhZGRpdGlvbmFsVHJhbnNmb3JtKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZnVsbCA/IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpIDogdGhpcy5jYWxjT3duTWF0cml4KCksXG4gICAgICAgICAgc3ZnVHJhbnNmb3JtID0gJ3RyYW5zZm9ybT1cIicgKyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyh0cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIHN2Z1RyYW5zZm9ybSArXG4gICAgICAgIChhZGRpdGlvbmFsVHJhbnNmb3JtIHx8ICcnKSArICdcIiAnO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzKSB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXModGhpcy5iYWNrZ3JvdW5kQ29sb3IpLFxuICAgICAgICAgICcgeD1cIicsXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy53aWR0aCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcocmV2aXZlciksIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgY2xpcFBhdGggcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9DbGlwUGF0aFNWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuICdcXHQnICsgdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKHJldml2ZXIpLCB7IHJldml2ZXI6IHJldml2ZXIgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cDogZnVuY3Rpb24ob2JqZWN0TWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciByZXZpdmVyID0gb3B0aW9ucy5yZXZpdmVyLFxuICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm0gfHwgJycsXG4gICAgICAgICAgY29tbW9uUGllY2VzID0gW1xuICAgICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0odHJ1ZSwgYWRkaXRpb25hbFRyYW5zZm9ybSksXG4gICAgICAgICAgICB0aGlzLmdldFN2Z0NvbW1vbnMoKSxcbiAgICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgICAgIC8vIGluc2VydCBjb21tb25zIGluIHRoZSBtYXJrdXAsIHN0eWxlIGFuZCBzdmdDb21tb25zXG4gICAgICAgICAgaW5kZXggPSBvYmplY3RNYXJrdXAuaW5kZXhPZignQ09NTU9OX1BBUlRTJyk7XG4gICAgICBvYmplY3RNYXJrdXBbaW5kZXhdID0gY29tbW9uUGllY2VzO1xuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG9iamVjdE1hcmt1cC5qb2luKCcnKSkgOiBvYmplY3RNYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VTVkdNYXJrdXA6IGZ1bmN0aW9uKG9iamVjdE1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgbm9TdHlsZSA9IG9wdGlvbnMubm9TdHlsZSxcbiAgICAgICAgICByZXZpdmVyID0gb3B0aW9ucy5yZXZpdmVyLFxuICAgICAgICAgIHN0eWxlSW5mbyA9IG5vU3R5bGUgPyAnJyA6ICdzdHlsZT1cIicgKyB0aGlzLmdldFN2Z1N0eWxlcygpICsgJ1wiICcsXG4gICAgICAgICAgc2hhZG93SW5mbyA9IG9wdGlvbnMud2l0aFNoYWRvdyA/ICdzdHlsZT1cIicgKyB0aGlzLmdldFN2Z0ZpbHRlcigpICsgJ1wiICcgOiAnJyxcbiAgICAgICAgICBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgsXG4gICAgICAgICAgdmVjdG9yRWZmZWN0ID0gdGhpcy5zdHJva2VVbmlmb3JtID8gJ3ZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiAnIDogJycsXG4gICAgICAgICAgYWJzb2x1dGVDbGlwUGF0aCA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCxcbiAgICAgICAgICBzdHJva2UgPSB0aGlzLnN0cm9rZSwgZmlsbCA9IHRoaXMuZmlsbCwgc2hhZG93ID0gdGhpcy5zaGFkb3csXG4gICAgICAgICAgY29tbW9uUGllY2VzLCBtYXJrdXAgPSBbXSwgY2xpcFBhdGhNYXJrdXAsXG4gICAgICAgICAgLy8gaW5zZXJ0IGNvbW1vbnMgaW4gdGhlIG1hcmt1cCwgc3R5bGUgYW5kIHN2Z0NvbW1vbnNcbiAgICAgICAgICBpbmRleCA9IG9iamVjdE1hcmt1cC5pbmRleE9mKCdDT01NT05fUEFSVFMnKSxcbiAgICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID0gb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtO1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoLmNsaXBQYXRoSWQgPSAnQ0xJUFBBVEhfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgY2xpcFBhdGhNYXJrdXAgPSAnPGNsaXBQYXRoIGlkPVwiJyArIGNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnXCIgPlxcbicgK1xuICAgICAgICAgIGNsaXBQYXRoLnRvQ2xpcFBhdGhTVkcocmV2aXZlcikgK1xuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbic7XG4gICAgICB9XG4gICAgICBpZiAoYWJzb2x1dGVDbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPGcgJywgc2hhZG93SW5mbywgdGhpcy5nZXRTdmdDb21tb25zKCksICcgPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGcgJyxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oZmFsc2UpLFxuICAgICAgICAhYWJzb2x1dGVDbGlwUGF0aCA/IHNoYWRvd0luZm8gKyB0aGlzLmdldFN2Z0NvbW1vbnMoKSA6ICcnLFxuICAgICAgICAnID5cXG4nXG4gICAgICApO1xuICAgICAgY29tbW9uUGllY2VzID0gW1xuICAgICAgICBzdHlsZUluZm8sXG4gICAgICAgIHZlY3RvckVmZmVjdCxcbiAgICAgICAgbm9TdHlsZSA/ICcnIDogdGhpcy5hZGRQYWludE9yZGVyKCksICcgJyxcbiAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA/ICd0cmFuc2Zvcm09XCInICsgYWRkaXRpb25hbFRyYW5zZm9ybSArICdcIiAnIDogJycsXG4gICAgICBdLmpvaW4oJycpO1xuICAgICAgb2JqZWN0TWFya3VwW2luZGV4XSA9IGNvbW1vblBpZWNlcztcbiAgICAgIGlmIChmaWxsICYmIGZpbGwudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKGZpbGwudG9TVkcodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cm9rZSAmJiBzdHJva2UudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHN0cm9rZS50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHNoYWRvdy50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goY2xpcFBhdGhNYXJrdXApO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2gob2JqZWN0TWFya3VwLmpvaW4oJycpKTtcbiAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICBhYnNvbHV0ZUNsaXBQYXRoICYmIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgYWRkUGFpbnRPcmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWludEZpcnN0ICE9PSAnZmlsbCcgPyAnIHBhaW50LW9yZGVyPVwiJyArIHRoaXMucGFpbnRGaXJzdCArICdcIiAnIDogJyc7XG4gICAgfVxuICB9KTtcbn0pKCk7XG4vKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBvcmlnaW5hbFNldCA9ICdzdGF0ZVByb3BlcnRpZXMnO1xuXG4gIC8qXG4gICAgRGVwZW5kcyBvbiBgc3RhdGVQcm9wZXJ0aWVzYFxuICAqL1xuICBmdW5jdGlvbiBzYXZlUHJvcHMob3JpZ2luLCBkZXN0aW5hdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgdG1wT2JqID0geyB9LCBkZWVwID0gdHJ1ZTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHRtcE9ialtwcm9wXSA9IG9yaWdpbltwcm9wXTtcbiAgICB9KTtcblxuICAgIGV4dGVuZChvcmlnaW5bZGVzdGluYXRpb25dLCB0bXBPYmosIGRlZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRXF1YWwob3JpZ1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0UGFzcykge1xuICAgIGlmIChvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgLy8gaWYgdGhlIG9iamVjdHMgYXJlIGlkZW50aWNhbCwgcmV0dXJuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmlnVmFsdWUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSB8fCBvcmlnVmFsdWUubGVuZ3RoICE9PSBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcmlnVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFfaXNFcXVhbChvcmlnVmFsdWVbaV0sIGN1cnJlbnRWYWx1ZVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnVmFsdWUgJiYgdHlwZW9mIG9yaWdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3JpZ1ZhbHVlKSwga2V5O1xuICAgICAgaWYgKCFjdXJyZW50VmFsdWUgfHxcbiAgICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICghZmlyc3RQYXNzICYmIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhjdXJyZW50VmFsdWUpLmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBzaW5jZSBjbGlwUGF0aCBpcyBpbiB0aGUgc3RhdGVmdWxsIGNhY2hlIGxpc3QgYW5kIHRoZSBjbGlwUGF0aCBvYmplY3RzXG4gICAgICAgIC8vIHdvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIG9iamVjdCwgdGhpcyB3b3VsZCBsZWFkIHRvIHBvc3NpYmxlIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBjb21wYXJlIHRob3NlLlxuICAgICAgICBpZiAoa2V5ID09PSAnY2FudmFzJyB8fCBrZXkgPT09ICdncm91cCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtrZXldLCBjdXJyZW50VmFsdWVba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IHN0YXRlIChvbmUgb2YgaXRzIHN0YXRlIHByb3BlcnRpZXMpIHdhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eVNldF0gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHNldCBvZiBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNhdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGluc3RhbmNlJyBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSBge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2F2ZVN0YXRlfWAgd2FzIGNhbGxlZFxuICAgICAqL1xuICAgIGhhc1N0YXRlQ2hhbmdlZDogZnVuY3Rpb24ocHJvcGVydHlTZXQpIHtcbiAgICAgIHByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICB2YXIgZGFzaGVkUHJvcGVydHlTZXQgPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSkubGVuZ3RoIDwgdGhpc1twcm9wZXJ0eVNldF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFfaXNFcXVhbCh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNhdmVTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHByb3BlcnR5U2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uID0gJ18nICsgcHJvcGVydHlTZXQ7XG4gICAgICBpZiAoIXRoaXNbZGVzdGluYXRpb25dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwU3RhdGUob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzYXZlUHJvcHModGhpcywgZGVzdGluYXRpb24sIHRoaXNbcHJvcGVydHlTZXRdKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXR1cFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0O1xuICAgICAgb3B0aW9ucy5wcm9wZXJ0eVNldCA9IHByb3BlcnR5U2V0O1xuICAgICAgdGhpc1snXycgKyBwcm9wZXJ0eVNldF0gPSB7IH07XG4gICAgICB0aGlzLnNhdmVTdGF0ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGljaCBjb3JuZXIgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgVGhlIHBvaW50ZXIgaW5kaWNhdGluZyB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn0gY29ybmVyIGNvZGUgKHRsLCB0ciwgYmwsIGJyLCBldGMuKSwgb3IgZmFsc2UgaWYgbm90aGluZyBpcyBmb3VuZFxuICAgICAqL1xuICAgIF9maW5kVGFyZ2V0Q29ybmVyOiBmdW5jdGlvbihwb2ludGVyLCBmb3JUb3VjaCkge1xuICAgICAgLy8gb2JqZWN0cyBpbiBncm91cCwgYW55a2luZCwgYXJlIG5vdCBzZWxmIG1vZGlmaWNhYmxlLFxuICAgICAgLy8gbXVzdCBub3QgcmV0dXJuIGFuIGhvdmVyZWQgY29ybmVyLlxuICAgICAgaWYgKCF0aGlzLmhhc0NvbnRyb2xzIHx8IHRoaXMuZ3JvdXAgfHwgKCF0aGlzLmNhbnZhcyB8fCB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0ICE9PSB0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBleCA9IHBvaW50ZXIueCxcbiAgICAgICAgICBleSA9IHBvaW50ZXIueSxcbiAgICAgICAgICB4UG9pbnRzLFxuICAgICAgICAgIGxpbmVzLCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vQ29vcmRzKSxcbiAgICAgICAgICBqID0ga2V5cy5sZW5ndGggLSAxLCBpO1xuICAgICAgdGhpcy5fX2Nvcm5lciA9IDA7XG5cbiAgICAgIC8vIGN5Y2xlIGluIHJldmVyc2Ugb3JkZXIgc28gd2UgcGljayBmaXJzdCB0aGUgb25lIG9uIHRvcFxuICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSB0aGlzLl9nZXRJbWFnZUxpbmVzKGZvclRvdWNoID8gdGhpcy5vQ29vcmRzW2ldLnRvdWNoQ29ybmVyIDogdGhpcy5vQ29vcmRzW2ldLmNvcm5lcik7XG4gICAgICAgIC8vIC8vIGRlYnVnZ2luZ1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuZC54LCBsaW5lcy5ib3R0b21saW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5vLngsIGxpbmVzLmJvdHRvbWxpbmUuby55LCAyLCAyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5kLngsIGxpbmVzLmxlZnRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5vLngsIGxpbmVzLnRvcGxpbmUuby55LCAyLCAyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuZC54LCBsaW5lcy5yaWdodGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuby54LCBsaW5lcy5yaWdodGxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHsgeDogZXgsIHk6IGV5IH0sIGxpbmVzKTtcbiAgICAgICAgaWYgKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9fY29ybmVyID0gaTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGNvbnRyb2wuIFRoZSBmdW5jdGlvbiBnZXRzIGNhbGxlZCxcbiAgICAgKiB3aXRoIHRoZSBjb250cm9sLCB0aGUgb2JqZWN0IHRoYXQgaXMgY2FsbGluZyB0aGUgaXRlcmF0b3IgYW5kIHRoZSBjb250cm9sJ3Mga2V5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIHRoZSBjb250cm9scyBvdmVyXG4gICAgICovXG4gICAgZm9yRWFjaENvbnRyb2w6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuY29udHJvbHMpIHtcbiAgICAgICAgZm4odGhpcy5jb250cm9sc1tpXSwgaSwgdGhpcyk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIG9mXG4gICAgICogdGhlIGltYWdlIHVzZWQgdG8gc2NhbGUvcm90YXRlIGl0LlxuICAgICAqIG5vdGU6IGlmIHdlIHdvdWxkIHN3aXRjaCB0byBST1VORCBjb3JuZXIgYXJlYSwgYWxsIG9mIHRoaXMgd291bGQgZGlzYXBwZWFyLlxuICAgICAqIGV2ZXJ5dGhpbmcgd291bGQgcmVzb2x2ZSB0byBhIHNpbmdsZSBwb2ludCBhbmQgYSBweXRoYWdvcmVhbiB0aGVvcmVtIGZvciB0aGUgZGlzdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRDb3JuZXJDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMub0Nvb3JkcztcblxuICAgICAgZm9yICh2YXIgY29udHJvbCBpbiBjb29yZHMpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xPYmplY3QgPSB0aGlzLmNvbnRyb2xzW2NvbnRyb2xdO1xuICAgICAgICBjb29yZHNbY29udHJvbF0uY29ybmVyID0gY29udHJvbE9iamVjdC5jYWxjQ29ybmVyQ29vcmRzKFxuICAgICAgICAgIHRoaXMuYW5nbGUsIHRoaXMuY29ybmVyU2l6ZSwgY29vcmRzW2NvbnRyb2xdLngsIGNvb3Jkc1tjb250cm9sXS55LCBmYWxzZSk7XG4gICAgICAgIGNvb3Jkc1tjb250cm9sXS50b3VjaENvcm5lciA9IGNvbnRyb2xPYmplY3QuY2FsY0Nvcm5lckNvb3JkcyhcbiAgICAgICAgICB0aGlzLmFuZ2xlLCB0aGlzLnRvdWNoQ29ybmVyU2l6ZSwgY29vcmRzW2NvbnRyb2xdLngsIGNvb3Jkc1tjb250cm9sXS55LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0LCBpbnNpZGUgaXRzIHNlbGVjdGlvbiBib3JkZXJzLlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3JcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBjb250ZXh0IGlzIHRyYW5zZm9ybWVkXG4gICAgICogaGFzIGNoZWNrcyB0byBiZSBza2lwcGVkIHdoZW4gdGhlIG9iamVjdCBpcyBvbiBhIHN0YXRpY0NhbnZhc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3U2VsZWN0aW9uQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIHx8XG4gICAgICAgICh0aGlzLmNhbnZhcyAmJiAhdGhpcy5jYW52YXMuaW50ZXJhY3RpdmUpIHx8XG4gICAgICAgICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0ICE9PSB0aGlzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdnB0WzBdLCAxIC8gdnB0WzNdKTtcbiAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoLXdoLnggLyAyLCAtd2gueSAvIDIsIHdoLngsIHdoLnkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib3JkZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdCb3JkZXJzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgdmFyIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPSB3aC54ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhhc0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IGZhbHNlO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmJvcmRlckRhc2hBcnJheSB8fCB0aGlzLmJvcmRlckRhc2hBcnJheSwgbnVsbCk7XG5cbiAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAtd2lkdGggLyAyLFxuICAgICAgICAtaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcblxuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQ29udHJvbChmdW5jdGlvbihjb250cm9sLCBrZXksIGZhYnJpY09iamVjdCkge1xuICAgICAgICAgIC8vIGluIHRoaXMgbW9tZW50LCB0aGUgY3R4IGlzIGNlbnRlcmVkIG9uIHRoZSBvYmplY3QuXG4gICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYWJvdmUgZnVuY3Rpb24gYXJlIHRoZSBzaXplIG9mIHRoZSBiYm94LlxuICAgICAgICAgIGlmIChjb250cm9sLndpdGhDb25uZWN0aW9uICYmIGNvbnRyb2wuZ2V0VmlzaWJpbGl0eShmYWJyaWNPYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IG1vdmVtZW50IGZvciBlYWNoIGNvbnRyb2xcbiAgICAgICAgICAgIHNob3VsZFN0cm9rZSA9IHRydWU7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNvbnRyb2wueCAqIHdpZHRoLCBjb250cm9sLnkgKiBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbC54ICogd2lkdGggKyBjb250cm9sLm9mZnNldFgsXG4gICAgICAgICAgICAgIGNvbnRyb2wueSAqIGhlaWdodCArIGNvbnRyb2wub2Zmc2V0WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hvdWxkU3Ryb2tlKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IHdoZW4gaXQgaXMgaW5zaWRlIGEgZ3JvdXAuXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCBvYmplY3QgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyc0luR3JvdXA6IGZ1bmN0aW9uKGN0eCwgb3B0aW9ucywgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgYmJveCA9IGZhYnJpYy51dGlsLnNpemVBZnRlclRyYW5zZm9ybSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgb3B0aW9ucyksXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHN0cm9rZVVuaWZvcm0gPSB0aGlzLnN0cm9rZVVuaWZvcm0sXG4gICAgICAgICAgYm9yZGVyU2NhbGVGYWN0b3IgPSB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID1cbiAgICAgICAgICAgIGJib3gueCArIHN0cm9rZVdpZHRoICogKHN0cm9rZVVuaWZvcm0gPyB0aGlzLmNhbnZhcy5nZXRab29tKCkgOiBvcHRpb25zLnNjYWxlWCkgKyBib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICBoZWlnaHQgPVxuICAgICAgICAgICAgYmJveC55ICsgc3Ryb2tlV2lkdGggKiAoc3Ryb2tlVW5pZm9ybSA/IHRoaXMuY2FudmFzLmdldFpvb20oKSA6IG9wdGlvbnMuc2NhbGVZKSArIGJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5ib3JkZXJEYXNoQXJyYXkgfHwgdGhpcy5ib3JkZXJEYXNoQXJyYXksIG51bGwpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGNvcm5lcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IGNvcm5lclNpemUsIHBhZGRpbmdcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Q29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLmNhbnZhcy5nZXRSZXRpbmFTY2FsaW5nKCksIDAsIDAsIHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKSwgMCwgMCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCB0aGlzLmNvcm5lckNvbG9yO1xuICAgICAgaWYgKCF0aGlzLnRyYW5zcGFyZW50Q29ybmVycykge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IHRoaXMuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuY29ybmVyRGFzaEFycmF5IHx8IHRoaXMuY29ybmVyRGFzaEFycmF5LCBudWxsKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgIGlmIChjb250cm9sLmdldFZpc2liaWxpdHkoZmFicmljT2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgY29udHJvbC5yZW5kZXIoY3R4LFxuICAgICAgICAgICAgZmFicmljT2JqZWN0Lm9Db29yZHNba2V5XS54LFxuICAgICAgICAgICAgZmFicmljT2JqZWN0Lm9Db29yZHNba2V5XS55LCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBUaGUga2V5IG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0NvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sc1tjb250cm9sS2V5XSAmJiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xLZXldLmdldFZpc2liaWxpdHkodGhpcywgY29udHJvbEtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHNwZWNpZmllZCBjb250cm9sLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sS2V5IFRoZSBrZXkgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIHRydWUgdG8gc2V0IHRoZSBzcGVjaWZpZWQgY29udHJvbCB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sS2V5LCB2aXNpYmxlKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eVtjb250cm9sS2V5XSA9IHZpc2libGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiBvYmplY3QgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmxdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5icl0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1ib3R0b20gY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWxdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tcl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3AgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGxdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cl0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdHJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wLXJvdGF0ZSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sc1Zpc2liaWxpdHk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRDb250cm9sVmlzaWJsZShwLCBvcHRpb25zW3BdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgX2Rpc2NhcmRBY3RpdmVPYmplY3Qgb3IgX3NldEFjdGl2ZU9iamVjdFxuICAgICAqIHRyeSB0byB0byBkZXNlbGVjdCB0aGlzIG9iamVjdC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHByb2Nlc3MgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHNlbnQgZnJvbSB0aGUgdXBwZXIgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gW29wdGlvbnMuZV0gZXZlbnQgaWYgdGhlIHByb2Nlc3MgaXMgZ2VuZXJhdGVkIGJ5IGFuIGV2ZW50XG4gICAgICovXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgX2Rpc2NhcmRBY3RpdmVPYmplY3Qgb3IgX3NldEFjdGl2ZU9iamVjdFxuICAgICAqIHRyeSB0byB0byBzZWxlY3QgdGhpcyBvYmplY3QuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBwcm9jZXNzIGlzIGNhbmNlbGxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBzZW50IGZyb20gdGhlIHVwcGVyIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtvcHRpb25zLmVdIGV2ZW50IGlmIHRoZSBwcm9jZXNzIGlzIGdlbmVyYXRlZCBieSBhbiBldmVudFxuICAgICAqL1xuICAgIG9uU2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBkdXJhdGlvbiAoaW4gbXMpIGZvciBmeCogbWV0aG9kc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIEZYX0RVUkFUSU9OOiA1MDAsXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhDZW50ZXJPYmplY3RIOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LmxlZnQsXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXIoKS5sZWZ0LFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnbGVmdCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IHdpdGggYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmeENlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QudG9wLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuZ2V0Q2VudGVyKCkudG9wLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgndG9wJywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYGZhYnJpYy5DYW52YXMjcmVtb3ZlYCBidXQgYW5pbWF0ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhSZW1vdmU6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICBzdGFydFZhbHVlOiBvYmplY3Qub3BhY2l0eSxcbiAgICAgIGVuZFZhbHVlOiAwLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnb3BhY2l0eScsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBBbmltYXRlcyBvYmplY3QncyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZSAoaWYgc3RyaW5nKSBvciBwcm9wZXJ0aWVzIHRvIGFuaW1hdGUgKGlmIG9iamVjdClcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBhbmltYXRlIHByb3BlcnR5IHRvIChpZiBzdHJpbmcgd2FzIGdpdmVuIGZpcnN0KSBvciBvcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2FuaW1hdGlvbn1cbiAgICogQGNoYWluYWJsZVxuICAgKlxuICAgKiBBcyBvYmplY3Qg4oCUIG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICpcbiAgICogb2JqZWN0LmFuaW1hdGUoeyBsZWZ0OiAuLi4sIHRvcDogLi4uIH0pO1xuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSwgeyBkdXJhdGlvbjogLi4uIH0pO1xuICAgKlxuICAgKiBBcyBzdHJpbmcg4oCUIG9uZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSgnbGVmdCcsIC4uLik7XG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgeyBkdXJhdGlvbjogLi4uIH0pO1xuICAgKlxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHByb3BzVG9BbmltYXRlID0gW10sIHByb3AsIHNraXBDYWxsYmFja3M7XG4gICAgICBmb3IgKHByb3AgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIHByb3BzVG9BbmltYXRlLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcHNUb0FuaW1hdGUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IHByb3BzVG9BbmltYXRlW2ldO1xuICAgICAgICBza2lwQ2FsbGJhY2tzID0gaSAhPT0gbGVuIC0gMTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZShwcm9wLCBhcmd1bWVudHNbMF1bcHJvcF0sIGFyZ3VtZW50c1sxXSwgc2tpcENhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fYW5pbWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIGFuaW1hdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvIFZhbHVlIHRvIGFuaW1hdGUgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ2FsbGJhY2tzXSBXaGVuIHRydWUsIGNhbGxiYWNrcyBsaWtlIG9uY2hhbmdlIGFuZCBvbmNvbXBsZXRlIGFyZSBub3QgaW52b2tlZFxuICAgKi9cbiAgX2FuaW1hdGU6IGZ1bmN0aW9uKHByb3BlcnR5LCB0bywgb3B0aW9ucywgc2tpcENhbGxiYWNrcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIHByb3BQYWlyO1xuXG4gICAgdG8gPSB0by50b1N0cmluZygpO1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0geyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKH5wcm9wZXJ0eS5pbmRleE9mKCcuJykpIHtcbiAgICAgIHByb3BQYWlyID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcElzQ29sb3IgPVxuICAgICAgX3RoaXMuY29sb3JQcm9wZXJ0aWVzLmluZGV4T2YocHJvcGVydHkpID4gLTEgfHxcbiAgICAgIChwcm9wUGFpciAmJiBfdGhpcy5jb2xvclByb3BlcnRpZXMuaW5kZXhPZihwcm9wUGFpclsxXSkgPiAtMSk7XG5cbiAgICB2YXIgY3VycmVudFZhbHVlID0gcHJvcFBhaXJcbiAgICAgID8gdGhpcy5nZXQocHJvcFBhaXJbMF0pW3Byb3BQYWlyWzFdXVxuICAgICAgOiB0aGlzLmdldChwcm9wZXJ0eSk7XG5cbiAgICBpZiAoISgnZnJvbScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZnJvbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3BJc0NvbG9yKSB7XG4gICAgICBpZiAofnRvLmluZGV4T2YoJz0nKSkge1xuICAgICAgICB0byA9IGN1cnJlbnRWYWx1ZSArIHBhcnNlRmxvYXQodG8ucmVwbGFjZSgnPScsICcnKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG8gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSB7XG4gICAgICBzdGFydFZhbHVlOiBvcHRpb25zLmZyb20sXG4gICAgICBlbmRWYWx1ZTogdG8sXG4gICAgICBieVZhbHVlOiBvcHRpb25zLmJ5LFxuICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgYWJvcnQ6IG9wdGlvbnMuYWJvcnQgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5hYm9ydC5jYWxsKF90aGlzKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHByb3BQYWlyKSB7XG4gICAgICAgICAgX3RoaXNbcHJvcFBhaXJbMF1dW3Byb3BQYWlyWzFdXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNldChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMub25DaGFuZ2UgJiYgb3B0aW9ucy5vbkNoYW5nZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcykge1xuICAgICAgICBpZiAoc2tpcENhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldENvb3JkcygpO1xuICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUgJiYgb3B0aW9ucy5vbkNvbXBsZXRlKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAocHJvcElzQ29sb3IpIHtcbiAgICAgIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvcihfb3B0aW9ucy5zdGFydFZhbHVlLCBfb3B0aW9ucy5lbmRWYWx1ZSwgX29wdGlvbnMuZHVyYXRpb24sIF9vcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMudXRpbC5hbmltYXRlKF9vcHRpb25zKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgY29vcmRQcm9wcyA9IHsgeDE6IDEsIHgyOiAxLCB5MTogMSwgeTI6IDEgfSxcbiAgICAgIHN1cHBvcnRzTGluZURhc2ggPSBmYWJyaWMuU3RhdGljQ2FudmFzLnN1cHBvcnRzKCdzZXRMaW5lRGFzaCcpO1xuXG4gIGlmIChmYWJyaWMuTGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuTGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTGluZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuTGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkxpbmUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5MaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MjogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTI6IDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3gxJywgJ3gyJywgJ3kxJywgJ3kyJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb2ludHNdIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuTGluZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcG9pbnRzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnNldCgneDEnLCBwb2ludHNbMF0pO1xuICAgICAgdGhpcy5zZXQoJ3kxJywgcG9pbnRzWzFdKTtcbiAgICAgIHRoaXMuc2V0KCd4MicsIHBvaW50c1syXSk7XG4gICAgICB0aGlzLnNldCgneTInLCBwb2ludHNbM10pO1xuXG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLndpZHRoID0gTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpO1xuICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmFicyh0aGlzLnkyIC0gdGhpcy55MSk7XG5cbiAgICAgIHRoaXMubGVmdCA9ICdsZWZ0JyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy5sZWZ0XG4gICAgICAgIDogdGhpcy5fZ2V0TGVmdFRvT3JpZ2luWCgpO1xuXG4gICAgICB0aGlzLnRvcCA9ICd0b3AnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLnRvcFxuICAgICAgICA6IHRoaXMuX2dldFRvcFRvT3JpZ2luWSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgY29vcmRQcm9wc1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBsZWZ0VG9PcmlnaW5YIERpc3RhbmNlIGZyb20gbGVmdCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5YIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldExlZnRUb09yaWdpblg6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblgnLFxuICAgICAgICBheGlzMTogJ3gxJyxcbiAgICAgICAgYXhpczI6ICd4MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ3dpZHRoJ1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAnbGVmdCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAncmlnaHQnXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0b3BUb09yaWdpblkgRGlzdGFuY2UgZnJvbSB0b3AgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWSBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRUb3BUb09yaWdpblk6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblknLFxuICAgICAgICBheGlzMTogJ3kxJyxcbiAgICAgICAgYXhpczI6ICd5MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ2hlaWdodCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ3RvcCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAnYm90dG9tJ1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgaWYgKCF0aGlzLnN0cm9rZURhc2hBcnJheSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSAmJiBzdXBwb3J0c0xpbmVEYXNoKSB7XG4gICAgICAgIC8vIG1vdmUgZnJvbSBjZW50ZXIgKG9mIHZpcnR1YWwgYm94KSB0byBpdHMgbGVmdC90b3AgY29ybmVyXG4gICAgICAgIC8vIHdlIGNhbid0IGFzc3VtZSB4MSwgeTEgaXMgdG9wIGxlZnQgYW5kIHgyLCB5MiBpcyBib3R0b20gcmlnaHRcbiAgICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocC54MSwgcC55MSk7XG4gICAgICAgIGN0eC5saW5lVG8ocC54MiwgcC55Mik7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuXG4gICAgICAvLyBUT0RPOiB0ZXN0IHRoaXNcbiAgICAgIC8vIG1ha2Ugc3VyZSBzZXR0aW5nIFwiZmlsbFwiIGNoYW5nZXMgY29sb3Igb2YgYSBsaW5lXG4gICAgICAvLyAoYnkgY29weWluZyBmaWxsU3R5bGUgdG8gc3Ryb2tlU3R5bGUsIHNpbmNlIGxpbmUgaXMgc3Ryb2tlZCwgbm90IGZpbGxlZClcbiAgICAgIHZhciBvcmlnU3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZSB8fCBjdHguZmlsbFN0eWxlO1xuICAgICAgdGhpcy5zdHJva2UgJiYgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcmlnU3Ryb2tlU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgcC54MSwgcC55MSwgcC54MiwgcC55MiwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QgaW4gdGhlIHN2Z1xuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIHBvaW50IGZyb20gZWxlbWVudCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKHRoaXMueDEgKyB0aGlzLngyKSAvIDIsXG4gICAgICAgIHk6ICh0aGlzLnkxICsgdGhpcy55MikgLyAyLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHRoaXMuY2FsY0xpbmVQb2ludHMoKSk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpbSA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zJyk7XG4gICAgICBpZiAodGhpcy5zdHJva2VMaW5lQ2FwID09PSAnYnV0dCcpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IDApIHtcbiAgICAgICAgICBkaW0ueSAtPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIGRpbS54IC09IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyBsaW5lIHBvaW50cyBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjYWxjTGluZVBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeE11bHQgPSB0aGlzLngxIDw9IHRoaXMueDIgPyAtMSA6IDEsXG4gICAgICAgICAgeU11bHQgPSB0aGlzLnkxIDw9IHRoaXMueTIgPyAtMSA6IDEsXG4gICAgICAgICAgeDEgPSAoeE11bHQgKiB0aGlzLndpZHRoICogMC41KSxcbiAgICAgICAgICB5MSA9ICh5TXVsdCAqIHRoaXMuaGVpZ2h0ICogMC41KSxcbiAgICAgICAgICB4MiA9ICh4TXVsdCAqIHRoaXMud2lkdGggKiAtMC41KSxcbiAgICAgICAgICB5MiA9ICh5TXVsdCAqIHRoaXMuaGVpZ2h0ICogLTAuNSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHkyOiB5MlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8bGluZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3gxPVwiJywgcC54MSxcbiAgICAgICAgJ1wiIHkxPVwiJywgcC55MSxcbiAgICAgICAgJ1wiIHgyPVwiJywgcC54MixcbiAgICAgICAgJ1wiIHkyPVwiJywgcC55MixcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5MaW5lLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjTGluZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5MaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3gxIHkxIHgyIHkyJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuTGluZSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICovXG4gIGZhYnJpYy5MaW5lLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5MaW5lLkFUVFJJQlVURV9OQU1FUyksXG4gICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngxIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueDIgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLnkyIHx8IDBcbiAgICAgICAgXTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkxpbmUocG9pbnRzLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuTGluZSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5MaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gX2NhbGxiYWNrKGluc3RhbmNlKSB7XG4gICAgICBkZWxldGUgaW5zdGFuY2UucG9pbnRzO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIH07XG4gICAgdmFyIG9wdGlvbnMgPSBjbG9uZShvYmplY3QsIHRydWUpO1xuICAgIG9wdGlvbnMucG9pbnRzID0gW29iamVjdC54MSwgb2JqZWN0LnkxLCBvYmplY3QueDIsIG9iamVjdC55Ml07XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnTGluZScsIG9wdGlvbnMsIF9jYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlcyBkaXN0YW5jZSBmcm9tIGNhbnZhcyBlZGdlIHRvIExpbmUgb3JpZ2luLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVkZ2VUb09yaWdpbkdldHRlcihwcm9wZXJ0eU5hbWVzLCBvcmlnaW5WYWx1ZXMpIHtcbiAgICB2YXIgb3JpZ2luID0gcHJvcGVydHlOYW1lcy5vcmlnaW4sXG4gICAgICAgIGF4aXMxID0gcHJvcGVydHlOYW1lcy5heGlzMSxcbiAgICAgICAgYXhpczIgPSBwcm9wZXJ0eU5hbWVzLmF4aXMyLFxuICAgICAgICBkaW1lbnNpb24gPSBwcm9wZXJ0eU5hbWVzLmRpbWVuc2lvbixcbiAgICAgICAgbmVhcmVzdCA9IG9yaWdpblZhbHVlcy5uZWFyZXN0LFxuICAgICAgICBjZW50ZXIgPSBvcmlnaW5WYWx1ZXMuY2VudGVyLFxuICAgICAgICBmYXJ0aGVzdCA9IG9yaWdpblZhbHVlcy5mYXJ0aGVzdDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5nZXQob3JpZ2luKSkge1xuICAgICAgICBjYXNlIG5lYXJlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgICAgY2FzZSBjZW50ZXI6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKSArICgwLjUgKiB0aGlzLmdldChkaW1lbnNpb24pKTtcbiAgICAgICAgY2FzZSBmYXJ0aGVzdDpcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpO1xuICAgICAgfVxuICAgIH07XG5cbiAgfVxuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBwaSA9IE1hdGguUEk7XG5cbiAgaWYgKGZhYnJpYy5DaXJjbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNpcmNsZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmNsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNpcmNsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DaXJjbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgIC8qKlxuICAgICAqIFJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmFkaXVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW5nbGUgb2YgdGhlIGNpcmNsZSwgbW92aW5nIGNsb2Nrd2lzZVxuICAgICAqIGRlcHJlY2F0ZWQgdHlwZSwgdGhpcyBzaG91bGQgYmUgaW4gZGVncmVlLCB0aGlzIHdhcyBhbiBvdmVyc2lnaHQuXG4gICAgICogcHJvYmFibHkgd2lsbCBjaGFuZ2UgdG8gZGVncmVlcyBpbiBuZXh0IG1ham9yIHZlcnNpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc3RhcnRBbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIEVuZCBhbmdsZSBvZiB0aGUgY2lyY2xlXG4gICAgICogZGVwcmVjYXRlZCB0eXBlLCB0aGlzIHNob3VsZCBiZSBpbiBkZWdyZWUsIHRoaXMgd2FzIGFuIG92ZXJzaWdodC5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDJQaVxuICAgICAqL1xuICAgIGVuZEFuZ2xlOiBwaSAqIDIsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJyksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcsIHggPSAwLCB5ID0gMCxcbiAgICAgICAgICBhbmdsZSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAlICggMiAqIHBpKTtcblxuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IFtcbiAgICAgICAgICAnPGNpcmNsZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgICAnY3g9XCInICsgeCArICdcIiBjeT1cIicgKyB5ICsgJ1wiICcsXG4gICAgICAgICAgJ3I9XCInLCB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnXCIgLz5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGZhYnJpYy51dGlsLmNvcyh0aGlzLnN0YXJ0QW5nbGUpICogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBzdGFydFkgPSBmYWJyaWMudXRpbC5zaW4odGhpcy5zdGFydEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgZW5kWCA9IGZhYnJpYy51dGlsLmNvcyh0aGlzLmVuZEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgZW5kWSA9IGZhYnJpYy51dGlsLnNpbih0aGlzLmVuZEFuZ2xlKSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgbGFyZ2VGbGFnID0gYW5nbGUgPiBwaSA/ICcxJyA6ICcwJztcbiAgICAgICAgc3ZnU3RyaW5nID0gW1xuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgdGhpcy5yYWRpdXMgKyAnICcgKyB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnIDAgJywgK2xhcmdlRmxhZyArICcgMScsICcgJyArIGVuZFggKyAnICcgKyBlbmRZLFxuICAgICAgICAgICdcIiAnLCAnQ09NTU9OX1BBUlRTJywgJyAvPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdmdTdHJpbmc7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yYWRpdXMsXG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZSxcbiAgICAgICAgdGhpcy5lbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9yaXpvbnRhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJhZGl1c1g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyYWRpdXMnKSAqIHRoaXMuZ2V0KCdzY2FsZVgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2ZXJ0aWNhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJhZGl1c1k6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyYWRpdXMnKSAqIHRoaXMuZ2V0KCdzY2FsZVknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyByYWRpdXMgb2YgYW4gb2JqZWN0IChhbmQgdXBkYXRlcyB3aWR0aCBhY2NvcmRpbmdseSlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0UmFkaXVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5yYWRpdXMgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLnNldCgnd2lkdGgnLCB2YWx1ZSAqIDIpLnNldCgnaGVpZ2h0JywgdmFsdWUgKiAyKTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5DaXJjbGUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNDaXJjbGVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ2N4IGN5IHInLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQ2lyY2xlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB2YWx1ZSBvZiBgcmAgYXR0cmlidXRlIGlzIG1pc3Npbmcgb3IgaW52YWxpZFxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTKTtcblxuICAgIGlmICghaXNWYWxpZFJhZGl1cyhwYXJzZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBvZiBgcmAgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGFuZCBjYW4gbm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgfVxuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gKHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucmFkaXVzO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMudG9wID0gKHBhcnNlZEF0dHJpYnV0ZXMudG9wIHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yYWRpdXM7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5DaXJjbGUocGFyc2VkQXR0cmlidXRlcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNWYWxpZFJhZGl1cyhhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuICgoJ3JhZGl1cycgaW4gYXR0cmlidXRlcykgJiYgKGF0dHJpYnV0ZXMucmFkaXVzID49IDApKTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQ2lyY2xlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEluc3RhbmNlIG9mIGZhYnJpYy5DaXJjbGVcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnQ2lyY2xlJywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlRyaWFuZ2xlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5UcmlhbmdsZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogVHJpYW5nbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5UcmlhbmdsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UcmlhbmdsZX0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVHJpYW5nbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UcmlhbmdsZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlRyaWFuZ2xlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3RyaWFuZ2xlJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgd2lkdGg6IDEwMCxcblxuICAgIC8qKlxuICAgICAqIEhlaWdodCBpcyBzZXQgdG8gMTAwIHRvIGNvbXBlbnNhdGUgdGhlIG9sZCBpbml0aWFsaXplIGNvZGUgdGhhdCB3YXMgc2V0dGluZyBpdCB0byAxMDBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhlaWdodDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgd2lkdGhCeTIgPSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBoZWlnaHRCeTIgPSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oLXdpZHRoQnkyLCBoZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbygwLCAtaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5saW5lVG8od2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCAtd2lkdGhCeTIsIGhlaWdodEJ5MiwgMCwgLWhlaWdodEJ5MiwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCAwLCAtaGVpZ2h0QnkyLCB3aWR0aEJ5MiwgaGVpZ2h0QnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHdpZHRoQnkyLCBoZWlnaHRCeTIsIC13aWR0aEJ5MiwgaGVpZ2h0QnkyLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIC13aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MixcbiAgICAgICAgICAgICcwICcgKyAtaGVpZ2h0QnkyLFxuICAgICAgICAgICAgd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTJcbiAgICAgICAgICBdLmpvaW4oJywnKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cG9seWdvbiAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cyxcbiAgICAgICAgJ1wiIC8+J1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlRyaWFuZ2xlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVHJpYW5nbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuVHJpYW5nbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVHJpYW5nbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgcGlCeTIgICA9IE1hdGguUEkgKiAyO1xuXG4gIGlmIChmYWJyaWMuRWxsaXBzZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuRWxsaXBzZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsbGlwc2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkVsbGlwc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuRWxsaXBzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdlbGxpcHNlJyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXQoJ3J4Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ4IHx8IDApO1xuICAgICAgdGhpcy5zZXQoJ3J5Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ5IHx8IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICBjYXNlICdyeCc6XG4gICAgICAgICAgdGhpcy5yeCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncnknOlxuICAgICAgICAgIHRoaXMucnkgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnaGVpZ2h0JywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9yaXpvbnRhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncngnKSAqIHRoaXMuZ2V0KCdzY2FsZVgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBWZXJ0aWNhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncnknKSAqIHRoaXMuZ2V0KCdzY2FsZVknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8ZWxsaXBzZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ2N4PVwiMFwiIGN5PVwiMFwiICcsXG4gICAgICAgICdyeD1cIicsIHRoaXMucngsXG4gICAgICAgICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgdGhpcy5yeSAvIHRoaXMucngsIDAsIDApO1xuICAgICAgY3R4LmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yeCxcbiAgICAgICAgMCxcbiAgICAgICAgcGlCeTIsXG4gICAgICAgIGZhbHNlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjRWxsaXBzZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ2N4IGN5IHJ4IHJ5Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gKHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucng7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJ5O1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuRWxsaXBzZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdFbGxpcHNlJywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKGZhYnJpYy5SZWN0KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5SZWN0IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN0YW5nbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5SZWN0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlJlY3R9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlJlY3QjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5SZWN0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUmVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdyZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcng6ICAgMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIGJvcmRlciByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ5OiAgIDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdFJ4UnkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgcngvcnkgYXR0cmlidXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRSeFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ4ICYmICF0aGlzLnJ5KSB7XG4gICAgICAgIHRoaXMucnkgPSB0aGlzLnJ4O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yeSAmJiAhdGhpcy5yeCkge1xuICAgICAgICB0aGlzLnJ4ID0gdGhpcy5yeTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG5cbiAgICAgIC8vIDF4MSBjYXNlICh1c2VkIGluIHNwcmF5IGJydXNoKSBvcHRpbWl6YXRpb24gd2FzIHJlbW92ZWQgYmVjYXVzZVxuICAgICAgLy8gd2l0aCBjYWNoaW5nIGFuZCBoaWdoZXIgem9vbSBsZXZlbCB0aGlzIG1ha2VzIG1vcmUgZGFtYWdlIHRoYW4gaGVscFxuXG4gICAgICB2YXIgcnggPSB0aGlzLnJ4ID8gTWF0aC5taW4odGhpcy5yeCwgdGhpcy53aWR0aCAvIDIpIDogMCxcbiAgICAgICAgICByeSA9IHRoaXMucnkgPyBNYXRoLm1pbih0aGlzLnJ5LCB0aGlzLmhlaWdodCAvIDIpIDogMCxcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBpc1JvdW5kZWQgPSByeCAhPT0gMCB8fCByeSAhPT0gMCxcbiAgICAgICAgICAvKiBcIm1hZ2ljIG51bWJlclwiIGZvciBiZXppZXIgYXBwcm94aW1hdGlvbnMgb2YgYXJjcyAoaHR0cDovL2l0Yy5rdHUubHQvaXRjMzU0L1Jpc2t1czM1NC5wZGYpICovXG4gICAgICAgICAgayA9IDEgLSAwLjU1MjI4NDc0OTg7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdyAtIHJ4LCB5KTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgdyAtIGsgKiByeCwgeSwgeCArIHcsIHkgKyBrICogcnksIHggKyB3LCB5ICsgcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHggKyB3LCB5ICsgaCAtIHJ5KTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgdywgeSArIGggLSBrICogcnksIHggKyB3IC0gayAqIHJ4LCB5ICsgaCwgeCArIHcgLSByeCwgeSArIGgpO1xuXG4gICAgICBjdHgubGluZVRvKHggKyByeCwgeSArIGgpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyBrICogcngsIHkgKyBoLCB4LCB5ICsgaCAtIGsgKiByeSwgeCwgeSArIGggLSByeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4LCB5ICsgayAqIHJ5LCB4ICsgayAqIHJ4LCB5LCB4ICsgcngsIHkpO1xuXG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB4ID0gLXRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHkgPSAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodDtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4ICsgdywgeSwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSwgeCArIHcsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHggKyB3LCB5ICsgaCwgeCwgeSArIGgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSArIGgsIHgsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cmVjdCAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICdcIiByeD1cIicsIHRoaXMucngsICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5SZWN0LmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgcnggcnkgd2lkdGggaGVpZ2h0Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyk7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgID0gcGFyc2VkQXR0cmlidXRlcy50b3AgIHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgID0gcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLndpZHRoICA9IHBhcnNlZEF0dHJpYnV0ZXMud2lkdGggfHwgMDtcbiAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdChleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmVjdC52aXNpYmxlID0gcmVjdC52aXNpYmxlICYmIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjYWxsYmFjayhyZWN0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlJlY3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUmVjdCcsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5bGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlsaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIFBvaW50cyBhcnJheVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwb2ludHM6IG51bGwsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BvaW50cycpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzICh3aGVyZSBlYWNoIHBvaW50IGlzIGFuIG9iamVjdCB3aXRoIHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2x5bGluZX0gdGhpc0FyZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvbHkgPSBuZXcgZmFicmljLlBvbHlsaW5lKFtcbiAgICAgKiAgICAgeyB4OiAxMCwgeTogMTAgfSxcbiAgICAgKiAgICAgeyB4OiA1MCwgeTogMzAgfSxcbiAgICAgKiAgICAgeyB4OiA0MCwgeTogNzAgfSxcbiAgICAgKiAgICAgeyB4OiA2MCwgeTogNTAgfSxcbiAgICAgKiAgICAgeyB4OiAxMDAsIHk6IDE1MCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiAxMDAgfVxuICAgICAqICAgXSwge1xuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uRGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgX3NldFBvc2l0aW9uRGltZW5zaW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhbGNEaW0gPSB0aGlzLl9jYWxjRGltZW5zaW9ucyhvcHRpb25zKSwgY29ycmVjdExlZnRUb3A7XG4gICAgICB0aGlzLndpZHRoID0gY2FsY0RpbS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FsY0RpbS5oZWlnaHQ7XG4gICAgICBpZiAoIW9wdGlvbnMuZnJvbVNWRykge1xuICAgICAgICBjb3JyZWN0TGVmdFRvcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihcbiAgICAgICAgICB7IHg6IGNhbGNEaW0ubGVmdCAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyLCB5OiBjYWxjRGltLnRvcCAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyIH0sXG4gICAgICAgICAgJ2xlZnQnLFxuICAgICAgICAgICd0b3AnLFxuICAgICAgICAgIHRoaXMub3JpZ2luWCxcbiAgICAgICAgICB0aGlzLm9yaWdpbllcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmxlZnQgPSBvcHRpb25zLmZyb21TVkcgPyBjYWxjRGltLmxlZnQgOiBjb3JyZWN0TGVmdFRvcC54O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy50b3AgPSBvcHRpb25zLmZyb21TVkcgPyBjYWxjRGltLnRvcCA6IGNvcnJlY3RMZWZ0VG9wLnk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhdGhPZmZzZXQgPSB7XG4gICAgICAgIHg6IGNhbGNEaW0ubGVmdCArIHRoaXMud2lkdGggLyAyLFxuICAgICAgICB5OiBjYWxjRGltLnRvcCArIHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2x5Z29uIG1pbiBhbmQgbWF4IHBvaW50IGZyb20gcG9pbnRzIGFycmF5LFxuICAgICAqIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgdG8gbWVhc3VyZSB0aGVcbiAgICAgKiBwb2x5Z29uIHNpemVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC5sZWZ0IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvbiBsZWZ0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LnRvcCBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoIGRpc3RhbmNlIGJldHdlZW4gWCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbiBsZWZ0bW9zdCBhbmQgcmlnaHRtb3N0IHBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QuaGVpZ2h0IGRpc3RhbmNlIGJldHdlZW4gWSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbiB0b3Btb3N0IGFuZCBib3R0b21tb3N0IHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgbWluWCA9IG1pbihwb2ludHMsICd4JykgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKHBvaW50cywgJ3knKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYIC0gbWluWCksXG4gICAgICAgICAgaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIHBvaW50czogdGhpcy5wb2ludHMuY29uY2F0KClcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbXSwgZGlmZlggPSB0aGlzLnBhdGhPZmZzZXQueCwgZGlmZlkgPSB0aGlzLnBhdGhPZmZzZXQueSxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS54IC0gZGlmZlgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnLCcsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS55IC0gZGlmZlksIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnICdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8JyArIHRoaXMudHlwZSArICcgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMuam9pbignJyksXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgY29tbW9uUmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwb2ludCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoLFxuICAgICAgICAgIHggPSB0aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB5ID0gdGhpcy5wYXRoT2Zmc2V0Lnk7XG5cbiAgICAgIGlmICghbGVuIHx8IGlzTmFOKHRoaXMucG9pbnRzW2xlbiAtIDFdLnkpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBkcmF3IGlmIG5vIHBvaW50cyBvciBvZGQgcG9pbnRzXG4gICAgICAgIC8vIE5hTiBjb21lcyBmcm9tIHBhcnNlRmxvYXQgb2YgYSBlbXB0eSBzdHJpbmcgaW4gcGFyc2VyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCAtIHgsIHRoaXMucG9pbnRzWzBdLnkgLSB5KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54IC0geCwgcG9pbnQueSAtIHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1vblJlbmRlcihjdHgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwMSwgcDI7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwMSA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBwMiA9IHRoaXMucG9pbnRzW2kgKyAxXSB8fCBwMTtcbiAgICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCBwMS54LCBwMS55LCBwMi54LCBwMi55LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3BvaW50cycpLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNQb2x5bGluZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlsaW5lIGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yID0gZnVuY3Rpb24oX2NsYXNzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBwb2ludHMgPSBmYWJyaWMucGFyc2VQb2ludHNBdHRyaWJ1dGUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKSxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWNbX2NsYXNzXS5BVFRSSUJVVEVfTkFNRVMpO1xuICAgICAgcGFyc2VkQXR0cmlidXRlcy5mcm9tU1ZHID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWNbX2NsYXNzXShwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICAgIH07XG4gIH07XG5cbiAgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50ID0gZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yKCdQb2x5bGluZScpO1xuXG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlsaW5lIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQb2x5bGluZScsIG9iamVjdCwgY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuUG9seWdvbikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWdvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUG9seWdvbiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvbHlnb25cbiAgICogQGV4dGVuZHMgZmFicmljLlBvbHlsaW5lXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5Z29uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUG9seWdvbiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Qb2x5bGluZSwgLyoqIEBsZW5kcyBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1vblJlbmRlcihjdHgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRGFzaGVkU3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyRGFzaGVkU3Ryb2tlJywgY3R4KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlnb25FbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5Qb2x5Z29ufSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tRWxlbWVudCA9IGZhYnJpYy5Qb2x5bGluZS5mcm9tRWxlbWVudEdlbmVyYXRvcignUG9seWdvbicpO1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5Z29uIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWdvbicsIG9iamVjdCwgY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlBhdGgpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBhdGggaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXRoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjcGF0aF9hbmRfcGF0aGdyb3VwfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0aCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBhdGggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5QYXRoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGF0aCBwb2ludHNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aDogbnVsbCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncGF0aCcsICdmaWxsUnVsZScpLFxuXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdwYXRoJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwYXRoIFBhdGggZGF0YSAoc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgYW5kIGNvcnJlc3BvbmRpbmcgXCJjb21tYW5kXCIgdG9rZW5zKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbUFycmF5ID0gX3RvU3RyaW5nLmNhbGwocGF0aCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cbiAgICAgIHRoaXMucGF0aCA9IGZyb21BcnJheVxuICAgICAgICA/IGZhYnJpYy51dGlsLm1ha2VQYXRoU2ltcGxlcihwYXRoKVxuXG4gICAgICAgIDogZmFicmljLnV0aWwubWFrZVBhdGhTaW1wbGVyKFxuICAgICAgICAgIGZhYnJpYy51dGlsLnBhcnNlUGF0aChwYXRoKVxuICAgICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMucGF0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmYWJyaWMuUG9seWxpbmUucHJvdG90eXBlLl9zZXRQb3NpdGlvbkRpbWVuc2lvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIHBhdGggb25cbiAgICAgKi9cbiAgICBfcmVuZGVyUGF0aENvbW1hbmRzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IDAsXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IDAsXG4gICAgICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgICAgICBjb250cm9sWCA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgICAgICAgY29udHJvbFkgPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeVxuICAgICAgICAgIGwgPSAtdGhpcy5wYXRoT2Zmc2V0LngsXG4gICAgICAgICAgdCA9IC10aGlzLnBhdGhPZmZzZXQueTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgeCArIGwsXG4gICAgICAgICAgICAgIHkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgeCA9IHN1YnBhdGhTdGFydFg7XG4gICAgICAgICAgICB5ID0gc3VicGF0aFN0YXJ0WTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJQYXRoQ29tbWFuZHMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5QYXRoICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRvcFwiOiAnICsgdGhpcy50b3AgKyAnLCBcImxlZnRcIjogJyArIHRoaXMubGVmdCArICcgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIHBhdGg6IHRoaXMucGF0aC5tYXAoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5zbGljZSgpOyB9KSxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvID0gdGhpcy50b09iamVjdChbJ3NvdXJjZVBhdGgnXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgICAgaWYgKG8uc291cmNlUGF0aCkge1xuICAgICAgICBkZWxldGUgby5wYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGgubWFwKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbignICcpO1xuICAgICAgfSkuam9pbignICcpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxwYXRoICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAnZD1cIicsIHBhdGgsXG4gICAgICAgICdcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgJyxcbiAgICAgICAgJy8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuXG4gICAgX2dldE9mZnNldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlnaXRzID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgcmV0dXJuICcgdHJhbnNsYXRlKCcgKyB0b0ZpeGVkKC10aGlzLnBhdGhPZmZzZXQueCwgZGlnaXRzKSArICcsICcgK1xuICAgICAgICAgIHRvRml4ZWQoLXRoaXMucGF0aE9mZnNldC55LCBkaWdpdHMpICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgYWRkaXRpb25hbFRyYW5zZm9ybSA9IHRoaXMuX2dldE9mZnNldFRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuICdcXHQnICsgdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKFxuICAgICAgICB0aGlzLl90b1NWRygpLCB7IHJldml2ZXI6IHJldml2ZXIsIGFkZGl0aW9uYWxUcmFuc2Zvcm06IGFkZGl0aW9uYWxUcmFuc2Zvcm0gfVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsVHJhbnNmb3JtID0gdGhpcy5fZ2V0T2Zmc2V0VHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCh0aGlzLl90b1NWRygpLCB7IHJldml2ZXI6IHJldml2ZXIsIGFkZGl0aW9uYWxUcmFuc2Zvcm06IGFkZGl0aW9uYWxUcmFuc2Zvcm0gIH0pO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZSBjb21wbGV4aXR5XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHN1YnBhdGhTdGFydFggPSAwLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSAwLFxuICAgICAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICAgICAgYm91bmRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgeCA9IHN1YnBhdGhTdGFydFg7XG4gICAgICAgICAgICB5ID0gc3VicGF0aFN0YXJ0WTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgIGFYLnB1c2gocG9pbnQueCk7XG4gICAgICAgICAgYVkucHVzaChwb2ludC55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFYLnB1c2goeCk7XG4gICAgICAgIGFZLnB1c2goeSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5YID0gbWluKGFYKSB8fCAwLFxuICAgICAgICAgIG1pblkgPSBtaW4oYVkpIHx8IDAsXG4gICAgICAgICAgbWF4WCA9IG1heChhWCkgfHwgMCxcbiAgICAgICAgICBtYXhZID0gbWF4KGFZKSB8fCAwLFxuICAgICAgICAgIGRlbHRhWCA9IG1heFggLSBtaW5YLFxuICAgICAgICAgIGRlbHRhWSA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiBkZWx0YVgsXG4gICAgICAgIGhlaWdodDogZGVsdGFZXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLlBhdGggZnJvbSBhbiBvYmplY3RcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3Quc291cmNlUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwYXRoVXJsID0gb2JqZWN0LnNvdXJjZVBhdGg7XG4gICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwocGF0aFVybCwgZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwYXRoID0gZWxlbWVudHNbMF07XG4gICAgICAgIHBhdGguc2V0T3B0aW9ucyhvYmplY3QpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BhdGgnLCBvYmplY3QsIGNhbGxiYWNrLCAncGF0aCcpO1xuICAgIH1cbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5QYXRoLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChbJ2QnXSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLlBhdGggZnJvbSBhbiBTVkcgPHBhdGg+IGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5QYXRoLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5mcm9tU1ZHID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBhdGgocGFyc2VkQXR0cmlidXRlcy5kLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4O1xuXG4gIGlmIChmYWJyaWMuR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Hcm91cFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Hcm91cCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyb3VwID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgZmFicmljLkNvbGxlY3Rpb24sIC8qKiBAbGVuZHMgZmFicmljLkdyb3VwLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2dyb3VwJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgY2xpY2ssIG1vdXNlb3ZlciwgbW91c2VvdXQgZXZlbnRzICYgaG92ZXJDdXJzb3Igc2hvdWxkIGFsc28gY2hlY2sgZm9yIHN1YnRhcmdldHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJUYXJnZXRDaGVjazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYXJlIGNvbnRhaW5lciwgZG8gbm90IHJlbmRlciBhbnl0aGluZyBvbiB0aGV5ciBvd24sIGVuY2Ugbm8gY2FjaGUgcHJvcGVydGllc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogc2V0T25Hcm91cCBpcyBhIG1ldGhvZCB1c2VkIGZvciBUZXh0Qm94IHRoYXQgaXMgbm8gbW9yZSB1c2VkIHNpbmNlIDIuMC4wIFRoZSBiZWhhdmlvciBpcyBzdGlsbFxuICAgICAqIGF2YWlsYWJsZSBzZXR0aW5nIHRoaXMgYm9vbGVhbiB0byB0cnVlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVzZVNldE9uR3JvdXA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBHcm91cCBvYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQWxyZWFkeUdyb3VwZWRdIGlmIHRydWUsIG9iamVjdHMgaGF2ZSBiZWVuIGdyb3VwZWQgYWxyZWFkeS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzLCBvcHRpb25zLCBpc0FscmVhZHlHcm91cGVkKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIC8vIGlmIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LFxuICAgICAgLy8gd2UgY2Fubm90IGNoYW5nZSBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuXG4gICAgICAvLyBUaHVzIHdlIG5lZWQgdG8gc2V0IG9wdGlvbnMgdG8gZ3JvdXAgd2l0aG91dCBvYmplY3RzLFxuICAgICAgaXNBbHJlYWR5R3JvdXBlZCAmJiB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uZ3JvdXAgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jZW50ZXJQb2ludDtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBzZXQgb3JpZ2lucyBiZWZvcmUgY2FsY3VsYXRpbmcgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgICAgLy8gc28gdGhhdCB0aGUgdG9wbGVmdCBjYW4gYmUgc2V0IHdpdGggdGhhdCBpbiBtaW5kLlxuICAgICAgICAvLyBpZiBzcGVjaWZpYyB0b3AgYW5kIGxlZnQgYXJlIHBhc3NlZCwgYXJlIG92ZXJ3cml0dGVuIGxhdGVyXG4gICAgICAgIC8vIHdpdGggdGhlIGNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpXG4gICAgICAgIGlmIChvcHRpb25zLm9yaWdpblggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3JpZ2luWCA9IG9wdGlvbnMub3JpZ2luWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5ZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY29taW5nIGZyb20gc3ZnIGkgZG8gbm90IHdhbnQgdG8gY2FsYyBib3VuZHMuXG4gICAgICAgIC8vIGkgYXNzdW1lIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHBhc3NlZCBhbG9uZyBvcHRpb25zXG4gICAgICAgIGNlbnRlciB8fCB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoY2VudGVyKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2VudGVyUG9pbnQ7XG4gICAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0FDb29yZHMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0c0FDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNraXBDb250cm9scyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ29vcmRzQ2hhbmdlXSBpZiB0cnVlLCBjb29yZGluYXRlcyBvZiBvYmplY3RzIGVuY2xvc2VkIGluIGEgZ3JvdXAgZG8gbm90IGNoYW5nZVxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RzQ29vcmRzOiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgIHZhciBjZW50ZXIgPSBjZW50ZXIgfHwgdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICl7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdENvb3Jkcyh0aGlzLl9vYmplY3RzW2ldLCBjZW50ZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyLCBjdXJyZW50IGNlbnRlciBvZiBncm91cC5cbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0Q29vcmRzOiBmdW5jdGlvbihvYmplY3QsIGNlbnRlcikge1xuICAgICAgdmFyIG9iamVjdExlZnQgPSBvYmplY3QubGVmdCxcbiAgICAgICAgICBvYmplY3RUb3AgPSBvYmplY3QudG9wLFxuICAgICAgICAgIHNraXBDb250cm9scyA9IHRydWU7XG5cbiAgICAgIG9iamVjdC5zZXQoe1xuICAgICAgICBsZWZ0OiBvYmplY3RMZWZ0IC0gY2VudGVyLngsXG4gICAgICAgIHRvcDogb2JqZWN0VG9wIC0gY2VudGVyLnlcbiAgICAgIH0pO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuR3JvdXA6ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9iamVjdCB0byBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICAgIGZhYnJpYy51dGlsLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgICAgb2JqZWN0Ll9zZXQoJ2NhbnZhcycsIHRoaXMuY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbW92ZVdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy51c2VTZXRPbkdyb3VwKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldE9uR3JvdXAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLl9zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLl9zZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIF9pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICB2YXIgb2Jqc1RvT2JqZWN0ID0gdGhpcy5fb2JqZWN0cy5tYXAoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbERlZmF1bHRzID0gb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBfaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIHZhciBfb2JqID0gb2JqLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICByZXR1cm4gX29iajtcbiAgICAgIH0pO1xuICAgICAgdmFyIG9iaiA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBvYmoub2JqZWN0cyA9IG9ianNUb09iamVjdDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlLCBpbiBkYXRhbGVzcyBtb2RlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmpzVG9PYmplY3QsIHNvdXJjZVBhdGggPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICBpZiAoc291cmNlUGF0aCkge1xuICAgICAgICBvYmpzVG9PYmplY3QgPSBzb3VyY2VQYXRoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBfaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSB0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBvYmpzVG9PYmplY3QgPSB0aGlzLl9vYmplY3RzLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxEZWZhdWx0cyA9IG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBfaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgdmFyIF9vYmogPSBvYmoudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b0RhdGFsZXNzT2JqZWN0LmNhbGwodGhpcywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBvYmoub2JqZWN0cyA9IG9ianNUb09iamVjdDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgaW5zdGFuY2Ugb24gYSBnaXZlbiBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBpbnN0YW5jZSBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgICAgdGhpcy5fdHJhbnNmb3JtRG9uZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBpcyBhbHJlYWR5IGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvd25DYWNoZSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnNob3VsZENhY2hlLmNhbGwodGhpcyk7XG4gICAgICBpZiAob3duQ2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXS53aWxsRHJhd1NoYWRvdygpKSB7XG4gICAgICAgICAgICB0aGlzLm93bkNhY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvd25DYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3Qgb3IgYSBjaGlsZCBvYmplY3Qgd2lsbCBjYXN0IGEgc2hhZG93XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZmFicmljLk9iamVjdC5wcm90b3R5cGUud2lsbERyYXdTaGFkb3cuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bkNhY2hpbmcgfHwgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC5pc09uQUNhY2hlKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnJlbmRlcihjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZHJhd0NsaXBQYXRoKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGRpcnR5XG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbihza2lwQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy5jYWxsU3VwZXIoJ2lzQ2FjaGVEaXJ0eScsIHNraXBDYW52YXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLmlzQ2FjaGVEaXJ0eSh0cnVlKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcykge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBncm91cCBoYXMgbm90IGEgY2FjaGUgY2FudmFzIHRoZXJlIGlzIG5vdGhpbmcgdG8gY2xlYW5cbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5jYWNoZVdpZHRoIC8gdGhpcy56b29tWCwgeSA9IHRoaXMuY2FjaGVIZWlnaHQgLyB0aGlzLnpvb21ZO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgteCAvIDIsIC15IC8gMiwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIHN0YXRlIG9mIGVhY2ggb2YgZ3JvdXAgb2JqZWN0cyAob3JpZ2luYWwgc3RhdGUgaXMgdGhhdCB3aGljaCB3YXMgYmVmb3JlIGdyb3VwIHdhcyBjcmVhdGVkKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZU9iamVjdHNTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2godGhpcy5fcmVzdG9yZU9iamVjdFN0YXRlLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyB0aGUgdHJhbnNmb3JtIGZyb20gdGhpcyBncm91cCBvbnRvIHRoZSBzdXBwbGllZCBvYmplY3RcbiAgICAgKiBpLmUuIGl0IHRlbGxzIHlvdSB3aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGUgc3VwcGxpZWQgb2JqZWN0IHdhcyBpblxuICAgICAqIHRoZSBncm91cCwgYW5kIHRoZW4gdGhlIGdyb3VwIHdhcyBkZXN0cm95ZWQuIEl0IG11dGF0ZXMgdGhlIHN1cHBsaWVkXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdHJhbnNmb3JtZWRPYmplY3RcbiAgICAgKi9cbiAgICByZWFsaXplVHJhbnNmb3JtOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBtYXRyaXggPSBvYmplY3QuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShtYXRyaXgpLFxuICAgICAgICAgIGNlbnRlciA9IG5ldyBmYWJyaWMuUG9pbnQob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgb2JqZWN0LmZsaXBYID0gZmFsc2U7XG4gICAgICBvYmplY3QuZmxpcFkgPSBmYWxzZTtcbiAgICAgIG9iamVjdC5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgIG9iamVjdC5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgIG9iamVjdC5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICBvYmplY3Quc2tld1kgPSBvcHRpb25zLnNrZXdZO1xuICAgICAgb2JqZWN0LmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgIG9iamVjdC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIHN0YXRlIG9mIGEgc3BlY2lmaWVkIG9iamVjdCBpbiBncm91cFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfcmVzdG9yZU9iamVjdFN0YXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMucmVhbGl6ZVRyYW5zZm9ybShvYmplY3QpO1xuICAgICAgZGVsZXRlIG9iamVjdC5ncm91cDtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIGdyb3VwIChyZXN0b3Jpbmcgc3RhdGUgb2YgaXRzIG9iamVjdHMpXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gd2hlbiBncm91cCBpcyBkZXN0cm95ZWQgb2JqZWN0cyBuZWVkcyB0byBnZXQgYSByZXBhaW50IHRvIGJlIGV2ZW50dWFsbHlcbiAgICAgIC8vIGRpc3BsYXllZCBvbiBjYW52YXMuXG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBncm91cCBhbiBhY3RpdmUgc2VsZWN0aW9uLCByZW1vdmUgdGhlIGdyb3VwIGZyb20gY2FudmFzXG4gICAgICogdGhlIGdyb3VwIGhhcyB0byBiZSBvbiBjYW52YXMgZm9yIHRoaXMgdG8gd29yay5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQWN0aXZlU2VsZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHRvQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMub2JqZWN0cztcbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihbXSk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uc2V0KG9wdGlvbnMpO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnR5cGUgPSAnYWN0aXZlU2VsZWN0aW9uJztcbiAgICAgIGNhbnZhcy5yZW1vdmUodGhpcyk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgb2JqZWN0LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgY2FudmFzLmFkZChvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uY2FudmFzID0gY2FudmFzO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzID0gb2JqZWN0cztcbiAgICAgIGNhbnZhcy5fYWN0aXZlT2JqZWN0ID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIGFjdGl2ZVNlbGVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB1bmdyb3VwT25DYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb29yZGluYXRlcyBvZiBhbGwgb2JqZWN0cyBpbnNpZGUgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0T2JqZWN0c0Nvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2tpcENvbnRyb2xzID0gdHJ1ZTtcbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3Jkcyhza2lwQ29udHJvbHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0JvdW5kczogZnVuY3Rpb24ob25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICB2YXIgYVggPSBbXSxcbiAgICAgICAgICBhWSA9IFtdLFxuICAgICAgICAgIG8sIHByb3AsXG4gICAgICAgICAgcHJvcHMgPSBbJ3RyJywgJ2JyJywgJ2JsJywgJ3RsJ10sXG4gICAgICAgICAgaSA9IDAsIGlMZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aCxcbiAgICAgICAgICBqLCBqTGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKCA7IGkgPCBpTGVuOyArK2kpIHtcbiAgICAgICAgbyA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIG8uYUNvb3JkcyA9IG8uY2FsY0FDb29yZHMoKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICBhWC5wdXNoKG8uYUNvb3Jkc1twcm9wXS54KTtcbiAgICAgICAgICBhWS5wdXNoKG8uYUNvb3Jkc1twcm9wXS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9nZXRCb3VuZHMoYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGFYLCBhWSwgb25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICB2YXIgbWluWFkgPSBuZXcgZmFicmljLlBvaW50KG1pbihhWCksIG1pbihhWSkpLFxuICAgICAgICAgIG1heFhZID0gbmV3IGZhYnJpYy5Qb2ludChtYXgoYVgpLCBtYXgoYVkpKSxcbiAgICAgICAgICB0b3AgPSBtaW5YWS55IHx8IDAsIGxlZnQgPSBtaW5YWS54IHx8IDAsXG4gICAgICAgICAgd2lkdGggPSAobWF4WFkueCAtIG1pblhZLngpIHx8IDAsXG4gICAgICAgICAgaGVpZ2h0ID0gKG1heFhZLnkgLSBtaW5YWS55KSB8fCAwO1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAoIW9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgICAvLyB0aGUgYm91bmRpbmcgYm94IGFsd2F5cyBmaW5kcyB0aGUgdG9wbGVmdCBtb3N0IGNvcm5lci5cbiAgICAgICAgLy8gd2hhdGV2ZXIgaXMgdGhlIGdyb3VwIG9yaWdpbiwgd2Ugc2V0IHVwIGhlcmUgdGhlIGxlZnQvdG9wIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4oeyB4OiBsZWZ0LCB5OiB0b3AgfSwgJ2xlZnQnLCAndG9wJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gWyc8ZyAnLCAnQ09NTU9OX1BBUlRTJywgJyA+XFxuJ107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKCdcXHRcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICAgIHN2Z1N0cmluZy5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnQsIHNwZWNpZmljIHZlcnNpb24gZm9yIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHR5cGVvZiB0aGlzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIHRoaXMub3BhY2l0eSAhPT0gMSA/XG4gICAgICAgICAgICAnb3BhY2l0eTogJyArIHRoaXMub3BhY2l0eSArICc7JyA6ICcnLFxuICAgICAgICAgIHZpc2liaWxpdHkgPSB0aGlzLnZpc2libGUgPyAnJyA6ICcgdmlzaWJpbGl0eTogaGlkZGVuOyc7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBvcGFjaXR5LFxuICAgICAgICB0aGlzLmdldFN2Z0ZpbHRlcigpLFxuICAgICAgICB2aXNpYmlsaXR5XG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKCdcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvQ2xpcFBhdGhTVkcocmV2aXZlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKHN2Z1N0cmluZywgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JvdXB9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Hcm91cFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncm91cCBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZ3JvdXAgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkdyb3VwLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdHMgPSBvYmplY3Qub2JqZWN0cyxcbiAgICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvYmplY3QsIHRydWUpO1xuICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgaWYgKHR5cGVvZiBvYmplY3RzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gaXQgaGFzIHRvIGJlIGFuIHVybCBvciBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChvYmplY3RzLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhlbGVtZW50cywgb2JqZWN0LCBvYmplY3RzKTtcbiAgICAgICAgZ3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhncm91cCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0cywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoW29iamVjdC5jbGlwUGF0aF0sIGZ1bmN0aW9uKGVubGl2ZWRDbGlwUGF0aCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvYmplY3QsIHRydWUpO1xuICAgICAgICBvcHRpb25zLmNsaXBQYXRoID0gZW5saXZlZENsaXBQYXRoWzBdO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkdyb3VwKGVubGl2ZW5lZE9iamVjdHMsIG9wdGlvbnMsIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQGV4dGVuZHMgZmFicmljLkdyb3VwXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2dyb3Vwc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkFjdGl2ZVNlbGVjdGlvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkFjdGl2ZVNlbGVjdGlvbiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Hcm91cCwgLyoqIEBsZW5kcyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2FjdGl2ZVNlbGVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEFjdGl2ZVNlbGVjdGlvbiBvYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uZ3JvdXAgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5YKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IG9wdGlvbnMub3JpZ2luWDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3B0aW9ucy5vcmlnaW5ZO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRlIGFjdGl2ZVNlbGVjdGlvbiB0byBhIG5vcm1hbCBncm91cCxcbiAgICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRoYXQgYXV0b21hdGljYWxseSBhZGRzIGl0IHRvIGNhbnZhcyBhc1xuICAgICAqIGFjdGl2ZSBvYmplY3QuIG5vIGV2ZW50cyBmaXJlZC5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9XG4gICAgICovXG4gICAgdG9Hcm91cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMuY29uY2F0KCk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG4gICAgICB2YXIgbmV3R3JvdXAgPSBuZXcgZmFicmljLkdyb3VwKFtdKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnR5cGU7XG4gICAgICBuZXdHcm91cC5zZXQob3B0aW9ucyk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5jYW52YXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IG5ld0dyb3VwO1xuICAgICAgfSk7XG4gICAgICBuZXdHcm91cC5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNhbnZhcy5hZGQobmV3R3JvdXApO1xuICAgICAgY2FudmFzLl9hY3RpdmVPYmplY3QgPSBuZXdHcm91cDtcbiAgICAgIG5ld0dyb3VwLnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIG5ld0dyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiByZXR1cm5zIHRydWUsIGRlc2VsZWN0aW9uIGlzIGNhbmNlbGxlZC5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBbY2FuY2VsXVxuICAgICAqL1xuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5BY3RpdmVTZWxlY3Rpb246ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG9iamVjdENhY2hpbmcgaXMgYSBnbG9iYWwgZmxhZywgd2lucyBvdmVyIGV2ZXJ5dGhpbmdcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgb3V0c2lkZSBpcyBjYWNoZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGNvbnRyb2xzIGFuZCBib3JkZXJzIGZvciB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjaGlsZHJlbk92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBjaGlsZHJlbiBvdmVycmlkZXNcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSwgY2hpbGRyZW5PdmVycmlkZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyQ29udHJvbHMnLCBjdHgsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgY2hpbGRyZW5PdmVycmlkZSA9IGNoaWxkcmVuT3ZlcnJpZGUgfHwgeyB9O1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbk92ZXJyaWRlLmhhc0NvbnRyb2xzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjaGlsZHJlbk92ZXJyaWRlLmhhc0NvbnRyb2xzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbk92ZXJyaWRlLmZvckFjdGl2ZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLl9yZW5kZXJDb250cm9scyhjdHgsIGNoaWxkcmVuT3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkFjdGl2ZVNlbGVjdGlvbn0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkFjdGl2ZVNlbGVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncm91cCBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gQWN0aXZlU2VsZWN0aW9uIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3Qub2JqZWN0cywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgZGVsZXRlIG9iamVjdC5vYmplY3RzO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oZW5saXZlbmVkT2JqZWN0cywgb2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmICghZ2xvYmFsLmZhYnJpYykge1xuICAgIGdsb2JhbC5mYWJyaWMgPSB7IH07XG4gIH1cblxuICBpZiAoZ2xvYmFsLmZhYnJpYy5JbWFnZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuSW1hZ2UgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbWFnZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjaW1hZ2VzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgc3Ryb2tlLlxuICAgICAqIEZvciBpbWFnZSBxdWFsaXR5IGEgc3Ryb2tlIG11bHRpcGxlIG9mIDIgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2FsbGluZyB7QGxpbmsgZmFicmljLkltYWdlLmdldFNyY30sIHJldHVybiB2YWx1ZSBmcm9tIGVsZW1lbnQgc3JjIHdpdGggYGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKWAuXG4gICAgICogVGhpcyBhbGxvd3MgZm9yIHJlbGF0aXZlIHVybHMgYXMgaW1hZ2Ugc3JjLlxuICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNyY0Zyb21BdHRyaWJ1dGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGVYIHRvIGRldGVjdFxuICAgICAqIGlmIHRoZSBJbWFnZSBnb3QgcmVzaXplZCBhZnRlciB0aGUgbGFzdCBSZW5kZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfbGFzdFNjYWxlWDogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxlWSB0byBkZXRlY3RcbiAgICAgKiBpZiB0aGUgSW1hZ2UgZ290IHJlc2l6ZWQgYWZ0ZXIgdGhlIGxhc3QgUmVuZGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2xhc3RTY2FsZVk6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsaW5nIGFwcGxpZWQgYnkgdGhlIGFwcGx5IGZpbHRlciBjaGFpblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9maWx0ZXJTY2FsaW5nWDogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxpbmcgYXBwbGllZCBieSB0aGUgYXBwbHkgZmlsdGVyIGNoYWluXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2ZpbHRlclNjYWxpbmdZOiAxLFxuXG4gICAgLyoqXG4gICAgICogbWluaW11bSBzY2FsZSBmYWN0b3IgdW5kZXIgd2hpY2ggYW55IHJlc2l6ZUZpbHRlciBpcyB0cmlnZ2VyZWQgdG8gcmVzaXplIHRoZSBpbWFnZVxuICAgICAqIDAgd2lsbCBkaXNhYmxlIHRoZSBhdXRvbWF0aWMgcmVzaXplLiAxIHdpbGwgdHJpZ2dlciBhdXRvbWF0aWNhbGx5IGFsd2F5cy5cbiAgICAgKiBudW1iZXIgYmlnZ2VyIHRoYW4gMSBhcmUgbm90IGltcGxlbWVudGVkIHlldC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBtaW5pbXVtU2NhbGVUcmlnZ2VyOiAwLjUsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgnY3JvcFgnLCAnY3JvcFknKSxcblxuICAgIC8qKlxuICAgICAqIGtleSB1c2VkIHRvIHJldHJpZXZlIHRoZSB0ZXh0dXJlIHJlcHJlc2VudGluZyB0aGlzIGltYWdlXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjYWNoZUtleTogJycsXG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBjcm9wIGluIHBpeGVscyBmcm9tIG9yaWdpbmFsIGltYWdlIHNpemUuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9wWDogMCxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BZOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nIHdoZW4gcGFpbnRpbmcgdGhpcyBpbWFnZS5cbiAgICAgKiBBbHNvIGluZmx1ZW5jZSBpZiB0aGUgY2FjaGVDYW52YXMgZm9yIHRoaXMgaW1hZ2UgdXNlcyBpbWFnZVNtb290aGluZ1xuICAgICAqIEBzaW5jZSA0LjAuMC1iZXRhLjExXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW1hZ2VTbW9vdGhpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IFN0cmluZ30gZWxlbWVudCBJbWFnZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBldmVudHVhbCBmaWx0ZXJzIGFwcGxpZWQuXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAgIHRoaXMuY2FjaGVLZXkgPSAndGV4dHVyZScgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW1hZ2UgZWxlbWVudCB3aGljaCB0aGlzIGluc3RhbmNlIGlmIGJhc2VkIG9uXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSW1hZ2UgZWxlbWVudFxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgaW1hZ2UgZWxlbWVudCBmb3IgdGhpcyBpbnN0YW5jZSB0byBhIHNwZWNpZmllZCBvbmUuXG4gICAgICogSWYgZmlsdGVycyBkZWZpbmVkIHRoZXkgYXJlIGFwcGxpZWQgdG8gbmV3IGltYWdlLlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYGNhbnZhcy5yZW5kZXJBbGxgIGFuZCBgb2JqZWN0LnNldENvb3Jkc2AgYWZ0ZXIgcmVwbGFjaW5nLCB0byByZW5kZXIgbmV3IGltYWdlIGFuZCB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5KTtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5faW5pdENvbmZpZyhvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICAvLyByZXNpemVGaWx0ZXJzIHdvcmsgb24gdGhlIGFscmVhZHkgZmlsdGVyZWQgY29weS5cbiAgICAgIC8vIHdlIG5lZWQgdG8gYXBwbHkgcmVzaXplRmlsdGVycyBBRlRFUiBub3JtYWwgZmlsdGVycy5cbiAgICAgIC8vIGFwcGx5UmVzaXplRmlsdGVycyBpcyBydW4gbW9yZSBvZnRlbiB0aGFuIG5vcm1hbCBmaWx0ZXJzXG4gICAgICAvLyBhbmQgaXMgdHJpZ2dlcmVkIGJ5IHVzZXIgaW50ZXJhY3Rpb25zIHJhdGhlciB0aGFuIGRldiBjb2RlXG4gICAgICBpZiAodGhpcy5yZXNpemVGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBzaW5nbGUgdGV4dHVyZSBpZiBpbiB3ZWJnbCBtb2RlXG4gICAgICovXG4gICAgcmVtb3ZlVGV4dHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgYmFja2VuZCA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kO1xuICAgICAgaWYgKGJhY2tlbmQgJiYgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSkge1xuICAgICAgICBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KGtleSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0ZXh0dXJlcywgcmVmZXJlbmNlIHRvIGVsZW1lbnRzIGFuZCBldmVudHVhbGx5IEpTRE9NIGNsZWFudXBcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5KTtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgWydfb3JpZ2luYWxFbGVtZW50JywgJ19lbGVtZW50JywgJ19maWx0ZXJlZEVsJywgJ19jYWNoZUNhbnZhcyddLmZvckVhY2goKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSh0aGlzW2VsZW1lbnRdKTtcbiAgICAgICAgdGhpc1tlbGVtZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNyb3NzT3JpZ2luIHZhbHVlIChvZiB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBlbGVtZW50KVxuICAgICAqL1xuICAgIGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbEVsZW1lbnQgJiYgKHRoaXMuX29yaWdpbmFsRWxlbWVudC5jcm9zc09yaWdpbiB8fCBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvcmlnaW5hbCBzaXplIG9mIGFuIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9yaWdpbmFsU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGggLyAyLCBoID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtdywgLWgpO1xuICAgICAgY3R4LmxpbmVUbyh3LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIGgpO1xuICAgICAgY3R4LmxpbmVUbygtdywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCAtaCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJEYXNoZWRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgdGhpcyk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCwgeSwgeCArIHcsIHksIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGZhYnJpYy51dGlsLmRyYXdEYXNoZWRMaW5lKGN0eCwgeCArIHcsIHksIHggKyB3LCB5ICsgaCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgZmFicmljLnV0aWwuZHJhd0Rhc2hlZExpbmUoY3R4LCB4ICsgdywgeSArIGgsIHgsIHkgKyBoLCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBmYWJyaWMudXRpbC5kcmF3RGFzaGVkTGluZShjdHgsIHgsIHkgKyBoLCB4LCB5LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZmlsdGVycyA9IFtdO1xuXG4gICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXJPYmopIHtcbiAgICAgICAgaWYgKGZpbHRlck9iaikge1xuICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXJPYmoudG9PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9iamVjdCA9IGV4dGVuZChcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoXG4gICAgICAgICAgJ3RvT2JqZWN0JyxcbiAgICAgICAgICBbJ2Nyb3BYJywgJ2Nyb3BZJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICksIHtcbiAgICAgICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuZ2V0Q3Jvc3NPcmlnaW4oKSxcbiAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICBvYmplY3QucmVzaXplRmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbWFnZSBoYXMgY3JvcCBhcHBsaWVkLCBpbnNwZWN0aW5nIHZhbHVlcyBvZiBjcm9wWCxjcm9wWSx3aWR0aCxoZWlnaHQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDcm9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyb3BYIHx8IHRoaXMuY3JvcFkgfHwgdGhpcy53aWR0aCA8IHRoaXMuX2VsZW1lbnQud2lkdGggfHwgdGhpcy5oZWlnaHQgPCB0aGlzLl9lbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW10sIGltYWdlTWFya3VwID0gW10sIHN0cm9rZVN2ZywgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgeCA9IC10aGlzLndpZHRoIC8gMiwgeSA9IC10aGlzLmhlaWdodCAvIDIsIGNsaXBQYXRoID0gJycsIGltYWdlUmVuZGVyaW5nID0gJyc7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzQ3JvcCgpKSB7XG4gICAgICAgIHZhciBjbGlwUGF0aElkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBzdmdTdHJpbmcucHVzaChcbiAgICAgICAgICAnPGNsaXBQYXRoIGlkPVwiaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJ1wiPlxcbicsXG4gICAgICAgICAgJ1xcdDxyZWN0IHg9XCInICsgeCArICdcIiB5PVwiJyArIHkgKyAnXCIgd2lkdGg9XCInICsgdGhpcy53aWR0aCArICdcIiBoZWlnaHQ9XCInICsgdGhpcy5oZWlnaHQgKyAnXCIgLz5cXG4nLFxuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbidcbiAgICAgICAgKTtcbiAgICAgICAgY2xpcFBhdGggPSAnIGNsaXAtcGF0aD1cInVybCgjaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJylcIiAnO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmltYWdlU21vb3RoaW5nKSB7XG4gICAgICAgIGltYWdlUmVuZGVyaW5nID0gJ1wiIGltYWdlLXJlbmRlcmluZz1cIm9wdGltaXplU3BlZWQnO1xuICAgICAgfVxuICAgICAgaW1hZ2VNYXJrdXAucHVzaCgnXFx0PGltYWdlICcsICdDT01NT05fUEFSVFMnLCAneGxpbms6aHJlZj1cIicsIHRoaXMuZ2V0U3ZnU3JjKHRydWUpLFxuICAgICAgICAnXCIgeD1cIicsIHggLSB0aGlzLmNyb3BYLCAnXCIgeT1cIicsIHkgLSB0aGlzLmNyb3BZLFxuICAgICAgICAvLyB3ZSdyZSBlc3NlbnRpYWxseSBtb3Zpbmcgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIGZyb20gdG9wL2xlZnQgY29ybmVyIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlXG4gICAgICAgIC8vIGJ5IHdyYXBwaW5nIGl0IGluIGNvbnRhaW5lciA8Zz4gZWxlbWVudCB3aXRoIGFjdHVhbCB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBvZmZzZXR0aW5nIG9iamVjdCB0byB0aGUgdG9wL2xlZnRcbiAgICAgICAgLy8gc28gdGhhdCBvYmplY3QncyBjZW50ZXIgYWxpZ25zIHdpdGggY29udGFpbmVyJ3MgbGVmdC90b3BcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgZWxlbWVudC53aWR0aCB8fCBlbGVtZW50Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsIGVsZW1lbnQuaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBpbWFnZVJlbmRlcmluZyxcbiAgICAgICAgJ1wiJywgY2xpcFBhdGgsXG4gICAgICAgICc+PC9pbWFnZT5cXG4nKTtcblxuICAgICAgaWYgKHRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlRGFzaEFycmF5KSB7XG4gICAgICAgIHZhciBvcmlnRmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgdGhpcy5maWxsID0gbnVsbDtcbiAgICAgICAgc3Ryb2tlU3ZnID0gW1xuICAgICAgICAgICdcXHQ8cmVjdCAnLFxuICAgICAgICAgICd4PVwiJywgeCwgJ1wiIHk9XCInLCB5LFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgICB0aGlzLmZpbGwgPSBvcmlnRmlsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJykge1xuICAgICAgICBzdmdTdHJpbmcgPSBzdmdTdHJpbmcuY29uY2F0KHN0cm9rZVN2ZywgaW1hZ2VNYXJrdXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5jb25jYXQoaW1hZ2VNYXJrdXAsIHN0cm9rZVN2Zyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlsdGVyZWQgaW5kaWNhdGVzIGlmIHRoZSBzcmMgaXMgbmVlZGVkIGZvciBzdmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqL1xuICAgIGdldFNyYzogZnVuY3Rpb24oZmlsdGVyZWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmlsdGVyZWQgPyB0aGlzLl9lbGVtZW50IDogdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudG9EYXRhVVJMKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9EYXRhVVJMKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zcmNGcm9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5zcmM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcmMgfHwgJyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBTb3VyY2Ugc3RyaW5nIChVUkwpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIChhbmQgYWxsIGZpbHRlcnMgaGF2ZSBiZWVuIGFwcGxpZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTcmM6IGZ1bmN0aW9uKHNyYywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShzcmMsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcywgaXNFcnJvcik7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkltYWdlOiB7IHNyYzogXCInICsgdGhpcy5nZXRTcmMoKSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIGFwcGx5UmVzaXplRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIsXG4gICAgICAgICAgbWluaW11bVNjYWxlID0gdGhpcy5taW5pbXVtU2NhbGVUcmlnZ2VyLFxuICAgICAgICAgIG9iamVjdFNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKSxcbiAgICAgICAgICBzY2FsZVggPSBvYmplY3RTY2FsZS5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gb2JqZWN0U2NhbGUuc2NhbGVZLFxuICAgICAgICAgIGVsZW1lbnRUb0ZpbHRlciA9IHRoaXMuX2ZpbHRlcmVkRWwgfHwgdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpbHRlciB8fCAoc2NhbGVYID4gbWluaW11bVNjYWxlICYmIHNjYWxlWSA+IG1pbmltdW1TY2FsZSkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRUb0ZpbHRlcjtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZmFicmljLmZpbHRlckJhY2tlbmQpIHtcbiAgICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQgPSBmYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBjYWNoZUtleSA9IHRoaXMuX2ZpbHRlcmVkRWwgPyAodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKSA6IHRoaXMuY2FjaGVLZXksXG4gICAgICAgICAgc291cmNlV2lkdGggPSBlbGVtZW50VG9GaWx0ZXIud2lkdGgsIHNvdXJjZUhlaWdodCA9IGVsZW1lbnRUb0ZpbHRlci5oZWlnaHQ7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc291cmNlSGVpZ2h0O1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGNhbnZhc0VsO1xuICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IGZpbHRlci5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB0aGlzLl9sYXN0U2NhbGVZID0gZmlsdGVyLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kLmFwcGx5RmlsdGVycyhcbiAgICAgICAgW2ZpbHRlcl0sIGVsZW1lbnRUb0ZpbHRlciwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGhpcy5fZWxlbWVudCwgY2FjaGVLZXkpO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSBjYW52YXNFbC53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aDtcbiAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gY2FudmFzRWwuaGVpZ2h0IC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXJzIGFzc2lnbmVkIHRvIHRoaXMgaW1hZ2UgKGZyb20gXCJmaWx0ZXJzXCIgYXJyYXkpIG9yIGZyb20gZmlsdGVyIHBhcmFtXG4gICAgICogQG1ldGhvZCBhcHBseUZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGFwcGxpZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvclJlc2l6aW5nIHNwZWNpZnkgaWYgdGhlIGZpbHRlciBvcGVyYXRpb24gaXMgYSByZXNpemUgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiB7dGhpc0FyZ30gcmV0dXJuIHRoZSBmYWJyaWMuSW1hZ2Ugb2JqZWN0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycykge1xuXG4gICAgICBmaWx0ZXJzID0gZmlsdGVycyB8fCB0aGlzLmZpbHRlcnMgfHwgW107XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIgJiYgIWZpbHRlci5pc05ldXRyYWxTdGF0ZSgpOyB9KTtcbiAgICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuXG4gICAgICAvLyBuZWVkcyB0byBjbGVhciBvdXQgb3IgV0VCR0wgd2lsbCBub3QgcmVzaXplIGNvcnJlY3RseVxuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG5cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nRWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudCxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGltZ0VsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGltZ0VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gaW1nRWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGltZ0VsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBleGlzdGluZyBlbGVtZW50IHRvIGdldCBuZXcgZmlsdGVyIGRhdGFcbiAgICAgICAgLy8gYWxzbyBkZXJlZmVyZW5jZSB0aGUgZXZlbnR1YWwgcmVzaXplZCBfZWxlbWVudFxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fZmlsdGVyZWRFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbC5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIHJlc2l6ZSBhZ2FpbiBhdCBuZXh0IHJlbmRlckFsbCwgc28gcmVtb3ZlIHNhdmVkIF9sYXN0U2NhbGVYL1lcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWJyaWMuZmlsdGVyQmFja2VuZCkge1xuICAgICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZCA9IGZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCgpO1xuICAgICAgfVxuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBmaWx0ZXJzLCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuY2FjaGVLZXkpO1xuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aCAhPT0gdGhpcy5fZWxlbWVudC53aWR0aCB8fFxuICAgICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0ICE9PSB0aGlzLl9lbGVtZW50LmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IHRoaXMuX2VsZW1lbnQud2lkdGggLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGg7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gdGhpcy5fZWxlbWVudC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nKTtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nICE9PSB0cnVlICYmIHRoaXMucmVzaXplRmlsdGVyICYmIHRoaXMuX25lZWRzUmVzaXplKCkpIHtcbiAgICAgICAgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0cm9rZShjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBpdCB3aWxsIHNldCB0aGUgaW1hZ2VTbW9vdGhpbmcgZm9yIHRoZSBkcmF3IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2FjaGVPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmcpO1xuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuZHJhd0NhY2hlT25DYW52YXMuY2FsbCh0aGlzLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBUaGlzIGlzIHRoZSBzcGVjaWFsIGltYWdlIHZlcnNpb24gd2hlcmUgd2Ugd291bGQgbGlrZSB0byBhdm9pZCBjYWNoaW5nIHdoZXJlIHBvc3NpYmxlLlxuICAgICAqIEVzc2VudGlhbGx5IGltYWdlcyBkbyBub3QgYmVuZWZpdCBmcm9tIGNhY2hpbmcuIFRoZXkgbWF5IHJlcXVpcmUgY2FjaGluZywgYW5kIGluIHRoYXRcbiAgICAgKiBjYXNlIHdlIGRvIGl0LiBBbHNvIGNhY2hpbmcgYW4gaW1hZ2UgdXN1YWxseSBlbmRzIGluIGEgbG9zcyBvZiBkZXRhaWxzLlxuICAgICAqIEEgZnVsbCBwZXJmb3JtYW5jZSBhdWRpdCBzaG91bGQgYmUgZG9uZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGVsZW1lbnRUb0RyYXcgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKCFlbGVtZW50VG9EcmF3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLl9maWx0ZXJTY2FsaW5nWCwgc2NhbGVZID0gdGhpcy5fZmlsdGVyU2NhbGluZ1ksXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCwgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgICAgIC8vIGNyb3AgdmFsdWVzIGNhbm5vdCBiZSBsZXNzZXIgdGhhbiAwLlxuICAgICAgICAgIGNyb3BYID0gbWF4KHRoaXMuY3JvcFgsIDApLCBjcm9wWSA9IG1heCh0aGlzLmNyb3BZLCAwKSxcbiAgICAgICAgICBlbFdpZHRoID0gZWxlbWVudFRvRHJhdy5uYXR1cmFsV2lkdGggfHwgZWxlbWVudFRvRHJhdy53aWR0aCxcbiAgICAgICAgICBlbEhlaWdodCA9IGVsZW1lbnRUb0RyYXcubmF0dXJhbEhlaWdodCB8fCBlbGVtZW50VG9EcmF3LmhlaWdodCxcbiAgICAgICAgICBzWCA9IGNyb3BYICogc2NhbGVYLFxuICAgICAgICAgIHNZID0gY3JvcFkgKiBzY2FsZVksXG4gICAgICAgICAgLy8gdGhlIHdpZHRoIGhlaWdodCBjYW5ub3QgZXhjZWVkIGVsZW1lbnQgd2lkdGgvaGVpZ2h0LCBzdGFydGluZyBmcm9tIHRoZSBjcm9wIG9mZnNldC5cbiAgICAgICAgICBzVyA9IG1pbih3ICogc2NhbGVYLCBlbFdpZHRoIC0gc1gpLFxuICAgICAgICAgIHNIID0gbWluKGggKiBzY2FsZVksIGVsSGVpZ2h0IC0gc1kpLFxuICAgICAgICAgIHggPSAtdyAvIDIsIHkgPSAtaCAvIDIsXG4gICAgICAgICAgbWF4RGVzdFcgPSBtaW4odywgZWxXaWR0aCAvIHNjYWxlWCAtIGNyb3BYKSxcbiAgICAgICAgICBtYXhEZXN0SCA9IG1pbihoLCBlbEhlaWdodCAvIHNjYWxlWCAtIGNyb3BZKTtcblxuICAgICAgZWxlbWVudFRvRHJhdyAmJiBjdHguZHJhd0ltYWdlKGVsZW1lbnRUb0RyYXcsIHNYLCBzWSwgc1csIHNILCB4LCB5LCBtYXhEZXN0VywgbWF4RGVzdEgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgaW1hZ2UgbmVlZHMgcmVzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIHJldHVybiAoc2NhbGUuc2NhbGVYICE9PSB0aGlzLl9sYXN0U2NhbGVYIHx8IHNjYWxlLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5nZXRPcmlnaW5hbFNpemUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBJbWFnZSBjbGFzcydzIGluaXRpYWxpemF0aW9uIG1ldGhvZC4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseVxuICAgICAqIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8U3RyaW5nfSBlbGVtZW50IFRoZSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldEVsZW1lbnQoZmFicmljLnV0aWwuZ2V0QnlJZChlbGVtZW50KSwgb3B0aW9ucyk7XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLmdldEVsZW1lbnQoKSwgZmFicmljLkltYWdlLkNTU19DQU5WQVMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdENvbmZpZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIGZhYnJpYy5JbWFnZS5maWx0ZXJzIGluc3RhbmNlcyBhcmUgY3JlYXRlZFxuICAgICAqL1xuICAgIF9pbml0RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKGZpbHRlcnMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfSwgJ2ZhYnJpYy5JbWFnZS5maWx0ZXJzJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBvYmplY3QsIHVzaW5nIHRoZSBlbGVtZW50IG9yIHRoZVxuICAgICAqIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB3aWR0aC9oZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB2YXIgZWwgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IGVsLm5hdHVyYWxXaWR0aCB8fCBlbC53aWR0aCB8fCAwO1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBlbC5uYXR1cmFsSGVpZ2h0IHx8IGVsLmhlaWdodCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb2Zmc2V0IGZvciBjZW50ZXIgYW5kIHNjYWxlIGZhY3RvciBmb3IgdGhlIGltYWdlIGluIG9yZGVyIHRvIHJlc3BlY3RcbiAgICAgKiB0aGUgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSh0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJycpLFxuICAgICAgICAgIHJXaWR0aCA9IHRoaXMuX2VsZW1lbnQud2lkdGgsIHJIZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMCwgY3JvcFggPSAwLCBjcm9wWSA9IDAsXG4gICAgICAgICAgb2Zmc2V0LCBwV2lkdGggPSB0aGlzLndpZHRoLCBwSGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHBhcnNlZEF0dHJpYnV0ZXMgPSB7IHdpZHRoOiBwV2lkdGgsIGhlaWdodDogcEhlaWdodCB9O1xuICAgICAgaWYgKHBBUiAmJiAocEFSLmFsaWduWCAhPT0gJ25vbmUnIHx8IHBBUi5hbGlnblkgIT09ICdub25lJykpIHtcbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9GaXQodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gKHBXaWR0aCAtIHJXaWR0aCAqIHNjYWxlWCkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gKHBIZWlnaHQgLSBySGVpZ2h0ICogc2NhbGVZKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvQ292ZXIodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gcldpZHRoIC0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBySGVpZ2h0IC0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcldpZHRoID0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIHJIZWlnaHQgPSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gcFdpZHRoIC8gcldpZHRoO1xuICAgICAgICBzY2FsZVkgPSBwSGVpZ2h0IC8gckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByV2lkdGgsXG4gICAgICAgIGhlaWdodDogckhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBvZmZzZXRUb3A6IG9mZnNldFRvcCxcbiAgICAgICAgY3JvcFg6IGNyb3BYLFxuICAgICAgICBjcm9wWTogY3JvcFlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKF9vYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShfb2JqZWN0KTtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIFtvYmplY3QucmVzaXplRmlsdGVyXSwgZnVuY3Rpb24ocmVzaXplRmlsdGVycykge1xuICAgICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSByZXNpemVGaWx0ZXJzWzBdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtvYmplY3QuY2xpcFBhdGhdLCBmdW5jdGlvbihlbmxpdmVkUHJvcHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5jbGlwUGF0aCA9IGVubGl2ZWRQcm9wc1swXTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QpO1xuICAgICAgICAgICAgY2FsbGJhY2soaW1hZ2UsIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCBudWxsLCBvYmplY3QuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGFuIFVSTCBzdHJpbmdcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBjcmVhdGUgYW4gaW1hZ2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGNyZWF0ZWQgKG5ld2x5IGNyZWF0ZWQgaW1hZ2UgaXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQpLiBTZWNvbmQgYXJndW1lbnQgaXMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3Igbm90LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ltZ09wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbVVSTCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGltZ09wdGlvbnMpIHtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UodXJsLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBpbWdPcHRpb25zKSwgaXNFcnJvcik7XG4gICAgfSwgbnVsbCwgaW1nT3B0aW9ucyAmJiBpbWdPcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI0ltYWdlRWxlbWVudH1cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMgPVxuICAgIGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoXG4gICAgICAneCB5IHdpZHRoIGhlaWdodCBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHhsaW5rOmhyZWYgY3Jvc3NPcmlnaW4gaW1hZ2UtcmVuZGVyaW5nJy5zcGxpdCgnICcpXG4gICAgKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkltYWdlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gZmFicmljLkltYWdlIG9iamVjdCBpcyBjcmVhdGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuSW1hZ2UuQVRUUklCVVRFX05BTUVTKTtcbiAgICBmYWJyaWMuSW1hZ2UuZnJvbVVSTChwYXJzZWRBdHRyaWJ1dGVzWyd4bGluazpocmVmJ10sIGNhbGxiYWNrLFxuICAgICAgZXh0ZW5kKChvcHRpb25zID8gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcykpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGUgdmFsdWVcbiAgICovXG4gIF9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZSAlIDM2MDtcbiAgICBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoYW5nbGUgLSAxKSAvIDkwKSAqIDkwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChhbmdsZSAvIDkwKSAqIDkwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBhbiBvYmplY3QgKHJvdGF0aW5nIGl0IGZyb20gY3VycmVudCBhbmdsZSB0byBvbmUgb2YgMCwgOTAsIDE4MCwgMjcwLCBldGMuIGRlcGVuZGluZyBvbiB3aGljaCBpcyBjbG9zZXIpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc3RyYWlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yb3RhdGUodGhpcy5fZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW4oKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMge0BsaW5rIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0cmFpZ2h0ZW59IGJ1dCB3aXRoIGFuaW1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2tzIE9iamVjdCB3aXRoIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnhTdHJhaWdodGVuOiBmdW5jdGlvbihjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgc3RhcnRWYWx1ZTogdGhpcy5nZXQoJ2FuZ2xlJyksXG4gICAgICBlbmRWYWx1ZTogdGhpcy5fZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW4oKSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF90aGlzLnJvdGF0ZSh2YWx1ZSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogU3RyYWlnaHRlbnMgb2JqZWN0LCB0aGVuIHJlcmVuZGVycyBjYW52YXNcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHN0cmFpZ2h0ZW5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnN0cmFpZ2h0ZW4oKTtcbiAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuc3RyYWlnaHRlbk9iamVjdH0sIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ4U3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIG9iamVjdC5meFN0cmFpZ2h0ZW4oe1xuICAgICAgb25DaGFuZ2U6IHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIHdlYmdsIHN1cHBvcnRzIGNlcnRhaW4gcHJlY2lzaW9uXG4gICAqIEBwYXJhbSB7V2ViR0x9IENhbnZhcyBXZWJHTCBjb250ZXh0IHRvIHRlc3Qgb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFByZWNpc2lvbiB0byB0ZXN0IGNhbiBiZSBhbnkgb2YgZm9sbG93aW5nOiAnbG93cCcsICdtZWRpdW1wJywgJ2hpZ2hwJ1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgV2ViR0wgc3VwcG9ydHMgZ2l2ZW4gcHJlY2lzaW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gdGVzdFByZWNpc2lvbihnbCwgcHJlY2lzaW9uKXtcbiAgICB2YXIgZnJhZ21lbnRTb3VyY2UgPSAncHJlY2lzaW9uICcgKyBwcmVjaXNpb24gKyAnIGZsb2F0O1xcbnZvaWQgbWFpbigpe30nO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciB0aGlzIGZpbHRlcmluZyBiYWNrZW5kIGlzIHN1cHBvcnRlZCBieSB0aGUgdXNlcidzIGJyb3dzZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aWxlU2l6ZSBjaGVjayBpZiB0aGUgdGlsZVNpemUgaXMgc3VwcG9ydGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBzdXBwb3J0cyBXZWJHTC5cbiAgICovXG4gIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkID0gZnVuY3Rpb24odGlsZVNpemUpIHtcbiAgICBpZiAoZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aWxlU2l6ZSA9IHRpbGVTaXplIHx8IGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlLnRpbGVTaXplO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG4gICAgdmFyIGlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaWYgKGdsKSB7XG4gICAgICBmYWJyaWMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgICBpc1N1cHBvcnRlZCA9IGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSA+PSB0aWxlU2l6ZTtcbiAgICAgIHZhciBwcmVjaXNpb25zID0gWydoaWdocCcsICdtZWRpdW1wJywgJ2xvd3AnXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKXtcbiAgICAgICAgaWYgKHRlc3RQcmVjaXNpb24oZ2wsIHByZWNpc2lvbnNbaV0pKXtcbiAgICAgICAgICBmYWJyaWMud2ViR2xQcmVjaXNpb24gPSBwcmVjaXNpb25zW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gaXNTdXBwb3J0ZWQ7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICB9O1xuXG4gIGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQgPSBXZWJnbEZpbHRlckJhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIFdlYkdMIGZpbHRlciBiYWNrZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gV2ViZ2xGaWx0ZXJCYWNrZW5kKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRpbGVTaXplKSB7XG4gICAgICB0aGlzLnRpbGVTaXplID0gb3B0aW9ucy50aWxlU2l6ZTtcbiAgICB9XG4gICAgdGhpcy5zZXR1cEdMQ29udGV4dCh0aGlzLnRpbGVTaXplLCB0aGlzLnRpbGVTaXplKTtcbiAgICB0aGlzLmNhcHR1cmVHUFVJbmZvKCk7XG4gIH07XG5cbiAgV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdGlsZVNpemU6IDIwNDgsXG5cbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwuIFRoaXMgb2JqZWN0IGlzIGEgc29ydCBvZiByZXBvc2l0b3J5IG9mIGhlbHAgbGF5ZXJzIHVzZWQgdG8gYXZvaWRcbiAgICAgKiBvZiByZWNyZWF0aW5nIHRoZW0gZHVyaW5nIGZyZXF1ZW50IGZpbHRlcmluZy4gSWYgeW91IGFyZSBwcmV2aWV3aW5nIGEgZmlsdGVyIHdpdGhcbiAgICAgKiBhIHNsaWRlciB5b3UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gY3JlYXRlIGhlbHAgbGF5ZXJzIGV2ZXJ5IGZpbHRlciBzdGVwLlxuICAgICAqIGluIHRoaXMgb2JqZWN0IHRoZXJlIHdpbGwgYmUgYXBwZW5kZWQgc29tZSBjYW52YXNlcywgY3JlYXRlZCBvbmNlLCByZXNpemVkIHNvbWV0aW1lc1xuICAgICAqIGNsZWFyZWQgbmV2ZXIuIENsZWFyaW5nIGlzIGxlZnQgdG8gdGhlIGRldmVsb3Blci5cbiAgICAgKiovXG4gICAgcmVzb3VyY2VzOiB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgYSBXZWJHTCBjb250ZXh0IHN1aXRhYmxlIGZvciBmaWx0ZXJpbmcsIGFuZCBiaW5kIGFueSBuZWVkZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICovXG4gICAgc2V0dXBHTENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5jcmVhdGVXZWJHTENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdGhpcy5hUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSk7XG4gICAgICB0aGlzLmNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGEgbWV0aG9kIHRvIGNvcHkgZGF0YSBmcm9tIEdMIGNvbnRleHQgdG8gMmQgY2FudmFzLiAgSW4gc29tZSBicm93c2VycyB1c2luZ1xuICAgICAqIHB1dEltYWdlRGF0YSBpcyBmYXN0ZXIgdGhhbiBkcmF3SW1hZ2UgZm9yIHRoYXQgc3BlY2lmaWMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FuTWVhc3VyZVBlcmYgPSB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJywgY2FuVXNlSW1hZ2VEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEltYWdlRGF0YSgxLCAxKTtcbiAgICAgICAgY2FuVXNlSW1hZ2VEYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNhblVzZUltYWdlRGF0YSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgY2FuVXNlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgY2FuVXNlVWludDhDbGFtcGVkID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgaWYgKCEoY2FuTWVhc3VyZVBlcmYgJiYgY2FuVXNlSW1hZ2VEYXRhICYmIGNhblVzZUFycmF5QnVmZmVyICYmIGNhblVzZVVpbnQ4Q2xhbXBlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0Q2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgaW1hZ2VCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgIGlmIChmYWJyaWMuZm9yY2VHTFB1dEltYWdlRGF0YSkge1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gaW1hZ2VCdWZmZXI7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkRQdXRJbWFnZURhdGE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXN0Q29udGV4dCA9IHtcbiAgICAgICAgaW1hZ2VCdWZmZXI6IGltYWdlQnVmZmVyLFxuICAgICAgICBkZXN0aW5hdGlvbldpZHRoOiB3aWR0aCxcbiAgICAgICAgZGVzdGluYXRpb25IZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdGFyZ2V0Q2FudmFzOiB0YXJnZXRDYW52YXNcbiAgICAgIH07XG4gICAgICB2YXIgc3RhcnRUaW1lLCBkcmF3SW1hZ2VUaW1lLCBwdXRJbWFnZURhdGFUaW1lO1xuICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb3B5R0xUbzJERHJhd0ltYWdlLmNhbGwodGVzdENvbnRleHQsIHRoaXMuZ2wsIHRlc3RDb250ZXh0KTtcbiAgICAgIGRyYXdJbWFnZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvcHlHTFRvMkRQdXRJbWFnZURhdGEuY2FsbCh0ZXN0Q29udGV4dCwgdGhpcy5nbCwgdGVzdENvbnRleHQpO1xuICAgICAgcHV0SW1hZ2VEYXRhVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgaWYgKGRyYXdJbWFnZVRpbWUgPiBwdXRJbWFnZURhdGFUaW1lKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIgPSBpbWFnZUJ1ZmZlcjtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRFB1dEltYWdlRGF0YTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJERHJhd0ltYWdlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjYW52YXMgZWxlbWVudCBhbmQgYXNzb2NpYXRlZCBXZWJHTCBjb250ZXh0IGFuZCBhdHRhY2hlcyB0aGVtIGFzXG4gICAgICogY2xhc3MgcHJvcGVydGllcyB0byB0aGUgR0xGaWx0ZXJCYWNrZW5kIGNsYXNzLlxuICAgICAqL1xuICAgIGNyZWF0ZVdlYkdMQ2FudmFzOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIGdsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBnbE9wdGlvbnMpO1xuICAgICAgaWYgKCFnbCkge1xuICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBnbE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKCFnbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgLy8gdGhpcyBjYW52YXMgY2FuIGZpcmUgd2ViZ2xjb250ZXh0bG9zdCBhbmQgd2ViZ2xjb250ZXh0cmVzdG9yZWRcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5nbCA9IGdsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBhcHBseSB0aGUgcmVxdWVzdGVkIGZpbHRlcnMgdG8gdGhlIHNvdXJjZSBwcm92aWRlZCwgZHJhd2luZyB0aGUgZmlsdGVyZWQgb3V0cHV0XG4gICAgICogdG8gdGhlIHByb3ZpZGVkIHRhcmdldCBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlIFRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgZGVzdGluYXRpb24gZm9yIGZpbHRlcmVkIG91dHB1dCB0byBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3x1bmRlZmluZWR9IGNhY2hlS2V5IEEga2V5IHVzZWQgdG8gY2FjaGUgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gdGhlIHNvdXJjZS4gSWZcbiAgICAgKiBvbWl0dGVkLCBjYWNoaW5nIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q2FudmFzLCBjYWNoZUtleSkge1xuICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgIHZhciBjYWNoZWRUZXh0dXJlO1xuICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgIGNhY2hlZFRleHR1cmUgPSB0aGlzLmdldENhY2hlZFRleHR1cmUoY2FjaGVLZXksIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIgcGlwZWxpbmVTdGF0ZSA9IHtcbiAgICAgICAgb3JpZ2luYWxXaWR0aDogc291cmNlLndpZHRoIHx8IHNvdXJjZS5vcmlnaW5hbFdpZHRoLFxuICAgICAgICBvcmlnaW5hbEhlaWdodDogc291cmNlLmhlaWdodCB8fCBzb3VyY2Uub3JpZ2luYWxIZWlnaHQsXG4gICAgICAgIHNvdXJjZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgc291cmNlSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGRlc3RpbmF0aW9uV2lkdGg6IHdpZHRoLFxuICAgICAgICBkZXN0aW5hdGlvbkhlaWdodDogaGVpZ2h0LFxuICAgICAgICBjb250ZXh0OiBnbCxcbiAgICAgICAgc291cmNlVGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCAhY2FjaGVkVGV4dHVyZSAmJiBzb3VyY2UpLFxuICAgICAgICB0YXJnZXRUZXh0dXJlOiB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgICBvcmlnaW5hbFRleHR1cmU6IGNhY2hlZFRleHR1cmUgfHxcbiAgICAgICAgICB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsICFjYWNoZWRUZXh0dXJlICYmIHNvdXJjZSksXG4gICAgICAgIHBhc3NlczogZmlsdGVycy5sZW5ndGgsXG4gICAgICAgIHdlYmdsOiB0cnVlLFxuICAgICAgICBhUG9zaXRpb246IHRoaXMuYVBvc2l0aW9uLFxuICAgICAgICBwcm9ncmFtQ2FjaGU6IHRoaXMucHJvZ3JhbUNhY2hlLFxuICAgICAgICBwYXNzOiAwLFxuICAgICAgICBmaWx0ZXJCYWNrZW5kOiB0aGlzLFxuICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhc1xuICAgICAgfTtcbiAgICAgIHZhciB0ZW1wRmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGVtcEZibyk7XG4gICAgICBmaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7IGZpbHRlciAmJiBmaWx0ZXIuYXBwbHlUbyhwaXBlbGluZVN0YXRlKTsgfSk7XG4gICAgICByZXNpemVDYW52YXNJZk5lZWRlZChwaXBlbGluZVN0YXRlKTtcbiAgICAgIHRoaXMuY29weUdMVG8yRChnbCwgcGlwZWxpbmVTdGF0ZSk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgIGdsLmRlbGV0ZVRleHR1cmUocGlwZWxpbmVTdGF0ZS5zb3VyY2VUZXh0dXJlKTtcbiAgICAgIGdsLmRlbGV0ZVRleHR1cmUocGlwZWxpbmVTdGF0ZS50YXJnZXRUZXh0dXJlKTtcbiAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRlbXBGYm8pO1xuICAgICAgdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJykuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgcmV0dXJuIHBpcGVsaW5lU3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGFjaCBldmVudCBsaXN0ZW5lcnMsIHJlbW92ZSByZWZlcmVuY2VzLCBhbmQgY2xlYW4gdXAgY2FjaGVzLlxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyV2ViR0xDYWNoZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2lwZSBvdXQgV2ViR0wtcmVsYXRlZCBjYWNoZXMuXG4gICAgICovXG4gICAgY2xlYXJXZWJHTENhY2hlczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnByb2dyYW1DYWNoZSA9IHt9O1xuICAgICAgdGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgV2ViR0wgdGV4dHVyZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBBY2NlcHRzIHNwZWNpZmljIGRpbWVuc2lvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgdGV4dHVyZSB0byBvciBhIHNvdXJjZSBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY29udGV4dCB0byB1c2UgZm9yIGNyZWF0aW5nIHRoZSB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gaW5pdGlhbGl6ZSB0aGUgdGV4dHVyZSBhdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gaW5pdGlhbGl6ZSB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHRleHR1cmVJbWFnZVNvdXJjZSBBIHNvdXJjZSBmb3IgdGhlIHRleHR1cmUgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7V2ViR0xUZXh0dXJlfVxuICAgICAqL1xuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCB0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgaWYgKHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmVJbWFnZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgb3B0aW9uYWxseSB1c2VkIHRvIGdldCBhIHRleHR1cmUgZnJvbSB0aGUgY2FjaGUgYXJyYXlcbiAgICAgKlxuICAgICAqIElmIGFuIGV4aXN0aW5nIHRleHR1cmUgaXMgbm90IGZvdW5kLCBhIG5ldyB0ZXh0dXJlIGlzIGNyZWF0ZWQgYW5kIGNhY2hlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1bmlxdWVJZCBBIGNhY2hlIGtleSB0byB1c2UgdG8gZmluZCBhbiBleGlzdGluZyB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gdGV4dHVyZUltYWdlU291cmNlIEEgc291cmNlIHRvIHVzZSB0byBjcmVhdGUgdGhlXG4gICAgICogdGV4dHVyZSBjYWNoZSBlbnRyeSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKi9cbiAgICBnZXRDYWNoZWRUZXh0dXJlOiBmdW5jdGlvbih1bmlxdWVJZCwgdGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoXG4gICAgICAgICAgdGhpcy5nbCwgdGV4dHVyZUltYWdlU291cmNlLndpZHRoLCB0ZXh0dXJlSW1hZ2VTb3VyY2UuaGVpZ2h0LCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF0gPSB0ZXh0dXJlO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgb3V0IGNhY2hlZCByZXNvdXJjZXMgcmVsYXRlZCB0byBhIHNvdXJjZSBpbWFnZSB0aGF0IGhhcyBiZWVuXG4gICAgICogZmlsdGVyZWQgcHJldmlvdXNseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWNoZUtleSBUaGUgY2FjaGUga2V5IHByb3ZpZGVkIHdoZW4gdGhlIHNvdXJjZSBpbWFnZSB3YXMgZmlsdGVyZWQuXG4gICAgICovXG4gICAgZXZpY3RDYWNoZXNGb3JLZXk6IGZ1bmN0aW9uKGNhY2hlS2V5KSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pO1xuICAgICAgICBkZWxldGUgdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb3B5R0xUbzJEOiBjb3B5R0xUbzJERHJhd0ltYWdlLFxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBleHRyYWN0IEdQVSBpbmZvcm1hdGlvbiBzdHJpbmdzIGZyb20gYSBXZWJHTCBjb250ZXh0LlxuICAgICAqXG4gICAgICogVXNlZnVsIGluZm9ybWF0aW9uIHdoZW4gZGVidWdnaW5nIG9yIGJsYWNrbGlzdGluZyBzcGVjaWZpYyBHUFVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gQSBHUFUgaW5mbyBvYmplY3Qgd2l0aCByZW5kZXJlciBhbmQgdmVuZG9yIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2FwdHVyZUdQVUluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZ3B1SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5ncHVJbmZvO1xuICAgICAgfVxuICAgICAgdmFyIGdsID0gdGhpcy5nbCwgZ3B1SW5mbyA9IHsgcmVuZGVyZXI6ICcnLCB2ZW5kb3I6ICcnIH07XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHJldHVybiBncHVJbmZvO1xuICAgICAgfVxuICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbycpO1xuICAgICAgaWYgKGV4dCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKTtcbiAgICAgICAgdmFyIHZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihleHQuVU5NQVNLRURfVkVORE9SX1dFQkdMKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgICAgZ3B1SW5mby5yZW5kZXJlciA9IHJlbmRlcmVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlbmRvcikge1xuICAgICAgICAgIGdwdUluZm8udmVuZG9yID0gdmVuZG9yLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZ3B1SW5mbyA9IGdwdUluZm87XG4gICAgICByZXR1cm4gZ3B1SW5mbztcbiAgICB9LFxuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gcmVzaXplQ2FudmFzSWZOZWVkZWQocGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsXG4gICAgICB3aWR0aCA9IHRhcmdldENhbnZhcy53aWR0aCwgaGVpZ2h0ID0gdGFyZ2V0Q2FudmFzLmhlaWdodCxcbiAgICAgIGRXaWR0aCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25XaWR0aCxcbiAgICAgIGRIZWlnaHQgPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uSGVpZ2h0O1xuXG4gIGlmICh3aWR0aCAhPT0gZFdpZHRoIHx8IGhlaWdodCAhPT0gZEhlaWdodCkge1xuICAgIHRhcmdldENhbnZhcy53aWR0aCA9IGRXaWR0aDtcbiAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gZEhlaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYW4gaW5wdXQgV2ViR0wgY2FudmFzIG9uIHRvIGFuIG91dHB1dCAyRCBjYW52YXMuXG4gKlxuICogVGhlIFdlYkdMIGNhbnZhcyBpcyBhc3N1bWVkIHRvIGJlIHVwc2lkZSBkb3duLCB3aXRoIHRoZSB0b3AtbGVmdCBwaXhlbCBvZiB0aGVcbiAqIGRlc2lyZWQgb3V0cHV0IGltYWdlIGFwcGVhcmluZyBpbiB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSBXZWJHTCBjYW52YXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHNvdXJjZUNvbnRleHQgVGhlIFdlYkdMIGNvbnRleHQgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gcGlwZWxpbmVTdGF0ZSBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICovXG5mdW5jdGlvbiBjb3B5R0xUbzJERHJhd0ltYWdlKGdsLCBwaXBlbGluZVN0YXRlKSB7XG4gIHZhciBnbENhbnZhcyA9IGdsLmNhbnZhcywgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsXG4gICAgICBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnRyYW5zbGF0ZSgwLCB0YXJnZXRDYW52YXMuaGVpZ2h0KTsgLy8gbW92ZSBpdCBkb3duIGFnYWluXG4gIGN0eC5zY2FsZSgxLCAtMSk7IC8vIHZlcnRpY2FsIGZsaXBcbiAgLy8gd2hlcmUgaXMgbXkgaW1hZ2Ugb24gdGhlIGJpZyBnbGNhbnZhcz9cbiAgdmFyIHNvdXJjZVkgPSBnbENhbnZhcy5oZWlnaHQgLSB0YXJnZXRDYW52YXMuaGVpZ2h0O1xuICBjdHguZHJhd0ltYWdlKGdsQ2FudmFzLCAwLCBzb3VyY2VZLCB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQsIDAsIDAsXG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoLCB0YXJnZXRDYW52YXMuaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBDb3B5IGFuIGlucHV0IFdlYkdMIGNhbnZhcyBvbiB0byBhbiBvdXRwdXQgMkQgY2FudmFzIHVzaW5nIDJkIGNhbnZhcycgcHV0SW1hZ2VEYXRhXG4gKiBBUEkuIE1lYXN1cmFibHkgZmFzdGVyIHRoYW4gdXNpbmcgY3R4LmRyYXdJbWFnZSBpbiBGaXJlZm94ICh2ZXJzaW9uIDU0IG9uIE9TWCBTaWVycmEpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBzb3VyY2VDb250ZXh0IFRoZSBXZWJHTCBjb250ZXh0IHRvIGNvcHkgZnJvbS5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHBpcGVsaW5lU3RhdGUgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqL1xuZnVuY3Rpb24gY29weUdMVG8yRFB1dEltYWdlRGF0YShnbCwgcGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgZFdpZHRoID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbldpZHRoLFxuICAgICAgZEhlaWdodCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25IZWlnaHQsXG4gICAgICBudW1CeXRlcyA9IGRXaWR0aCAqIGRIZWlnaHQgKiA0O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgdTggPSBuZXcgVWludDhBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBudW1CeXRlcyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgdThDbGFtcGVkID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMuaW1hZ2VCdWZmZXIsIDAsIG51bUJ5dGVzKTtcblxuICBnbC5yZWFkUGl4ZWxzKDAsIDAsIGRXaWR0aCwgZEhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdTgpO1xuICB2YXIgaW1nRGF0YSA9IG5ldyBJbWFnZURhdGEodThDbGFtcGVkLCBkV2lkdGgsIGRIZWlnaHQpO1xuICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xufVxuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQgPSBDYW52YXMyZEZpbHRlckJhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIENhbnZhcyAyRCBmaWx0ZXIgYmFja2VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhczJkRmlsdGVyQmFja2VuZCgpIHt9O1xuXG4gIENhbnZhczJkRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQucHJvdG90eXBlICovIHtcbiAgICBldmljdENhY2hlc0ZvcktleTogbm9vcCxcbiAgICBkaXNwb3NlOiBub29wLFxuICAgIGNsZWFyV2ViR0xDYWNoZXM6IG5vb3AsXG5cbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwuIFRoaXMgb2JqZWN0IGlzIGEgc29ydCBvZiByZXBvc2l0b3J5IG9mIGhlbHAgbGF5ZXJzIHVzZWQgdG8gYXZvaWRcbiAgICAgKiBvZiByZWNyZWF0aW5nIHRoZW0gZHVyaW5nIGZyZXF1ZW50IGZpbHRlcmluZy4gSWYgeW91IGFyZSBwcmV2aWV3aW5nIGEgZmlsdGVyIHdpdGhcbiAgICAgKiBhIHNsaWRlciB5b3UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gY3JlYXRlIGhlbHAgbGF5ZXJzIGV2ZXJ5IGZpbHRlciBzdGVwLlxuICAgICAqIGluIHRoaXMgb2JqZWN0IHRoZXJlIHdpbGwgYmUgYXBwZW5kZWQgc29tZSBjYW52YXNlcywgY3JlYXRlZCBvbmNlLCByZXNpemVkIHNvbWV0aW1lc1xuICAgICAqIGNsZWFyZWQgbmV2ZXIuIENsZWFyaW5nIGlzIGxlZnQgdG8gdGhlIGRldmVsb3Blci5cbiAgICAgKiovXG4gICAgcmVzb3VyY2VzOiB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBzZXQgb2YgZmlsdGVycyBhZ2FpbnN0IGEgc291cmNlIGltYWdlIGFuZCBkcmF3IHRoZSBmaWx0ZXJlZCBvdXRwdXRcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgZGVzdGluYXRpb24gY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZEZpbHRlcn0gZmlsdGVycyBUaGUgZmlsdGVyIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlRWxlbWVudCBUaGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VXaWR0aCBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIGRlc3RpbmF0aW9uIGZvciBmaWx0ZXJlZCBvdXRwdXQgdG8gYmUgZHJhd24uXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBzb3VyY2VFbGVtZW50LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0YXJnZXRDYW52YXMpIHtcbiAgICAgIHZhciBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc291cmNlRWxlbWVudCwgMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBvcmlnaW5hbEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgcGlwZWxpbmVTdGF0ZSA9IHtcbiAgICAgICAgc291cmNlV2lkdGg6IHNvdXJjZVdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQ6IHNvdXJjZUhlaWdodCxcbiAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZURhdGEsXG4gICAgICAgIG9yaWdpbmFsRWw6IHNvdXJjZUVsZW1lbnQsXG4gICAgICAgIG9yaWdpbmFsSW1hZ2VEYXRhOiBvcmlnaW5hbEltYWdlRGF0YSxcbiAgICAgICAgY2FudmFzRWw6IHRhcmdldENhbnZhcyxcbiAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgIGZpbHRlckJhY2tlbmQ6IHRoaXMsXG4gICAgICB9O1xuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyBmaWx0ZXIuYXBwbHlUbyhwaXBlbGluZVN0YXRlKTsgfSk7XG4gICAgICBpZiAocGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEud2lkdGggIT09IHNvdXJjZVdpZHRoIHx8IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLmhlaWdodCAhPT0gc291cmNlSGVpZ2h0KSB7XG4gICAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLndpZHRoO1xuICAgICAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShwaXBlbGluZVN0YXRlLmltYWdlRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm4gcGlwZWxpbmVTdGF0ZTtcbiAgICB9LFxuXG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZVxuICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjaW1hZ2VfZmlsdGVyc31cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAqL1xuZmFicmljLkltYWdlID0gZmFicmljLkltYWdlIHx8IHsgfTtcbmZhYnJpYy5JbWFnZS5maWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMgfHwgeyB9O1xuXG4vKipcbiAqIFJvb3QgZmlsdGVyIGNsYXNzIGZyb20gd2hpY2ggYWxsIGZpbHRlciBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICovXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEZpbHRlciB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB0eXBlOiAnQmFzZUZpbHRlcicsXG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gc2VuZCB3aXRoIGJ1ZmZlcnMuIGRvIG5vdCBtb2RpZnlcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmVydGV4U291cmNlOiAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAndlRleENvb3JkID0gYVBvc2l0aW9uO1xcbicgK1xuICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24gKiAyLjAgLSAxLjAsIDAuMCwgMS4wKTtcXG4nICtcbiAgICAnfScsXG5cbiAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAnZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICd9JyxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGZpbHRlcidzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlciBwcm9ncmFtLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHRvIHVzZSBmb3Igc2hhZGVyIGNvbXBpbGF0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJhZ21lbnRTb3VyY2UgZnJhZ21lbnRTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmVydGV4U291cmNlIHZlcnRleFNoYWRlciBzb3VyY2UgZm9yIGNvbXBpbGF0aW9uXG4gICAqL1xuICBjcmVhdGVQcm9ncmFtOiBmdW5jdGlvbihnbCwgZnJhZ21lbnRTb3VyY2UsIHZlcnRleFNvdXJjZSkge1xuICAgIGZyYWdtZW50U291cmNlID0gZnJhZ21lbnRTb3VyY2UgfHwgdGhpcy5mcmFnbWVudFNvdXJjZTtcbiAgICB2ZXJ0ZXhTb3VyY2UgPSB2ZXJ0ZXhTb3VyY2UgfHwgdGhpcy52ZXJ0ZXhTb3VyY2U7XG4gICAgaWYgKGZhYnJpYy53ZWJHbFByZWNpc2lvbiAhPT0gJ2hpZ2hwJyl7XG4gICAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlLnJlcGxhY2UoXG4gICAgICAgIC9wcmVjaXNpb24gaGlnaHAgZmxvYXQvZyxcbiAgICAgICAgJ3ByZWNpc2lvbiAnICsgZmFicmljLndlYkdsUHJlY2lzaW9uICsgJyBmbG9hdCdcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnVmVydGV4IHNoYWRlciBjb21waWxlIGVycm9yIGZvciAnICsgdGhpcy50eXBlICsgJzogJyArXG4gICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ0ZyYWdtZW50IHNoYWRlciBjb21waWxlIGVycm9yIGZvciAnICsgdGhpcy50eXBlICsgJzogJyArXG4gICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdTaGFkZXIgbGluayBlcnJvciBmb3IgXCIke3RoaXMudHlwZX1cIiAnICtcbiAgICAgICAgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHRoaXMuZ2V0QXR0cmlidXRlTG9jYXRpb25zKGdsLCBwcm9ncmFtKTtcbiAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSkgfHwgeyB9O1xuICAgIHVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBXID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwSCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBIJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICBhdHRyaWJ1dGVMb2NhdGlvbnM6IGF0dHJpYnV0ZUxvY2F0aW9ucyxcbiAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHVuaWZvcm1Mb2NhdGlvbnNcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXAgb2YgYXR0cmlidXRlIG5hbWVzIHRvIFdlYkdMQXR0cmlidXRlTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGUgc2hhZGVyIHByb2dyYW0gZnJvbSB3aGljaCB0byB0YWtlIGF0dHJpYnV0ZSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIHJldHVybiB7XG4gICAgICBhUG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUG9zaXRpb24nKSxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXAgb2YgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzLlxuICAgKlxuICAgKiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICogQHJldHVybnMge09iamVjdH0gQSBtYXAgb2YgdW5pZm9ybSBuYW1lcyB0byB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uICgvKiBnbCwgcHJvZ3JhbSAqLykge1xuICAgIC8vIGluIGNhc2UgaSBkbyBub3QgbmVlZCBhbnkgc3BlY2lhbCB1bmlmb3JtIGkgbmVlZCB0byByZXR1cm4gYW4gZW1wdHkgb2JqZWN0XG4gICAgcmV0dXJuIHsgfTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZCBhdHRyaWJ1dGUgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVMb2NhdGlvbnMgQSBtYXAgb2Ygc2hhZGVyIGF0dHJpYnV0ZSBuYW1lcyB0byB0aGVpciBsb2NhdGlvbnMuXG4gICAqL1xuICBzZW5kQXR0cmlidXRlRGF0YTogZnVuY3Rpb24oZ2wsIGF0dHJpYnV0ZUxvY2F0aW9ucywgYVBvc2l0aW9uRGF0YSkge1xuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbiA9IGF0dHJpYnV0ZUxvY2F0aW9ucy5hUG9zaXRpb247XG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhUG9zaXRpb25EYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG4gIH0sXG5cbiAgX3NldHVwRnJhbWVCdWZmZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQsIHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKG9wdGlvbnMucGFzc2VzID4gMSkge1xuICAgICAgd2lkdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGg7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0O1xuICAgICAgaWYgKG9wdGlvbnMuc291cmNlV2lkdGggIT09IHdpZHRoIHx8IG9wdGlvbnMuc291cmNlSGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShvcHRpb25zLnRhcmdldFRleHR1cmUpO1xuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZHJhdyBsYXN0IGZpbHRlciBvbiBjYW52YXMgYW5kIG5vdCB0byBmcmFtZWJ1ZmZlci5cbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICBnbC5maW5pc2goKTtcbiAgICB9XG4gIH0sXG5cbiAgX3N3YXBUZXh0dXJlczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMucGFzc2VzLS07XG4gICAgb3B0aW9ucy5wYXNzKys7XG4gICAgdmFyIHRlbXAgPSBvcHRpb25zLnRhcmdldFRleHR1cmU7XG4gICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlO1xuICAgIG9wdGlvbnMuc291cmNlVGV4dHVyZSA9IHRlbXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgaXNOZXV0cmFsIGltcGxlbWVudGF0aW9uIGZvciBvbmUgcGFyYW1ldGVyIGJhc2VkIGZpbHRlcnMuXG4gICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICogb24gdGhlIGltYWdlXG4gICAqIE90aGVyIGZpbHRlcnMgbWF5IG5lZWQgdGhlaXIgb3duIHZlcnNpb24gKCBDb2xvck1hdHJpeCwgSHVlUm90YXRpb24sIGdhbW1hLCBDb21wb3NlZEZpbHRlciApXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqKi9cbiAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKC8qIG9wdGlvbnMgKi8pIHtcbiAgICB2YXIgbWFpbiA9IHRoaXMubWFpblBhcmFtZXRlcixcbiAgICAgICAgX2NsYXNzID0gZmFicmljLkltYWdlLmZpbHRlcnNbdGhpcy50eXBlXS5wcm90b3R5cGU7XG4gICAgaWYgKG1haW4pIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KF9jbGFzc1ttYWluXSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IF9jbGFzc1ttYWluXS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAodGhpc1ttYWluXVtpXSAhPT0gX2NsYXNzW21haW5dW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfY2xhc3NbbWFpbl0gPT09IHRoaXNbbWFpbl07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdG8gdGhlIGlucHV0IGltYWdlIGRhdGEgcHJvdmlkZWQuXG4gICAqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVt0aGlzLnR5cGVdID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVt0aGlzLnR5cGVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBseSB0aGlzIGZpbHRlciB1c2luZyB3ZWJnbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUgVGhlIHRleHR1cmUgb2YgdGhlIG9yaWdpbmFsIGlucHV0IGltYWdlLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUb1dlYkdMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0O1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLnJldHJpZXZlU2hhZGVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnBhc3MgPT09IDAgJiYgb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUpIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBvcHRpb25zLnNvdXJjZVRleHR1cmUpO1xuICAgIH1cbiAgICBnbC51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcbiAgICB0aGlzLnNlbmRBdHRyaWJ1dGVEYXRhKGdsLCBzaGFkZXIuYXR0cmlidXRlTG9jYXRpb25zLCBvcHRpb25zLmFQb3NpdGlvbik7XG5cbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBXLCAxIC8gb3B0aW9ucy5zb3VyY2VXaWR0aCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51bmlmb3JtTG9jYXRpb25zLnVTdGVwSCwgMSAvIG9wdGlvbnMuc291cmNlSGVpZ2h0KTtcblxuICAgIHRoaXMuc2VuZFVuaWZvcm1EYXRhKGdsLCBzaGFkZXIudW5pZm9ybUxvY2F0aW9ucyk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoLCBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0KTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgfSxcblxuICBiaW5kQWRkaXRpb25hbFRleHR1cmU6IGZ1bmN0aW9uKGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIC8vIHJlc2V0IGFjdGl2ZSB0ZXh0dXJlIHRvIDAgYXMgdXN1YWxcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgfSxcblxuICB1bmJpbmRBZGRpdGlvbmFsVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIH0sXG5cbiAgZ2V0TWFpblBhcmFtZXRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbdGhpcy5tYWluUGFyYW1ldGVyXTtcbiAgfSxcblxuICBzZXRNYWluUGFyYW1ldGVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXNbdGhpcy5tYWluUGFyYW1ldGVyXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kIHVuaWZvcm0gZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc2hhZGVyIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbigvKiBnbCwgdW5pZm9ybUxvY2F0aW9ucyAqLykge1xuICAgIC8vIEludGVudGlvbmFsbHkgbGVmdCBibGFuay4gIE92ZXJyaWRlIG1lIGluIHN1YmNsYXNzZXMuXG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5lZWRlZCBieSBhIDJkIGZpbHRlciwgdGhpcyBmdW5jdGlvbnMgY2FuIGNyZWF0ZSBhbiBoZWxwZXIgY2FudmFzIHRvIGJlIHVzZWRcbiAgICogcmVtZW1iZXIgdGhhdCBvcHRpb25zLnRhcmdldENhbnZhcyBpcyBhdmFpbGFibGUgZm9yIHVzZSB0aWxsIGVuZCBvZiBjaGFpbi5cbiAgICovXG4gIGNyZWF0ZUhlbHBMYXllcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5oZWxwTGF5ZXIpIHtcbiAgICAgIHZhciBoZWxwTGF5ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGhlbHBMYXllci53aWR0aCA9IG9wdGlvbnMuc291cmNlV2lkdGg7XG4gICAgICBoZWxwTGF5ZXIuaGVpZ2h0ID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICBvcHRpb25zLmhlbHBMYXllciA9IGhlbHBMYXllcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqL1xuICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdCA9IHsgdHlwZTogdGhpcy50eXBlIH0sIG1haW5QID0gdGhpcy5tYWluUGFyYW1ldGVyO1xuICAgIGlmIChtYWluUCkge1xuICAgICAgb2JqZWN0W21haW5QXSA9IHRoaXNbbWFpblBdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT05cbiAgICovXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KCk7XG4gIH1cbn0pO1xuXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnNbb2JqZWN0LnR5cGVdKG9iamVjdCk7XG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKGZpbHRlcik7XG4gIHJldHVybiBmaWx0ZXI7XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbG9yIE1hdHJpeCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3d3dy53ZWJ3YXNwLmNvLnVrL3R1dG9yaWFscy8yMTkvQ29sb3JfTWF0cml4X0ZpbHRlci5waHB9XG4gICAqIEBzZWUge0BMaW5rIGh0dHA6Ly9waG9ib3NsYWIub3JnL2xvZy8yMDEzLzExL2Zhc3QtaW1hZ2UtZmlsdGVycy13aXRoLXdlYmdsfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Lb2RhY2hyb21lIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeCh7XG4gICAqICBtYXRyaXg6IFtcbiAgICAgICAxLjEyODU1ODIzOTY1OTM1MjUsIC0wLjM5NjczODIyODM2MDEzNDgsIC0wLjAzOTkyNTU5MTcyOTIxNzkzLCAwLCA2My43Mjk1ODc2MjE5NjUwMixcbiAgICAgICAtMC4xNjQwNDMzOTk2MjI0NDYxNiwgMS4wODM1MjUxNTY2MjkxMzA0LCAtMC4wNTQ5ODgwNTExNTYzMzEzMiwgMCwgMjQuNzMyNDA3ODk2NzA2MjAzLFxuICAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLCAtMC41NjAzNDE2Mjc3Njk1MjQ4LCAxLjYwMTQ4NTA3NjE5NjQ5NDMsIDAsIDM1LjYyOTgyODA3NDYwOTQ2LFxuICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5Db2xvck1hdHJpeCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbG9yTWF0cml4JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBtYXQ0IHVDb2xvck1hdHJpeDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUNvbnN0YW50cztcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IgKj0gdUNvbG9yTWF0cml4O1xcbicgK1xuICAgICAgICAnY29sb3IgKz0gdUNvbnN0YW50cztcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3JtYXRyaXggZm9yIHBpeGVscy5cbiAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICogb3V0c2lkZSB0aGUgLTEsIDEgcmFuZ2UuXG4gICAgICogMC4wMDM5MjE1Njg2IGlzIHRoZSBwYXJ0IG9mIDEgdGhhdCBnZXQgdHJhbnNsYXRlZCB0byAxIGluIDJkXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0cml4IGFycmF5IG9mIDIwIG51bWJlcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYXRyaXg6IFtcbiAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ21hdHJpeCcsXG5cbiAgICAvKipcbiAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGEsIG1hbmx5IGZvciBub24gd2ViZ2wgc2NlbmFyaW9cbiAgICAgKiB0byBzYXZlIHNvbWUgY2FsY3VsYXRpb25cbiAgICAgKi9cbiAgICBjb2xvcnNPbmx5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubWF0cml4LnNsaWNlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQ29sb3JNYXRyaXggb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGksIGNvbG9yc09ubHkgPSB0aGlzLmNvbG9yc09ubHk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICBpZiAoY29sb3JzT25seSkge1xuICAgICAgICAgIGRhdGFbaV0gPSByICogbVswXSArIGcgKiBtWzFdICsgYiAqIG1bMl0gKyBtWzRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gciAqIG1bNV0gKyBnICogbVs2XSArIGIgKiBtWzddICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIG1bMTRdICogMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgYSAqIG1bM10gKyBtWzRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gciAqIG1bNV0gKyBnICogbVs2XSArIGIgKiBtWzddICsgYSAqIG1bOF0gKyBtWzldICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDJdID0gciAqIG1bMTBdICsgZyAqIG1bMTFdICsgYiAqIG1bMTJdICsgYSAqIG1bMTNdICsgbVsxNF0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgM10gPSByICogbVsxNV0gKyBnICogbVsxNl0gKyBiICogbVsxN10gKyBhICogbVsxOF0gKyBtWzE5XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbG9yTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb2xvck1hdHJpeCcpLFxuICAgICAgICB1Q29uc3RhbnRzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb25zdGFudHMnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgbWF0cml4ID0gW1xuICAgICAgICAgICAgbVswXSwgbVsxXSwgbVsyXSwgbVszXSxcbiAgICAgICAgICAgIG1bNV0sIG1bNl0sIG1bN10sIG1bOF0sXG4gICAgICAgICAgICBtWzEwXSwgbVsxMV0sIG1bMTJdLCBtWzEzXSxcbiAgICAgICAgICAgIG1bMTVdLCBtWzE2XSwgbVsxN10sIG1bMThdXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjb25zdGFudHMgPSBbbVs0XSwgbVs5XSwgbVsxNF0sIG1bMTldXTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3JNYXRyaXgsIGZhbHNlLCBtYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVDb25zdGFudHMsIGNvbnN0YW50cyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXguZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCcmlnaHRuZXNzIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzKHtcbiAgICogICBicmlnaHRuZXNzOiAwLjA1XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQnJpZ2h0bmVzcyA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQnJpZ2h0bmVzcycsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVCcmlnaHRuZXNzO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiArPSB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQnJpZ2h0bmVzcyB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIHRyYW5zbGF0ZWQgdG8gLTI1NSB0byAyNTUgZm9yIDJkXG4gICAgICogMC4wMDM5MjE1Njg2IGlzIHRoZSBwYXJ0IG9mIDEgdGhhdCBnZXQgdHJhbnNsYXRlZCB0byAxIGluIDJkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3NcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJyaWdodG5lc3M6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnYnJpZ2h0bmVzcycsXG5cbiAgICAvKipcbiAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5icmlnaHRuZXNzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGJyaWdodG5lc3MgPSBNYXRoLnJvdW5kKHRoaXMuYnJpZ2h0bmVzcyAqIDI1NSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gKyBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMl0gPSBkYXRhW2kgKyAyXSArIGJyaWdodG5lc3M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1QnJpZ2h0bmVzczogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QnJpZ2h0bmVzcycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJyaWdodG5lc3MsIHRoaXMuYnJpZ2h0bmVzcyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaW1hZ2VmaWx0ZXJzL1wiPmh0bWw1cm9ja3MgYXJ0aWNsZTwvYT5cbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TaGFycGVuIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAwLCAtMSwgIDAsXG4gICAqICAgICAgICAgICAgLTEsICA1LCAtMSxcbiAgICogICAgICAgICAgICAgMCwgLTEsICAwIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkJsdXIgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzkgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1ib3NzIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXIgd2l0aCBvcGFxdWVuZXNzPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgb3BhcXVlOiB0cnVlLFxuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnZvbHV0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb252b2x1dGUnLFxuXG4gICAgLypcbiAgICAgKiBPcGFxdWUgdmFsdWUgKHRydWUvZmFsc2UpXG4gICAgICovXG4gICAgb3BhcXVlOiBmYWxzZSxcblxuICAgIC8qXG4gICAgICogbWF0cml4IGZvciB0aGUgZmlsdGVyLCBtYXggOXg5XG4gICAgICovXG4gICAgbWF0cml4OiBbMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMF0sXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgQ29udm9sdXRlXzNfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCAzLjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDMuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAxKSwgdVN0ZXBIICogKGggLSAxKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogMy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzNfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCAzLjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDMuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAxLjApLCB1U3RlcEggKiAoaCAtIDEuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogMy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA1LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfNV8wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbMjVdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA1LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDUuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAyLjApLCB1U3RlcEggKiAoaCAtIDIuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA3LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfN18wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbNDldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA3LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDcuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAzLjApLCB1U3RlcEggKiAoaCAtIDMuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA5LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfOV8wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbODFdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA5LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDkuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSA0LjApLCB1U3RlcEggKiAoaCAtIDQuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3BhcXVlPWZhbHNlXSBPcGFxdWUgdmFsdWUgKHRydWUvZmFsc2UpXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWF0cml4XSBGaWx0ZXIgbWF0cml4XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBNYXRoLnNxcnQodGhpcy5tYXRyaXgubGVuZ3RoKTtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHNpemUgKyAnXycgKyAodGhpcy5vcGFxdWUgPyAxIDogMCk7XG4gICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVtjYWNoZUtleV07XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIHdlaWdodHMgPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKSxcbiAgICAgICAgICBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpLFxuICAgICAgICAgIHN3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIHNoID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBvdXRwdXQgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoc3csIHNoKSxcbiAgICAgICAgICBkc3QgPSBvdXRwdXQuZGF0YSxcbiAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBwaXhlbHNcbiAgICAgICAgICBhbHBoYUZhYyA9IHRoaXMub3BhcXVlID8gMSA6IDAsXG4gICAgICAgICAgciwgZywgYiwgYSwgZHN0T2ZmLFxuICAgICAgICAgIHNjeCwgc2N5LCBzcmNPZmYsIHd0LFxuICAgICAgICAgIHgsIHksIGN4LCBjeTtcblxuICAgICAgZm9yICh5ID0gMDsgeSA8IHNoOyB5KyspIHtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgICBkc3RPZmYgPSAoeSAqIHN3ICsgeCkgKiA0O1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgd2VpZ2hlZCBzdW0gb2YgdGhlIHNvdXJjZSBpbWFnZSBwaXhlbHMgdGhhdFxuICAgICAgICAgIC8vIGZhbGwgdW5kZXIgdGhlIGNvbnZvbHV0aW9uIG1hdHJpeFxuICAgICAgICAgIHIgPSAwOyBnID0gMDsgYiA9IDA7IGEgPSAwO1xuXG4gICAgICAgICAgZm9yIChjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgICAgZm9yIChjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICAgICAgICBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAoc2N5IDwgMCB8fCBzY3kgPj0gc2ggfHwgc2N4IDwgMCB8fCBzY3ggPj0gc3cpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNyY09mZiA9IChzY3kgKiBzdyArIHNjeCkgKiA0O1xuICAgICAgICAgICAgICB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG4gICAgICAgICAgICAgIHIgKz0gZGF0YVtzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICAgIGcgKz0gZGF0YVtzcmNPZmYgKyAxXSAqIHd0O1xuICAgICAgICAgICAgICBiICs9IGRhdGFbc3JjT2ZmICsgMl0gKiB3dDtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAoIWFscGhhRmFjKSB7XG4gICAgICAgICAgICAgICAgYSArPSBkYXRhW3NyY09mZiArIDNdICogd3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZHN0W2RzdE9mZl0gPSByO1xuICAgICAgICAgIGRzdFtkc3RPZmYgKyAxXSA9IGc7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDJdID0gYjtcbiAgICAgICAgICBpZiAoIWFscGhhRmFjKSB7XG4gICAgICAgICAgICBkc3RbZHN0T2ZmICsgM10gPSBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGRhdGFbZHN0T2ZmICsgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLmltYWdlRGF0YSA9IG91dHB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU1hdHJpeCcpLFxuICAgICAgICB1T3BhcXVlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VPcGFxdWUnKSxcbiAgICAgICAgdUhhbGZTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIYWxmU2l6ZScpLFxuICAgICAgICB1U2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2l6ZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmdih1bmlmb3JtTG9jYXRpb25zLnVNYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgb3BhcXVlOiB0aGlzLm9wYXF1ZSxcbiAgICAgICAgbWF0cml4OiB0aGlzLm1hdHJpeFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdyYXlzY2FsZSBpbWFnZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5HcmF5c2NhbGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR3JheXNjYWxlJyxcblxuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBhdmVyYWdlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5iICsgY29sb3IuZykgLyAzLjA7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sb3IuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGxpZ2h0bmVzczogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBpbnQgdU1vZGU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgYXZlcmFnZSA9IChtYXgobWF4KGNvbC5yLCBjb2wuZyksY29sLmIpICsgbWluKG1pbihjb2wuciwgY29sLmcpLGNvbC5iKSkgLyAyLjA7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBsdW1pbm9zaXR5OiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gMC4yMSAqIGNvbC5yICsgMC43MiAqIGNvbC5nICsgMC4wNyAqIGNvbC5iO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbC5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdyYXlzY2FsZSBtb2RlLCBiZXR3ZWVuICdhdmVyYWdlJywgJ2xpZ2h0bmVzcycsICdsdW1pbm9zaXR5J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb2RlOiAnYXZlcmFnZScsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnbW9kZScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgR3JheXNjYWxlIG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsIHZhbHVlLFxuICAgICAgICAgIG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdhdmVyYWdlJykge1xuICAgICAgICAgIHZhbHVlID0gKGRhdGFbaV0gKyBkYXRhW2kgKyAxXSArIGRhdGFbaSArIDJdKSAvIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2xpZ2h0bmVzcycpIHtcbiAgICAgICAgICB2YWx1ZSA9IChNYXRoLm1pbihkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pICtcbiAgICAgICAgICAgIE1hdGgubWF4KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbHVtaW5vc2l0eScpIHtcbiAgICAgICAgICB2YWx1ZSA9IDAuMjEgKiBkYXRhW2ldICsgMC43MiAqIGRhdGFbaSArIDFdICsgMC4wNyAqIGRhdGFbaSArIDJdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbaV0gPSB2YWx1ZTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSB2YWx1ZTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW3RoaXMubW9kZV07XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1vZGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU1vZGUnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIC8vIGRlZmF1bHQgYXZlcmFnZSBtb2RlLlxuICAgICAgdmFyIG1vZGUgPSAxO1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudU1vZGUsIG1vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcmF5c2NhbGUgZmlsdGVyIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVGhlIGZpbHRlciBpcyBuZXZlciBuZXV0cmFsXG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEludmVydCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0KCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLkludmVydCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdJbnZlcnQnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBpbnQgdUludmVydDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdpZiAodUludmVydCA9PSAxKSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMS4wIC0gY29sb3IuciwxLjAgLWNvbG9yLmcsMS4wIC1jb2xvci5iLGNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgaW52ZXJ0LiBpZiBmYWxzZSwgZG9lcyBub3RoaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbnZlcnRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGludmVydDogdHJ1ZSxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdpbnZlcnQnLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEludmVydCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgZmlsdGVyIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVXNlZCBvbmx5IGluIGltYWdlIGFwcGx5RmlsdGVycyB0byBkaXNjYXJkIGZpbHRlcnMgdGhhdCB3aWxsIG5vdCBoYXZlIGFuIGVmZmVjdFxuICAgICAqIG9uIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pbnZlcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1SW52ZXJ0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VJbnZlcnQnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVJbnZlcnQsIHRoaXMuaW52ZXJ0KTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIE5vaXNlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlKHtcbiAgICogICBub2lzZTogNzAwXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Ob2lzZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ05vaXNlJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIG5vaXNlIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVOb2lzZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTZWVkO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAnZmxvYXQgcmFuZCh2ZWMyIGNvLCBmbG9hdCBzZWVkLCBmbG9hdCB2U2NhbGUpIHtcXG4nICtcbiAgICAgICAgJ3JldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICogdlNjYWxlICx2ZWMyKDEyLjk4OTggLCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzICogKHNlZWQgKyAwLjAxKSAvIDIuMCk7XFxuJyArXG4gICAgICAnfVxcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gKDAuNSAtIHJhbmQodlRleENvb3JkLCB1U2VlZCwgMC4xIC8gdVN0ZXBIKSkgKiB1Tm9pc2U7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdub2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBOb2lzZSB2YWx1ZSwgZnJvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBub2lzZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm9pc2U6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm5vaXNlID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG5vaXNlID0gdGhpcy5ub2lzZSwgcmFuZDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHJhbmQgPSAoMC41IC0gTWF0aC5yYW5kb20oKSkgKiBub2lzZTtcblxuICAgICAgICBkYXRhW2ldICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IHJhbmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Tm9pc2U6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU5vaXNlJyksXG4gICAgICAgIHVTZWVkOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTZWVkJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51Tm9pc2UsIHRoaXMubm9pc2UgLyAyNTUpO1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVNlZWQsIE1hdGgucmFuZG9tKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBub2lzZTogdGhpcy5ub2lzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFBpeGVsYXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlKHtcbiAgICogICBibG9ja3NpemU6IDhcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5QaXhlbGF0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1BpeGVsYXRlJyxcblxuICAgIGJsb2Nrc2l6ZTogNCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdibG9ja3NpemUnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgUGl4ZWxhdGUgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUJsb2Nrc2l6ZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGJsb2NrVyA9IHVCbG9ja3NpemUgKiB1U3RlcFc7XFxuJyArXG4gICAgICAgICdmbG9hdCBibG9ja0ggPSB1QmxvY2tzaXplICogdVN0ZXBXO1xcbicgK1xuICAgICAgICAnaW50IHBvc1ggPSBpbnQodlRleENvb3JkLnggLyBibG9ja1cpO1xcbicgK1xuICAgICAgICAnaW50IHBvc1kgPSBpbnQodlRleENvb3JkLnkgLyBibG9ja0gpO1xcbicgK1xuICAgICAgICAnZmxvYXQgZnBvc1ggPSBmbG9hdChwb3NYKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGZwb3NZID0gZmxvYXQocG9zWSk7XFxuJyArXG4gICAgICAgICd2ZWMyIHNxdWFyZUNvb3JkcyA9IHZlYzIoZnBvc1ggKiBibG9ja1csIGZwb3NZICogYmxvY2tIKTtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHNxdWFyZUNvb3Jkcyk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBQaXhlbGF0ZSBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgakxlbiA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBpbmRleCwgaSwgaiwgciwgZywgYiwgYSxcbiAgICAgICAgICBfaSwgX2osIF9pTGVuLCBfakxlbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gdGhpcy5ibG9ja3NpemUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gdGhpcy5ibG9ja3NpemUpIHtcblxuICAgICAgICAgIGluZGV4ID0gKGkgKiA0KSAqIGpMZW4gKyAoaiAqIDQpO1xuXG4gICAgICAgICAgciA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgIGcgPSBkYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgYiA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICBhID0gZGF0YVtpbmRleCArIDNdO1xuXG4gICAgICAgICAgX2lMZW4gPSBNYXRoLm1pbihpICsgdGhpcy5ibG9ja3NpemUsIGlMZW4pO1xuICAgICAgICAgIF9qTGVuID0gTWF0aC5taW4oaiArIHRoaXMuYmxvY2tzaXplLCBqTGVuKTtcbiAgICAgICAgICBmb3IgKF9pID0gaTsgX2kgPCBfaUxlbjsgX2krKykge1xuICAgICAgICAgICAgZm9yIChfaiA9IGo7IF9qIDwgX2pMZW47IF9qKyspIHtcbiAgICAgICAgICAgICAgaW5kZXggPSAoX2kgKiA0KSAqIGpMZW4gKyAoX2ogKiA0KTtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSByO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBnO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgMl0gPSBiO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgM10gPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB3aGVuIHRoZSBmaWx0ZXIgaXMgbm90IGdvbm5hIGFwcGx5IGNoYW5nZXMgdG8gdGhlIGltYWdlXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2Nrc2l6ZSA9PT0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVCbG9ja3NpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJsb2Nrc2l6ZScpLFxuICAgICAgICB1U3RlcFc6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyksXG4gICAgICAgIHVTdGVwSDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcEgnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCbG9ja3NpemUsIHRoaXMuYmxvY2tzaXplKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgd2hpdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvclxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvciNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3Ioe1xuICAgKiAgIHRocmVzaG9sZDogMC4yLFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuUmVtb3ZlQ29sb3IgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdSZW1vdmVDb2xvcicsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byByZW1vdmUsIGluIGFueSBmb3JtYXQgdW5kZXJzdG9vZCBieSBmYWJyaWMuQ29sb3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbG9yOiAnI0ZGRkZGRicsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUxvdztcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUhpZ2g7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdpZihhbGwoZ3JlYXRlclRoYW4oZ2xfRnJhZ0NvbG9yLnJnYix1TG93LnJnYikpICYmIGFsbChncmVhdGVyVGhhbih1SGlnaC5yZ2IsZ2xfRnJhZ0NvbG9yLnJnYikpKSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gMC4wO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogZGlzdGFuY2UgdG8gYWN0dWFsIGNvbG9yLCBhcyB2YWx1ZSB1cCBvciBkb3duIGZyb20gZWFjaCByLGcsYlxuICAgICAqIGJldHdlZW4gMCBhbmQgMVxuICAgICAqKi9cbiAgICBkaXN0YW5jZTogMC4wMixcblxuICAgIC8qKlxuICAgICAqIEZvciBjb2xvciB0byByZW1vdmUgaW5zaWRlIGRpc3RhbmNlLCB1c2UgYWxwaGEgY2hhbm5lbCBmb3IgYSBzbW9vdGhlciBkZWxldGlvblxuICAgICAqIE5PVCBJTVBMRU1FTlRFRCBZRVRcbiAgICAgKiovXG4gICAgdXNlQWxwaGE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2xvcj0jUlJHR0JCXSBUaHJlc2hvbGQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGlzdGFuY2U9MTBdIERpc3RhbmNlIHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlICogMjU1LFxuICAgICAgICAgIHIsIGcsIGIsXG4gICAgICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBsb3dDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAtIGRpc3RhbmNlLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgaGlnaEMgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdICsgZGlzdGFuY2UsXG4gICAgICAgICAgXTtcblxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgaWYgKHIgPiBsb3dDWzBdICYmXG4gICAgICAgICAgICBnID4gbG93Q1sxXSAmJlxuICAgICAgICAgICAgYiA+IGxvd0NbMl0gJiZcbiAgICAgICAgICAgIHIgPCBoaWdoQ1swXSAmJlxuICAgICAgICAgICAgZyA8IGhpZ2hDWzFdICYmXG4gICAgICAgICAgICBiIDwgaGlnaENbMl0pIHtcbiAgICAgICAgICBkYXRhW2kgKyAzXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVMb3c6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUxvdycpLFxuICAgICAgICB1SGlnaDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SGlnaCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgICAgZGlzdGFuY2UgPSBwYXJzZUZsb2F0KHRoaXMuZGlzdGFuY2UpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICAwICsgc291cmNlWzBdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAwICsgc291cmNlWzFdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAwICsgc291cmNlWzJdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVMb3csIGxvd0MpO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVIaWdoLCBoaWdoQyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBkaXN0YW5jZTogdGhpcy5kaXN0YW5jZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgdmFyIG1hdHJpY2VzID0ge1xuICAgIEJyb3duaWU6IFtcbiAgICAgIDAuNTk5NzAsMC4zNDU1MywtMC4yNzA4MiwwLDAuMTg2LFxuICAgICAgLTAuMDM3NzAsMC44NjA5NSwwLjE1MDU5LDAsLTAuMTQ0OSxcbiAgICAgIDAuMjQxMTMsLTAuMDc0NDEsMC40NDk3MiwwLC0wLjAyOTY1LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBWaW50YWdlOiBbXG4gICAgICAwLjYyNzkzLDAuMzIwMjEsLTAuMDM5NjUsMCwwLjAzNzg0LFxuICAgICAgMC4wMjU3OCwwLjY0NDExLDAuMDMyNTksMCwwLjAyOTI2LFxuICAgICAgMC4wNDY2MCwtMC4wODUxMiwwLjUyNDE2LDAsMC4wMjAyMyxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgS29kYWNocm9tZTogW1xuICAgICAgMS4xMjg1NSwtMC4zOTY3MywtMC4wMzk5MiwwLDAuMjQ5OTEsXG4gICAgICAtMC4xNjQwNCwxLjA4MzUyLC0wLjA1NDk4LDAsMC4wOTY5OCxcbiAgICAgIC0wLjE2Nzg2LC0wLjU2MDM0LDEuNjAxNDgsMCwwLjEzOTcyLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBUZWNobmljb2xvcjogW1xuICAgICAgMS45MTI1MiwtMC44NTQ1MywtMC4wOTE1NSwwLDAuMDQ2MjQsXG4gICAgICAtMC4zMDg3OCwxLjc2NTg5LC0wLjEwNjAxLDAsLTAuMjc1ODksXG4gICAgICAtMC4yMzExMCwtMC43NTAxOCwxLjg0NzU5LDAsMC4xMjEzNyxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgUG9sYXJvaWQ6IFtcbiAgICAgIDEuNDM4LC0wLjA2MiwtMC4wNjIsMCwwLFxuICAgICAgLTAuMTIyLDEuMzc4LC0wLjEyMiwwLDAsXG4gICAgICAtMC4wMTYsLTAuMDE2LDEuNDgzLDAsMCxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgU2VwaWE6IFtcbiAgICAgIDAuMzkzLCAwLjc2OSwgMC4xODksIDAsIDAsXG4gICAgICAwLjM0OSwgMC42ODYsIDAuMTY4LCAwLCAwLFxuICAgICAgMC4yNzIsIDAuNTM0LCAwLjEzMSwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdLFxuICAgIEJsYWNrV2hpdGU6IFtcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDAsIDAsIDAsIDEsIDAsXG4gICAgXVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBtYXRyaWNlcykge1xuICAgIGZpbHRlcnNba2V5XSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQ29sb3JNYXRyaXgsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEucHJvdG90eXBlICovIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAqIEBkZWZhdWx0XG4gICAgICAgKi9cbiAgICAgIHR5cGU6IGtleSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDb2xvcm1hdHJpeCBmb3IgdGhlIGVmZmVjdFxuICAgICAgICogYXJyYXkgb2YgMjAgZmxvYXRzLiBOdW1iZXJzIGluIHBvc2l0aW9ucyA0LCA5LCAxNCwgMTkgbG9vc2UgbWVhbmluZ1xuICAgICAgICogb3V0c2lkZSB0aGUgLTEsIDEgcmFuZ2UuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggYXJyYXkgb2YgMjAgbnVtYmVycy5cbiAgICAgICAqIEBkZWZhdWx0XG4gICAgICAgKi9cbiAgICAgIG1hdHJpeDogbWF0cmljZXNba2V5XSxcblxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBtYXRyaXggZXhwb3J0IGZvciB0aGlzIGtpbmQgb2Ygc3RhdGljLCBwYXJhbWV0ZXIgbGVzcyBmaWx0ZXJzLlxuICAgICAgICovXG4gICAgICBtYWluUGFyYW1ldGVyOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogTG9jayB0aGUgY29sb3JtYXRyaXggb24gdGhlIGNvbG9yIHBhcnQsIHNraXBwaW5nIGFscGhhXG4gICAgICAgKi9cbiAgICAgIGNvbG9yc09ubHk6IHRydWUsXG5cbiAgICB9KTtcbiAgICBmYWJyaWMuSW1hZ2UuZmlsdGVyc1trZXldLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG4gIH1cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbG9yIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZENvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kQ29sb3IgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmQucHJvdG90eXBlICovIHtcbiAgICB0eXBlOiAnQmxlbmRDb2xvcicsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byBtYWtlIHRoZSBibGVuZCBvcGVyYXRpb24gd2l0aC4gZGVmYXVsdCB0byBhIHJlZGRpc2ggY29sb3Igc2luY2UgYmxhY2sgb3Igd2hpdGVcbiAgICAgKiBnaXZlcyBhbHdheXMgc3Ryb25nIHJlc3VsdC5cbiAgICAgKiovXG4gICAgY29sb3I6ICcjRjk1QzYzJyxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXI6IG9uZSBvZiBtdWx0aXBseSwgYWRkLCBkaWZmLCBzY3JlZW4sIHN1YnRyYWN0LFxuICAgICAqIGRhcmtlbiwgbGlnaHRlbiwgb3ZlcmxheSwgZXhjbHVzaW9uLCB0aW50LlxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGNvbG9yIG9wZXJhdGlvbi5cbiAgICAgKiovXG4gICAgYWxwaGE6IDEsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBNdWx0aXBseSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIG11bHRpcGx5OiAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSB1Q29sb3IucmdiO1xcbicsXG4gICAgICBzY3JlZW46ICdnbF9GcmFnQ29sb3IucmdiID0gMS4wIC0gKDEuMCAtIGdsX0ZyYWdDb2xvci5yZ2IpICogKDEuMCAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBhZGQ6ICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIGRpZmY6ICdnbF9GcmFnQ29sb3IucmdiID0gYWJzKGdsX0ZyYWdDb2xvci5yZ2IgLSB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgc3VidHJhY3Q6ICdnbF9GcmFnQ29sb3IucmdiIC09IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIGxpZ2h0ZW46ICdnbF9GcmFnQ29sb3IucmdiID0gbWF4KGdsX0ZyYWdDb2xvci5yZ2IsIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBkYXJrZW46ICdnbF9GcmFnQ29sb3IucmdiID0gbWluKGdsX0ZyYWdDb2xvci5yZ2IsIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBleGNsdXNpb246ICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2IgLSAyLjAgKiAodUNvbG9yLnJnYiAqIGdsX0ZyYWdDb2xvci5yZ2IpO1xcbicsXG4gICAgICBvdmVybGF5OiAnaWYgKHVDb2xvci5yIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5yICo9IDIuMCAqIHVDb2xvci5yO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnIpICogKDEuMCAtIHVDb2xvci5yKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuZyA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuZyAqPSAyLjAgKiB1Q29sb3IuZztcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5nKSAqICgxLjAgLSB1Q29sb3IuZyk7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdpZiAodUNvbG9yLmIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmIgKj0gMi4wICogdUNvbG9yLmI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IuYikgKiAoMS4wIC0gdUNvbG9yLmIpO1xcbicgK1xuICAgICAgICAnfVxcbicsXG4gICAgICB0aW50OiAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSAoMS4wIC0gdUNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yLnJnYiArPSB1Q29sb3IucmdiO1xcbicsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJ1aWxkIHRoZSBmcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBmaWx0ZXJzLCBqb2luaW5nIHRoZSBjb21tb24gcGFydCB3aXRoXG4gICAgICogdGhlIHNwZWNpZmljIG9uZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSB0aGUgbW9kZSBvZiB0aGUgZmlsdGVyLCBhIGtleSBvZiB0aGlzLmZyYWdtZW50U291cmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgc291cmNlIHRvIGJlIGNvbXBpbGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBidWlsZFNvdXJjZTogZnVuY3Rpb24obW9kZSkge1xuICAgICAgcmV0dXJuICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnaWYgKGNvbG9yLmEgPiAwLjApIHtcXG4nICtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTb3VyY2VbbW9kZV0gK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICd9JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZSwgc2hhZGVyU291cmNlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgc2hhZGVyU291cmNlID0gdGhpcy5idWlsZFNvdXJjZSh0aGlzLm1vZGUpO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJsZW5kIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHRyLCB0ZywgdGIsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UsIGFscGhhMSA9IDEgLSB0aGlzLmFscGhhO1xuXG4gICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgdHIgPSBzb3VyY2VbMF0gKiB0aGlzLmFscGhhO1xuICAgICAgdGcgPSBzb3VyY2VbMV0gKiB0aGlzLmFscGhhO1xuICAgICAgdGIgPSBzb3VyY2VbMl0gKiB0aGlzLmFscGhhO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2NyZWVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSAyNTUgLSAoMjU1IC0gcikgKiAoMjU1IC0gdHIpIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSAoMjU1IC0gZykgKiAoMjU1IC0gdGcpIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSAyNTUgLSAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICsgdHI7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKyB0ZztcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiArIHRiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGlmZic6XG4gICAgICAgICAgY2FzZSAnZGlmZmVyZW5jZSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5hYnMociAtIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5hYnMoZyAtIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5hYnMoYiAtIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N1YnRyYWN0JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByIC0gdHI7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgLSB0ZztcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAtIHRiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGFya2VuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1pbihyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWluKGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5taW4oYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbGlnaHRlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5tYXgociwgdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heChnLCB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KGIsIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ292ZXJsYXknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyIDwgMTI4ID8gKDIgKiByICogdHIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gcikgKiAoMjU1IC0gdHIpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgPCAxMjggPyAoMiAqIGcgKiB0ZyAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiA8IDEyOCA/ICgyICogYiAqIHRiIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGIpICogKDI1NSAtIHRiKSAvIDI1NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdleGNsdXNpb24nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAtICgoMiAqIHRyICogcikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyArIGcgLSAoKDIgKiB0ZyAqIGcpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgKyBiIC0gKCgyICogdGIgKiBiKSAvIDI1NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0aW50JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0ciArIHIgKiBhbHBoYTE7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgKyBiICogYWxwaGExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbG9yJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVswXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMF0gLyAyNTU7XG4gICAgICBzb3VyY2VbMV0gPSB0aGlzLmFscGhhICogc291cmNlWzFdIC8gMjU1O1xuICAgICAgc291cmNlWzJdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVsyXSAvIDI1NTtcbiAgICAgIHNvdXJjZVszXSA9IHRoaXMuYWxwaGE7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yLCBzb3VyY2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvclxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbWFnZSBCbGVuZCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXIuQmxlbmRJbWFnZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3Ioe1xuICAgKiAgY29sb3I6ICcjMDAwJyxcbiAgICogIG1vZGU6ICdtdWx0aXBseSdcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZSh7XG4gICAqICBpbWFnZTogZmFicmljSW1hZ2VPYmplY3QsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknLFxuICAgKiAgYWxwaGE6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG5cbiAgZmlsdGVycy5CbGVuZEltYWdlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2UucHJvdG90eXBlICovIHtcbiAgICB0eXBlOiAnQmxlbmRJbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byBtYWtlIHRoZSBibGVuZCBvcGVyYXRpb24gd2l0aC4gZGVmYXVsdCB0byBhIHJlZGRpc2ggY29sb3Igc2luY2UgYmxhY2sgb3Igd2hpdGVcbiAgICAgKiBnaXZlcyBhbHdheXMgc3Ryb25nIHJlc3VsdC5cbiAgICAgKiovXG4gICAgaW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBCbGVuZCBtb2RlIGZvciB0aGUgZmlsdGVyOiBvbmUgb2YgbXVsdGlwbHksIGFkZCwgZGlmZiwgc2NyZWVuLCBzdWJ0cmFjdCxcbiAgICAgKiBkYXJrZW4sIGxpZ2h0ZW4sIG92ZXJsYXksIGV4Y2x1c2lvbiwgdGludC5cbiAgICAgKiovXG4gICAgbW9kZTogJ211bHRpcGx5JyxcblxuICAgIC8qKlxuICAgICAqIGFscGhhIHZhbHVlLiByZXByZXNlbnQgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibGVuZCBpbWFnZSBvcGVyYXRpb24uXG4gICAgICogbm90IGltcGxlbWVudGVkLlxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gbWF0MyB1VHJhbnNmb3JtTWF0cml4O1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICAgJ3ZUZXhDb29yZDIgPSAodVRyYW5zZm9ybU1hdHJpeCAqIHZlYzMoYVBvc2l0aW9uLCAxLjApKS54eTtcXG4nICtcbiAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24gKiAyLjAgLSAxLjAsIDAuMCwgMS4wKTtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yLnJnYmEgKj0gY29sb3IyLnJnYmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBtYXNrOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1SW1hZ2U7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1SW1hZ2UsIHZUZXhDb29yZDIpO1xcbicgK1xuICAgICAgICAgICdjb2xvci5hID0gY29sb3IyLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyB0aGlzLm1vZGU7XG4gICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVt0aGlzLm1vZGVdO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIGFwcGx5VG9XZWJHTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgLy8gbG9hZCB0ZXh0dXJlIHRvIGJsZW5kLlxuICAgICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgIHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUob3B0aW9ucy5maWx0ZXJCYWNrZW5kLCB0aGlzLmltYWdlKTtcbiAgICAgIHRoaXMuYmluZEFkZGl0aW9uYWxUZXh0dXJlKGdsLCB0ZXh0dXJlLCBnbC5URVhUVVJFMSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignYXBwbHlUb1dlYkdMJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnVuYmluZEFkZGl0aW9uYWxUZXh0dXJlKGdsLCBnbC5URVhUVVJFMSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uKGJhY2tlbmQsIGltYWdlKSB7XG4gICAgICByZXR1cm4gYmFja2VuZC5nZXRDYWNoZWRUZXh0dXJlKGltYWdlLmNhY2hlS2V5LCBpbWFnZS5fZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhIHRyYW5zZm9ybU1hdHJpeCB0byBhZGFwdCB0aGUgaW1hZ2UgdG8gYmxlbmQgb3ZlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICAgICAgd2lkdGggPSBpbWFnZS5fZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5fZWxlbWVudC5oZWlnaHQ7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAxIC8gaW1hZ2Uuc2NhbGVYLCAwLCAwLFxuICAgICAgICAwLCAxIC8gaW1hZ2Uuc2NhbGVZLCAwLFxuICAgICAgICAtaW1hZ2UubGVmdCAvIHdpZHRoLCAtaW1hZ2UudG9wIC8gaGVpZ2h0LCAxXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgcmVzb3VyY2VzID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGlMZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIHRyLCB0ZywgdGIsIHRhLFxuICAgICAgICAgIHIsIGcsIGIsIGEsXG4gICAgICAgICAgY2FudmFzMSwgY29udGV4dCwgaW1hZ2UgPSB0aGlzLmltYWdlLCBibGVuZERhdGE7XG5cbiAgICAgIGlmICghcmVzb3VyY2VzLmJsZW5kSW1hZ2UpIHtcbiAgICAgICAgcmVzb3VyY2VzLmJsZW5kSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG4gICAgICBjYW52YXMxID0gcmVzb3VyY2VzLmJsZW5kSW1hZ2U7XG4gICAgICBjb250ZXh0ID0gY2FudmFzMS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKGNhbnZhczEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhczEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMxLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKGltYWdlLnNjYWxlWCwgMCwgMCwgaW1hZ2Uuc2NhbGVZLCBpbWFnZS5sZWZ0LCBpbWFnZS50b3ApO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UuX2VsZW1lbnQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYmxlbmREYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICBhID0gZGF0YVtpICsgM107XG5cbiAgICAgICAgdHIgPSBibGVuZERhdGFbaV07XG4gICAgICAgIHRnID0gYmxlbmREYXRhW2kgKyAxXTtcbiAgICAgICAgdGIgPSBibGVuZERhdGFbaSArIDJdO1xuICAgICAgICB0YSA9IGJsZW5kRGF0YVtpICsgM107XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICdtdWx0aXBseSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciAqIHRyIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnICogdGcgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgKiB0YiAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gYSAqIHRhIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFzayc6XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IHRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRyYW5zZm9ybU1hdHJpeCcpLFxuICAgICAgICB1SW1hZ2U6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUltYWdlJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVJbWFnZSwgMSk7IC8vIHRleHR1cmUgdW5pdCAxLlxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1bmlmb3JtTG9jYXRpb25zLnVUcmFuc2Zvcm1NYXRyaXgsIGZhbHNlLCBtYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBpbWFnZTogdGhpcy5pbWFnZSAmJiB0aGlzLmltYWdlLnRvT2JqZWN0KCksXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYWxwaGE6IHRoaXMuYWxwaGFcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLkltYWdlLmZyb21PYmplY3Qob2JqZWN0LmltYWdlLCBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob2JqZWN0KTtcbiAgICAgIG9wdGlvbnMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKG9wdGlvbnMpKTtcbiAgICB9KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSwgcG93ID0gTWF0aC5wb3csIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgIHNxcnQgPSBNYXRoLnNxcnQsIGFicyA9IE1hdGguYWJzLCByb3VuZCA9IE1hdGgucm91bmQsIHNpbiA9IE1hdGguc2luLFxuICAgICAgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBpbWFnZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlJlc2l6ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdSZXNpemUnLFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHR5cGVcbiAgICAgKiBmb3Igd2ViZ2wgcmVzaXplVHlwZSBpcyBqdXN0IGxhbmN6b3MsIGZvciBjYW52YXMyZCBjYW4gYmU6XG4gICAgICogYmlsaW5lYXIsIGhlcm1pdGUsIHNsaWNlSGFjaywgbGFuY3pvcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzaXplVHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVzaXplVHlwZTogJ2hlcm1pdGUnLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeCBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeSBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogTGFuY3pvc0xvYmVzIHBhcmFtZXRlciBmb3IgbGFuY3pvcyBmaWx0ZXIsIHZhbGlkIGZvciByZXNpemVUeXBlIGxhbmN6b3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGFuY3pvc0xvYmVzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsYW5jem9zTG9iZXM6IDMsXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1RGVsdGE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndURlbHRhJyksXG4gICAgICAgIHVUYXBzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VUYXBzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMmZ2KHVuaWZvcm1Mb2NhdGlvbnMudURlbHRhLCB0aGlzLmhvcml6b250YWwgPyBbMSAvIHRoaXMud2lkdGgsIDBdIDogWzAsIDEgLyB0aGlzLmhlaWdodF0pO1xuICAgICAgZ2wudW5pZm9ybTFmdih1bmlmb3JtTG9jYXRpb25zLnVUYXBzLCB0aGlzLnRhcHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGZpbHRlcldpbmRvdyA9IHRoaXMuZ2V0RmlsdGVyV2luZG93KCksIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgZmlsdGVyV2luZG93O1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhpcy5nZW5lcmF0ZVNoYWRlcihmaWx0ZXJXaW5kb3cpO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBmcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJXaW5kb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy50ZW1wU2NhbGU7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMubGFuY3pvc0xvYmVzIC8gc2NhbGUpO1xuICAgIH0sXG5cbiAgICBnZXRUYXBzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsb2JlRnVuY3Rpb24gPSB0aGlzLmxhbmN6b3NDcmVhdGUodGhpcy5sYW5jem9zTG9iZXMpLCBzY2FsZSA9IHRoaXMudGVtcFNjYWxlLFxuICAgICAgICAgIGZpbHRlcldpbmRvdyA9IHRoaXMuZ2V0RmlsdGVyV2luZG93KCksIHRhcHMgPSBuZXcgQXJyYXkoZmlsdGVyV2luZG93KTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZpbHRlcldpbmRvdzsgaSsrKSB7XG4gICAgICAgIHRhcHNbaSAtIDFdID0gbG9iZUZ1bmN0aW9uKGkgKiBzY2FsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdmVydGV4IGFuZCBzaGFkZXIgc291cmNlcyBmcm9tIHRoZSBuZWNlc3Nhcnkgc3RlcHMgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmaWx0ZXJXaW5kb3dcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVNoYWRlcjogZnVuY3Rpb24oZmlsdGVyV2luZG93KSB7XG4gICAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShmaWx0ZXJXaW5kb3cpLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNvdXJjZVRPUCwgZmlsdGVyV2luZG93O1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmaWx0ZXJXaW5kb3c7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2kgLSAxXSA9IGkgKyAnLjAgKiB1RGVsdGEnO1xuICAgICAgfVxuXG4gICAgICBmcmFnbWVudFNoYWRlciArPSAndW5pZm9ybSBmbG9hdCB1VGFwc1snICsgZmlsdGVyV2luZG93ICsgJ107XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd2b2lkIG1haW4oKSB7XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGZsb2F0IHN1bSA9IDEuMDtcXG4nO1xuXG4gICAgICBvZmZzZXRzLmZvckVhY2goZnVuY3Rpb24ob2Zmc2V0LCBpKSB7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgJyArIG9mZnNldCArICcpICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCAtICcgKyBvZmZzZXQgKyAnKSAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgc3VtICs9IDIuMCAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgIH0pO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyBzdW07XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd9JztcbiAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICB9LFxuXG4gICAgZnJhZ21lbnRTb3VyY2VUT1A6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMyIHVEZWx0YTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcmVzaXplIGZpbHRlciB0byB0aGUgaW1hZ2VcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgICAgb3B0aW9ucy5wYXNzZXMrKztcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMuc291cmNlV2lkdGg7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZFcgPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnNjYWxlWCk7XG4gICAgICAgIHRoaXMuZEggPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRXIC8gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy50YXBzID0gdGhpcy5nZXRUYXBzKCk7XG4gICAgICAgIG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aCA9IHRoaXMuZFc7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc291cmNlV2lkdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGg7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZEggPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogdGhpcy5zY2FsZVkpO1xuICAgICAgICB0aGlzLnRlbXBTY2FsZSA9IHRoaXMuZEggLyB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy50YXBzID0gdGhpcy5nZXRUYXBzKCk7XG4gICAgICAgIG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQgPSB0aGlzLmRIO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnNvdXJjZUhlaWdodCA9IG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlWCA9PT0gMSAmJiB0aGlzLnNjYWxlWSA9PT0gMTtcbiAgICB9LFxuXG4gICAgbGFuY3pvc0NyZWF0ZTogZnVuY3Rpb24obG9iZXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID49IGxvYmVzIHx8IHggPD0gLWxvYmVzKSB7XG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3ICYmIHggPiAtMS4xOTIwOTI5MEUtMDcpIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgIHggKj0gTWF0aC5QSTtcbiAgICAgICAgdmFyIHh4ID0geCAvIGxvYmVzO1xuICAgICAgICByZXR1cm4gKHNpbih4KSAvIHgpICogc2luKHh4KSAvIHh4O1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuXG4gICAgICB0aGlzLnJjcFNjYWxlWCA9IDEgLyBzY2FsZVg7XG4gICAgICB0aGlzLnJjcFNjYWxlWSA9IDEgLyBzY2FsZVk7XG5cbiAgICAgIHZhciBvVyA9IGltYWdlRGF0YS53aWR0aCwgb0ggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGRXID0gcm91bmQob1cgKiBzY2FsZVgpLCBkSCA9IHJvdW5kKG9IICogc2NhbGVZKSxcbiAgICAgICAgICBuZXdEYXRhO1xuXG4gICAgICBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnc2xpY2VIYWNrJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5zbGljZUJ5VHdvKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2hlcm1pdGUnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmhlcm1pdGVGYXN0UmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2JpbGluZWFyJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5iaWxpbmVhckZpbHRlcmluZyhvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdsYW5jem9zJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5sYW5jem9zUmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gbmV3RGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHNsaWNlQnlUd29cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIHNsaWNlQnlUd286IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgbXVsdCA9IDAuNSwgZG9uZVcgPSBmYWxzZSwgZG9uZUggPSBmYWxzZSwgc3RlcFcgPSBvVyAqIG11bHQsXG4gICAgICAgICAgc3RlcEggPSBvSCAqIG11bHQsIHJlc291cmNlcyA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICB0bXBDYW52YXMsIGN0eCwgc1ggPSAwLCBzWSA9IDAsIGRYID0gb1csIGRZID0gMDtcbiAgICAgIGlmICghcmVzb3VyY2VzLnNsaWNlQnlUd28pIHtcbiAgICAgICAgcmVzb3VyY2VzLnNsaWNlQnlUd28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHJlc291cmNlcy5zbGljZUJ5VHdvO1xuICAgICAgaWYgKHRtcENhbnZhcy53aWR0aCA8IG9XICogMS41IHx8IHRtcENhbnZhcy5oZWlnaHQgPCBvSCkge1xuICAgICAgICB0bXBDYW52YXMud2lkdGggPSBvVyAqIDEuNTtcbiAgICAgICAgdG1wQ2FudmFzLmhlaWdodCA9IG9IO1xuICAgICAgfVxuICAgICAgY3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9XICogMS41LCBvSCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGRXID0gZmxvb3IoZFcpO1xuICAgICAgZEggPSBmbG9vcihkSCk7XG5cbiAgICAgIHdoaWxlICghZG9uZVcgfHwgIWRvbmVIKSB7XG4gICAgICAgIG9XID0gc3RlcFc7XG4gICAgICAgIG9IID0gc3RlcEg7XG4gICAgICAgIGlmIChkVyA8IGZsb29yKHN0ZXBXICogbXVsdCkpIHtcbiAgICAgICAgICBzdGVwVyA9IGZsb29yKHN0ZXBXICogbXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RlcFcgPSBkVztcbiAgICAgICAgICBkb25lVyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRIIDwgZmxvb3Ioc3RlcEggKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBIID0gZmxvb3Ioc3RlcEggKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwSCA9IGRIO1xuICAgICAgICAgIGRvbmVIID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgc1gsIHNZLCBvVywgb0gsIGRYLCBkWSwgc3RlcFcsIHN0ZXBIKTtcbiAgICAgICAgc1ggPSBkWDtcbiAgICAgICAgc1kgPSBkWTtcbiAgICAgICAgZFkgKz0gc3RlcEg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmdldEltYWdlRGF0YShzWCwgc1ksIGRXLCBkSCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBsYW5jem9zUmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBsYW5jem9zUmVzaXplOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzKHUpIHtcbiAgICAgICAgdmFyIHYsIGksIHdlaWdodCwgaWR4LCBhLCByZWQsIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSwgYWxwaGEsIGZYLCBmWTtcbiAgICAgICAgY2VudGVyLnggPSAodSArIDAuNSkgKiByYXRpb1g7XG4gICAgICAgIGljZW50ZXIueCA9IGZsb29yKGNlbnRlci54KTtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGRIOyB2KyspIHtcbiAgICAgICAgICBjZW50ZXIueSA9ICh2ICsgMC41KSAqIHJhdGlvWTtcbiAgICAgICAgICBpY2VudGVyLnkgPSBmbG9vcihjZW50ZXIueSk7XG4gICAgICAgICAgYSA9IDA7IHJlZCA9IDA7IGdyZWVuID0gMDsgYmx1ZSA9IDA7IGFscGhhID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBpY2VudGVyLnggLSByYW5nZTJYOyBpIDw9IGljZW50ZXIueCArIHJhbmdlMlg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gb1cpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmWCA9IGZsb29yKDEwMDAgKiBhYnMoaSAtIGNlbnRlci54KSk7XG4gICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF0pIHtcbiAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXSA9IHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpY2VudGVyLnkgLSByYW5nZTJZOyBqIDw9IGljZW50ZXIueSArIHJhbmdlMlk7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBvSCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZZID0gZmxvb3IoMTAwMCAqIGFicyhqIC0gY2VudGVyLnkpKTtcbiAgICAgICAgICAgICAgaWYgKCFjYWNoZUxhbmNbZlhdW2ZZXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlTGFuY1tmWF1bZlldID0gbGFuY3pvcyhzcXJ0KHBvdyhmWCAqIHJjcFJhdGlvWCwgMikgKyBwb3coZlkgKiByY3BSYXRpb1ksIDIpKSAvIDEwMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdlaWdodCA9IGNhY2hlTGFuY1tmWF1bZlldO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IChqICogb1cgKyBpKSAqIDQ7XG4gICAgICAgICAgICAgICAgYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmVkICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4XTtcbiAgICAgICAgICAgICAgICBncmVlbiArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgICAgIGJsdWUgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgICAgICBhbHBoYSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCA9ICh2ICogZFcgKyB1KSAqIDQ7XG4gICAgICAgICAgZGVzdERhdGFbaWR4XSA9IHJlZCAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMV0gPSBncmVlbiAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMl0gPSBibHVlIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAzXSA9IGFscGhhIC8gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3UgPCBkVykge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzKHUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0SW1nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBkZXN0SW1nID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdERhdGEgPSBkZXN0SW1nLmRhdGEsXG4gICAgICAgICAgbGFuY3pvcyA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksXG4gICAgICAgICAgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJjcFJhdGlvWCA9IDIgLyB0aGlzLnJjcFNjYWxlWCwgcmNwUmF0aW9ZID0gMiAvIHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhbmdlMlggPSBjZWlsKHJhdGlvWCAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgcmFuZ2UyWSA9IGNlaWwocmF0aW9ZICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICBjYWNoZUxhbmMgPSB7IH0sIGNlbnRlciA9IHsgfSwgaWNlbnRlciA9IHsgfTtcblxuICAgICAgcmV0dXJuIHByb2Nlc3MoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbGluZWFyRmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBiaWxpbmVhckZpbHRlcmluZzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBhLCBiLCBjLCBkLCB4LCB5LCBpLCBqLCB4RGlmZiwgeURpZmYsIGNobmwsXG4gICAgICAgICAgY29sb3IsIG9mZnNldCA9IDAsIG9yaWdQaXgsIHJhdGlvWCA9IHRoaXMucmNwU2NhbGVYLFxuICAgICAgICAgIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHc0ID0gNCAqIChvVyAtIDEpLCBpbWcgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBwaXhlbHMgPSBpbWcuZGF0YSwgZGVzdEltYWdlID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdFBpeGVscyA9IGRlc3RJbWFnZS5kYXRhO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGRIOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRXOyBqKyspIHtcbiAgICAgICAgICB4ID0gZmxvb3IocmF0aW9YICogaik7XG4gICAgICAgICAgeSA9IGZsb29yKHJhdGlvWSAqIGkpO1xuICAgICAgICAgIHhEaWZmID0gcmF0aW9YICogaiAtIHg7XG4gICAgICAgICAgeURpZmYgPSByYXRpb1kgKiBpIC0geTtcbiAgICAgICAgICBvcmlnUGl4ID0gNCAqICh5ICogb1cgKyB4KTtcblxuICAgICAgICAgIGZvciAoY2hubCA9IDA7IGNobmwgPCA0OyBjaG5sKyspIHtcbiAgICAgICAgICAgIGEgPSBwaXhlbHNbb3JpZ1BpeCArIGNobmxdO1xuICAgICAgICAgICAgYiA9IHBpeGVsc1tvcmlnUGl4ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgYyA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyBjaG5sXTtcbiAgICAgICAgICAgIGQgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgY29sb3IgPSBhICogKDEgLSB4RGlmZikgKiAoMSAtIHlEaWZmKSArIGIgKiB4RGlmZiAqICgxIC0geURpZmYpICtcbiAgICAgICAgICAgICAgICAgICAgYyAqIHlEaWZmICogKDEgLSB4RGlmZikgKyBkICogeERpZmYgKiB5RGlmZjtcbiAgICAgICAgICAgIGRlc3RQaXhlbHNbb2Zmc2V0KytdID0gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdEltYWdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZXJtaXRlRmFzdFJlc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgaGVybWl0ZUZhc3RSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgcmF0aW9XID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvSCA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhdGlvV0hhbGYgPSBjZWlsKHJhdGlvVyAvIDIpLFxuICAgICAgICAgIHJhdGlvSEhhbGYgPSBjZWlsKHJhdGlvSCAvIDIpLFxuICAgICAgICAgIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1nLmRhdGEsXG4gICAgICAgICAgaW1nMiA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShkVywgZEgpLCBkYXRhMiA9IGltZzIuZGF0YTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZEg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRXOyBpKyspIHtcbiAgICAgICAgICB2YXIgeDIgPSAoaSArIGogKiBkVykgKiA0LCB3ZWlnaHQgPSAwLCB3ZWlnaHRzID0gMCwgd2VpZ2h0c0FscGhhID0gMCxcbiAgICAgICAgICAgICAgZ3hSID0gMCwgZ3hHID0gMCwgZ3hCID0gMCwgZ3hBID0gMCwgY2VudGVyWSA9IChqICsgMC41KSAqIHJhdGlvSDtcbiAgICAgICAgICBmb3IgKHZhciB5eSA9IGZsb29yKGogKiByYXRpb0gpOyB5eSA8IChqICsgMSkgKiByYXRpb0g7IHl5KyspIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGFicyhjZW50ZXJZIC0gKHl5ICsgMC41KSkgLyByYXRpb0hIYWxmLFxuICAgICAgICAgICAgICAgIGNlbnRlclggPSAoaSArIDAuNSkgKiByYXRpb1csIHcwID0gZHkgKiBkeTtcbiAgICAgICAgICAgIGZvciAodmFyIHh4ID0gZmxvb3IoaSAqIHJhdGlvVyk7IHh4IDwgKGkgKyAxKSAqIHJhdGlvVzsgeHgrKykge1xuICAgICAgICAgICAgICB2YXIgZHggPSBhYnMoY2VudGVyWCAtICh4eCArIDAuNSkpIC8gcmF0aW9XSGFsZixcbiAgICAgICAgICAgICAgICAgIHcgPSBzcXJ0KHcwICsgZHggKiBkeCk7XG4gICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgICBpZiAodyA+IDEgJiYgdyA8IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9oZXJtaXRlIGZpbHRlclxuICAgICAgICAgICAgICB3ZWlnaHQgPSAyICogdyAqIHcgKiB3IC0gMyAqIHcgKiB3ICsgMTtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBkeCA9IDQgKiAoeHggKyB5eSAqIG9XKTtcbiAgICAgICAgICAgICAgICAvL2FscGhhXG4gICAgICAgICAgICAgICAgZ3hBICs9IHdlaWdodCAqIGRhdGFbZHggKyAzXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzQWxwaGEgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIC8vY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbZHggKyAzXSA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0ICogZGF0YVtkeCArIDNdIC8gMjUwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBneFIgKz0gd2VpZ2h0ICogZGF0YVtkeF07XG4gICAgICAgICAgICAgICAgZ3hHICs9IHdlaWdodCAqIGRhdGFbZHggKyAxXTtcbiAgICAgICAgICAgICAgICBneEIgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDJdO1xuICAgICAgICAgICAgICAgIHdlaWdodHMgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEyW3gyXSA9IGd4UiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAxXSA9IGd4RyAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAyXSA9IGd4QiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAzXSA9IGd4QSAvIHdlaWdodHNBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGltZzI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHJlc2l6ZVR5cGU6IHRoaXMucmVzaXplVHlwZSxcbiAgICAgICAgbGFuY3pvc0xvYmVzOiB0aGlzLmxhbmN6b3NMb2Jlc1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29udHJhc3QgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3Qoe1xuICAgKiAgIGNvbnRyYXN0OiAwLjI1XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29udHJhc3QgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb250cmFzdCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVDb250cmFzdDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBjb250cmFzdEYgPSAxLjAxNSAqICh1Q29udHJhc3QgKyAxLjApIC8gKDEuMCAqICgxLjAxNSAtIHVDb250cmFzdCkpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiID0gY29udHJhc3RGICogKGNvbG9yLnJnYiAtIDAuNSkgKyAwLjU7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIGNvbnRyYXN0IHZhbHVlLCByYW5nZSBmcm9tIC0xIHRvIDEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGNvbnRyYXN0OiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2NvbnRyYXN0JyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29udHJhc3Q9MF0gVmFsdWUgdG8gY29udHJhc3QgdGhlIGltYWdlIHVwICgtMS4uLjEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgICogQXBwbHkgdGhlIENvbnRyYXN0IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5jb250cmFzdCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGksIGxlbixcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGNvbnRyYXN0ID0gTWF0aC5mbG9vcih0aGlzLmNvbnRyYXN0ICogMjU1KSxcbiAgICAgICAgICBjb250cmFzdEYgPSAyNTkgKiAoY29udHJhc3QgKyAyNTUpIC8gKDI1NSAqICgyNTkgLSBjb250cmFzdCkpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGNvbnRyYXN0RiAqIChkYXRhW2ldIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAyXSAtIDEyOCkgKyAxMjg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29udHJhc3Q6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbnRyYXN0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51Q29udHJhc3QsIHRoaXMuY29udHJhc3QpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3R9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogU2F0dXJhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24oe1xuICAgKiAgIHNhdHVyYXRpb246IDEwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlNhdHVyYXRpb24gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1NhdHVyYXRpb24nLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ01heCA9IG1heChjb2xvci5yLCBjb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHJnYk1heCA9IG1heChyZ01heCwgY29sb3IuYik7XFxuJyArXG4gICAgICAgICdjb2xvci5yICs9IHJnYk1heCAhPSBjb2xvci5yID8gKHJnYk1heCAtIGNvbG9yLnIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuZyArPSByZ2JNYXggIT0gY29sb3IuZyA/IChyZ2JNYXggLSBjb2xvci5nKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgKz0gcmdiTWF4ICE9IGNvbG9yLmIgPyAocmdiTWF4IC0gY29sb3IuYikgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIHNhdHVyYXRpb246IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnc2F0dXJhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRlPTBdIFZhbHVlIHRvIHNhdHVyYXRlIHRoZSBpbWFnZSAoLTEuLi4xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFNhdHVyYXRpb24gb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5zYXR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGFkanVzdCA9IC10aGlzLnNhdHVyYXRpb24sIGksIG1heDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSk7XG4gICAgICAgIGRhdGFbaV0gKz0gbWF4ICE9PSBkYXRhW2ldID8gKG1heCAtIGRhdGFbaV0pICogYWRqdXN0IDogMDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gbWF4ICE9PSBkYXRhW2kgKyAxXSA/IChtYXggLSBkYXRhW2kgKyAxXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSBtYXggIT09IGRhdGFbaSArIDJdID8gKG1heCAtIGRhdGFbaSArIDJdKSAqIGFkanVzdCA6IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1U2F0dXJhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2F0dXJhdGlvbicpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVNhdHVyYXRpb24sIC10aGlzLnNhdHVyYXRpb24pO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEJsdXIgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIoe1xuICAgKiAgIGJsdXI6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuQmx1ciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAnQmx1cicsXG5cbiAgICAvKlxuJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTcgKiB1RGVsdGEpKjAuMDA0NDI5OTEyMTA1NTExMzI2NTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTYgKiB1RGVsdGEpKjAuMDA4OTU3ODEyMTE3OTQ7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC01ICogdURlbHRhKSowLjAyMTU5NjM4NjYwNTM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC00ICogdURlbHRhKSowLjA0NDM2ODMzMzg3MTg7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0zICogdURlbHRhKSowLjA3NzY3NDQyMTk5MzM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0yICogdURlbHRhKSowLjExNTg3NjYyMTEwNTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTEgKiB1RGVsdGEpKjAuMTQ3MzA4MDU2MTIxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgICAgICAgICAgICAgICkqMC4xNTk1NzY5MTIxNjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDEgKiB1RGVsdGEpKjAuMTQ3MzA4MDU2MTIxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAyICogdURlbHRhKSowLjExNTg3NjYyMTEwNTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMyAqIHVEZWx0YSkqMC4wNzc2NzQ0MjE5OTMzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA0ICogdURlbHRhKSowLjA0NDM2ODMzMzg3MTg7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDUgKiB1RGVsdGEpKjAuMDIxNTk2Mzg2NjA1MzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNiAqIHVEZWx0YSkqMC4wMDg5NTc4MTIxMTc5NDsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNyAqIHVEZWx0YSkqMC4wMDQ0Mjk5MTIxMDU1MTEzMjY1OycsXG4qL1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMiB1RGVsdGE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICdjb25zdCBmbG9hdCBuU2FtcGxlcyA9IDE1LjA7XFxuJyArXG4gICAgICAndmVjMyB2M29mZnNldCA9IHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4Mik7XFxuJyArXG4gICAgICAnZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUpIHtcXG4nICtcbiAgICAgICAgLyogdXNlIHRoZSBmcmFnbWVudCBwb3NpdGlvbiBmb3IgYSBkaWZmZXJlbnQgc2VlZCBwZXItcGl4ZWwgKi9cbiAgICAgICAgJ3JldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXosIHNjYWxlKSkgKiA0Mzc1OC41NDUzKTtcXG4nICtcbiAgICAgICd9XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHRvdGFsID0gMC4wO1xcbicgK1xuICAgICAgICAnZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHYzb2Zmc2V0KTtcXG4nICtcbiAgICAgICAgJ2ZvciAoZmxvYXQgdCA9IC1uU2FtcGxlczsgdCA8PSBuU2FtcGxlczsgdCsrKSB7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyBuU2FtcGxlcztcXG4nICtcbiAgICAgICAgICAnZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbicgK1xuICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIHVEZWx0YSAqIHBlcmNlbnQpICogd2VpZ2h0O1xcbicgK1xuICAgICAgICAgICd0b3RhbCArPSB3ZWlnaHQ7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbicgK1xuICAgICAgJ30nLFxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgLyoqXG4gICAgICogYmx1ciB2YWx1ZSwgaW4gcGVyY2VudGFnZSBvZiBpbWFnZSBkaW1lbnNpb25zLlxuICAgICAqIHNwZWNpZmljIHRvIGtlZXAgdGhlIGltYWdlIGJsdXIgY29uc3RhbnQgYXQgZGlmZmVyZW50IHJlc29sdXRpb25zXG4gICAgICogcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmx1cicsXG5cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICAvLyB0aGlzIGFzcGVjdFJhdGlvIGlzIHVzZWQgdG8gZ2l2ZSB0aGUgc2FtZSBibHVyIHRvIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsXG4gICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBvcHRpb25zLnNvdXJjZVdpZHRoIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIG9wdGlvbnMucGFzc2VzKys7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIHBhaW50IGNhbnZhc0VsIHdpdGggY3VycmVudCBpbWFnZSBkYXRhLlxuICAgICAgLy9vcHRpb25zLmN0eC5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSB0aGlzLnNpbXBsZUJsdXIob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHNpbXBsZUJsdXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLCBjYW52YXMxLCBjYW52YXMyLFxuICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5pbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5pbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgICBpZiAoIXJlc291cmNlcy5ibHVyTGF5ZXIxKSB7XG4gICAgICAgIHJlc291cmNlcy5ibHVyTGF5ZXIxID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmx1ckxheWVyMTtcbiAgICAgIGNhbnZhczIgPSByZXNvdXJjZXMuYmx1ckxheWVyMjtcbiAgICAgIGlmIChjYW52YXMxLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMxLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhczIud2lkdGggPSBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczIuaGVpZ2h0ID0gY2FudmFzMS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgY3R4MSA9IGNhbnZhczEuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBjdHgyID0gY2FudmFzMi5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIG5TYW1wbGVzID0gMTUsXG4gICAgICAgICAgcmFuZG9tLCBwZXJjZW50LCBqLCBpLFxuICAgICAgICAgIGJsdXIgPSB0aGlzLmJsdXIgKiAwLjA2ICogMC41O1xuXG4gICAgICAvLyBsb2FkIGZpcnN0IGNhbnZhc1xuICAgICAgY3R4MS5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIHdpZHRoICsgcmFuZG9tO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMSAtIE1hdGguYWJzKHBlcmNlbnQpO1xuICAgICAgICBjdHgyLmRyYXdJbWFnZShjYW52YXMxLCBqLCByYW5kb20pO1xuICAgICAgICBjdHgxLmRyYXdJbWFnZShjYW52YXMyLCAwLCAwKTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczIud2lkdGgsIGNhbnZhczIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIGhlaWdodCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgcmFuZG9tLCBqKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmN0eC5kcmF3SW1hZ2UoY2FudmFzMSwgMCwgMCk7XG4gICAgICB2YXIgbmV3SW1hZ2VEYXRhID0gb3B0aW9ucy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIGN0eDEuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4MS5jbGVhclJlY3QoMCwgMCwgY2FudmFzMS53aWR0aCwgY2FudmFzMS5oZWlnaHQpO1xuICAgICAgcmV0dXJuIG5ld0ltYWdlRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbHRhOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VEZWx0YScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5jaG9vc2VSaWdodERlbHRhKCk7XG4gICAgICBnbC51bmlmb3JtMmZ2KHVuaWZvcm1Mb2NhdGlvbnMuZGVsdGEsIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2hvb3NlIHJpZ2h0IHZhbHVlIG9mIGltYWdlIHBlcmNlbnRhZ2UgdG8gYmx1ciB3aXRoXG4gICAgICogQHJldHVybnMge0FycmF5fSBhIG51bWVyaWMgYXJyYXkgd2l0aCBkZWx0YSB2YWx1ZXNcbiAgICAgKi9cbiAgICBjaG9vc2VSaWdodERlbHRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBibHVyU2NhbGUgPSAxLCBkZWx0YSA9IFswLCAwXSwgYmx1cjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPiAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgd2lkZSwgaSB3YW50IHRvIHNocmluayByYWRpdXMgaG9yaXpvbnRhbFxuICAgICAgICAgIGJsdXJTY2FsZSA9IDEgLyB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPCAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgdGFsbCwgaSB3YW50IHRvIHNocmluayByYWRpdXMgdmVydGljYWxcbiAgICAgICAgICBibHVyU2NhbGUgPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBibHVyID0gYmx1clNjYWxlICogdGhpcy5ibHVyICogMC4xMjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgZGVsdGFbMF0gPSBibHVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlbHRhWzFdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIGRlZmluaXRpb24gb2YgYSBCbHVyRmlsdGVyIGludG8gYSBjb25jcmV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGZpbHRlcnMuQmx1ci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR2FtbWEgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEoe1xuICAgKiAgIGdhbW1hOiBbMSwgMC41LCAyLjFdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuR2FtbWEgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHYW1tYScsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzMgdUdhbW1hO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ3ZlYzMgY29ycmVjdGlvbiA9ICgxLjAgLyB1R2FtbWEpO1xcbicgK1xuICAgICAgICAnY29sb3IuciA9IHBvdyhjb2xvci5yLCBjb3JyZWN0aW9uLnIpO1xcbicgK1xuICAgICAgICAnY29sb3IuZyA9IHBvdyhjb2xvci5nLCBjb3JyZWN0aW9uLmcpO1xcbicgK1xuICAgICAgICAnY29sb3IuYiA9IHBvdyhjb2xvci5iLCBjb3JyZWN0aW9uLmIpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yLmE7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBHYW1tYSBhcnJheSB2YWx1ZSwgZnJvbSAwLjAxIHRvIDIuMi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBnYW1tYVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZ2FtbWE6IFsxLCAxLCAxXSxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdnYW1tYScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmdhbW1hID0gWzEsIDEsIDFdO1xuICAgICAgZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHYW1tYSBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBnYW1tYSA9IHRoaXMuZ2FtbWEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHJJbnYgPSAxIC8gZ2FtbWFbMF0sIGdJbnYgPSAxIC8gZ2FtbWFbMV0sXG4gICAgICAgICAgYkludiA9IDEgLyBnYW1tYVsyXSwgaTtcblxuICAgICAgaWYgKCF0aGlzLnJWYWxzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnJWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuZ1ZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5iVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIC0gcHJlLWNvbXB1dGUgYSBsb29rLXVwIHRhYmxlIGZvciBlYWNoIGNvbG9yIGNoYW5uZWxcbiAgICAgIC8vIGluc3RlYWQgb2YgcGVyZm9ybWluZyB0aGVzZSBwb3cgY2FsbHMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIGltYWdlLlxuICAgICAgZm9yIChpID0gMCwgbGVuID0gMjU2OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5yVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIHJJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmdWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgZ0ludikgKiAyNTU7XG4gICAgICAgIHRoaXMuYlZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBiSW52KSAqIDI1NTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IHRoaXMuclZhbHNbZGF0YVtpXV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gdGhpcy5nVmFsc1tkYXRhW2kgKyAxXV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gdGhpcy5iVmFsc1tkYXRhW2kgKyAyXV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1R2FtbWE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUdhbW1hJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtM2Z2KHVuaWZvcm1Mb2NhdGlvbnMudUdhbW1hLCB0aGlzLmdhbW1hKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEEgY29udGFpbmVyIGNsYXNzIHRoYXQga25vd3MgaG93IHRvIGFwcGx5IGEgc2VxdWVuY2Ugb2YgZmlsdGVycyB0byBhbiBpbnB1dCBpbWFnZS5cbiAgICovXG4gIGZpbHRlcnMuQ29tcG9zZWQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdDb21wb3NlZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIG5vbiBzcGFyc2UgYXJyYXkgb2YgZmlsdGVycyB0byBhcHBseVxuICAgICAqL1xuICAgIHN1YkZpbHRlcnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLnN1YkZpbHRlcnMgPSB0aGlzLnN1YkZpbHRlcnMuc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgY29udGFpbmVyJ3MgZmlsdGVycyB0byB0aGUgaW5wdXQgaW1hZ2UgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5wYXNzZXMgKz0gdGhpcy5zdWJGaWx0ZXJzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLnN1YkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyLmFwcGx5VG8ob3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgZmlsdGVyIGludG8gSlNPTi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZpbHRlci5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBzdWJGaWx0ZXJzOiB0aGlzLnN1YkZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyLnRvT2JqZWN0KCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5zdWJGaWx0ZXJzLnNvbWUoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiAhZmlsdGVyLmlzTmV1dHJhbFN0YXRlKCk7IH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQ29tcG9zZWRGaWx0ZXIgaW50byBhIGNvbmNyZXRlIGluc3RhbmNlLlxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlsdGVycyA9IG9iamVjdC5zdWJGaWx0ZXJzIHx8IFtdLFxuICAgICAgICBzdWJGaWx0ZXJzID0gZmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tmaWx0ZXIudHlwZV0oZmlsdGVyKTtcbiAgICAgICAgfSksXG4gICAgICAgIGluc3RhbmNlID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkKHsgc3ViRmlsdGVyczogc3ViRmlsdGVycyB9KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEh1ZVJvdGF0aW9uIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uKHtcbiAgICogICByb3RhdGlvbjogLTAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkh1ZVJvdGF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0h1ZVJvdGF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEh1ZVJvdGF0aW9uIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogdGhlIHVuaXQgaXMgcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBteVBhcmFtZXRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAncm90YXRpb24nLFxuXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYWQgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSwgY29zID0gZmFicmljLnV0aWwuY29zKHJhZCksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWQpLFxuICAgICAgICAgIGFUaGlyZCA9IDEgLyAzLCBhVGhpcmRTcXRTaW4gPSBNYXRoLnNxcnQoYVRoaXJkKSAqIHNpbiwgT25lTWludXNDb3MgPSAxIC0gY29zO1xuICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF07XG4gICAgICB0aGlzLm1hdHJpeFswXSA9IGNvcyArIE9uZU1pbnVzQ29zIC8gMztcbiAgICAgIHRoaXMubWF0cml4WzFdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsyXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbNV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzZdID0gY29zICsgYVRoaXJkICogT25lTWludXNDb3M7XG4gICAgICB0aGlzLm1hdHJpeFs3XSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTBdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEyXSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIdWVSb3RhdGlvbiBpc05ldXRyYWxTdGF0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIHJldHVybiBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmlzTmV1dHJhbFN0YXRlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgZmlsdGVyIHRvIHRoZSBpbnB1dCBpbWFnZSBkYXRhIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmFwcGx5VG8uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb259IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBpZiAoZmFicmljLlRleHQpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRleHQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFkZGl0aW9uYWxQcm9wcyA9XG4gICAgKCdmb250RmFtaWx5IGZvbnRXZWlnaHQgZm9udFNpemUgdGV4dCB1bmRlcmxpbmUgb3ZlcmxpbmUgbGluZXRocm91Z2gnICtcbiAgICAnIHRleHRBbGlnbiBmb250U3R5bGUgbGluZUhlaWdodCB0ZXh0QmFja2dyb3VuZENvbG9yIGNoYXJTcGFjaW5nIHN0eWxlcyBwYXRoJykuc3BsaXQoJyAnKTtcblxuICAvKipcbiAgICogVGV4dCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiN0ZXh0fVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IFtcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICAndGV4dEFsaWduJyxcbiAgICAgICdzdHlsZXMnLFxuICAgICAgJ3BhdGgnXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlTmV3bGluZTogL1xccj9cXG4vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZXMgdGhhdCBpcyBub3QgYSBuZXcgbGluZS5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZXNBbmRUYWJzOiAvWyBcXHRcXHJdL2csXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGZvciB3aGl0ZXNwYWNlIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VBbmRUYWI6IC9bIFxcdFxccl0vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBjb25zZWN1dGl2ZSBncm91cHMgb2Ygbm9uIHNwYWNlcy5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVXb3JkczogL1xcUysvZyxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAgICAgICAgICAgICAgICAgJ3RleHQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250U2l6ZTogICAgICAgICAgICAgNDAsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHdlaWdodCAoZS5nLiBib2xkLCBub3JtYWwsIDQwMCwgNjAwLCA4MDApXG4gICAgICogQHR5cGUgeyhOdW1iZXJ8U3RyaW5nKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRXZWlnaHQ6ICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgZmFtaWx5XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250RmFtaWx5OiAgICAgICAgICAgJ1RpbWVzIE5ldyBSb21hbicsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gdW5kZXJsaW5lLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuZGVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gb3ZlcmxpbmUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxpbmU6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIGxpbmV0aHJvdWdoLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmV0aHJvdWdoOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IFwibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCIsIFwianVzdGlmeVwiLFxuICAgICAqIFwianVzdGlmeS1sZWZ0XCIsIFwianVzdGlmeS1jZW50ZXJcIiBvciBcImp1c3RpZnktcmlnaHRcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRBbGlnbjogICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIC4gUG9zc2libGUgdmFsdWVzOiBcIlwiLCBcIm5vcm1hbFwiLCBcIml0YWxpY1wiIG9yIFwib2JsaXF1ZVwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFN0eWxlOiAgICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmVIZWlnaHQ6ICAgICAgICAgICAxLjE2LFxuXG4gICAgLyoqXG4gICAgICogU3VwZXJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdXBlcnNjcmlwdDoge1xuICAgICAgc2l6ZTogICAgICAwLjYwLCAvLyBmb250U2l6ZSBmYWN0b3JcbiAgICAgIGJhc2VsaW5lOiAtMC4zNSAgLy8gYmFzZWxpbmUtc2hpZnQgZmFjdG9yICh1cHdhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogIDAuMTEgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAoZG93bndhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIHRleHQgbGluZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6ICAnJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KGFkZGl0aW9uYWxQcm9wcyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoYWRkaXRpb25hbFByb3BzKSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvci5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInN0cm9rZVN0eWxlXCIgdW50aWwgdjEuMS42XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIG5hbWVkIFwidGV4dFNoYWRvd1wiIChTdHJpbmcpIHVudGlsIHYxLjIuMTFcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZvbnRTaXplRnJhY3Rpb246IDAuMjIyLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvZmZzZXRzOiB7XG4gICAgICB1bmRlcmxpbmU6IDAuMTAsXG4gICAgICBsaW5ldGhyb3VnaDogLTAuMzE1LFxuICAgICAgb3ZlcmxpbmU6IC0wLjg4XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgTGluZSBwcm9wb3J0aW9uIHRvIGZvbnQgU2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX2ZvbnRTaXplTXVsdDogICAgICAgICAgICAgMS4xMyxcblxuICAgIC8qKlxuICAgICAqIGFkZGl0aW9uYWwgc3BhY2UgYmV0d2VlbiBjaGFyYWN0ZXJzXG4gICAgICogZXhwcmVzc2VkIGluIHRob3VzYW5kcyBvZiBlbSB1bml0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjaGFyU3BhY2luZzogICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGNoYXJhY3RlciBzdHlsZXMgLSB0b3AtbGV2ZWwgcHJvcGVydGllcyAtPiBsaW5lIG51bWJlcnMsXG4gICAgICogMm5kLWxldmVsIHByb3BlcnRpZXMgLSBjaGFyYWN0ZXIgbnVtYmVyc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGEgY29udGV4dCB0byBtZWFzdXJlIHRleHQgY2hhciBvciBjb3VwbGUgb2YgY2hhcnNcbiAgICAgKiB0aGUgY2FjaGVDb250ZXh0IG9mIHRoZSBjYW52YXMgd2lsbCBiZSB1c2VkIG9yIGEgZnJlc2hseSBjcmVhdGVkIG9uZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBvbiBjYW52YXNcbiAgICAgKiBvbmNlIGNyZWF0ZWQgaXQgd2lsbCBiZSByZWZlcmVuY2VkIG9uIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCB0byBhdm9pZCBjcmVhdGluZyBhIGNhbnZhcyBmb3IgZXZlcnlcbiAgICAgKiB0ZXh0IG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfbWVhc3VyaW5nQ29udGV4dDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJhc2VsaW5lIHNoaWZ0LCBzdHlsZXMgb25seSwga2VlcCBhdCAwIGZvciB0aGUgbWFpbiB0ZXh0IG9iamVjdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkZWx0YVk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIGEgc3R5bGUgdW5pdCAob2YgJ3N0eWxlcycpLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9zdHlsZVByb3BlcnRpZXM6IFtcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICdmaWxsJyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICd1bmRlcmxpbmUnLFxuICAgICAgJ292ZXJsaW5lJyxcbiAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAnZGVsdGFZJyxcbiAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogY29udGFpbnMgY2hhcmFjdGVycyBib3VuZGluZyBib3hlc1xuICAgICAqL1xuICAgIF9fY2hhckJvdW5kczogW10sXG5cbiAgICAvKipcbiAgICAgKiB1c2UgdGhpcyBzaXplIHdoZW4gbWVhc3VyaW5nIHRleHQuIFRvIGF2b2lkIElFMTEgcm91bmRpbmcgZXJyb3JzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ0FDSEVfRk9OVF9TSVpFOiA0MDAsXG5cbiAgICAvKipcbiAgICAgKiBjb250YWlucyB0aGUgbWluIHRleHQgd2lkdGggdG8gYXZvaWQgZ2V0dGluZyAwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIE1JTl9URVhUX1dJRFRIOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0gb3B0aW9ucyA/IChvcHRpb25zLnN0eWxlcyB8fCB7IH0pIDogeyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5zZXR1cFN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0ZXh0IGhhcyBhIHBhdGgsIGl0IHdpbGwgYWRkIHRoZSBleHRyYSBpbmZvcm1hdGlvbiBuZWVkZWRcbiAgICAgKiBmb3IgcGF0aCBhbmQgdGV4dCBjYWxjdWxhdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldFBhdGhJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aC5zZWdtZW50c0luZm8gPSBmYWJyaWMudXRpbC5nZXRQYXRoU2VnbWVudHNJbmZvKHBhdGgucGF0aCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvbnRleHQgZm9yIG1lYXN1cmVtZW50IG9mIHRleHQgc3RyaW5nLlxuICAgICAqIGlmIGNyZWF0ZWQgaXQgZ2V0cyBzdG9yZWQgZm9yIHJldXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBnZXRNZWFzdXJpbmdDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgcmV0dXJuIHdlIGhhdmUgdG8gbWVhc3VyZSBzb21ldGhpbmcuXG4gICAgICBpZiAoIWZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCkge1xuICAgICAgICBmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQgPSB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jb250ZXh0Q2FjaGUgfHxcbiAgICAgICAgICBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGl2aWRlcyB0ZXh0IGludG8gbGluZXMgb2YgdGV4dCBhbmQgbGluZXMgb2YgZ3JhcGhlbWVzLlxuICAgICAqL1xuICAgIF9zcGxpdFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5ld0xpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMudGV4dCk7XG4gICAgICB0aGlzLnRleHRMaW5lcyA9IG5ld0xpbmVzLmxpbmVzO1xuICAgICAgdGhpcy5fdGV4dExpbmVzID0gbmV3TGluZXMuZ3JhcGhlbWVMaW5lcztcbiAgICAgIHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lcyA9IG5ld0xpbmVzLl91bndyYXBwZWRMaW5lcztcbiAgICAgIHRoaXMuX3RleHQgPSBuZXdMaW5lcy5ncmFwaGVtZVRleHQ7XG4gICAgICByZXR1cm4gbmV3TGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb3IgdXBkYXRlIHRleHQgZGltZW5zaW9ucy5cbiAgICAgKiBVcGRhdGVzIHRoaXMud2lkdGggYW5kIHRoaXMuaGVpZ2h0IHdpdGggdGhlIHByb3BlciB2YWx1ZXMuXG4gICAgICogRG9lcyBub3QgcmV0dXJuIGRpbWVuc2lvbnMuXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NwbGl0VGV4dCgpO1xuICAgICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5wYXRoLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMucGF0aC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FsY1RleHRXaWR0aCgpIHx8IHRoaXMuY3Vyc29yV2lkdGggfHwgdGhpcy5NSU5fVEVYVF9XSURUSDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbGNUZXh0SGVpZ2h0KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmxhcmdlIHNwYWNlIGJveGVzIGFuZCBzaGlmdCB0aGUgb3RoZXJzXG4gICAgICovXG4gICAgZW5sYXJnZVNwYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlmZlNwYWNlLCBjdXJyZW50TGluZVdpZHRoLCBudW1iZXJPZlNwYWNlcywgYWNjdW11bGF0ZWRTcGFjZSwgbGluZSwgY2hhckJvdW5kLCBzcGFjZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRBbGlnbiAhPT0gJ2p1c3RpZnknICYmIChpID09PSBsZW4gLSAxIHx8IHRoaXMuaXNFbmRPZldyYXBwaW5nKGkpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtdWxhdGVkU3BhY2UgPSAwO1xuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoIDwgdGhpcy53aWR0aCAmJiAoc3BhY2VzID0gdGhpcy50ZXh0TGluZXNbaV0ubWF0Y2godGhpcy5fcmVTcGFjZXNBbmRUYWJzKSkpIHtcbiAgICAgICAgICBudW1iZXJPZlNwYWNlcyA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgZGlmZlNwYWNlID0gKHRoaXMud2lkdGggLSBjdXJyZW50TGluZVdpZHRoKSAvIG51bWJlck9mU3BhY2VzO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPD0gamxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGFyQm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtqXSkpIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLndpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmtlcm5lZFdpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSB0ZXh0IGxpbmUgaXMgZW5kZWQgd2l0aCBhbiBoYXJkIGJyZWFrXG4gICAgICogdGV4dCBhbmQgaXRleHQgZG8gbm90IGhhdmUgd3JhcHBpbmcsIHJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbmRPZldyYXBwaW5nOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiBsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYSBsaW5lIGhhcyBhIGxpbmVicmVhayBhbmQgc28gd2UgbmVlZCB0byBhY2NvdW50IGZvciBpdCB3aGVuIG1vdmluZ1xuICAgICAqIGFuZCBjb3VudGluZyBzdHlsZS5cbiAgICAgKiBJdCByZXR1cm4gYWx3YXlzIGZvciB0ZXh0IGFuZCBJdGV4dC5cbiAgICAgKiBAcmV0dXJuIE51bWJlclxuICAgICAqL1xuICAgIG1pc3NpbmdOZXdsaW5lT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRleHQgb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5UZXh0ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRleHRcIjogXCInICsgdGhpcy50ZXh0ICsgJ1wiLCBcImZvbnRGYW1pbHlcIjogXCInICsgdGhpcy5mb250RmFtaWx5ICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnggd2lkdGggb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueSBoZWlnaHQgb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2dldENhY2hlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgICAgZGltcy53aWR0aCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVg7XG4gICAgICBkaW1zLmhlaWdodCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVk7XG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICd1bmRlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ292ZXJsaW5lJyk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICdsaW5ldGhyb3VnaCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZvbnQgcGFyYW1ldGVyIG9mIHRoZSBjb250ZXh0IHdpdGggdGhlIG9iamVjdCBwcm9wZXJ0aWVzIG9yIHdpdGggY2hhclN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjaGFyU3R5bGVdIG9iamVjdCB3aXRoIGZvbnQgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRGYW1pbHldIEZvbnQgRmFtaWx5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjaGFyU3R5bGUuZm9udFNpemVdIEZvbnQgc2l6ZSBpbiBwaXhlbHMuICggd2l0aG91dCBweCBzdWZmaXggKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRXZWlnaHRdIEZvbnQgd2VpZ2h0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFN0eWxlXSBGb250IHN0eWxlIChpdGFsaWN8bm9ybWFsKVxuICAgICAqL1xuICAgIF9zZXRUZXh0U3R5bGVzOiBmdW5jdGlvbihjdHgsIGNoYXJTdHlsZSwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oY2hhclN0eWxlLCBmb3JNZWFzdXJpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgdGV4dCBXaWR0aCBtZWFzdXJpbmcgZWFjaCBsaW5lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTWF4aW11bSB3aWR0aCBvZiBmYWJyaWMuVGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjVGV4dFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKDApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIFRleHQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lIGluIGEgdGV4dFxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZTogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJDaGFycyhtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB0ZXh0IGJhY2tncm91bmQgZm9yIGxpbmVzLCB0YWtpbmcgY2FyZSBvZiBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yICYmICF0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhlaWdodE9mTGluZSxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCwgb3JpZ2luYWxGaWxsID0gY3R4LmZpbGxTdHlsZSxcbiAgICAgICAgICBsaW5lLCBsYXN0Q29sb3IsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICBsaW5lVG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgYm94U3RhcnQgPSAwLCBib3hXaWR0aCA9IDAsIGNoYXJCb3gsIGN1cnJlbnRDb2xvciwgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InLCBpKSkge1xuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgYm94U3RhcnQgPSAwO1xuICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudENvbG9yO1xuICAgICAgICAgICAgY3VycmVudENvbG9yICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgLWNoYXJCb3gud2lkdGggLyAyLFxuICAgICAgICAgICAgICAtaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSxcbiAgICAgICAgICAgICAgY2hhckJveC53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY3VycmVudENvbG9yICE9PSBsYXN0Q29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0Q29sb3I7XG4gICAgICAgICAgICBsYXN0Q29sb3IgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgICAgbGluZVRvcE9mZnNldCxcbiAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgICAgbGFzdENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3IgJiYgIXBhdGgpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudENvbG9yO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgbGluZVRvcE9mZnNldCxcbiAgICAgICAgICAgIGJveFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcmlnaW5hbEZpbGw7XG4gICAgICAvLyBpZiB0aGVyZSBpcyB0ZXh0IGJhY2tncm91bmQgY29sb3Igbm9cbiAgICAgIC8vIG90aGVyIHNoYWRvd3Mgc2hvdWxkIGJlIGNhc3RlZFxuICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY2wgc3R5bGUgZGVjbGFyYXRpb24gZm9yIGNhY2hlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udEZhbWlseSBmb250RmFtaWx5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udFN0eWxlIGZvbnRTdHlsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRXZWlnaHQgZm9udFdlaWdodFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcmVmZXJlbmNlIHRvIGNhY2hlXG4gICAgICovXG4gICAgZ2V0Rm9udENhY2hlOiBmdW5jdGlvbihkZWNsKSB7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IGRlY2wuZm9udEZhbWlseS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0gPSB7IH07XG4gICAgICB9XG4gICAgICB2YXIgY2FjaGUgPSBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldLFxuICAgICAgICAgIGNhY2hlUHJvcCA9IGRlY2wuZm9udFN0eWxlLnRvTG93ZXJDYXNlKCkgKyAnXycgKyAoZGVjbC5mb250V2VpZ2h0ICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWNhY2hlW2NhY2hlUHJvcF0pIHtcbiAgICAgICAgY2FjaGVbY2FjaGVQcm9wXSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZVtjYWNoZVByb3BdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGFuZCByZXR1cm4gdGhlIHdpZHRoIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAgICAgKiBwb3NzaWJseSBvdmVycmlkZGVuIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBtZWFzdXJlIGxvZ2ljIG9yXG4gICAgICogdG8gaG9vayBzb21lIGV4dGVybmFsIGxpYiBmb3IgY2hhcmFjdGVyIG1lYXN1cmVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXIsIGNoYXIgdG8gYmUgbWVhc3VyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhclN0eWxlIHN0eWxlIG9mIGNoYXIgdG8gYmUgbWVhc3VyZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZXZpb3VzQ2hhcl0gcHJldmlvdXMgY2hhclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJldkNoYXJTdHlsZV0gc3R5bGUgb2YgcHJldmlvdXMgY2hhclxuICAgICAqL1xuICAgIF9tZWFzdXJlQ2hhcjogZnVuY3Rpb24oX2NoYXIsIGNoYXJTdHlsZSwgcHJldmlvdXNDaGFyLCBwcmV2Q2hhclN0eWxlKSB7XG4gICAgICAvLyBmaXJzdCBpIHRyeSB0byByZXR1cm4gZnJvbSBjYWNoZVxuICAgICAgdmFyIGZvbnRDYWNoZSA9IHRoaXMuZ2V0Rm9udENhY2hlKGNoYXJTdHlsZSksIGZvbnREZWNsYXJhdGlvbiA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihjaGFyU3R5bGUpLFxuICAgICAgICAgIHByZXZpb3VzRm9udERlY2xhcmF0aW9uID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKHByZXZDaGFyU3R5bGUpLCBjb3VwbGUgPSBwcmV2aW91c0NoYXIgKyBfY2hhcixcbiAgICAgICAgICBzdHlsZXNBcmVFcXVhbCA9IGZvbnREZWNsYXJhdGlvbiA9PT0gcHJldmlvdXNGb250RGVjbGFyYXRpb24sIHdpZHRoLCBjb3VwbGVXaWR0aCwgcHJldmlvdXNXaWR0aCxcbiAgICAgICAgICBmb250TXVsdGlwbGllciA9IGNoYXJTdHlsZS5mb250U2l6ZSAvIHRoaXMuQ0FDSEVfRk9OVF9TSVpFLCBrZXJuZWRXaWR0aDtcblxuICAgICAgaWYgKHByZXZpb3VzQ2hhciAmJiBmb250Q2FjaGVbcHJldmlvdXNDaGFyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZXZpb3VzV2lkdGggPSBmb250Q2FjaGVbcHJldmlvdXNDaGFyXTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250Q2FjaGVbX2NoYXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVkV2lkdGggPSB3aWR0aCA9IGZvbnRDYWNoZVtfY2hhcl07XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVzQXJlRXF1YWwgJiYgZm9udENhY2hlW2NvdXBsZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb3VwbGVXaWR0aCA9IGZvbnRDYWNoZVtjb3VwbGVdO1xuICAgICAgICBrZXJuZWRXaWR0aCA9IGNvdXBsZVdpZHRoIC0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHByZXZpb3VzV2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb3VwbGVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdldE1lYXN1cmluZ0NvbnRleHQoKTtcbiAgICAgICAgLy8gc2VuZCBhIFRSVUUgdG8gc3BlY2lmeSBtZWFzdXJpbmcgZm9udCBzaXplIENBQ0hFX0ZPTlRfU0laRVxuICAgICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCwgY2hhclN0eWxlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gd2lkdGggPSBjdHgubWVhc3VyZVRleHQoX2NoYXIpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbX2NoYXJdID0gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAocHJldmlvdXNXaWR0aCA9PT0gdW5kZWZpbmVkICYmIHN0eWxlc0FyZUVxdWFsICYmIHByZXZpb3VzQ2hhcikge1xuICAgICAgICBwcmV2aW91c1dpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHByZXZpb3VzQ2hhcikud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdID0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXNBcmVFcXVhbCAmJiBjb3VwbGVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHdlIGNhbiBtZWFzdXJlIHRoZSBrZXJuaW5nIGNvdXBsZSBhbmQgc3VidHJhY3QgdGhlIHdpZHRoIG9mIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgY291cGxlV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY291cGxlKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW2NvdXBsZV0gPSBjb3VwbGVXaWR0aDtcbiAgICAgICAga2VybmVkV2lkdGggPSBjb3VwbGVXaWR0aCAtIHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB3aWR0aDogd2lkdGggKiBmb250TXVsdGlwbGllciwga2VybmVkV2lkdGg6IGtlcm5lZFdpZHRoICogZm9udE11bHRpcGxpZXIgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgaGVpZ2h0IG9mIGNoYXJhY3RlciBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lIHRoZSBsaW5lIGluZGV4IG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBfY2hhciB0aGUgY2hhcmFjdGVyIGluZGV4IG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gZm9udFNpemUgb2YgdGhlIGNoYXJhY3RlclxuICAgICAqL1xuICAgIGdldEhlaWdodE9mQ2hhcjogZnVuY3Rpb24obGluZSwgX2NoYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmUsIF9jaGFyLCAnZm9udFNpemUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWVhc3VyZSBhIHRleHQgbGluZSBtZWFzdXJpbmcgYWxsIGNoYXJhY3RlcnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBsaW5lIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSB3aWR0aFxuICAgICAqL1xuICAgIG1lYXN1cmVMaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lSW5mbyA9IHRoaXMuX21lYXN1cmVMaW5lKGxpbmVJbmRleCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICBsaW5lSW5mby53aWR0aCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSW5mby53aWR0aCA8IDApIHtcbiAgICAgICAgbGluZUluZm8ud2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGV2ZXJ5IGdyYXBoZW1lIG9mIGEgbGluZSwgcG9wdWxhdGluZyBfX2NoYXJCb3VuZHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGggdG90YWwgd2lkdGggb2YgY2hhcmFjdGVyc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoT2ZTcGFjZXMgbGVuZ3RoIG9mIGNoYXJzIHRoYXQgbWF0Y2ggdGhpcy5fcmVTcGFjZXNBbmRUYWJzXG4gICAgICovXG4gICAgX21lYXN1cmVMaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciB3aWR0aCA9IDAsIGksIGdyYXBoZW1lLCBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sIHByZXZHcmFwaGVtZSxcbiAgICAgICAgICBncmFwaGVtZUluZm8sIG51bU9mU3BhY2VzID0gMCwgbGluZUJvdW5kcyA9IG5ldyBBcnJheShsaW5lLmxlbmd0aCksXG4gICAgICAgICAgcG9zaXRpb25JblBhdGggPSAwLCBzdGFydGluZ1BvaW50LCB0b3RhbFBhdGhMZW5ndGgsIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF0gPSBsaW5lQm91bmRzO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgc3RhcnRpbmdQb2ludCA9IGZhYnJpYy51dGlsLmdldFBvaW50T25QYXRoKHBhdGgucGF0aCwgMCwgcGF0aC5zZWdtZW50c0luZm8pO1xuICAgICAgICB0b3RhbFBhdGhMZW5ndGggPSBwYXRoLnNlZ21lbnRzSW5mb1twYXRoLnNlZ21lbnRzSW5mby5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgIHN0YXJ0aW5nUG9pbnQueCArPSBwYXRoLnBhdGhPZmZzZXQueDtcbiAgICAgICAgc3RhcnRpbmdQb2ludC55ICs9IHBhdGgucGF0aE9mZnNldC55O1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JhcGhlbWUgPSBsaW5lW2ldO1xuICAgICAgICBncmFwaGVtZUluZm8gPSB0aGlzLl9nZXRHcmFwaGVtZUJveChncmFwaGVtZSwgbGluZUluZGV4LCBpLCBwcmV2R3JhcGhlbWUpO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIGlmIChwb3NpdGlvbkluUGF0aCA+IHRvdGFsUGF0aExlbmd0aCkge1xuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggJT0gdG90YWxQYXRoTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpdCB3b3VsZCBwcm9iYWJseSBtdWNoIGZhdGVyIHRvIHNlbmQgYWxsIHRoZSBncmFwaGVtZSBwb3NpdGlvbiBmb3IgYSBsaW5lXG4gICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSBwYXRoIHBvc2l0aW9uL2FuZ2xlIGF0IG9uY2UuXG4gICAgICAgICAgdGhpcy5fc2V0R3JhcGhlbWVPblBhdGgocG9zaXRpb25JblBhdGgsIGdyYXBoZW1lSW5mbywgc3RhcnRpbmdQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZUJvdW5kc1tpXSA9IGdyYXBoZW1lSW5mbztcbiAgICAgICAgd2lkdGggKz0gZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoO1xuICAgICAgICBwb3NpdGlvbkluUGF0aCArPSBncmFwaGVtZUluZm8ua2VybmVkV2lkdGg7XG4gICAgICAgIHByZXZHcmFwaGVtZSA9IGdyYXBoZW1lO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBsYXRlc3QgYm91bmQgYm94IHJlcHJlc2VudCB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGxpbmVcbiAgICAgIC8vIHRvIHNpbXBsaWZ5IGN1cnNvciBoYW5kbGluZyBpbiBpbnRlcmFjdGl2ZSBtb2RlLlxuICAgICAgbGluZUJvdW5kc1tpXSA9IHtcbiAgICAgICAgbGVmdDogZ3JhcGhlbWVJbmZvID8gZ3JhcGhlbWVJbmZvLmxlZnQgKyBncmFwaGVtZUluZm8ud2lkdGggOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAga2VybmVkV2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogdGhpcy5mb250U2l6ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgbnVtT2ZTcGFjZXM6IG51bU9mU3BhY2VzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgYW5nbGUgIGFuZCB0aGUgbGVmdCx0b3AgcG9zaXRpb24gb2YgdGhlIGNoYXIgdGhhdCBmb2xsb3cgYSBwYXRoLlxuICAgICAqIEl0IGFwcGVuZHMgaXQgdG8gZ3JhcGhlbWVJbmZvIHRvIGJlIHJldXNlZCBsYXRlciBhdCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbkluUGF0aCB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGVtZUluZm8gY3VycmVudCBncmFwaGVtZSBib3ggaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRpbmdQb2ludCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBfc2V0R3JhcGhlbWVPblBhdGg6IGZ1bmN0aW9uKHBvc2l0aW9uSW5QYXRoLCBncmFwaGVtZUluZm8sIHN0YXJ0aW5nUG9pbnQpIHtcbiAgICAgIHZhciBjZW50ZXJQb3NpdGlvbiA9IHBvc2l0aW9uSW5QYXRoICsgZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoIC8gMixcbiAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgICAvLyB3ZSBhcmUgYXQgY3VycmVudFBvc2l0aW9uT25QYXRoLiB3ZSB3YW50IHRvIGtub3cgd2hhdCBwb2ludCBvbiB0aGUgcGF0aCBpcy5cbiAgICAgIHZhciBpbmZvID0gZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGgocGF0aC5wYXRoLCBjZW50ZXJQb3NpdGlvbiwgcGF0aC5zZWdtZW50c0luZm8pO1xuICAgICAgZ3JhcGhlbWVJbmZvLnJlbmRlckxlZnQgPSBpbmZvLnggLSBzdGFydGluZ1BvaW50Lng7XG4gICAgICBncmFwaGVtZUluZm8ucmVuZGVyVG9wID0gaW5mby55IC0gc3RhcnRpbmdQb2ludC55O1xuICAgICAgZ3JhcGhlbWVJbmZvLmFuZ2xlID0gaW5mby5hbmdsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhbmQgcmV0dXJuIHRoZSBpbmZvIG9mIGEgc2luZ2xlIGdyYXBoZW1lLlxuICAgICAqIG5lZWRzIHRoZSB0aGUgaW5mbyBvZiBwcmV2aW91cyBncmFwaGVtZXMgYWxyZWFkeSBmaWxsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncmFwaGVtZSB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggaW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXIgaXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHBvc2l0aW9uIGluIHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2R3JhcGhlbWVdIGNoYXJhY3RlciBwcmVjZWRpbmcgdGhlIG9uZSB0byBiZSBtZWFzdXJlZFxuICAgICAqL1xuICAgIF9nZXRHcmFwaGVtZUJveDogZnVuY3Rpb24oZ3JhcGhlbWUsIGxpbmVJbmRleCwgY2hhckluZGV4LCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgcHJldlN0eWxlID0gcHJldkdyYXBoZW1lID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXggLSAxKSA6IHsgfSxcbiAgICAgICAgICBpbmZvID0gdGhpcy5fbWVhc3VyZUNoYXIoZ3JhcGhlbWUsIHN0eWxlLCBwcmV2R3JhcGhlbWUsIHByZXZTdHlsZSksXG4gICAgICAgICAga2VybmVkV2lkdGggPSBpbmZvLmtlcm5lZFdpZHRoLFxuICAgICAgICAgIHdpZHRoID0gaW5mby53aWR0aCwgY2hhclNwYWNpbmc7XG5cbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgIHdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgICBrZXJuZWRXaWR0aCArPSBjaGFyU3BhY2luZztcbiAgICAgIH1cblxuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmZvbnRTaXplLFxuICAgICAgICBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGgsXG4gICAgICAgIGRlbHRhWTogc3R5bGUuZGVsdGFZLFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFySW5kZXggPiAwICYmICFza2lwTGVmdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleCAtIDFdO1xuICAgICAgICBib3gubGVmdCA9IHByZXZpb3VzQm94LmxlZnQgKyBwcmV2aW91c0JveC53aWR0aCArIGluZm8ua2VybmVkV2lkdGggLSBpbmZvLndpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBvZiBsaW5lIGF0ICdsaW5lSW5kZXgnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiBsaW5lIHRvIGNhbGN1bGF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICAvLyBjaGFyIDAgaXMgbWVhc3VyZWQgYmVmb3JlIHRoZSBsaW5lIGN5Y2xlIGJlY2F1c2UgaXQgbm5lZHMgdG8gY2hhclxuICAgICAgICAgIC8vIGVtcHR5bGluZXNcbiAgICAgICAgICBtYXhIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIDApO1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGxpbmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5nZXRIZWlnaHRPZkNoYXIobGluZUluZGV4LCBpKSwgbWF4SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdID0gbWF4SGVpZ2h0ICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGV4dCBib3ggaGVpZ2h0XG4gICAgICovXG4gICAgY2FsY1RleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVIZWlnaHQsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaGVpZ2h0ICs9IChpID09PSBsZW4gLSAxID8gbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodCA6IGxpbmVIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExlZnQgb2Zmc2V0XG4gICAgICovXG4gICAgX2dldExlZnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLndpZHRoIC8gMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRvcCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0VG9wT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtdGhpcy5oZWlnaHQgLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICovXG4gICAgX3JlbmRlclRleHRDb21tb246IGZ1bmN0aW9uKGN0eCwgbWV0aG9kKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHRzID0gMCwgbGVmdCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSwgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSxcbiAgICAgICAgICAgIG1heEhlaWdodCA9IGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmUoXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICB0aGlzLl90ZXh0TGluZXNbaV0sXG4gICAgICAgICAgbGVmdCArIGxlZnRPZmZzZXQsXG4gICAgICAgICAgdG9wICsgbGluZUhlaWdodHMgKyBtYXhIZWlnaHQsXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICBsaW5lSGVpZ2h0cyArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dEZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmZpbGwgJiYgIXRoaXMuc3R5bGVIYXMoJ2ZpbGwnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnZmlsbFRleHQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dENvbW1vbihjdHgsICdzdHJva2VUZXh0Jyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgZmlsbFRleHQgb3Igc3Ryb2tlVGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBDb250ZW50IG9mIHRoZSBsaW5lLCBzcGxpdHRlZCBpbiBhbiBhcnJheSBieSBncmFwaGVtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCkge1xuICAgICAgLy8gc2V0IHByb3BlciBsaW5lIG9mZnNldFxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgYWN0dWFsU3R5bGUsXG4gICAgICAgICAgbmV4dFN0eWxlLFxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJyxcbiAgICAgICAgICBjaGFyQm94LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICB0aW1lVG9SZW5kZXIsXG4gICAgICAgICAgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICBzaG9ydEN1dCA9ICFpc0p1c3RpZnkgJiYgdGhpcy5jaGFyU3BhY2luZyA9PT0gMCAmJiB0aGlzLmlzRW1wdHlTdHlsZXMobGluZUluZGV4KSAmJiAhcGF0aDtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRvcCAtPSBsaW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVGcmFjdGlvbiAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgIGlmIChzaG9ydEN1dCkge1xuICAgICAgICAvLyByZW5kZXIgYWxsIHRoZSBsaW5lIGluIG9uZSBwYXNzIHdpdGhvdXQgY2hlY2tpbmdcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCAwLCBsaW5lLmpvaW4oJycpLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nIHx8IHBhdGg7XG4gICAgICAgIGNoYXJzVG9SZW5kZXIgKz0gbGluZVtpXTtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1baV07XG4gICAgICAgIGlmIChib3hXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIGxlZnQgKz0gY2hhckJveC5rZXJuZWRXaWR0aCAtIGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0p1c3RpZnkgJiYgIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtpXSkpIHtcbiAgICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBjaGFyU3BhY2luZywgd2UgcmVuZGVyIGNoYXIgYnkgY2hhclxuICAgICAgICAgIGFjdHVhbFN0eWxlID0gYWN0dWFsU3R5bGUgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKTtcbiAgICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkgKyAxKTtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0aGlzLl9oYXNTdHlsZUNoYW5nZWQoYWN0dWFsU3R5bGUsIG5leHRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIC1ib3hXaWR0aCAvIDIsIDAsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIGxlZnQsIHRvcCwgbGluZUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJztcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IG5leHRTdHlsZTtcbiAgICAgICAgICBsZWZ0ICs9IGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cnkgdG8gcGF0Y2ggdGhlIG1pc3NpbmcgZ3JhZGllbnRUcmFuc2Zvcm0gb24gY2FudmFzIGdyYWRpZW50cy5cbiAgICAgKiB0cmFuc2Zvcm1pbmcgYSBjb250ZXh0IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQsIGlzIGdvaW5nIHRvIHRyYW5zZm9ybSB0aGUgc3Ryb2tlIHRvby5cbiAgICAgKiB3ZSB3YW50IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQgYnV0IG5vdCB0aGUgc3Ryb2tlIG9wZXJhdGlvbiwgc28gd2UgY3JlYXRlXG4gICAgICogYSB0cmFuc2Zvcm1lZCBncmFkaWVudCBvbiBhIHBhdHRlcm4gYW5kIHRoZW4gd2UgdXNlIHRoZSBwYXR0ZXJuIGluc3RlYWQgb2YgdGhlIGdyYWRpZW50LlxuICAgICAqIHRoaXMgbWV0aG9kIGhhcyBkcmF3YmFja3M6IGlzIHNsb3csIGlzIGluIGxvdyByZXNvbHV0aW9uLCBuZWVkcyBhIHBhdGNoIGZvciB3aGVuIHRoZSBzaXplXG4gICAgICogaXMgbGltaXRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLkdyYWRpZW50fSBmaWxsZXIgYSBmYWJyaWMgZ3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufSBhIHBhdHRlcm4gdG8gdXNlIGFzIGZpbGwvc3Ryb2tlIHN0eWxlXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtVGV4dDogZnVuY3Rpb24oZmlsbGVyKSB7XG4gICAgICB2YXIgcENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSwgcEN0eCxcbiAgICAgICAgICAvLyBUT0RPOiB2ZXJpZnkgY29tcGF0aWJpbGl0eSB3aXRoIHN0cm9rZVVuaWZvcm1cbiAgICAgICAgICB3aWR0aCA9IHRoaXMud2lkdGggKyB0aGlzLnN0cm9rZVdpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCArIHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICBwQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBwQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHBDdHggPSBwQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBwQ3R4LmJlZ2luUGF0aCgpOyBwQ3R4Lm1vdmVUbygwLCAwKTsgcEN0eC5saW5lVG8od2lkdGgsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHBDdHgubGluZVRvKDAsIGhlaWdodCk7IHBDdHguY2xvc2VQYXRoKCk7XG4gICAgICBwQ3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgcEN0eC5maWxsU3R5bGUgPSBmaWxsZXIudG9MaXZlKHBDdHgpO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0ocEN0eCwgZmlsbGVyKTtcbiAgICAgIHBDdHguZmlsbCgpO1xuICAgICAgcmV0dXJuIHBDdHguY3JlYXRlUGF0dGVybihwQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgfSxcblxuICAgIGhhbmRsZUZpbGxlcjogZnVuY3Rpb24oY3R4LCBwcm9wZXJ0eSwgZmlsbGVyKSB7XG4gICAgICB2YXIgb2Zmc2V0WCwgb2Zmc2V0WTtcbiAgICAgIGlmIChmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIGlmIChmaWxsZXIuZ3JhZGllbnRVbml0cyA9PT0gJ3BlcmNlbnRhZ2UnIHx8IGZpbGxlci5ncmFkaWVudFRyYXNuZm9ybSB8fCBmaWxsZXIucGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICAgIC8vIG5lZWQgdG8gdHJhbnNmb3JtIGdyYWRpZW50IGluIGEgcGF0dGVybi5cbiAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdyBwcm9jZXNzLiBJZiB5b3UgYXJlIGhpdHRpbmcgdGhpcyBjb2RlcGF0aCwgYW5kIHRoZSBvYmplY3RcbiAgICAgICAgICAvLyBpcyBub3QgdXNpbmcgY2FjaGluZywgeW91IHNob3VsZCBjb25zaWRlciBzd2l0Y2hpbmcgaXQgb24uXG4gICAgICAgICAgLy8gd2UgbmVlZCBhIGNhbnZhcyBhcyBiaWcgYXMgdGhlIGN1cnJlbnQgb2JqZWN0IGNhY2hpbmcgY2FudmFzLlxuICAgICAgICAgIG9mZnNldFggPSAtdGhpcy53aWR0aCAvIDI7XG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDI7XG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICBjdHhbcHJvcGVydHldID0gdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0KGZpbGxlcik7XG4gICAgICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogb2Zmc2V0WCwgb2Zmc2V0WTogb2Zmc2V0WSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGlzIGEgc2ltcGxlIGdyYWRpZW50IG9yIHBhdHRlcm5cbiAgICAgICAgICBjdHhbcHJvcGVydHldID0gZmlsbGVyLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIGZpbGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpcyBhIGNvbG9yXG4gICAgICAgIGN0eFtwcm9wZXJ0eV0gPSBmaWxsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgfSxcblxuICAgIF9zZXRTdHJva2VTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICBjdHgubGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcDtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlRGFzaE9mZnNldDtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUZpbGxlcihjdHgsICdzdHJva2VTdHlsZScsIGRlY2wuc3Ryb2tlKTtcbiAgICB9LFxuXG4gICAgX3NldEZpbGxTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRmlsbGVyKGN0eCwgJ2ZpbGxTdHlsZScsIGRlY2wuZmlsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUhlaWdodCBIZWlnaHQgb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcjogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgY2hhckluZGV4LCBfY2hhciwgbGVmdCwgdG9wKSB7XG4gICAgICB2YXIgZGVjbCA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIGZ1bGxEZWNsID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIHNob3VsZEZpbGwgPSBtZXRob2QgPT09ICdmaWxsVGV4dCcgJiYgZnVsbERlY2wuZmlsbCxcbiAgICAgICAgICBzaG91bGRTdHJva2UgPSBtZXRob2QgPT09ICdzdHJva2VUZXh0JyAmJiBmdWxsRGVjbC5zdHJva2UgJiYgZnVsbERlY2wuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbE9mZnNldHMsIHN0cm9rZU9mZnNldHM7XG5cbiAgICAgIGlmICghc2hvdWxkU3Ryb2tlICYmICFzaG91bGRGaWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIHNob3VsZEZpbGwgJiYgKGZpbGxPZmZzZXRzID0gdGhpcy5fc2V0RmlsbFN0eWxlcyhjdHgsIGZ1bGxEZWNsKSk7XG4gICAgICBzaG91bGRTdHJva2UgJiYgKHN0cm9rZU9mZnNldHMgPSB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCBmdWxsRGVjbCkpO1xuXG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihmdWxsRGVjbCk7XG5cblxuICAgICAgaWYgKGRlY2wgJiYgZGVjbC50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlY2wgJiYgZGVjbC5kZWx0YVkpIHtcbiAgICAgICAgdG9wICs9IGRlY2wuZGVsdGFZO1xuICAgICAgfVxuICAgICAgc2hvdWxkRmlsbCAmJiBjdHguZmlsbFRleHQoX2NoYXIsIGxlZnQgLSBmaWxsT2Zmc2V0cy5vZmZzZXRYLCB0b3AgLSBmaWxsT2Zmc2V0cy5vZmZzZXRZKTtcbiAgICAgIHNob3VsZFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dChfY2hhciwgbGVmdCAtIHN0cm9rZU9mZnNldHMub2Zmc2V0WCwgdG9wIC0gc3Ryb2tlT2Zmc2V0cy5vZmZzZXRZKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIHRoZSBjaGFyYWN0ZXIgaW50byBhICdzdXBlcmlvciBmaWd1cmUnIChpLmUuICdzdXBlcnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdXBlcnNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFNjcmlwdChzdGFydCwgZW5kLCB0aGlzLnN1cGVyc2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGFuICdpbmZlcmlvciBmaWd1cmUnIChpLmUuICdzdWJzY3JpcHQnKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBzZWxlY3Rpb24gc3RhcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIHNlbGVjdGlvbiBlbmRcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3Vic2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3Vic2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyAnc2NoZW1hJyBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2hlbWFcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3NldFNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgc2NoZW1hKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2ZvbnRTaXplJyksXG4gICAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgsICdkZWx0YVknKSxcbiAgICAgICAgICBzdHlsZSA9IHsgZm9udFNpemU6IGZvbnRTaXplICogc2NoZW1hLnNpemUsIGRlbHRhWTogZHkgKyBmb250U2l6ZSAqIHNjaGVtYS5iYXNlbGluZSB9O1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdHlsZXMoc3R5bGUsIHN0YXJ0LCBlbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGVcbiAgICAgKi9cbiAgICBfaGFzU3R5bGVDaGFuZ2VkOiBmdW5jdGlvbihwcmV2U3R5bGUsIHRoaXNTdHlsZSkge1xuICAgICAgcmV0dXJuIHByZXZTdHlsZS5maWxsICE9PSB0aGlzU3R5bGUuZmlsbCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuc3Ryb2tlICE9PSB0aGlzU3R5bGUuc3Ryb2tlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2VXaWR0aCAhPT0gdGhpc1N0eWxlLnN0cm9rZVdpZHRoIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250U2l6ZSAhPT0gdGhpc1N0eWxlLmZvbnRTaXplIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250RmFtaWx5ICE9PSB0aGlzU3R5bGUuZm9udEZhbWlseSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFdlaWdodCAhPT0gdGhpc1N0eWxlLmZvbnRXZWlnaHQgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTdHlsZSAhPT0gdGhpc1N0eWxlLmZvbnRTdHlsZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZGVsdGFZICE9PSB0aGlzU3R5bGUuZGVsdGFZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc1N0eWxlXG4gICAgICovXG4gICAgX2hhc1N0eWxlQ2hhbmdlZEZvclN2ZzogZnVuY3Rpb24ocHJldlN0eWxlLCB0aGlzU3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNTdHlsZUNoYW5nZWQocHJldlN0eWxlLCB0aGlzU3R5bGUpIHx8XG4gICAgICAgIHByZXZTdHlsZS5vdmVybGluZSAhPT0gdGhpc1N0eWxlLm92ZXJsaW5lIHx8XG4gICAgICAgIHByZXZTdHlsZS51bmRlcmxpbmUgIT09IHRoaXNTdHlsZS51bmRlcmxpbmUgfHxcbiAgICAgICAgcHJldlN0eWxlLmxpbmV0aHJvdWdoICE9PSB0aGlzU3R5bGUubGluZXRocm91Z2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCB0ZXh0IGxpbmVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgbGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGluZUxlZnRPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGxpbmVJbmRleCk7XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53aWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduID09PSAnanVzdGlmeS1jZW50ZXInICYmIHRoaXMuaXNFbmRPZldyYXBwaW5nKGxpbmVJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LXJpZ2h0JyAmJiB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoIC0gbGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHMgPSBbXTtcbiAgICAgIHRoaXMuX19saW5lSGVpZ2h0cyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYXJCb3VuZHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9mb3JjZUNsZWFyQ2FjaGU7XG4gICAgICBzaG91bGRDbGVhciB8fCAoc2hvdWxkQ2xlYXIgPSB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJykpO1xuICAgICAgaWYgKHNob3VsZENsZWFyKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRDbGVhcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhIHNpbmdsZSBsaW5lIGdpdmVuIGl0cyBpbmRleC4gVXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWxcbiAgICAgKiB0ZXh0IGJvdW5kaW5nIGJveC4gVGhlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBhbmQgc3RvcmVkIGluIF9fbGluZVdpZHRocyBjYWNoZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBnZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCwgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLCBsaW5lSW5mbztcblxuICAgICAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIHdpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsaW5lSW5mbyA9IHRoaXMubWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgICAgd2lkdGggPSBsaW5lSW5mby53aWR0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0gPSB3aWR0aDtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgX2dldFdpZHRoT2ZDaGFyU3BhY2luZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250U2l6ZSAqIHRoaXMuY2hhclNwYWNpbmcgLyAxMDAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYXQgZ2l2ZW4gY2hhcmFjdGVyIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0aGUgbGluZSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHRoZSBjaGFyYWN0ZXIgbnVtYmVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mICdwcm9wZXJ0eSdcbiAgICAgKi9cbiAgICBnZXRWYWx1ZU9mUHJvcGVydHlBdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgY2hhclN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgICBpZiAoY2hhclN0eWxlICYmIHR5cGVvZiBjaGFyU3R5bGVbcHJvcGVydHldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gY2hhclN0eWxlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHREZWNvcmF0aW9uOiBmdW5jdGlvbihjdHgsIHR5cGUpIHtcbiAgICAgIGlmICghdGhpc1t0eXBlXSAmJiAhdGhpcy5zdHlsZUhhcyh0eXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGVpZ2h0T2ZMaW5lLCBzaXplLCBfc2l6ZSxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCwgZHksIF9keSxcbiAgICAgICAgICBsaW5lLCBsYXN0RGVjb3JhdGlvbixcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIHRvcE9mZnNldCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLCB0b3AsXG4gICAgICAgICAgYm94U3RhcnQsIGJveFdpZHRoLCBjaGFyQm94LCBjdXJyZW50RGVjb3JhdGlvbixcbiAgICAgICAgICBtYXhIZWlnaHQsIGN1cnJlbnRGaWxsLCBsYXN0RmlsbCwgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBpZiAoIXRoaXNbdHlwZV0gJiYgIXRoaXMuc3R5bGVIYXModHlwZSwgaSkpIHtcbiAgICAgICAgICB0b3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIG1heEhlaWdodCA9IGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgYm94U3RhcnQgPSAwO1xuICAgICAgICBib3hXaWR0aCA9IDA7XG4gICAgICAgIGxhc3REZWNvcmF0aW9uID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCB0eXBlKTtcbiAgICAgICAgbGFzdEZpbGwgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICdmaWxsJyk7XG4gICAgICAgIHRvcCA9IHRvcE9mZnNldCArIG1heEhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG4gICAgICAgIHNpemUgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihpLCAwKTtcbiAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICdkZWx0YVknKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICBjdXJyZW50RGVjb3JhdGlvbiA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgdHlwZSk7XG4gICAgICAgICAgY3VycmVudEZpbGwgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICdmaWxsJyk7XG4gICAgICAgICAgX3NpemUgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihpLCBqKTtcbiAgICAgICAgICBfZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICdkZWx0YVknKTtcbiAgICAgICAgICBpZiAocGF0aCAmJiBjdXJyZW50RGVjb3JhdGlvbiAmJiBjdXJyZW50RmlsbCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0RmlsbDtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2hhckJveC5yZW5kZXJMZWZ0LCBjaGFyQm94LnJlbmRlclRvcCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGNoYXJCb3guYW5nbGUpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAtY2hhckJveC5rZXJuZWRXaWR0aCAvIDIsXG4gICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1t0eXBlXSAqIF9zaXplICsgX2R5LFxuICAgICAgICAgICAgICBjaGFyQm94Lmtlcm5lZFdpZHRoLFxuICAgICAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIChjdXJyZW50RGVjb3JhdGlvbiAhPT0gbGFzdERlY29yYXRpb24gfHwgY3VycmVudEZpbGwgIT09IGxhc3RGaWxsIHx8IF9zaXplICE9PSBzaXplIHx8IF9keSAhPT0gZHkpXG4gICAgICAgICAgICAmJiBib3hXaWR0aCA+IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGxhc3REZWNvcmF0aW9uICYmIGxhc3RGaWxsICYmXG4gICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgICAgICB0b3AgKyB0aGlzLm9mZnNldHNbdHlwZV0gKiBzaXplICsgZHksXG4gICAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICAgIGxhc3REZWNvcmF0aW9uID0gY3VycmVudERlY29yYXRpb247XG4gICAgICAgICAgICBsYXN0RmlsbCA9IGN1cnJlbnRGaWxsO1xuICAgICAgICAgICAgc2l6ZSA9IF9zaXplO1xuICAgICAgICAgICAgZHkgPSBfZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN1cnJlbnRGaWxsO1xuICAgICAgICBjdXJyZW50RGVjb3JhdGlvbiAmJiBjdXJyZW50RmlsbCAmJiBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgdG9wICsgdGhpcy5vZmZzZXRzW3R5cGVdICogc2l6ZSArIGR5LFxuICAgICAgICAgIGJveFdpZHRoIC0gY2hhclNwYWNpbmcsXG4gICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICk7XG4gICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSBpcyB0ZXh0IGJhY2tncm91bmQgY29sb3Igbm9cbiAgICAgIC8vIG90aGVyIHNoYWRvd3Mgc2hvdWxkIGJlIGNhc3RlZFxuICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBmb250IGRlY2xhcmF0aW9uIHN0cmluZyBmb3IgY2FudmFzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT2JqZWN0XSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBmb250IGRlY2xhcmF0aW9uIGZvcm1hdHRlZCBmb3IgY2FudmFzIGNvbnRleHQuXG4gICAgICovXG4gICAgX2dldEZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24oc3R5bGVPYmplY3QsIGZvck1lYXN1cmluZykge1xuICAgICAgdmFyIHN0eWxlID0gc3R5bGVPYmplY3QgfHwgdGhpcywgZmFtaWx5ID0gdGhpcy5mb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRJc0dlbmVyaWMgPSBmYWJyaWMuVGV4dC5nZW5lcmljRm9udHMuaW5kZXhPZihmYW1pbHkudG9Mb3dlckNhc2UoKSkgPiAtMTtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZmFtaWx5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGZhbWlseS5pbmRleE9mKCdcXCcnKSA+IC0xIHx8IGZhbWlseS5pbmRleE9mKCcsJykgPiAtMSB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1wiJykgPiAtMSB8fCBmb250SXNHZW5lcmljXG4gICAgICAgID8gc3R5bGUuZm9udEZhbWlseSA6ICdcIicgKyBzdHlsZS5mb250RmFtaWx5ICsgJ1wiJztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIC8vIG5vZGUtY2FudmFzIG5lZWRzIFwid2VpZ2h0IHN0eWxlXCIsIHdoaWxlIGJyb3dzZXJzIG5lZWQgXCJzdHlsZSB3ZWlnaHRcIlxuICAgICAgICAvLyB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgZml4ZWQgaW4gSlNET01cbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250V2VpZ2h0IDogc3R5bGUuZm9udFN0eWxlKSxcbiAgICAgICAgKGZhYnJpYy5pc0xpa2VseU5vZGUgPyBzdHlsZS5mb250U3R5bGUgOiBzdHlsZS5mb250V2VpZ2h0KSxcbiAgICAgICAgZm9yTWVhc3VyaW5nID8gdGhpcy5DQUNIRV9GT05UX1NJWkUgKyAncHgnIDogc3R5bGUuZm9udFNpemUgKyAncHgnLFxuICAgICAgICBmb250RmFtaWx5XG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IGluc3RhbmNlIG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIGRvIG5vdCByZW5kZXIgaWYgb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCBhcyBhbiBhcnJheSBvZiBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgICogQHJldHVybnMge0FycmF5fSBMaW5lcyBpbiB0aGUgdGV4dFxuICAgICAqL1xuICAgIF9zcGxpdFRleHRJbnRvTGluZXM6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQodGhpcy5fcmVOZXdsaW5lKSxcbiAgICAgICAgICBuZXdMaW5lcyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpLFxuICAgICAgICAgIG5ld0xpbmUgPSBbJ1xcbiddLFxuICAgICAgICAgIG5ld1RleHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3TGluZXNbaV0gPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChsaW5lc1tpXSk7XG4gICAgICAgIG5ld1RleHQgPSBuZXdUZXh0LmNvbmNhdChuZXdMaW5lc1tpXSwgbmV3TGluZSk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LnBvcCgpO1xuICAgICAgcmV0dXJuIHsgX3Vud3JhcHBlZExpbmVzOiBuZXdMaW5lcywgbGluZXM6IGxpbmVzLCBncmFwaGVtZVRleHQ6IG5ld1RleHQsIGdyYXBoZW1lTGluZXM6IG5ld0xpbmVzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvcGVydGllcyA9IFtcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAnZm9udFdlaWdodCcsXG4gICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICAgJ3VuZGVybGluZScsXG4gICAgICAgICdvdmVybGluZScsXG4gICAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICBdLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIHZhciBvYmogPSB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBhZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICBvYmouc3R5bGVzID0gY2xvbmUodGhpcy5zdHlsZXMsIHRydWUpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICB2YXIgbmVlZHNEaW1zID0gZmFsc2U7XG4gICAgICB2YXIgaXNBZGRpbmdQYXRoID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2tleSBpbiBrZXkpIHtcbiAgICAgICAgICBpZiAoX2tleSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhdGhJbmZvKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzRGltcyA9IG5lZWRzRGltcyB8fCB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKF9rZXkpICE9PSAtMTtcbiAgICAgICAgICBpc0FkZGluZ1BhdGggPSBpc0FkZGluZ1BhdGggfHwgX2tleSA9PT0gJ3BhdGgnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmVlZHNEaW1zID0gdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgICAgaXNBZGRpbmdQYXRoID0ga2V5ID09PSAncGF0aCc7XG4gICAgICB9XG4gICAgICBpZiAoaXNBZGRpbmdQYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc0RpbXMpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3RleHQuaHRtbCNUZXh0RWxlbWVudFxuICAgKi9cbiAgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChcbiAgICAneCB5IGR4IGR5IGZvbnQtZmFtaWx5IGZvbnQtc3R5bGUgZm9udC13ZWlnaHQgZm9udC1zaXplIGxldHRlci1zcGFjaW5nIHRleHQtZGVjb3JhdGlvbiB0ZXh0LWFuY2hvcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgU1ZHIGZvbnQgc2l6ZVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKi9cbiAgZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFID0gMTY7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHQgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudCAoPGI+bm90IHlldCBpbXBsZW1lbnRlZDwvYj4pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5UZXh0LkFUVFJJQlVURV9OQU1FUyksXG4gICAgICAgIHBhcnNlZEFuY2hvciA9IHBhcnNlZEF0dHJpYnV0ZXMudGV4dEFuY2hvciB8fCAnbGVmdCc7XG4gICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoKG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpO1xuXG4gICAgb3B0aW9ucy50b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMubGVmdCB8fCAwO1xuICAgIGlmIChwYXJzZWRBdHRyaWJ1dGVzLnRleHREZWNvcmF0aW9uKSB7XG4gICAgICB2YXIgdGV4dERlY29yYXRpb24gPSBwYXJzZWRBdHRyaWJ1dGVzLnRleHREZWNvcmF0aW9uO1xuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLnVuZGVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZignb3ZlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy5vdmVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZignbGluZS10aHJvdWdoJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMubGluZXRocm91Z2ggPSB0cnVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG9wdGlvbnMudGV4dERlY29yYXRpb247XG4gICAgfVxuICAgIGlmICgnZHgnIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMubGVmdCArPSBwYXJzZWRBdHRyaWJ1dGVzLmR4O1xuICAgIH1cbiAgICBpZiAoJ2R5JyBpbiBwYXJzZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLnRvcCArPSBwYXJzZWRBdHRyaWJ1dGVzLmR5O1xuICAgIH1cbiAgICBpZiAoISgnZm9udFNpemUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgLy8gVGhlIFhNTCBpcyBub3QgcHJvcGVybHkgcGFyc2VkIGluIElFOSBzbyBhIHdvcmthcm91bmQgdG8gZ2V0XG4gICAgLy8gdGV4dENvbnRlbnQgaXMgdGhyb3VnaCBmaXJzdENoaWxkLmRhdGEuIEFub3RoZXIgd29ya2Fyb3VuZCB3b3VsZCBiZVxuICAgIC8vIHRvIGNvbnZlcnQgWE1MIGxvYWRlZCBmcm9tIGEgZmlsZSB0byBiZSBjb252ZXJ0ZWQgdXNpbmcgRE9NUGFyc2VyIChzYW1lIHdheSBsb2FkU1ZHRnJvbVN0cmluZygpIGRvZXMpXG4gICAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBlbGVtZW50KSkge1xuICAgICAgaWYgKCdmaXJzdENoaWxkJyBpbiBlbGVtZW50ICYmIGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoJ2RhdGEnIGluIGVsZW1lbnQuZmlyc3RDaGlsZCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC5maXJzdENoaWxkLmRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfVxuXG4gICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJHxcXG4rL2csICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgdmFyIG9yaWdpbmFsU3Ryb2tlV2lkdGggPSBvcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgIG9wdGlvbnMuc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgdmFyIHRleHQgPSBuZXcgZmFicmljLlRleHQodGV4dENvbnRlbnQsIG9wdGlvbnMpLFxuICAgICAgICB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IgPSB0ZXh0LmdldFNjYWxlZEhlaWdodCgpIC8gdGV4dC5oZWlnaHQsXG4gICAgICAgIGxpbmVIZWlnaHREaWZmID0gKHRleHQuaGVpZ2h0ICsgdGV4dC5zdHJva2VXaWR0aCkgKiB0ZXh0LmxpbmVIZWlnaHQgLSB0ZXh0LmhlaWdodCxcbiAgICAgICAgc2NhbGVkRGlmZiA9IGxpbmVIZWlnaHREaWZmICogdGV4dEhlaWdodFNjYWxlRmFjdG9yLFxuICAgICAgICB0ZXh0SGVpZ2h0ID0gdGV4dC5nZXRTY2FsZWRIZWlnaHQoKSArIHNjYWxlZERpZmYsXG4gICAgICAgIG9mZlggPSAwO1xuICAgIC8qXG4gICAgICBBZGp1c3QgcG9zaXRpb25pbmc6XG4gICAgICAgIHgveSBhdHRyaWJ1dGVzIGluIFNWRyBjb3JyZXNwb25kIHRvIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGV4dCBib3VuZGluZyBib3hcbiAgICAgICAgZmFicmljIG91dHB1dCBieSBkZWZhdWx0IGF0IHRvcCwgbGVmdC5cbiAgICAqL1xuICAgIGlmIChwYXJzZWRBbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRTY2FsZWRXaWR0aCgpIC8gMjtcbiAgICB9XG4gICAgaWYgKHBhcnNlZEFuY2hvciA9PT0gJ3JpZ2h0Jykge1xuICAgICAgb2ZmWCA9IHRleHQuZ2V0U2NhbGVkV2lkdGgoKTtcbiAgICB9XG4gICAgdGV4dC5zZXQoe1xuICAgICAgbGVmdDogdGV4dC5sZWZ0IC0gb2ZmWCxcbiAgICAgIHRvcDogdGV4dC50b3AgLSAodGV4dEhlaWdodCAtIHRleHQuZm9udFNpemUgKiAoMC4wNyArIHRleHQuX2ZvbnRTaXplRnJhY3Rpb24pKSAvIHRleHQubGluZUhlaWdodCxcbiAgICAgIHN0cm9rZVdpZHRoOiB0eXBlb2Ygb3JpZ2luYWxTdHJva2VXaWR0aCAhPT0gJ3VuZGVmaW5lZCcgPyBvcmlnaW5hbFN0cm9rZVdpZHRoIDogMSxcbiAgICB9KTtcbiAgICBjYWxsYmFjayh0ZXh0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHQnLCBvYmplY3QsIGNhbGxiYWNrLCAndGV4dCcpO1xuICB9O1xuXG4gIGZhYnJpYy5UZXh0LmdlbmVyaWNGb250cyA9IFsnc2Fucy1zZXJpZicsICdzZXJpZicsICdjdXJzaXZlJywgJ2ZhbnRhc3knLCAnbW9ub3NwYWNlJ107XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzICYmIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuVGV4dCk7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgbm8gc3R5bGluZyBvciBubyBzdHlsaW5nIGluIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggLCBsaW5lSW5kZXggaXMgb24gd3JhcHBlZCBsaW5lcy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHlTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGluZUluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0eXBlb2YgbGluZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc3R5bGVzIDogeyBsaW5lOiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdIH07XG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgIGZvciAodmFyIHAzIGluIG9ialtwMV1bcDJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgYSBzdHlsZSBwcm9wZXJ0eSBvciBoYXMgaXQgaW5hIHNwZWNpZmllZCBsaW5lXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVjdCBpZiBhIHRleHQgd2lsbCB1c2UgYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdG8gY2hlY2sgZm9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0byBjaGVjayB0aGUgc3R5bGUgb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0eWxlSGFzOiBmdW5jdGlvbihwcm9wZXJ0eSwgbGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0eXBlb2YgbGluZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc3R5bGVzIDogeyAwOiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdIH07XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW3AxXVtwMl1bcHJvcGVydHldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNoYXJhY3RlcnMgaW4gYSB0ZXh0IGhhdmUgYSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eVxuICAgICAqIHdob3NlIHZhbHVlIG1hdGNoZXMgdGhlIHRleHRib3gncyB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eS4gIElmIHNvLFxuICAgICAqIHRoZSBjaGFyYWN0ZXItbGV2ZWwgcHJvcGVydHkgaXMgZGVsZXRlZC4gIElmIHRoZSBjaGFyYWN0ZXJcbiAgICAgKiBoYXMgbm8gb3RoZXIgcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbHNvIGRlbGV0ZWQuICBGaW5hbGx5LFxuICAgICAqIGlmIHRoZSBsaW5lIGNvbnRhaW5pbmcgdGhhdCBjaGFyYWN0ZXIgaGFzIG5vIG90aGVyIGNoYXJhY3RlcnNcbiAgICAgKiB0aGVuIGl0IGFsc28gaXMgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gY29tcGFyZSBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kIHRleHQuXG4gICAgICovXG4gICAgY2xlYW5TdHlsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXMsIHN0eWxlc0NvdW50ID0gMCwgbGV0dGVyQ291bnQsIHN0eWxlUHJvcGVydHlWYWx1ZSxcbiAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IHRydWUsIGdyYXBoZW1lQ291bnQgPSAwLCBzdHlsZU9iamVjdDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIGxldHRlckNvdW50ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICB2YXIgc3R5bGVPYmplY3QgPSBvYmpbcDFdW3AyXSxcbiAgICAgICAgICAgICAgc3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQgPSBzdHlsZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBzdHlsZXNDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKHN0eWxlUHJvcGVydHlIYXNCZWVuU2V0KSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICBzdHlsZVByb3BlcnR5VmFsdWUgPSBzdHlsZU9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZU9iamVjdFtwcm9wZXJ0eV0gIT09IHN0eWxlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3R5bGVPYmplY3RbcHJvcGVydHldID09PSB0aGlzW3Byb3BlcnR5XSkge1xuICAgICAgICAgICAgICBkZWxldGUgc3R5bGVPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0eWxlT2JqZWN0KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGxldHRlckNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtwMV1bcDJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXR0ZXJDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbcDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpZiBldmVyeSBncmFwaGVtZSBoYXMgdGhlIHNhbWUgc3R5bGUgc2V0IHRoZW5cbiAgICAgIC8vIGRlbGV0ZSB0aG9zZSBzdHlsZXMgYW5kIHNldCBpdCBvbiB0aGUgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZUNvdW50ICs9IHRoaXMuX3RleHRMaW5lc1tpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggJiYgc3R5bGVzQ291bnQgPT09IGdyYXBoZW1lQ291bnQpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBzdHlsZVByb3BlcnR5VmFsdWU7XG4gICAgICAgIHRoaXMucmVtb3ZlU3R5bGUocHJvcGVydHkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eSBvciBwcm9wZXJ0aWVzIGZyb20gYWxsIGluZGl2aWR1YWwgY2hhcmFjdGVyIHN0eWxlc1xuICAgICAqIGluIGEgdGV4dCBvYmplY3QuICBEZWxldGVzIHRoZSBjaGFyYWN0ZXIgc3R5bGUgb2JqZWN0IGlmIGl0IGNvbnRhaW5zIG5vIG90aGVyIHN0eWxlXG4gICAgICogcHJvcHMuICBEZWxldGVzIGEgbGluZSBzdHlsZSBvYmplY3QgaWYgaXQgY29udGFpbnMgbm8gb3RoZXIgY2hhcmFjdGVyIHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wcyBUaGUgcHJvcGVydHkgdG8gcmVtb3ZlIGZyb20gY2hhcmFjdGVyIHN0eWxlcy5cbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXMsIGxpbmUsIGxpbmVOdW0sIGNoYXJOdW07XG4gICAgICBmb3IgKGxpbmVOdW0gaW4gb2JqKSB7XG4gICAgICAgIGxpbmUgPSBvYmpbbGluZU51bV07XG4gICAgICAgIGZvciAoY2hhck51bSBpbiBsaW5lKSB7XG4gICAgICAgICAgZGVsZXRlIGxpbmVbY2hhck51bV1bcHJvcGVydHldO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsaW5lW2NoYXJOdW1dKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaW5lW2NoYXJOdW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobGluZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtsaW5lTnVtXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leHRlbmRTdHlsZXM6IGZ1bmN0aW9uKGluZGV4LCBzdHlsZXMpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oaW5kZXgpO1xuXG4gICAgICBpZiAoIXRoaXMuX2dldExpbmVTdHlsZShsb2MubGluZUluZGV4KSkge1xuICAgICAgICB0aGlzLl9zZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KSkge1xuICAgICAgICB0aGlzLl9zZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgsIHt9KTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpLCBzdHlsZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIDJkIHJlcHJlc2VudGF0aW9uIChsaW5lSW5kZXggYW5kIGNoYXJJbmRleCkgb2YgY3Vyc29yIChvciBzZWxlY3Rpb24gc3RhcnQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWxlY3Rpb25TdGFydF0gT3B0aW9uYWwgaW5kZXguIFdoZW4gbm90IGdpdmVuLCBjdXJyZW50IHNlbGVjdGlvblN0YXJ0IGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcFdyYXBwaW5nXSBjb25zaWRlciB0aGUgbG9jYXRpb24gZm9yIHVud3JhcHBlZCBsaW5lcy4gdXNlZnVsIHRvIG1hbmFnZSBzdHlsZXMuXG4gICAgICovXG4gICAgZ2V0MkRDdXJzb3JMb2NhdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQsIHNraXBXcmFwcGluZykge1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rpb25TdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVzID0gc2tpcFdyYXBwaW5nID8gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzIDogdGhpcy5fdGV4dExpbmVzLFxuICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0IDw9IGxpbmVzW2ldLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lSW5kZXg6IGksXG4gICAgICAgICAgICBjaGFySW5kZXg6IHNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydCAtPSBsaW5lc1tpXS5sZW5ndGggKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZUluZGV4OiBpIC0gMSxcbiAgICAgICAgY2hhckluZGV4OiBsaW5lc1tpIC0gMV0ubGVuZ3RoIDwgc2VsZWN0aW9uU3RhcnQgPyBsaW5lc1tpIC0gMV0ubGVuZ3RoIDogc2VsZWN0aW9uU3RhcnRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgKGF0IHRoZSBzdGFydCBwb3NpdGlvbilcbiAgICAgKiBpZiBzdGFydEluZGV4IG9yIGVuZEluZGV4IGFyZSBub3QgcHJvdmlkZWQsIHNlbGVjdGlvblN0YXJ0IG9yIHNlbGVjdGlvbkVuZCB3aWxsIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4XSBTdGFydCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleF0gRW5kIGluZGV4IHRvIGdldCBzdHlsZXMgYXQsIGlmIG5vdCBzcGVjaWZpZWQgc2VsZWN0aW9uRW5kIG9yIHN0YXJ0SW5kZXggKyAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcGxldGVdIGdldCBmdWxsIHN0eWxlIG9yIG5vdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBzdHlsZXMgYW4gYXJyYXkgd2l0aCBvbmUsIHplcm8gb3IgbW9yZSBTdHlsZSBvYmplY3RzXG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdGFydEluZGV4LCBlbmRJbmRleCwgY29tcGxldGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5kSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVuZEluZGV4ID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgc3RhcnRJbmRleDtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgICBzdHlsZXMucHVzaCh0aGlzLmdldFN0eWxlQXRQb3NpdGlvbihpLCBjb21wbGV0ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uL2N1cnNvciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAgdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXBsZXRlXSBmdWxsIHN0eWxlIGlmIHRydWVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIFN0eWxlIG9iamVjdCBhdCBhIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U3R5bGVBdFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbiwgY29tcGxldGUpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24ocG9zaXRpb24pLFxuICAgICAgICAgIHN0eWxlID0gY29tcGxldGUgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KSA6XG4gICAgICAgICAgICB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpO1xuICAgICAgcmV0dXJuIHN0eWxlIHx8IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24sIGlmIG5vIHNlbGVjdGlvbiBleGlzdCwgZG8gbm90IHNldCBhbnl0aGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlc10gU3R5bGVzIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0LCBpZiBub3Qgc3BlY2lmaWVkIHNlbGVjdGlvbkVuZCBvciBzdGFydEluZGV4ICsgMVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdHlsZXM6IGZ1bmN0aW9uKHN0eWxlcywgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5kSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVuZEluZGV4ID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgc3RhcnRJbmRleDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgICB0aGlzLl9leHRlbmRTdHlsZXMoaSwgc3R5bGVzKTtcbiAgICAgIH1cbiAgICAgIC8qIG5vdCBpbmNsdWRlZCBpbiBfZXh0ZW5kU3R5bGVzIHRvIGF2b2lkIGNsZWFyaW5nIGNhY2hlIG1vcmUgdGhhbiBvbmNlICovXG4gICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcmVmZXJlbmNlLCBub3QgYSBjbG9uZSwgb2YgdGhlIHN0eWxlIG9iamVjdCBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgb2JqZWN0XG4gICAgICovXG4gICAgX2dldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgbGluZVN0eWxlID0gdGhpcy5zdHlsZXMgJiYgdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICAgIGlmICghbGluZVN0eWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVTdHlsZVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBuZXcgb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBzdHlsZSBwcm9wZXJ0eSBmb3IgYSBjaGFyYWN0ZXJcbiAgICAgKiB0aGUgb2JqZWN0IHJldHVybmVkIGlzIG5ld2x5IGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IG9mIHRoZSBsaW5lIHdoZXJlIHRoZSBjaGFyYWN0ZXIgaXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHBvc2l0aW9uIG9mIHRoZSBjaGFyYWN0ZXIgb24gdGhlIGxpbmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIG9iamVjdFxuICAgICAqL1xuICAgIGdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHx8IHsgfSxcbiAgICAgICAgICBzdHlsZU9iamVjdCA9IHsgfSwgcHJvcDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3R5bGVQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3AgPSB0aGlzLl9zdHlsZVByb3BlcnRpZXNbaV07XG4gICAgICAgIHN0eWxlT2JqZWN0W3Byb3BdID0gdHlwZW9mIHN0eWxlW3Byb3BdID09PSAndW5kZWZpbmVkJyA/IHRoaXNbcHJvcF0gOiBzdHlsZVtwcm9wXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBpZiB0aGUgbGluZSBleGlzdHMgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGluZSBzdHlsZSB0byBhbiBlbXB0eSBvYmplY3Qgc28gdGhhdCBpcyBpbml0aWFsaXplZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlTGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBwYXJzZURlY29yYXRpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpID4gLTEgJiYgKG9iamVjdC51bmRlcmxpbmUgPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSA+IC0xICYmIChvYmplY3QubGluZXRocm91Z2ggPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpID4gLTEgJiYgKG9iamVjdC5vdmVybGluZSA9IHRydWUpO1xuICAgICAgZGVsZXRlIG9iamVjdC50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSVRleHQgY2xhc3MgKGludHJvZHVjZWQgaW4gPGI+djEuNDwvYj4pIEV2ZW50cyBhcmUgYWxzbyBmaXJlZCB3aXRoIFwidGV4dDpcIlxuICAgKiBwcmVmaXggd2hlbiBvYnNlcnZpbmcgY2FudmFzLlxuICAgKiBAY2xhc3MgZmFicmljLklUZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5UZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKlxuICAgKiBAZmlyZXMgY2hhbmdlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNoYW5nZWRcbiAgICogQGZpcmVzIGVkaXRpbmc6ZW50ZXJlZFxuICAgKiBAZmlyZXMgZWRpdGluZzpleGl0ZWRcbiAgICpcbiAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQga2V5IGNvbWJpbmF0aW9uczo8L3A+XG4gICAqIDxwcmU+XG4gICAqICAgTW92ZSBjdXJzb3I6ICAgICAgICAgICAgICAgICAgICBsZWZ0LCByaWdodCwgdXAsIGRvd25cbiAgICogICBTZWxlY3QgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIHNoaWZ0ICsgbGVmdCwgc2hpZnQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB0ZXh0IHZlcnRpY2FsbHk6ICAgICAgICAgc2hpZnQgKyB1cCwgc2hpZnQgKyBkb3duXG4gICAqICAgTW92ZSBjdXJzb3IgYnkgd29yZDogICAgICAgICAgICBhbHQgKyBsZWZ0LCBhbHQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB3b3JkczogICAgICAgICAgICAgICAgICAgc2hpZnQgKyBhbHQgKyBsZWZ0LCBzaGlmdCArIGFsdCArIHJpZ2h0XG4gICAqICAgTW92ZSBjdXJzb3IgdG8gbGluZSBzdGFydC9lbmQ6ICBjbWQgKyBsZWZ0LCBjbWQgKyByaWdodCBvciBob21lLCBlbmRcbiAgICogICBTZWxlY3QgdGlsbCBzdGFydC9lbmQgb2YgbGluZTogIGNtZCArIHNoaWZ0ICsgbGVmdCwgY21kICsgc2hpZnQgKyByaWdodCBvciBzaGlmdCArIGhvbWUsIHNoaWZ0ICsgZW5kXG4gICAqICAgSnVtcCB0byBzdGFydC9lbmQgb2YgdGV4dDogICAgICBjbWQgKyB1cCwgY21kICsgZG93blxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgY21kICsgc2hpZnQgKyB1cCwgY21kICsgc2hpZnQgKyBkb3duIG9yIHNoaWZ0ICsgcGdVcCwgc2hpZnQgKyBwZ0Rvd25cbiAgICogICBEZWxldGUgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIGJhY2tzcGFjZVxuICAgKiAgIERlbGV0ZSB3b3JkOiAgICAgICAgICAgICAgICAgICAgYWx0ICsgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIGxpbmU6ICAgICAgICAgICAgICAgICAgICBjbWQgKyBiYWNrc3BhY2VcbiAgICogICBGb3J3YXJkIGRlbGV0ZTogICAgICAgICAgICAgICAgIGRlbGV0ZVxuICAgKiAgIENvcHkgdGV4dDogICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyBjXG4gICAqICAgUGFzdGUgdGV4dDogICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIHZcbiAgICogICBDdXQgdGV4dDogICAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgeFxuICAgKiAgIFNlbGVjdCBlbnRpcmUgdGV4dDogICAgICAgICAgICAgY3RybC9jbWQgKyBhXG4gICAqICAgUXVpdCBlZGl0aW5nICAgICAgICAgICAgICAgICAgICB0YWIgb3IgZXNjXG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQgbW91c2UvdG91Y2ggY29tYmluYXRpb248L3A+XG4gICAqIDxwcmU+XG4gICAqICAgUG9zaXRpb24gY3Vyc29yOiAgICAgICAgICAgICAgICBjbGljay90b3VjaFxuICAgKiAgIENyZWF0ZSBzZWxlY3Rpb246ICAgICAgICAgICAgICAgY2xpY2svdG91Y2ggJiBkcmFnXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljayAmIHNoaWZ0ICsgY2xpY2tcbiAgICogICBTZWxlY3Qgd29yZDogICAgICAgICAgICAgICAgICAgIGRvdWJsZSBjbGlja1xuICAgKiAgIFNlbGVjdCBsaW5lOiAgICAgICAgICAgICAgICAgICAgdHJpcGxlIGNsaWNrXG4gICAqIDwvcHJlPlxuICAgKi9cbiAgZmFicmljLklUZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpLXRleHQnLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gc3RhcnRzIChvciB3aGVyZSBjdXJzb3IgaXMgd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24pXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25TdGFydDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGV4IHdoZXJlIHRleHQgc2VsZWN0aW9uIGVuZHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkVuZDogMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRleHQgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Db2xvcjogJ3JnYmEoMTcsMTE5LDI1NSwwLjMpJyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRleHQgaXMgaW4gZWRpdGluZyBtb2RlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGEgdGV4dCBjYW4gYmUgZWRpdGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBCb3JkZXIgY29sb3Igb2YgdGV4dCBvYmplY3Qgd2hpbGUgaXQncyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVkaXRpbmdCb3JkZXJDb2xvcjogJ3JnYmEoMTAyLDE1MywyNTUsMC4yNSknLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgY3Vyc29yIChpbiBweClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvcldpZHRoOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGV4dCBjdXJzb3IgY29sb3IgaW4gZWRpdGluZyBtb2RlLlxuICAgICAqIGlmIG5vdCBzZXQgKGRlZmF1bHQpIHdpbGwgdGFrZSBjb2xvciBmcm9tIHRoZSB0ZXh0LlxuICAgICAqIGlmIHNldCB0byBhIGNvbG9yIHZhbHVlIHRoYXQgZmFicmljIGNhbiB1bmRlcnN0YW5kLCBpdCB3aWxsXG4gICAgICogYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjb2xvciBvZiB0aGUgdGV4dCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckNvbG9yOiAnJyxcblxuICAgIC8qKlxuICAgICAqIERlbGF5IGJldHdlZW4gY3Vyc29yIGJsaW5rIChpbiBtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckRlbGF5OiAxMDAwLFxuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2YgY3Vyc29yIGZhZGVpbiAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEdXJhdGlvbjogNjAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgaW50ZXJuYWwgdGV4dCBjaGFyIHdpZHRocyBjYW4gYmUgY2FjaGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2U6IC9cXHN8XFxuLyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2N1cnJlbnRDdXJzb3JPcGFjaXR5OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0aW9uRGlyZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWJvcnRDdXJzb3JBbmltYXRpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3dpZHRoT2ZTcGFjZTogW10sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwcyBkZXRlcm1pbmluZyB3aGVuIHRoZSB0ZXh0IGlzIGluIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZSBjdXJzb3JcbiAgICAgKiByZW5kZXJpbmcgaXMgYWx0ZXJlZC5cbiAgICAgKi9cbiAgICBpbkNvbXBvc2l0aW9uTW9kZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgdGV4dCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmluaXRCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBzdGFydCAobGVmdCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBzdGFydCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25TdGFydCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gZW5kIChyaWdodCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBlbmQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25FbmQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnRleHQubGVuZ3RoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvbkVuZCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgJ3NlbGVjdGlvblN0YXJ0JyBvciAnc2VsZWN0aW9uRW5kJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBuZXcgcG9zaXRpb24gb2YgcHJvcGVydHlcbiAgICAgKi9cbiAgICBfdXBkYXRlQW5kRmlyZTogZnVuY3Rpb24ocHJvcGVydHksIGluZGV4KSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5kZXg7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgZXZlbiBvZiBzZWxlY3Rpb24gY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNoYW5nZWQnKTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6c2VsZWN0aW9uOmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0ZXh0IGRpbWVuc2lvbnMuIFJlbmRlciBhbGwgdGV4dCBvbiBnaXZlbiBjb250ZXh0XG4gICAgICogb3Igb24gYSBvZmZzY3JlZW4gY2FudmFzIHRvIGdldCB0aGUgdGV4dCB3aWR0aCB3aXRoIG1lYXN1cmVUZXh0LlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdERpbWVuc2lvbnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIC8vIGNsZWFyIHRoZSBjdXJzb3JPZmZzZXRDYWNoZSwgc28gd2UgZW5zdXJlIHRvIGNhbGN1bGF0ZSBvbmNlIHBlciByZW5kZXJDdXJzb3JcbiAgICAgIC8vIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGJ1dCBub3QgYXQgZXZlcnkgY3Vyc29yIGFuaW1hdGlvbi5cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGFuZCBjbGVhbiB0aGUgY29udGV4dFRvcFxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dFRvcDogZnVuY3Rpb24oc2tpcFJlc3RvcmUpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICB0aGlzLl9jbGVhclRleHRBcmVhKGN0eCk7XG4gICAgICBza2lwUmVzdG9yZSB8fCBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3Igb3Igc2VsZWN0aW9uIChkZXBlbmRpbmcgb24gd2hhdCBleGlzdHMpXG4gICAgICogaXQgZG9lcyBvbiB0aGUgY29udGV4dFRvcC4gSWYgY29udGV4dFRvcCBpcyBub3QgYXZhaWxhYmxlLCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIHJlbmRlckN1cnNvck9yU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcygpLFxuICAgICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCh0cnVlKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvcihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBfY2xlYXJUZXh0QXJlYTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyB3ZSBhZGQgNCBwaXhlbCwgdG8gYmUgc3VyZSB0byBkbyBub3QgbGVhdmUgYW55IHBpeGVsIG91dFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCArIDQsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgNDtcbiAgICAgIGN0eC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnNvciBib3VuZGFyaWVzIChsZWZ0LCB0b3AsIGxlZnRPZmZzZXQsIHRvcE9mZnNldClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIEFycmF5IG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU9mQm91bmRhcmllc1xuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXG4gICAgICAvLyBsZWZ0L3RvcCBhcmUgbGVmdC90b3Agb2YgZW50aXJlIHRleHQgYm94XG4gICAgICAvLyBsZWZ0T2Zmc2V0L3RvcE9mZnNldCBhcmUgb2Zmc2V0IGZyb20gdGhhdCBsZWZ0L3RvcCBwb2ludCBvZiBhIHRleHQgYm94XG5cbiAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzKHBvc2l0aW9uKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnRPZmZzZXQ6IG9mZnNldHMubGVmdCxcbiAgICAgICAgdG9wT2Zmc2V0OiBvZmZzZXRzLnRvcFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5jdXJzb3JPZmZzZXRDYWNoZSAmJiAndG9wJyBpbiB0aGlzLmN1cnNvck9mZnNldENhY2hlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvck9mZnNldENhY2hlO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICAgIGxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXgsXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gMCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICBib3VuZGFyaWVzLFxuICAgICAgICAgIGN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHBvc2l0aW9uKTtcbiAgICAgIGNoYXJJbmRleCA9IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleDtcbiAgICAgIGxpbmVJbmRleCA9IGN1cnNvclBvc2l0aW9uLmxpbmVJbmRleDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUluZGV4OyBpKyspIHtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgfVxuICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpO1xuICAgICAgdmFyIGJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgICAgYm91bmQgJiYgKGxlZnRPZmZzZXQgPSBib3VuZC5sZWZ0KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwICYmIGNoYXJJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBib3VuZGFyaWVzID0ge1xuICAgICAgICB0b3A6IHRvcE9mZnNldCxcbiAgICAgICAgbGVmdDogbGluZUxlZnRPZmZzZXQgKyAobGVmdE9mZnNldCA+IDAgPyBsZWZ0T2Zmc2V0IDogMCksXG4gICAgICB9O1xuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IGJvdW5kYXJpZXM7XG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcbiAgICAgIHZhciBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbigpLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4IC0gMSA6IDAsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLnNjYWxlWCAqIHRoaXMuY2FudmFzLmdldFpvb20oKSxcbiAgICAgICAgICBjdXJzb3JXaWR0aCA9IHRoaXMuY3Vyc29yV2lkdGggLyBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRvcE9mZnNldCA9IGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2RlbHRhWScpO1xuXG4gICAgICB0b3BPZmZzZXQgKz0gKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCkgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgLSBjaGFySGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcblxuICAgICAgaWYgKHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb24oYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3Vyc29yQ29sb3IgfHwgdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2ZpbGwnKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX19pc01vdXNlZG93biA/IDEgOiB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eTtcbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICsgYm91bmRhcmllcy5sZWZ0T2Zmc2V0IC0gY3Vyc29yV2lkdGggLyAyLFxuICAgICAgICB0b3BPZmZzZXQgKyBib3VuZGFyaWVzLnRvcCArIGR5LFxuICAgICAgICBjdXJzb3JXaWR0aCxcbiAgICAgICAgY2hhckhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllcyBPYmplY3Qgd2l0aCBsZWZ0L3RvcC9sZWZ0T2Zmc2V0L3RvcE9mZnNldFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcblxuICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQgOiB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIHNlbGVjdGlvbkVuZCA9IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCA6IHRoaXMuc2VsZWN0aW9uRW5kLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgc3RhcnQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uU3RhcnQpLFxuICAgICAgICAgIGVuZCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25FbmQpLFxuICAgICAgICAgIHN0YXJ0TGluZSA9IHN0YXJ0LmxpbmVJbmRleCxcbiAgICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmVJbmRleCxcbiAgICAgICAgICBzdGFydENoYXIgPSBzdGFydC5jaGFySW5kZXggPCAwID8gMCA6IHN0YXJ0LmNoYXJJbmRleCxcbiAgICAgICAgICBlbmRDaGFyID0gZW5kLmNoYXJJbmRleCA8IDAgPyAwIDogZW5kLmNoYXJJbmRleDtcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKSB8fCAwLFxuICAgICAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpLFxuICAgICAgICAgICAgcmVhbExpbmVIZWlnaHQgPSAwLCBib3hTdGFydCA9IDAsIGJveEVuZCA9IDA7XG5cbiAgICAgICAgaWYgKGkgPT09IHN0YXJ0TGluZSkge1xuICAgICAgICAgIGJveFN0YXJ0ID0gdGhpcy5fX2NoYXJCb3VuZHNbc3RhcnRMaW5lXVtzdGFydENoYXJdLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gc3RhcnRMaW5lICYmIGkgPCBlbmRMaW5lKSB7XG4gICAgICAgICAgYm94RW5kID0gaXNKdXN0aWZ5ICYmICF0aGlzLmlzRW5kT2ZXcmFwcGluZyhpKSA/IHRoaXMud2lkdGggOiB0aGlzLmdldExpbmVXaWR0aChpKSB8fCA1OyAvLyBXVEYgaXMgdGhpcyA1P1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPT09IGVuZExpbmUpIHtcbiAgICAgICAgICBpZiAoZW5kQ2hhciA9PT0gMCkge1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhcl0ubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgICAgIGJveEVuZCA9IHRoaXMuX19jaGFyQm91bmRzW2VuZExpbmVdW2VuZENoYXIgLSAxXS5sZWZ0XG4gICAgICAgICAgICAgICsgdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLndpZHRoIC0gY2hhclNwYWNpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlYWxMaW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMubGluZUhlaWdodCA8IDEgfHwgKGkgPT09IGVuZExpbmUgJiYgdGhpcy5saW5lSGVpZ2h0ID4gMSkpIHtcbiAgICAgICAgICBsaW5lSGVpZ2h0IC89IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbXBvc2l0aW9uQ29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICsgbGluZUhlaWdodCxcbiAgICAgICAgICAgIGJveEVuZCAtIGJveFN0YXJ0LFxuICAgICAgICAgICAgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgYm91bmRhcmllcy5sZWZ0ICsgbGluZU9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCxcbiAgICAgICAgICAgIGJveEVuZCAtIGJveFN0YXJ0LFxuICAgICAgICAgICAgbGluZUhlaWdodCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICs9IHJlYWxMaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRvIGtub3cgdGhlIGhlaWdodCBvZiB0aGUgY3Vyc29yLlxuICAgICAqIHRoZSBjdXJyZW50Q2hhciBpcyB0aGUgb25lIHRoYXQgcHJlY2VkZXMgdGhlIGN1cnNvclxuICAgICAqIFJldHVybnMgZm9udFNpemUgb2YgY2hhciBhdCB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgKiBVbnVzZWQgZnJvbSB0aGUgbGlicmFyeSwgaXMgZm9yIHRoZSBlbmQgdXNlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ2hhcmFjdGVyIGZvbnQgc2l6ZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyRm9udFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgY29sb3Igb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGNvbG9yIChmaWxsKSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIFVudXNlZCBmcm9tIHRoZSBsaWJyYXJ5LCBpcyBmb3IgdGhlIGVuZCB1c2VyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBDaGFyYWN0ZXIgY29sb3IgKGZpbGwpXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJDb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3AgPSB0aGlzLl9nZXRDdXJyZW50Q2hhckluZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChjcC5sLCBjcC5jLCAnZmlsbCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgcG9zaXRpb24gZm9yIHRoZSBnZXRDdXJyZW50Li4gZnVuY3Rpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q3VycmVudENoYXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4ID4gMCA/IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleCAtIDEgOiAwO1xuICAgICAgcmV0dXJuIHsgbDogY3Vyc29yUG9zaXRpb24ubGluZUluZGV4LCBjOiBjaGFySW5kZXggfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5JVGV4dCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSVRleHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuSVRleHQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBwYXJzZURlY29yYXRpb24ob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0LnN0eWxlcykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmplY3Quc3R5bGVzKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gb2JqZWN0LnN0eWxlc1tpXSkge1xuICAgICAgICAgIHBhcnNlRGVjb3JhdGlvbihvYmplY3Quc3R5bGVzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdJVGV4dCcsIG9iamVjdCwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHRoZSBpbnRlcmFjdGl2ZSBiZWhhdmlvciBvZiBJVGV4dFxuICAgICAqL1xuICAgIGluaXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluaXRBZGRlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdFJlbW92ZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVycygpO1xuICAgICAgdGhpcy5pbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uKCk7XG4gICAgICB0aGlzLm1vdXNlTW92ZUhhbmRsZXIgPSB0aGlzLm1vdXNlTW92ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmV4aXRFZGl0aW5nKCk7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwiYWRkZWRcIiBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgaW5pdEFkZGVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbignYWRkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGlmICghY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2luaXRDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLnB1c2goX3RoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdFJlbW92ZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdyZW1vdmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBmYWJyaWMudXRpbC5yZW1vdmVGcm9tQXJyYXkoY2FudmFzLl9pVGV4dEluc3RhbmNlcywgX3RoaXMpO1xuICAgICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWdpc3RlciBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdENhbnZhc0hhbmRsZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIG9iai5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjYW52YXMub24oJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMub2ZmKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSA9IHRoaXMuX2FuaW1hdGVDdXJzb3IodGhpcywgMSwgdGhpcy5jdXJzb3JEdXJhdGlvbiwgJ19vblRpY2tDb21wbGV0ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlQ3Vyc29yOiBmdW5jdGlvbihvYmosIHRhcmdldE9wYWNpdHksIGR1cmF0aW9uLCBjb21wbGV0ZU1ldGhvZCkge1xuXG4gICAgICB2YXIgdGlja1N0YXRlO1xuXG4gICAgICB0aWNrU3RhdGUgPSB7XG4gICAgICAgIGlzQWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBvYmouYW5pbWF0ZSgnX2N1cnJlbnRDdXJzb3JPcGFjaXR5JywgdGFyZ2V0T3BhY2l0eSwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGlja1N0YXRlLmlzQWJvcnRlZCkge1xuICAgICAgICAgICAgb2JqW2NvbXBsZXRlTWV0aG9kXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGFuaW1hdGUgYSBzZWxlY3Rpb24sIG9ubHkgY3Vyc29yXG4gICAgICAgICAgaWYgKG9iai5jYW52YXMgJiYgb2JqLnNlbGVjdGlvblN0YXJ0ID09PSBvYmouc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICBvYmoucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGlja1N0YXRlLmlzQWJvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGlja1N0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblRpY2tDb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jdXJzb3JUaW1lb3V0MSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlID0gX3RoaXMuX2FuaW1hdGVDdXJzb3IoX3RoaXMsIDAsIHRoaXMuY3Vyc29yRHVyYXRpb24gLyAyLCAnX3RpY2snKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGRlbGF5ZWQgY3Vyc29yXG4gICAgICovXG4gICAgaW5pdERlbGF5ZWRDdXJzb3I6IGZ1bmN0aW9uKHJlc3RhcnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgZGVsYXkgPSByZXN0YXJ0ID8gMCA6IHRoaXMuY3Vyc29yRGVsYXk7XG5cbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3RpY2soKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWJvcnRzIGN1cnNvciBhbmltYXRpb24gYW5kIGNsZWFycyBhbGwgdGltZW91dHNcbiAgICAgKi9cbiAgICBhYm9ydEN1cnNvckFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSxcbiAgICAgICAgICBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tTdGF0ZS5hYm9ydCgpO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5hYm9ydCgpO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQyKTtcblxuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAwO1xuICAgICAgLy8gdG8gY2xlYXIganVzdCBpdGV4dCBhcmVhIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZSBjb250ZXh0XG4gICAgICAvLyBpdCBtYXkgbm90IGJlIHdvcnRoIGl0XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcy5jbGVhckNvbnRleHQoY2FudmFzLmNvbnRleHRUb3AgfHwgY2FudmFzLmNvbnRleHRDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgZW50aXJlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2VsZWN0ZWQgdGV4dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGJlZm9yZSBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gLSBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgZW5kIG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeVJpZ2h0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGFmdGVyIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCBsaW5lIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kTGluZUJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICB3aGlsZSAoIS9cXG4vLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gKyBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGluZGV4IGNvcnJlc3BvbmRpbmcgdG8gYmVnaW5uaW5nIG9yIGVuZCBvZiBhIHdvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIDEgb3IgLTFcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqL1xuICAgIHNlYXJjaFdvcmRCb3VuZGFyeTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQsIGRpcmVjdGlvbikge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLl90ZXh0LFxuICAgICAgICAgIGluZGV4ICAgICA9IHRoaXMuX3JlU3BhY2UudGVzdCh0ZXh0W3NlbGVjdGlvblN0YXJ0XSkgPyBzZWxlY3Rpb25TdGFydCAtIDEgOiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBfY2hhciAgICAgPSB0ZXh0W2luZGV4XSxcbiAgICAgICAgICAvLyB3cm9uZ1xuICAgICAgICAgIHJlTm9uV29yZCA9IGZhYnJpYy5yZU5vbldvcmQ7XG5cbiAgICAgIHdoaWxlICghcmVOb25Xb3JkLnRlc3QoX2NoYXIpICYmIGluZGV4ID4gMCAmJiBpbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbjtcbiAgICAgICAgX2NoYXIgPSB0ZXh0W2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU5vbldvcmQudGVzdChfY2hhcikpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uID09PSAxID8gMCA6IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB3b3JkIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqL1xuICAgIHNlbGVjdFdvcmQ6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgLTEpLCAvKiBzZWFyY2ggYmFja3dhcmRzICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIDEpOyAvKiBzZWFyY2ggZm9yd2FyZCAqL1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgbGluZSBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0TGluZTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeUxlZnQoc2VsZWN0aW9uU3RhcnQpLFxuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeVJpZ2h0KHNlbGVjdGlvblN0YXJ0KTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnRlcnMgZWRpdGluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBlbnRlckVkaXRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5jYWxjT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuZXhpdEVkaXRpbmdPbk90aGVycyh0aGlzLmNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcblxuICAgICAgdGhpcy5pbml0SGlkZGVuVGV4dGFyZWEoZSk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMuX3NhdmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3NldEVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fdGV4dEJlZm9yZUVkaXQgPSB0aGlzLnRleHQ7XG5cbiAgICAgIHRoaXMuX3RpY2soKTtcbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzplbnRlcmVkJyk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzplbnRlcmVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB0aGlzLmluaXRNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXhpdEVkaXRpbmdPbk90aGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5leGl0RWRpdGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwibW91c2Vtb3ZlXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRNb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2FudmFzLm9uKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuX19pc01vdXNlZG93biB8fCAhdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSxcbiAgICAgICAgICBjdXJyZW50U3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGN1cnJlbnRFbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmIChcbiAgICAgICAgKG5ld1NlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biB8fCBjdXJyZW50U3RhcnQgPT09IGN1cnJlbnRFbmQpXG4gICAgICAgICYmXG4gICAgICAgIChjdXJyZW50U3RhcnQgPT09IG5ld1NlbGVjdGlvblN0YXJ0IHx8IGN1cnJlbnRFbmQgPT09IG5ld1NlbGVjdGlvblN0YXJ0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gY3VycmVudFN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uRW5kICE9PSBjdXJyZW50RW5kKSB7XG4gICAgICAgIHRoaXMucmVzdGFydEN1cnNvcklmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaG92ZXJDdXJzb3IgPSAndGV4dCc7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5jYW52YXMubW92ZUN1cnNvciA9ICd0ZXh0JztcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuZWRpdGluZ0JvcmRlckNvbG9yO1xuICAgICAgdGhpcy5oYXNDb250cm9scyA9IHRoaXMuc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5sb2NrTW92ZW1lbnRZID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIHRleHRhcmVhIHRvIGdyYXBoZW1lIGluZGV4ZXNcbiAgICAgKi9cbiAgICBmcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0KSxcbiAgICAgICAgICBncmFwaGVtZVN0YXJ0ID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRTdGFydCkubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gdGV4dC5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICBncmFwaGVtZUVuZCA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHNtYWxsZXJUZXh0RW5kKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIGZhYnJpYyB0byB0ZXh0YXJlYSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgX3RleHQpIHtcbiAgICAgIHZhciBzbWFsbGVyVGV4dFN0YXJ0ID0gX3RleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBzbWFsbGVyVGV4dFN0YXJ0LmpvaW4oJycpLmxlbmd0aDtcbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzbWFsbGVyVGV4dEVuZCA9IF90ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gc21hbGxlclRleHRFbmQuam9pbignJykubGVuZ3RoO1xuICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCArIGdyYXBoZW1lRW5kIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICBpZiAoIXRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCB0aGlzLl90ZXh0KTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlRnJvbVRleHRBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLCB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUubGVmdCA9IHN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUudG9wID0gc3R5bGUudG9wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgY29udGFpbnMgc3R5bGUgZm9yIGhpZGRlblRleHRhcmVhXG4gICAgICovXG4gICAgX2NhbGNUZXh0YXJlYVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMSwgeTogMSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRlc2lyZWRQb3NpdGlvbiA9IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmNvbXBvc2l0aW9uU3RhcnQgOiB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKGRlc2lyZWRQb3NpdGlvbiksXG4gICAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZGVzaXJlZFBvc2l0aW9uKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSAqIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gYm91bmRhcmllcy5sZWZ0T2Zmc2V0LFxuICAgICAgICAgIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBwID0ge1xuICAgICAgICAgICAgeDogYm91bmRhcmllcy5sZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICAgIHk6IGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBjaGFySGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpLFxuICAgICAgICAgIHVwcGVyQ2FudmFzID0gdGhpcy5jYW52YXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICB1cHBlckNhbnZhc1dpZHRoID0gdXBwZXJDYW52YXMud2lkdGggLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIHVwcGVyQ2FudmFzSGVpZ2h0ID0gdXBwZXJDYW52YXMuaGVpZ2h0IC8gcmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBtYXhXaWR0aCA9IHVwcGVyQ2FudmFzV2lkdGggLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIG1heEhlaWdodCA9IHVwcGVyQ2FudmFzSGVpZ2h0IC0gY2hhckhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSB1cHBlckNhbnZhcy5jbGllbnRXaWR0aCAvIHVwcGVyQ2FudmFzV2lkdGgsXG4gICAgICAgICAgc2NhbGVZID0gdXBwZXJDYW52YXMuY2xpZW50SGVpZ2h0IC8gdXBwZXJDYW52YXNIZWlnaHQ7XG5cbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCBtKTtcbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICBwLnggKj0gc2NhbGVYO1xuICAgICAgcC55ICo9IHNjYWxlWTtcbiAgICAgIGlmIChwLnggPCAwKSB7XG4gICAgICAgIHAueCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgcC54ID0gbWF4V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAocC55IDwgMCkge1xuICAgICAgICBwLnkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHAueSA+IG1heEhlaWdodCkge1xuICAgICAgICBwLnkgPSBtYXhIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBjYW52YXMgb2Zmc2V0IG9uIGRvY3VtZW50XG4gICAgICBwLnggKz0gdGhpcy5jYW52YXMuX29mZnNldC5sZWZ0O1xuICAgICAgcC55ICs9IHRoaXMuY2FudmFzLl9vZmZzZXQudG9wO1xuXG4gICAgICByZXR1cm4geyBsZWZ0OiBwLnggKyAncHgnLCB0b3A6IHAueSArICdweCcsIGZvbnRTaXplOiBjaGFySGVpZ2h0ICsgJ3B4JywgY2hhckhlaWdodDogY2hhckhlaWdodCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlRWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3NhdmVkUHJvcHMgPSB7XG4gICAgICAgIGhhc0NvbnRyb2xzOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgICAgbG9ja01vdmVtZW50WDogdGhpcy5sb2NrTW92ZW1lbnRYLFxuICAgICAgICBsb2NrTW92ZW1lbnRZOiB0aGlzLmxvY2tNb3ZlbWVudFksXG4gICAgICAgIGhvdmVyQ3Vyc29yOiB0aGlzLmhvdmVyQ3Vyc29yLFxuICAgICAgICBzZWxlY3RhYmxlOiB0aGlzLnNlbGVjdGFibGUsXG4gICAgICAgIGRlZmF1bHRDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IsXG4gICAgICAgIG1vdmVDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLm1vdmVDdXJzb3JcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc3RvcmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zYXZlZFByb3BzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuaG92ZXJDdXJzb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5fc2F2ZWRQcm9wcy5oYXNDb250cm9scztcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLl9zYXZlZFByb3BzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5fc2F2ZWRQcm9wcy5zZWxlY3RhYmxlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRYO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRZID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRZO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuZGVmYXVsdEN1cnNvcjtcbiAgICAgICAgdGhpcy5jYW52YXMubW92ZUN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMubW92ZUN1cnNvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhpdHMgZnJvbSBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGV4aXRFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc1RleHRDaGFuZ2VkID0gKHRoaXMuX3RleHRCZWZvcmVFZGl0ICE9PSB0aGlzLnRleHQpO1xuICAgICAgdmFyIGhpZGRlblRleHRhcmVhID0gdGhpcy5oaWRkZW5UZXh0YXJlYTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcblxuICAgICAgaWYgKGhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIGhpZGRlblRleHRhcmVhLmJsdXIgJiYgaGlkZGVuVGV4dGFyZWEuYmx1cigpO1xuICAgICAgICBoaWRkZW5UZXh0YXJlYS5wYXJlbnROb2RlICYmIGhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlkZGVuVGV4dGFyZWEpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYSA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9yZXN0b3JlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzpleGl0ZWQnKTtcbiAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5maXJlKCdtb2RpZmllZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLm9mZignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzpleGl0ZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmNhbnZhcy5maXJlKCdvYmplY3Q6bW9kaWZpZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuZCByZWZsb3cgYSBzdHlsZSBibG9jayBmcm9tIHN0YXJ0IHRvIGVuZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbGluZWFyIHN0YXJ0IHBvc2l0aW9uIGZvciByZW1vdmFsIChpbmNsdWRlZCBpbiByZW1vdmFsKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgbGluZWFyIGVuZCBwb3NpdGlvbiBmb3IgcmVtb3ZhbCAoIGV4Y2x1ZGVkIGZyb20gcmVtb3ZhbCApXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGVGcm9tVG86IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBjdXJzb3JTdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY3Vyc29yRW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGVuZCwgdHJ1ZSksXG4gICAgICAgICAgbGluZVN0YXJ0ID0gY3Vyc29yU3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJTdGFydCA9IGN1cnNvclN0YXJ0LmNoYXJJbmRleCxcbiAgICAgICAgICBsaW5lRW5kID0gY3Vyc29yRW5kLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFyRW5kID0gY3Vyc29yRW5kLmNoYXJJbmRleCxcbiAgICAgICAgICBpLCBzdHlsZU9iajtcbiAgICAgIGlmIChsaW5lU3RhcnQgIT09IGxpbmVFbmQpIHtcbiAgICAgICAgLy8gc3RlcDEgcmVtb3ZlIHRoZSB0cmFpbGluZyBvZiBsaW5lU3RhcnRcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyU3RhcnQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZVN0YXJ0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAyIG1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVFbmQgdG8gbGluZVN0YXJ0IGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUVuZF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyRW5kOyBpIDwgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVFbmRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVFbmRdW2ldO1xuICAgICAgICAgICAgaWYgKHN0eWxlT2JqKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gfHwgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gPSB7IH0pO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdW2NoYXJTdGFydCArIGkgLSBjaGFyRW5kXSA9IHN0eWxlT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwMyBkZXRlY3RzIGxpbmVzIHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBmb3IgKGkgPSBsaW5lU3RhcnQgKyAxOyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwNCBzaGlmdCByZW1haW5pbmcgbGluZXMuXG4gICAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGxpbmVFbmQsIGxpbmVTdGFydCAtIGxpbmVFbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbmQgc2hpZnQgbGVmdCBvbiB0aGUgc2FtZSBsaW5lXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lU3RhcnRdKSB7XG4gICAgICAgICAgc3R5bGVPYmogPSB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdO1xuICAgICAgICAgIHZhciBkaWZmID0gY2hhckVuZCAtIGNoYXJTdGFydCwgbnVtZXJpY0NoYXIsIF9jaGFyO1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IGNoYXJFbmQ7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKF9jaGFyIGluIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICAgIG51bWVyaWNDaGFyID0gcGFyc2VJbnQoX2NoYXIsIDEwKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljQ2hhciA+PSBjaGFyRW5kKSB7XG4gICAgICAgICAgICAgIHN0eWxlT2JqW251bWVyaWNDaGFyIC0gZGlmZl0gPSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBsaW5lIHN0eWxlcyB1cCBvciBkb3duXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IENhbiBhbnkgbnVtYmVyP1xuICAgICAqL1xuICAgIHNoaWZ0TGluZVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4LCBvZmZzZXQpIHtcbiAgICAgIC8vIHNoaWZ0IGFsbCBsaW5lIHN0eWxlcyBieSBvZmZzZXQgdXB3YXJkIG9yIGRvd253YXJkXG4gICAgICAvLyBkbyBub3QgY2xvbmUgZGVlcC4gd2UgbmVlZCBuZXcgYXJyYXksIG5vdCBuZXcgc3R5bGUgb2JqZWN0c1xuICAgICAgdmFyIGNsb25lZFN0eWxlcyA9IGNsb25lKHRoaXMuc3R5bGVzKTtcbiAgICAgIGZvciAodmFyIGxpbmUgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdmFyIG51bWVyaWNMaW5lID0gcGFyc2VJbnQobGluZSwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0xpbmUgPiBsaW5lSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tudW1lcmljTGluZSArIG9mZnNldF0gPSBjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIGlmICghY2xvbmVkU3R5bGVzW251bWVyaWNMaW5lIC0gb2Zmc2V0XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzdGFydEN1cnNvcklmTmVlZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmlzQWJvcnRlZFxuICAgICAgICB8fCAhdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5pc0Fib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbnNlcnRpb24gb2YgbW9yZSBjb25zZWN1dGl2ZSBzdHlsZSBsaW5lcyBmb3Igd2hlbiBvbmUgb3IgbW9yZVxuICAgICAqIG5ld2xpbmVzIGdldHMgYWRkZWQgdG8gdGhlIHRleHQuIFNpbmNlIGN1cnJlbnQgc3R5bGUgbmVlZHMgdG8gYmUgc2hpZnRlZFxuICAgICAqIGZpcnN0IHdlIHNoaWZ0IHRoZSBjdXJyZW50IHN0eWxlIG9mIHRoZSBudW1iZXIgbGluZXMgbmVlZGVkLCB0aGVuIHdlIGFkZFxuICAgICAqIG5ldyBsaW5lcyBmcm9tIHRoZSBsYXN0IHRvIHRoZSBmaXJzdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggSW5kZXggb2YgYSBjaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF0eSBudW1iZXIgb2YgbGluZXMgdG8gYWRkXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgQXJyYXkgb2Ygb2JqZWN0cyBzdHlsZXNcbiAgICAgKi9cbiAgICBpbnNlcnROZXdsaW5lU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBxdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICB2YXIgY3VycmVudENoYXJTdHlsZSxcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzID0ge30sXG4gICAgICAgICAgc29tZXRoaW5nQWRkZWQgPSBmYWxzZSxcbiAgICAgICAgICBpc0VuZE9mTGluZSA9IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCA9PT0gY2hhckluZGV4O1xuXG4gICAgICBxdHkgfHwgKHF0eSA9IDEpO1xuICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUluZGV4LCBxdHkpO1xuICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgY3VycmVudENoYXJTdHlsZSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ID09PSAwID8gY2hhckluZGV4IDogY2hhckluZGV4IC0gMV07XG4gICAgICB9XG4gICAgICAvLyB3ZSBjbG9uZSBzdHlsZXMgb2YgYWxsIGNoYXJzXG4gICAgICAvLyBhZnRlciBjdXJzb3Igb250byB0aGUgY3VycmVudCBsaW5lXG4gICAgICBmb3IgKHZhciBpbmRleCBpbiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHZhciBudW1JbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgICAgIGlmIChudW1JbmRleCA+PSBjaGFySW5kZXgpIHtcbiAgICAgICAgICBzb21ldGhpbmdBZGRlZCA9IHRydWU7XG4gICAgICAgICAgbmV3TGluZVN0eWxlc1tudW1JbmRleCAtIGNoYXJJbmRleF0gPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAvLyByZW1vdmUgbGluZXMgZnJvbSB0aGUgcHJldmlvdXMgbGluZSBzaW5jZSB0aGV5J3JlIG9uIGEgbmV3IGxpbmUgbm93XG4gICAgICAgICAgaWYgKCEoaXNFbmRPZkxpbmUgJiYgY2hhckluZGV4ID09PSAwKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0eWxlQ2FycmllZE92ZXIgPSBmYWxzZTtcbiAgICAgIGlmIChzb21ldGhpbmdBZGRlZCAmJiAhaXNFbmRPZkxpbmUpIHtcbiAgICAgICAgLy8gaWYgaXMgZW5kIG9mIGxpbmUsIHRoZSBleHRyYSBzdHlsZSB3ZSBjb3BpZWRcbiAgICAgICAgLy8gaXMgcHJvYmFibHkgbm90IHNvbWV0aGluZyB3ZSB3YW50XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSBuZXdMaW5lU3R5bGVzO1xuICAgICAgICBzdHlsZUNhcnJpZWRPdmVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZUNhcnJpZWRPdmVyKSB7XG4gICAgICAgIC8vIHNraXAgdGhlIGxhc3QgbGluZSBvZiBzaW5jZSB3ZSBhbHJlYWR5IHByZXBhcmVkIGl0LlxuICAgICAgICBxdHktLTtcbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgYWxsIHRoZSBsaW5lcyBvciBhbGwgdGhlIG90aGVyIGxpbmVzXG4gICAgICAvLyB3ZSBjbG9uZSBjdXJyZW50IGNoYXIgc3R5bGUgb250byB0aGUgbmV4dCAob3RoZXJ3aXNlIGVtcHR5KSBsaW5lXG4gICAgICB3aGlsZSAocXR5ID4gMCkge1xuICAgICAgICBpZiAoY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGVbcXR5IC0gMV0pIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0geyAwOiBjbG9uZShjb3BpZWRTdHlsZVtxdHkgLSAxXSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhclN0eWxlKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IHsgMDogY2xvbmUoY3VycmVudENoYXJTdHlsZSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XTtcbiAgICAgICAgfVxuICAgICAgICBxdHktLTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGxpbmUvY2hhciBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbnRpdHkgbnVtYmVyIFN0eWxlIG9iamVjdCB0byBpbnNlcnQsIGlmIGdpdmVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWN0c1xuICAgICAqL1xuICAgIGluc2VydENoYXJTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF1YW50aXR5LCBjb3BpZWRTdHlsZSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRMaW5lU3R5bGVzICAgICAgID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XSxcbiAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCA9IGN1cnJlbnRMaW5lU3R5bGVzID8gY2xvbmUoY3VycmVudExpbmVTdHlsZXMpIDoge307XG5cbiAgICAgIHF1YW50aXR5IHx8IChxdWFudGl0eSA9IDEpO1xuICAgICAgLy8gc2hpZnQgYWxsIGNoYXIgc3R5bGVzIGJ5IHF1YW50aXR5IGZvcndhcmRcbiAgICAgIC8vIDAsMSwyLDMgLT4gKGNoYXJJbmRleD0yKSAtPiAwLDEsMyw0IC0+IChpbnNlcnQgMikgLT4gMCwxLDIsMyw0XG4gICAgICBmb3IgKHZhciBpbmRleCBpbiBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCkge1xuICAgICAgICB2YXIgbnVtZXJpY0luZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bWVyaWNJbmRleCA+PSBjaGFySW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXggKyBxdWFudGl0eV0gPSBjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXhdO1xuICAgICAgICAgIC8vIG9ubHkgZGVsZXRlIHRoZSBzdHlsZSBpZiB0aGVyZSB3YXMgbm90aGluZyBtb3ZlZCB0aGVyZVxuICAgICAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXNDbG9uZWRbbnVtZXJpY0luZGV4IC0gcXVhbnRpdHldKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgd2hpbGUgKHF1YW50aXR5LS0pIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGNvcGllZFN0eWxlW3F1YW50aXR5XSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ICsgcXVhbnRpdHldID0gY2xvbmUoY29waWVkU3R5bGVbcXVhbnRpdHldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRMaW5lU3R5bGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTdHlsZSA9IGN1cnJlbnRMaW5lU3R5bGVzW2NoYXJJbmRleCA/IGNoYXJJbmRleCAtIDEgOiAxXTtcbiAgICAgIHdoaWxlIChuZXdTdHlsZSAmJiBxdWFudGl0eS0tKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ICsgcXVhbnRpdHldID0gY2xvbmUobmV3U3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHN0eWxlIG9iamVjdChzKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluc2VydGVkVGV4dCBDaGFyYWN0ZXJzIGF0IHRoZSBsb2NhdGlvbiB3aGVyZSBzdHlsZSBpcyBpbnNlcnRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBjdXJzb3IgaW5kZXggZm9yIGluc2VydGluZyBzdHlsZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb3BpZWRTdHlsZV0gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyB0byBpbnNlcnQuXG4gICAgICovXG4gICAgaW5zZXJ0TmV3U3R5bGVCbG9jazogZnVuY3Rpb24oaW5zZXJ0ZWRUZXh0LCBzdGFydCwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJzb3JMb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGFkZGVkTGluZXMgPSBbMF0sIGxpbmVzTGVuZ3RoID0gMDtcbiAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBob3cgbWFueSBjaGFyIHBlciBsaW5lcyBhcmUgYmVpbmcgYWRkZWQuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc2VydGVkVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5zZXJ0ZWRUZXh0W2ldID09PSAnXFxuJykge1xuICAgICAgICAgIGxpbmVzTGVuZ3RoKys7XG4gICAgICAgICAgYWRkZWRMaW5lc1tsaW5lc0xlbmd0aF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFkZGVkTGluZXNbbGluZXNMZW5ndGhdKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgZmlyc3QgbGluZSBjb3B5IHRoZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGNoYXIgcG9zaXRpb24uXG4gICAgICBpZiAoYWRkZWRMaW5lc1swXSA+IDApIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCwgY3Vyc29yTG9jLmNoYXJJbmRleCwgYWRkZWRMaW5lc1swXSwgY29waWVkU3R5bGUpO1xuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbMF0gKyAxKTtcbiAgICAgIH1cbiAgICAgIGxpbmVzTGVuZ3RoICYmIHRoaXMuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0KFxuICAgICAgICBjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4ICsgYWRkZWRMaW5lc1swXSwgbGluZXNMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tjdXJzb3JMb2MubGluZUluZGV4ICsgaV1bMF0gPSBjb3BpZWRTdHlsZVswXTtcbiAgICAgICAgfVxuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbaV0gKyAxKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHVzZSBpIG91dHNpZGUgdGhlIGxvb3AgdG8gZ2V0IGl0IGxpa2UgbGluZXNMZW5ndGhcbiAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4ICsgaSwgMCwgYWRkZWRMaW5lc1tpXSwgY29waWVkU3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgYWNjb3JkaW5nIHRvIHRoZSBuZXcgcG9zaXRpb24gb2YgY3Vyc29yXG4gICAgICogbWltaWMgdGhlIGtleSAtIG1vdXNlIG5hdmlnYXRpb24gd2hlbiBzaGlmdCBpcyBwcmVzc2VkLlxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pIHtcbiAgICAgIGlmIChuZXdTZWxlY3Rpb24gPD0gc3RhcnQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5ld1NlbGVjdGlvbiA+IHN0YXJ0ICYmIG5ld1NlbGVjdGlvbiA8IGVuZCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5ld1NlbGVjdGlvbiBpcyA+IHNlbGVjdGlvbiBzdGFydCBhbmQgZW5kXG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcImRiY2xpY2tcIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgIC8vIGZvciBkb3VibGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgLy8gZm9yIHRyaXBsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0geyB9O1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0byBzaW11bGF0ZSB0cmlwbGUgY2xpY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fbmV3Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG5ld1BvaW50ZXIgPSBvcHRpb25zLnBvaW50ZXI7XG4gICAgaWYgKHRoaXMuaXNUcmlwbGVDbGljayhuZXdQb2ludGVyKSkge1xuICAgICAgdGhpcy5maXJlKCd0cmlwbGVjbGljaycsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3RvcEV2ZW50KG9wdGlvbnMuZSk7XG4gICAgfVxuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9IHRoaXMuX19sYXN0Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gdGhpcy5fX25ld0NsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSBuZXdQb2ludGVyO1xuICAgIHRoaXMuX19sYXN0SXNFZGl0aW5nID0gdGhpcy5pc0VkaXRpbmc7XG4gICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG4gIH0sXG5cbiAgaXNUcmlwbGVDbGljazogZnVuY3Rpb24obmV3UG9pbnRlcikge1xuICAgIHJldHVybiB0aGlzLl9fbmV3Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgLSB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnggPT09IG5ld1BvaW50ZXIueCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueSA9PT0gbmV3UG9pbnRlci55O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0b3BFdmVudDogZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50IGhhbmRsZXJzIHJlbGF0ZWQgdG8gY3Vyc29yIG9yIHNlbGVjdGlvblxuICAgKi9cbiAgaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluaXRNb3VzZWRvd25IYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0TW91c2V1cEhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRDbGlja3MoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoYW5kbGVyIGZvciBkb3VibGUgY2xpY2ssIHNlbGVjdCBhIHdvcmRcbiAgICovXG4gIGRvdWJsZUNsaWNrSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RXb3JkKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoYW5kbGVyIGZvciB0cmlwbGUgY2xpY2ssIHNlbGVjdCBhIGxpbmVcbiAgICovXG4gIHRyaXBsZUNsaWNrSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RMaW5lKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZG91YmxlIGFuZCB0cmlwbGUgY2xpY2sgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGluaXRDbGlja3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZGJsY2xpY2snLCB0aGlzLmRvdWJsZUNsaWNrSGFuZGxlcik7XG4gICAgdGhpcy5vbigndHJpcGxlY2xpY2snLCB0aGlzLnRyaXBsZUNsaWNrSGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gX21vdXNlRG93blxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiBmaW5kIHRoZSBjbGljayBwb3NpdGlvbiwgc2V0IHNlbGVjdGlvblN0YXJ0XG4gICAqIGZpbmQgc2VsZWN0aW9uRW5kLCBpbml0aWFsaXplIHRoZSBkcmF3aW5nIG9mIGVpdGhlciBjdXJzb3Igb3Igc2VsZWN0aW9uIGFyZWFcbiAgICogaW5pdGlhbGl6aW5nIGEgbW91c2VkRG93biBvbiBhIHRleHQgYXJlYSB3aWxsIGNhbmNlbCBmYWJyaWNqcyBrbm93bGVkZ2Ugb2ZcbiAgICogY3VycmVudCBjb21wb3NpdGlvbk1vZGUuIEl0IHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fX2lzTW91c2Vkb3duID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLnNldEN1cnNvckJ5Q2xpY2sob3B0aW9ucy5lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXMgbmVlZGVkIG9uIG1vdXNlZG93bjpiZWZvcmVcbiAgICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudC5cbiAgICogU2NvcGUgb2YgdGhpcyBpbXBsZW1lbnRhdGlvbiBpczogdmVyaWZ5IHRoZSBvYmplY3QgaXMgYWxyZWFkeSBzZWxlY3RlZCB3aGVuIG1vdXNpbmcgZG93blxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXJCZWZvcmU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHdlIHdhbnQgdG8gYXZvaWQgdGhhdCBhbiBvYmplY3QgdGhhdCB3YXMgc2VsZWN0ZWQgYW5kIHRoZW4gYmVjb21lcyB1bnNlbGVjdGFibGUsXG4gICAgLy8gbWF5IHRyaWdnZXIgZWRpdGluZyBtb2RlIGluIHNvbWUgd2F5LlxuICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzID09PSB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNlZG93blwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZWRvd25IYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyKTtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd246YmVmb3JlJywgdGhpcy5fbW91c2VEb3duSGFuZGxlckJlZm9yZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2V1cFwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZXVwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMubW91c2VVcEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzdGFuZGFyZCBoYW5kbGVyIGZvciBtb3VzZSB1cCwgb3ZlcnJpZGFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1vdXNlVXBIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmVkaXRhYmxlIHx8IHRoaXMuZ3JvdXAgfHxcbiAgICAgIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvcHRpb25zLnRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQpIHx8XG4gICAgICAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmUgPSB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmUgJiYgY3VycmVudEFjdGl2ZSAhPT0gdGhpcykge1xuICAgICAgICAvLyBhdm9pZCBydW5uaW5nIHRoaXMgbG9naWMgd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmUgb2JqZWN0XG4gICAgICAgIC8vIHRoaXMgYmVjYXVzZSBpcyBwb3NzaWJsZSB3aXRoIHNoaWZ0IGNsaWNrIGFuZCBmYXN0IGNsaWNrcyxcbiAgICAgICAgLy8gdG8gcmFwaWRseSBkZXNlbGVjdCBhbmQgcmVzZWxlY3QgdGhpcyBvYmplY3QgYW5kIHRyaWdnZXIgYW4gZW50ZXJFZGl0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX2xhc3RTZWxlY3RlZCAmJiAhdGhpcy5fX2Nvcm5lcikge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbnRlckVkaXRpbmcob3B0aW9ucy5lKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZXMgY3Vyc29yIGxvY2F0aW9uIGluIGEgdGV4dCBkZXBlbmRpbmcgb24gcGFzc2VkIHBvaW50ZXIgKHgveSkgb2JqZWN0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBzZXRDdXJzb3JCeUNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihlKSxcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCBlbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdChzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5kZXggb2YgYSBjaGFyYWN0ZXIgY29ycmVzcG9uZGluZyB0byB3aGVyZSBhbiBvYmplY3Qgd2FzIGNsaWNrZWRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcjogZnVuY3Rpb24oZSkge1xuICAgIHZhciBtb3VzZU9mZnNldCA9IHRoaXMuZ2V0TG9jYWxQb2ludGVyKGUpLFxuICAgICAgICBwcmV2V2lkdGggPSAwLFxuICAgICAgICB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGNoYXJJbmRleCA9IDAsXG4gICAgICAgIGxpbmVJbmRleCA9IDAsXG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICBsaW5lO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGhlaWdodCA8PSBtb3VzZU9mZnNldC55KSB7XG4gICAgICAgIGhlaWdodCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsaW5lSW5kZXggPSBpO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBjaGFySW5kZXggKz0gdGhpcy5fdGV4dExpbmVzW2kgLSAxXS5sZW5ndGggKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCk7XG4gICAgd2lkdGggPSBsaW5lTGVmdE9mZnNldCAqIHRoaXMuc2NhbGVYO1xuICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XTtcbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBwcmV2V2lkdGggPSB3aWR0aDtcbiAgICAgIC8vIGkgcmVtb3ZlZCBzb21ldGhpbmcgYWJvdXQgZmxpcFggaGVyZSwgY2hlY2suXG4gICAgICB3aWR0aCArPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2pdLmtlcm5lZFdpZHRoICogdGhpcy5zY2FsZVg7XG4gICAgICBpZiAod2lkdGggPD0gbW91c2VPZmZzZXQueCkge1xuICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldChtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgY2hhckluZGV4LCBqbGVuKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQ6IGZ1bmN0aW9uKG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBpbmRleCwgamxlbikge1xuICAgIC8vIHdlIG5lZWQgTWF0aC5hYnMgYmVjYXVzZSB3aGVuIHdpZHRoIGlzIGFmdGVyIHRoZSBsYXN0IGNoYXIsIHRoZSBvZmZzZXQgaXMgZ2l2ZW4gYXMgMSwgd2hpbGUgaXMgMFxuICAgIHZhciBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yID0gbW91c2VPZmZzZXQueCAtIHByZXZXaWR0aCxcbiAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA9IHdpZHRoIC0gbW91c2VPZmZzZXQueCxcbiAgICAgICAgb2Zmc2V0ID0gZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA+IGRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IgfHxcbiAgICAgICAgICBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yIDwgMCA/IDAgOiAxLFxuICAgICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IGluZGV4ICsgb2Zmc2V0O1xuICAgIC8vIGlmIG9iamVjdCBpcyBob3Jpem9udGFsbHkgZmxpcHBlZCwgbWlycm9yIGN1cnNvciBsb2NhdGlvbiBmcm9tIHRoZSBlbmRcbiAgICBpZiAodGhpcy5mbGlwWCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBqbGVuIC0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5fdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1NlbGVjdGlvblN0YXJ0O1xuICB9XG59KTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGhpZGRlbiB0ZXh0YXJlYSAobmVlZGVkIHRvIGJyaW5nIHVwIGtleWJvYXJkIGluIGlPUylcbiAgICovXG4gIGluaXRIaWRkZW5UZXh0YXJlYTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYSA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NvcnJlY3QnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdkYXRhLWZhYnJpYy1oaWRkZW50ZXh0YXJlYScsICcnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnd3JhcCcsICdvZmYnKTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLl9jYWxjVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIC8vIGxpbmUtaGVpZ2h0OiAxcHg7IHdhcyByZW1vdmVkIGZyb20gdGhlIHN0eWxlIHRvIGZpeCB0aGlzOlxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg3MDk2NlxuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogJyArIHN0eWxlLnRvcCArXG4gICAgJzsgbGVmdDogJyArIHN0eWxlLmxlZnQgKyAnOyB6LWluZGV4OiAtOTk5OyBvcGFjaXR5OiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFweDsgZm9udC1zaXplOiAxcHg7JyArXG4gICAgJyBwYWRkaW5n772wdG9wOiAnICsgc3R5bGUuZm9udFNpemUgKyAnOyc7XG4gICAgZmFicmljLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG5cbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5ZG93bicsIHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnaW5wdXQnLCB0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvcHknLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2N1dCcsIHRoaXMuY29weS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAncGFzdGUnLCB0aGlzLnBhc3RlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnN0YXJ0JywgdGhpcy5vbkNvbXBvc2l0aW9uU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9udXBkYXRlJywgdGhpcy5vbkNvbXBvc2l0aW9uVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbmVuZCcsIHRoaXMub25Db21wb3NpdGlvbkVuZC5iaW5kKHRoaXMpKTtcblxuICAgIGlmICghdGhpcy5fY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5jYW52YXMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5RG93blxuICAgKiBNYXAgYSBzcGVjaWFsIGtleSB0byBhIGZ1bmN0aW9uIG9mIHRoZSBpbnN0YW5jZS9wcm90b3R5cGVcbiAgICogSWYgeW91IG5lZWQgZGlmZmVyZW50IGJlaGF2aW91ciBmb3IgRVNDIG9yIFRBQiBvciBhcnJvd3MsIHlvdSBoYXZlIHRvIGNoYW5nZVxuICAgKiB0aGlzIG1hcCBzZXR0aW5nIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdGhhdCB5b3UgYnVpbGQgb24gdGhlIGZhYnJpYy5JdGV4dCBvclxuICAgKiB5b3VyIHByb3RvdHlwZS5cbiAgICogdGhlIG1hcCBjaGFuZ2Ugd2lsbCBhZmZlY3QgYWxsIEluc3RhbmNlcyB1bmxlc3MgeW91IG5lZWQgZm9yIG9ubHkgc29tZSB0ZXh0IEluc3RhbmNlc1xuICAgKiBpbiB0aGF0IGNhc2UgeW91IGhhdmUgdG8gY2xvbmUgdGhpcyBvYmplY3QgYW5kIGFzc2lnbiB5b3VyIEluc3RhbmNlLlxuICAgKiB0aGlzLmtleXNNYXAgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5rZXlzTWFwKTtcbiAgICogVGhlIGZ1bmN0aW9uIG11c3QgYmUgaW4gZmFicmljLkl0ZXh0LnByb3RvdHlwZS5teUZ1bmN0aW9uIEFuZCB3aWxsIHJlY2VpdmUgZXZlbnQgYXMgYXJnc1swXVxuICAgKi9cbiAga2V5c01hcDoge1xuICAgIDk6ICAnZXhpdEVkaXRpbmcnLFxuICAgIDI3OiAnZXhpdEVkaXRpbmcnLFxuICAgIDMzOiAnbW92ZUN1cnNvclVwJyxcbiAgICAzNDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICAzNTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzY6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzc6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzg6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM5OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICA0MDogJ21vdmVDdXJzb3JEb3duJyxcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlVcCArIGN0cmwgfHwgY21kXG4gICAqL1xuICBjdHJsS2V5c01hcFVwOiB7XG4gICAgNjc6ICdjb3B5JyxcbiAgICA4ODogJ2N1dCdcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlEb3duICsgY3RybCB8fCBjbWRcbiAgICovXG4gIGN0cmxLZXlzTWFwRG93bjoge1xuICAgIDY1OiAnc2VsZWN0QWxsJ1xuICB9LFxuXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5vIG5lZWQgdG8gdHJpZ2dlciBjbGljayBldmVudCBoZXJlLCBmb2N1cyBpcyBlbm91Z2ggdG8gaGF2ZSB0aGUga2V5Ym9hcmQgYXBwZWFyIG9uIEFuZHJvaWRcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50XG4gICAqIG9ubHkgdXNlZCBmb3IgYXJyb3dzIGFuZCBjb21iaW5hdGlvbiBvZiBtb2RpZmllciBrZXlzLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5rZXlDb2RlIGluIHRoaXMua2V5c01hcCkge1xuICAgICAgdGhpc1t0aGlzLmtleXNNYXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcERvd24pICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgdGhpc1t0aGlzLmN0cmxLZXlzTWFwRG93bltlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLmtleUNvZGUgPj0gMzMgJiYgZS5rZXlDb2RlIDw9IDQwKSB7XG4gICAgICAvLyBpZiBpIHByZXNzIGFuIGFycm93IGtleSBqdXN0IHVwZGF0ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXl1cCBldmVudFxuICAgKiBXZSBoYW5kbGUgS2V5VXAgYmVjYXVzZSBpZTExIGFuZCBlZGdlIGhhdmUgZGlmZmljdWx0aWVzIGNvcHkvcGFzdGluZ1xuICAgKiBpZiBhIGNvcHkvY3V0IGV2ZW50IGZpcmVkLCBrZXl1cCBpcyBkaXNtaXNzZWRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uS2V5VXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nIHx8IHRoaXMuX2NvcHlEb25lIHx8IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgIHRoaXMuX2NvcHlEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuY3RybEtleXNNYXBVcCkgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBVcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBvbklucHV0IGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbklucHV0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGZyb21QYXN0ZSA9IHRoaXMuZnJvbVBhc3RlO1xuICAgIHRoaXMuZnJvbVBhc3RlID0gZmFsc2U7XG4gICAgZSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZGVjaXNpb25zIGFib3V0IHN0eWxlIGNoYW5nZXMuXG4gICAgdmFyIG5leHRUZXh0ID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUpLmdyYXBoZW1lVGV4dCxcbiAgICAgICAgY2hhckNvdW50ID0gdGhpcy5fdGV4dC5sZW5ndGgsXG4gICAgICAgIG5leHRDaGFyQ291bnQgPSBuZXh0VGV4dC5sZW5ndGgsXG4gICAgICAgIHJlbW92ZWRUZXh0LCBpbnNlcnRlZFRleHQsXG4gICAgICAgIGNoYXJEaWZmID0gbmV4dENoYXJDb3VudCAtIGNoYXJDb3VudCxcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbkVuZCxcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCxcbiAgICAgICAgY29waWVkU3R5bGUsIHJlbW92ZUZyb20sIHJlbW92ZVRvO1xuICAgIGlmICh0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID09PSAnJykge1xuICAgICAgdGhpcy5zdHlsZXMgPSB7IH07XG4gICAgICB0aGlzLnVwZGF0ZUZyb21UZXh0QXJlYSgpO1xuICAgICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dGFyZWFTZWxlY3Rpb24gPSB0aGlzLmZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uKFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZVxuICAgICk7XG4gICAgdmFyIGJhY2tEZWxldGUgPSBzZWxlY3Rpb25TdGFydCA+IHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvblN0YXJ0O1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgY2hhckRpZmYgKz0gc2VsZWN0aW9uRW5kIC0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5leHRDaGFyQ291bnQgPCBjaGFyQ291bnQpIHtcbiAgICAgIGlmIChiYWNrRGVsZXRlKSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZShzZWxlY3Rpb25FbmQgKyBjaGFyRGlmZiwgc2VsZWN0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvblN0YXJ0IC0gY2hhckRpZmYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRlZFRleHQgPSBuZXh0VGV4dC5zbGljZSh0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQgLSBjaGFyRGlmZiwgdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uRW5kKTtcbiAgICBpZiAocmVtb3ZlZFRleHQgJiYgcmVtb3ZlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoaW5zZXJ0ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAvLyBsZXQncyBjb3B5IHNvbWUgc3R5bGUgYmVmb3JlIGRlbGV0aW5nLlxuICAgICAgICAvLyB3ZSB3YW50IHRvIGNvcHkgdGhlIHN0eWxlIGJlZm9yZSB0aGUgY3Vyc29yIE9SIHRoZSBzdHlsZSBhdCB0aGUgY3Vyc29yIGlmIHNlbGVjdGlvblxuICAgICAgICAvLyBpcyBiaWdnZXIgdGhhbiAwLlxuICAgICAgICBjb3BpZWRTdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGVzKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25TdGFydCArIDEsIGZhbHNlKTtcbiAgICAgICAgLy8gbm93IGR1cGxpY2F0ZSB0aGUgc3R5bGUgb25lIGZvciBlYWNoIGluc2VydGVkIHRleHQuXG4gICAgICAgIGNvcGllZFN0eWxlID0gaW5zZXJ0ZWRUZXh0Lm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyB0aGlzIHJldHVybiBhbiBhcnJheSBvZiByZWZlcmVuY2VzLCBidXQgdGhhdCBpcyBmaW5lIHNpbmNlIHdlIGFyZVxuICAgICAgICAgIC8vIGNvcHlpbmcgdGhlIHN0eWxlIGxhdGVyLlxuICAgICAgICAgIHJldHVybiBjb3BpZWRTdHlsZVswXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbW92ZUZyb20gPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgcmVtb3ZlVG8gPSBzZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrRGVsZXRlKSB7XG4gICAgICAgIC8vIGRldGVjdCBkaWZmZXJlbmNlcyBiZXR3ZWVuIGZvcndhcmREZWxldGUgYW5kIGJhY2tEZWxldGVcbiAgICAgICAgcmVtb3ZlRnJvbSA9IHNlbGVjdGlvbkVuZCAtIHJlbW92ZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgcmVtb3ZlVG8gPSBzZWxlY3Rpb25FbmQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbSA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgcmVtb3ZlVG8gPSBzZWxlY3Rpb25FbmQgKyByZW1vdmVkVGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHJlbW92ZUZyb20sIHJlbW92ZVRvKTtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmIChmcm9tUGFzdGUgJiYgaW5zZXJ0ZWRUZXh0LmpvaW4oJycpID09PSBmYWJyaWMuY29waWVkVGV4dCAmJiAhZmFicmljLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSkge1xuICAgICAgICBjb3BpZWRTdHlsZSA9IGZhYnJpYy5jb3BpZWRUZXh0U3R5bGU7XG4gICAgICB9XG4gICAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soaW5zZXJ0ZWRUZXh0LCBzZWxlY3Rpb25TdGFydCwgY29waWVkU3R5bGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUZyb21UZXh0QXJlYSgpO1xuICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQ29tcG9zaXRpb24gc3RhcnRcbiAgICovXG4gIG9uQ29tcG9zaXRpb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBvc2l0aW9uIGVuZFxuICAgKi9cbiAgb25Db21wb3NpdGlvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IGZhbHNlO1xuICB9LFxuXG4gIC8vIC8qKlxuICAvLyAgKiBDb21wb3NpdGlvbiB1cGRhdGVcbiAgLy8gICovXG4gIG9uQ29tcG9zaXRpb25VcGRhdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmNvbXBvc2l0aW9uU3RhcnQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydDtcbiAgICB0aGlzLmNvbXBvc2l0aW9uRW5kID0gZS50YXJnZXQuc2VsZWN0aW9uRW5kO1xuICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3BpZXMgc2VsZWN0ZWQgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAvL2RvIG5vdCBjdXQtY29weSBpZiBubyBzZWxlY3Rpb25cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWJyaWMuY29waWVkVGV4dCA9IHRoaXMuZ2V0U2VsZWN0ZWRUZXh0KCk7XG4gICAgaWYgKCFmYWJyaWMuZGlzYWJsZVN0eWxlQ29weVBhc3RlKSB7XG4gICAgICBmYWJyaWMuY29waWVkVGV4dFN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZXModGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9jb3B5RG9uZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhc3RlcyB0ZXh0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBwYXN0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5mcm9tUGFzdGUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IENsaXBib2FyZCBkYXRhIG9iamVjdFxuICAgKi9cbiAgX2dldENsaXBib2FyZERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZS5jbGlwYm9hcmREYXRhKSB8fCBmYWJyaWMud2luZG93LmNsaXBib2FyZERhdGE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSB3aWR0aCBpbiBwaXhlbHMgYmVmb3JlIHRoZSBjdXJzb3Igb24gdGhlIHNhbWUgbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aEJlZm9yZUN1cnNvciB3aWR0aCBiZWZvcmUgY3Vyc29yXG4gICAqL1xuICBfZ2V0V2lkdGhCZWZvcmVDdXJzb3I6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KSwgYm91bmQ7XG5cbiAgICBpZiAoY2hhckluZGV4ID4gMCkge1xuICAgICAgYm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleCAtIDFdO1xuICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgKz0gYm91bmQubGVmdCArIGJvdW5kLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGhCZWZvcmVDdXJzb3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgc3RhcnQgb2Zmc2V0IG9mIGEgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXREb3duQ3Vyc29yT2Zmc2V0OiBmdW5jdGlvbihlLCBpc1JpZ2h0KSB7XG4gICAgdmFyIHNlbGVjdGlvblByb3AgPSB0aGlzLl9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQoZSwgaXNSaWdodCksXG4gICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvblByb3ApLFxuICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXg7XG4gICAgLy8gaWYgb24gbGFzdCBsaW5lLCBkb3duIGN1cnNvciBnb2VzIHRvIGVuZCBvZiBsaW5lXG4gICAgaWYgKGxpbmVJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aCAtIDEgfHwgZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzQpIHtcbiAgICAgIC8vIG1vdmUgdG8gdGhlIGVuZCBvZiBhIHRleHRcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0Lmxlbmd0aCAtIHNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4ICsgMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QWZ0ZXJDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZShjaGFySW5kZXgpO1xuICAgIHJldHVybiB0ZXh0QWZ0ZXJDdXJzb3IubGVuZ3RoICsgaW5kZXhPbk90aGVyTGluZSArIDEgKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGxpbmVJbmRleCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHByaXZhdGVcbiAgICogSGVscHMgZmluZGluZyBpZiB0aGUgb2Zmc2V0IHNob3VsZCBiZSBjb3VudGVkIGZyb20gU3RhcnQgb3IgRW5kXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBfZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0OiBmdW5jdGlvbihlLCBpc1JpZ2h0KSB7XG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5zZWxlY3Rpb25FbmQgJiYgaXNSaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFVwQ3Vyc29yT2Zmc2V0OiBmdW5jdGlvbihlLCBpc1JpZ2h0KSB7XG4gICAgdmFyIHNlbGVjdGlvblByb3AgPSB0aGlzLl9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQoZSwgaXNSaWdodCksXG4gICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvblByb3ApLFxuICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXg7XG4gICAgaWYgKGxpbmVJbmRleCA9PT0gMCB8fCBlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzMykge1xuICAgICAgLy8gaWYgb24gZmlyc3QgbGluZSwgdXAgY3Vyc29yIGdvZXMgdG8gc3RhcnQgb2YgbGluZVxuICAgICAgcmV0dXJuIC1zZWxlY3Rpb25Qcm9wO1xuICAgIH1cbiAgICB2YXIgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldFdpZHRoQmVmb3JlQ3Vyc29yKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgaW5kZXhPbk90aGVyTGluZSA9IHRoaXMuX2dldEluZGV4T25MaW5lKGxpbmVJbmRleCAtIDEsIHdpZHRoQmVmb3JlQ3Vyc29yKSxcbiAgICAgICAgdGV4dEJlZm9yZUN1cnNvciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLnNsaWNlKDAsIGNoYXJJbmRleCksXG4gICAgICAgIG1pc3NpbmdOZXdsaW5lT2Zmc2V0ID0gdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChsaW5lSW5kZXggLSAxKTtcbiAgICAvLyByZXR1cm4gYSBuZWdhdGl2ZSBvZmZzZXRcbiAgICByZXR1cm4gLXRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXggLSAxXS5sZW5ndGhcbiAgICAgKyBpbmRleE9uT3RoZXJMaW5lIC0gdGV4dEJlZm9yZUN1cnNvci5sZW5ndGggKyAoMSAtIG1pc3NpbmdOZXdsaW5lT2Zmc2V0KTtcbiAgfSxcblxuICAvKipcbiAgICogZm9yIGEgZ2l2ZW4gd2lkdGggaXQgZm91bmRzIHRoZSBtYXRjaGluZyBjaGFyYWN0ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0SW5kZXhPbkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCwgd2lkdGgpIHtcblxuICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KSxcbiAgICAgICAgd2lkdGhPZkNoYXJzT25MaW5lID0gbGluZUxlZnRPZmZzZXQsXG4gICAgICAgIGluZGV4T25MaW5lID0gMCwgY2hhcldpZHRoLCBmb3VuZE1hdGNoO1xuXG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgY2hhcldpZHRoID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtqXS53aWR0aDtcbiAgICAgIHdpZHRoT2ZDaGFyc09uTGluZSArPSBjaGFyV2lkdGg7XG4gICAgICBpZiAod2lkdGhPZkNoYXJzT25MaW5lID4gd2lkdGgpIHtcbiAgICAgICAgZm91bmRNYXRjaCA9IHRydWU7XG4gICAgICAgIHZhciBsZWZ0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSAtIGNoYXJXaWR0aCxcbiAgICAgICAgICAgIHJpZ2h0RWRnZSA9IHdpZHRoT2ZDaGFyc09uTGluZSxcbiAgICAgICAgICAgIG9mZnNldEZyb21MZWZ0RWRnZSA9IE1hdGguYWJzKGxlZnRFZGdlIC0gd2lkdGgpLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbVJpZ2h0RWRnZSA9IE1hdGguYWJzKHJpZ2h0RWRnZSAtIHdpZHRoKTtcblxuICAgICAgICBpbmRleE9uTGluZSA9IG9mZnNldEZyb21SaWdodEVkZ2UgPCBvZmZzZXRGcm9tTGVmdEVkZ2UgPyBqIDogKGogLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVhY2hlZCBlbmRcbiAgICBpZiAoIWZvdW5kTWF0Y2gpIHtcbiAgICAgIGluZGV4T25MaW5lID0gbGluZS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleE9uTGluZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgZG93blxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA+PSB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ0Rvd24nLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yVXA6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yVXBPckRvd24oJ1VwJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCBvciBkb3duLCBmaXJlcyB0aGUgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ1VwJyBvciAnRG93bidcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yVXBPckRvd246IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIC8vIGdldFVwQ3Vyc29yT2Zmc2V0XG4gICAgLy8gZ2V0RG93bkN1cnNvck9mZnNldFxuICAgIHZhciBhY3Rpb24gPSAnZ2V0JyArIGRpcmVjdGlvbiArICdDdXJzb3JPZmZzZXQnLFxuICAgICAgICBvZmZzZXQgPSB0aGlzW2FjdGlvbl0oZSwgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKTtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0KG9mZnNldCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB3aXRoIHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRoU2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0J1xuICAgICAgPyB0aGlzLnNlbGVjdGlvblN0YXJ0ICsgb2Zmc2V0XG4gICAgICA6IHRoaXMuc2VsZWN0aW9uRW5kICsgb2Zmc2V0O1xuICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsIG5ld1NlbGVjdGlvbik7XG4gICAgcmV0dXJuIG9mZnNldCAhPT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwIHdpdGhvdXQgc2hpZnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgbW92ZUN1cnNvcldpdGhvdXRTaGlmdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kICs9IG9mZnNldDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCAhPT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdMZWZ0JywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgYSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIF9tb3ZlOiBmdW5jdGlvbihlLCBwcm9wLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgbmV3VmFsdWU7XG4gICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXNbJ2ZpbmRXb3JkQm91bmRhcnknICsgZGlyZWN0aW9uXSh0aGlzW3Byb3BdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzUgfHwgIGUua2V5Q29kZSA9PT0gMzYgKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXNbJ2ZpbmRMaW5lQm91bmRhcnknICsgZGlyZWN0aW9uXSh0aGlzW3Byb3BdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzW3Byb3BdICs9IGRpcmVjdGlvbiA9PT0gJ0xlZnQnID8gLTEgOiAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzW3Byb3BdICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpc1twcm9wXSA9IG5ld1ZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVMZWZ0OiBmdW5jdGlvbihlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUoZSwgcHJvcCwgJ0xlZnQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlUmlnaHQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnUmlnaHQnKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2l0aG91dCBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcblxuICAgIC8vIG9ubHkgbW92ZSBjdXJzb3Igd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24sXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGRpc2NhcmQgaXQsIGFuZCBsZWF2ZSBjdXJzb3Igb24gc2FtZSBwbGFjZVxuICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA9PT0gdGhpcy5zZWxlY3Rpb25TdGFydCAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKSB7XG4gICAgICBjaGFuZ2UgPSB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcblxuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnRXaXRoU2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKXtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdSaWdodCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgb3IgTGVmdCwgZmlyZXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnTGVmdCcsICdSaWdodCdcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQ6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIHZhciBhY3Rpb25OYW1lID0gJ21vdmVDdXJzb3InICsgZGlyZWN0aW9uICsgJ1dpdGgnO1xuICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdTaGlmdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWN0aW9uTmFtZSArPSAnb3V0U2hpZnQnO1xuICAgIH1cbiAgICBpZiAodGhpc1thY3Rpb25OYW1lXShlKSkge1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCAhPT0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25FbmQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHRXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcblxuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgY2hhbmdlZCA9IHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGNoYXJhY3RlcnMgZnJvbSBzdGFydC9lbmRcbiAgICogc3RhcnQvZW5kIGFyIHBlciBncmFwaGVtZSBwb3NpdGlvbiBpbiBfdGV4dCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgZGVmYXVsdCB0byBzdGFydCArIDFcbiAgICovXG4gIHJlbW92ZUNoYXJzOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fdGV4dC5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogaW5zZXJ0IGNoYXJhY3RlcnMgYXQgc3RhcnQgcG9zaXRpb24sIGJlZm9yZSBzdGFydCBwb3NpdGlvbi5cbiAgICogc3RhcnQgIGVxdWFsIDEgaXQgbWVhbnMgdGhlIHRleHQgZ2V0IGluc2VydGVkIGJldHdlZW4gYWN0dWFsIGdyYXBoZW1lIDAgYW5kIDFcbiAgICogaWYgc3R5bGUgYXJyYXkgaXMgcHJvdmlkZWQsIGl0IG11c3QgYmUgYXMgdGhlIHNhbWUgbGVuZ3RoIG9mIHRleHQgaW4gZ3JhcGhlbWVzXG4gICAqIGlmIGVuZCBpcyBwcm92aWRlZCBhbmQgaXMgYmlnZ2VyIHRoYW4gc3RhcnQsIG9sZCB0ZXh0IGlzIHJlcGxhY2VkLlxuICAgKiBzdGFydC9lbmQgYXIgcGVyIGdyYXBoZW1lIHBvc2l0aW9uIGluIF90ZXh0IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGRlZmF1bHQgdG8gc3RhcnQgKyAxXG4gICAqL1xuICBpbnNlcnRDaGFyczogZnVuY3Rpb24odGV4dCwgc3R5bGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHZhciBncmFwaGVtZXMgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh0ZXh0KTtcbiAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soZ3JhcGhlbWVzLCBzdGFydCwgc3R5bGUpO1xuICAgIHRoaXMuX3RleHQgPSBbXS5jb25jYXQodGhpcy5fdGV4dC5zbGljZSgwLCBzdGFydCksIGdyYXBoZW1lcywgdGhpcy5fdGV4dC5zbGljZShlbmQpKTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxufSk7XG5cblxuLyogX1RPX1NWR19TVEFSVF8gKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgbXVsdGlwbGVTcGFjZXNSZWdleCA9IC8gICsvZztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvZmZzZXRzID0gdGhpcy5fZ2V0U1ZHTGVmdFRvcE9mZnNldHMoKSxcbiAgICAgICAgICB0ZXh0QW5kQmcgPSB0aGlzLl9nZXRTVkdUZXh0QW5kQmcob2Zmc2V0cy50ZXh0VG9wLCBvZmZzZXRzLnRleHRMZWZ0KTtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwU1ZHVGV4dEFuZEJnKHRleHRBbmRCZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cChcbiAgICAgICAgdGhpcy5fdG9TVkcoKSxcbiAgICAgICAgeyByZXZpdmVyOiByZXZpdmVyLCBub1N0eWxlOiB0cnVlLCB3aXRoU2hhZG93OiB0cnVlIH1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNWR0xlZnRUb3BPZmZzZXRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHRMZWZ0OiAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHRleHRUb3A6IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIGxpbmVUb3A6IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKDApXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF93cmFwU1ZHVGV4dEFuZEJnOiBmdW5jdGlvbih0ZXh0QW5kQmcpIHtcbiAgICAgIHZhciBub1NoYWRvdyA9IHRydWUsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHRoaXMpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGV4dEFuZEJnLnRleHRCZ1JlY3RzLmpvaW4oJycpLFxuICAgICAgICAnXFx0XFx0PHRleHQgeG1sOnNwYWNlPVwicHJlc2VydmVcIiAnLFxuICAgICAgICAodGhpcy5mb250RmFtaWx5ID8gJ2ZvbnQtZmFtaWx5PVwiJyArIHRoaXMuZm9udEZhbWlseS5yZXBsYWNlKC9cIi9nLCAnXFwnJykgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRoaXMuZm9udFNpemUgPyAnZm9udC1zaXplPVwiJyArIHRoaXMuZm9udFNpemUgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRoaXMuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU9XCInICsgdGhpcy5mb250U3R5bGUgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRoaXMuZm9udFdlaWdodCA/ICdmb250LXdlaWdodD1cIicgKyB0aGlzLmZvbnRXZWlnaHQgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRleHREZWNvcmF0aW9uID8gJ3RleHQtZGVjb3JhdGlvbj1cIicgKyB0ZXh0RGVjb3JhdGlvbiArICdcIiAnIDogJycpLFxuICAgICAgICAnc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcyhub1NoYWRvdyksICdcIicsIHRoaXMuYWRkUGFpbnRPcmRlcigpLCAnID4nLFxuICAgICAgICB0ZXh0QW5kQmcudGV4dFNwYW5zLmpvaW4oJycpLFxuICAgICAgICAnPC90ZXh0PlxcbidcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRleHRUb3BPZmZzZXQgVGV4dCB0b3Agb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRleHRMZWZ0T2Zmc2V0IFRleHQgbGVmdCBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgX2dldFNWR1RleHRBbmRCZzogZnVuY3Rpb24odGV4dFRvcE9mZnNldCwgdGV4dExlZnRPZmZzZXQpIHtcbiAgICAgIHZhciB0ZXh0U3BhbnMgPSBbXSxcbiAgICAgICAgICB0ZXh0QmdSZWN0cyA9IFtdLFxuICAgICAgICAgIGhlaWdodCA9IHRleHRUb3BPZmZzZXQsIGxpbmVPZmZzZXQ7XG4gICAgICAvLyBib3VuZGluZy1ib3ggYmFja2dyb3VuZFxuICAgICAgdGhpcy5fc2V0U1ZHQmcodGV4dEJnUmVjdHMpO1xuXG4gICAgICAvLyB0ZXh0IGFuZCB0ZXh0LWJhY2tncm91bmRcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICBpZiAodGhpcy50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InLCBpKSkge1xuICAgICAgICAgIHRoaXMuX3NldFNWR1RleHRMaW5lQmcodGV4dEJnUmVjdHMsIGksIHRleHRMZWZ0T2Zmc2V0ICsgbGluZU9mZnNldCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZVRleHQodGV4dFNwYW5zLCBpLCB0ZXh0TGVmdE9mZnNldCArIGxpbmVPZmZzZXQsIGhlaWdodCk7XG4gICAgICAgIGhlaWdodCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dFNwYW5zOiB0ZXh0U3BhbnMsXG4gICAgICAgIHRleHRCZ1JlY3RzOiB0ZXh0QmdSZWN0c1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVGV4dENoYXJTcGFuOiBmdW5jdGlvbihfY2hhciwgc3R5bGVEZWNsLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBzaG91bGRVc2VXaGl0ZXNwYWNlID0gX2NoYXIgIT09IF9jaGFyLnRyaW0oKSB8fCBfY2hhci5tYXRjaChtdWx0aXBsZVNwYWNlc1JlZ2V4KSxcbiAgICAgICAgICBzdHlsZVByb3BzID0gdGhpcy5nZXRTdmdTcGFuU3R5bGVzKHN0eWxlRGVjbCwgc2hvdWxkVXNlV2hpdGVzcGFjZSksXG4gICAgICAgICAgZmlsbFN0eWxlcyA9IHN0eWxlUHJvcHMgPyAnc3R5bGU9XCInICsgc3R5bGVQcm9wcyArICdcIicgOiAnJyxcbiAgICAgICAgICBkeSA9IHN0eWxlRGVjbC5kZWx0YVksIGR5U3BhbiA9ICcnLFxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICBpZiAoZHkpIHtcbiAgICAgICAgZHlTcGFuID0gJyBkeT1cIicgKyB0b0ZpeGVkKGR5LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzx0c3BhbiB4PVwiJywgdG9GaXhlZChsZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKHRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiAnLCBkeVNwYW4sXG4gICAgICAgIGZpbGxTdHlsZXMsICc+JyxcbiAgICAgICAgZmFicmljLnV0aWwuc3RyaW5nLmVzY2FwZVhtbChfY2hhciksXG4gICAgICAgICc8L3RzcGFuPidcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIF9zZXRTVkdUZXh0TGluZVRleHQ6IGZ1bmN0aW9uKHRleHRTcGFucywgbGluZUluZGV4LCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCkge1xuICAgICAgLy8gc2V0IHByb3BlciBsaW5lIG9mZnNldFxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgYWN0dWFsU3R5bGUsXG4gICAgICAgICAgbmV4dFN0eWxlLFxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJyxcbiAgICAgICAgICBjaGFyQm94LCBzdHlsZSxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIHRpbWVUb1JlbmRlcjtcblxuICAgICAgdGV4dFRvcE9mZnNldCArPSBsaW5lSGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lLmxlbmd0aCAtIDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdGltZVRvUmVuZGVyID0gaSA9PT0gbGVuIHx8IHRoaXMuY2hhclNwYWNpbmc7XG4gICAgICAgIGNoYXJzVG9SZW5kZXIgKz0gbGluZVtpXTtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1baV07XG4gICAgICAgIGlmIChib3hXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IGNoYXJCb3gua2VybmVkV2lkdGggLSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNKdXN0aWZ5ICYmICF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KGxpbmVbaV0pKSB7XG4gICAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgY2hhclNwYWNpbmcsIHdlIHJlbmRlciBjaGFyIGJ5IGNoYXJcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IGFjdHVhbFN0eWxlIHx8IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSk7XG4gICAgICAgICAgbmV4dFN0eWxlID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpICsgMSk7XG4gICAgICAgICAgdGltZVRvUmVuZGVyID0gdGhpcy5faGFzU3R5bGVDaGFuZ2VkRm9yU3ZnKGFjdHVhbFN0eWxlLCBuZXh0U3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKSB8fCB7IH07XG4gICAgICAgICAgdGV4dFNwYW5zLnB1c2godGhpcy5fY3JlYXRlVGV4dENoYXJTcGFuKGNoYXJzVG9SZW5kZXIsIHN0eWxlLCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCkpO1xuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJztcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IG5leHRTdHlsZTtcbiAgICAgICAgICB0ZXh0TGVmdE9mZnNldCArPSBib3hXaWR0aDtcbiAgICAgICAgICBib3hXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3B1c2hUZXh0QmdSZWN0OiBmdW5jdGlvbih0ZXh0QmdSZWN0cywgY29sb3IsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICB0ZXh0QmdSZWN0cy5wdXNoKFxuICAgICAgICAnXFx0XFx0PHJlY3QgJyxcbiAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXMoY29sb3IpLFxuICAgICAgICAnIHg9XCInLFxuICAgICAgICB0b0ZpeGVkKGxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgeT1cIicsXG4gICAgICAgIHRvRml4ZWQodG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHdpZHRoPVwiJyxcbiAgICAgICAgdG9GaXhlZCh3aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICB0b0ZpeGVkKGhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIj48L3JlY3Q+XFxuJyk7XG4gICAgfSxcblxuICAgIF9zZXRTVkdUZXh0TGluZUJnOiBmdW5jdGlvbih0ZXh0QmdSZWN0cywgaSwgbGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV0sXG4gICAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSkgLyB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIGJveFN0YXJ0ID0gMCxcbiAgICAgICAgICBjaGFyQm94LCBjdXJyZW50Q29sb3IsXG4gICAgICAgICAgbGFzdENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgIGN1cnJlbnRDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvciAhPT0gbGFzdENvbG9yKSB7XG4gICAgICAgICAgbGFzdENvbG9yICYmIHRoaXMuX3B1c2hUZXh0QmdSZWN0KHRleHRCZ1JlY3RzLCBsYXN0Q29sb3IsIGxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIHRleHRUb3BPZmZzZXQsIGJveFdpZHRoLCBoZWlnaHRPZkxpbmUpO1xuICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBsYXN0Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VycmVudENvbG9yICYmIHRoaXMuX3B1c2hUZXh0QmdSZWN0KHRleHRCZ1JlY3RzLCBjdXJyZW50Q29sb3IsIGxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgdGV4dFRvcE9mZnNldCwgYm94V2lkdGgsIGhlaWdodE9mTGluZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkb2JlIElsbHVzdHJhdG9yIChhdCBsZWFzdCBDUzUpIGlzIHVuYWJsZSB0byByZW5kZXIgcmdiYSgpLWJhc2VkIGZpbGwgdmFsdWVzXG4gICAgICogd2Ugd29yayBhcm91bmQgaXQgYnkgXCJtb3ZpbmdcIiBhbHBoYSBjaGFubmVsIGludG8gb3BhY2l0eSBhdHRyaWJ1dGUgYW5kIHNldHRpbmcgZmlsbCdzIGFscGhhIHRvIDFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBfZ2V0RmlsbEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZmlsbENvbG9yID0gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpID8gbmV3IGZhYnJpYy5Db2xvcih2YWx1ZSkgOiAnJztcbiAgICAgIGlmICghZmlsbENvbG9yIHx8ICFmaWxsQ29sb3IuZ2V0U291cmNlKCkgfHwgZmlsbENvbG9yLmdldEFscGhhKCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdmaWxsPVwiJyArIHZhbHVlICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnb3BhY2l0eT1cIicgKyBmaWxsQ29sb3IuZ2V0QWxwaGEoKSArICdcIiBmaWxsPVwiJyArIGZpbGxDb2xvci5zZXRBbHBoYSgxKS50b1JnYigpICsgJ1wiJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U1ZHTGluZVRvcE9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVRvcE9mZnNldCA9IDAsIGxhc3RIZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lSW5kZXg7IGorKykge1xuICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGopO1xuICAgICAgfVxuICAgICAgbGFzdEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGopO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVRvcDogbGluZVRvcE9mZnNldCxcbiAgICAgICAgb2Zmc2V0OiAodGhpcy5fZm9udFNpemVNdWx0IC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiBsYXN0SGVpZ2h0IC8gKHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFNoYWRvdyBhIGJvb2xlYW4gdG8gc2tpcCBzaGFkb3cgZmlsdGVyIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKHNraXBTaGFkb3cpIHtcbiAgICAgIHZhciBzdmdTdHlsZSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmdldFN2Z1N0eWxlcy5jYWxsKHRoaXMsIHNraXBTaGFkb3cpO1xuICAgICAgcmV0dXJuIHN2Z1N0eWxlICsgJyB3aGl0ZS1zcGFjZTogcHJlOyc7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuLyogX1RPX1NWR19FTkRfICovXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHt9KTtcblxuICAvKipcbiAgICogVGV4dGJveCBjbGFzcywgYmFzZWQgb24gSVRleHQsIGFsbG93cyB0aGUgdXNlciB0byByZXNpemUgdGhlIHRleHQgcmVjdGFuZ2xlXG4gICAqIGFuZCB3cmFwcyBsaW5lcyBhdXRvbWF0aWNhbGx5LiBUZXh0Ym94ZXMgaGF2ZSB0aGVpciBZIHNjYWxpbmcgbG9ja2VkLCB0aGVcbiAgICogdXNlciBjYW4gb25seSBjaGFuZ2Ugd2lkdGguIEhlaWdodCBpcyBhZGp1c3RlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZVxuICAgKiB3cmFwcGluZyBvZiBsaW5lcy5cbiAgICogQGNsYXNzIGZhYnJpYy5UZXh0Ym94XG4gICAqIEBleHRlbmRzIGZhYnJpYy5JVGV4dFxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHJldHVybiB7ZmFicmljLlRleHRib3h9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRleHRib3gjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLklUZXh0LCBmYWJyaWMuT2JzZXJ2YWJsZSwge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICd0ZXh0Ym94JyxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gd2lkdGggb2YgdGV4dGJveCwgaW4gcGl4ZWxzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWluV2lkdGg6IDIwLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBjYWxjdWxhdGVkIHdpZHRoIG9mIGEgdGV4dGJveCwgaW4gcGl4ZWxzLlxuICAgICAqIGZpeGVkIHRvIDIgc28gdGhhdCBhbiBlbXB0eSB0ZXh0Ym94IGNhbm5vdCBnbyB0byAwXG4gICAgICogYW5kIGlzIHN0aWxsIHNlbGVjdGFibGUgd2l0aG91dCB0ZXh0LlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZHluYW1pY01pbldpZHRoOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGFycmF5IG9mIHRleHQgd3JhcHBpbmcuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBfX2NhY2hlZExpbmVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc3RhbmRhcmQgT2JqZWN0IGNsYXNzIHZhbHVlc1xuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nRmxpcDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKiBUZXh0Ym94IG5lZWRzIHRoaXMgb24gZmFsc2VcbiAgICAgKi9cbiAgICBub1NjYWxlQ2FjaGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyB3aGljaCB3aGVuIHNldCBjYXVzZSBvYmplY3QgdG8gY2hhbmdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczogZmFicmljLlRleHQucHJvdG90eXBlLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5jb25jYXQoJ3dpZHRoJyksXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gc3BsaXQgc3RyaW5ncyBpbiBicmVha2FibGUgbGluZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF93b3JkSm9pbmVyczogL1sgXFx0XFxyXS8sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBib29sZWFuIHByb3BlcnR5IGluIG9yZGVyIHRvIHNwbGl0IHN0cmluZ3MgdGhhdCBoYXZlIG5vIHdoaXRlIHNwYWNlIGNvbmNlcHQuXG4gICAgICogdGhpcyBpcyBhIGNoZWFwIHdheSB0byBoZWxwIHdpdGggY2hpbmVzZS9qYXBhbmVzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMi42LjBcbiAgICAgKi9cbiAgICBzcGxpdEJ5R3JhcGhlbWU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVW5saWtlIHN1cGVyY2xhc3MncyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIFRleHRib3ggZG9lcyBub3QgdXBkYXRlXG4gICAgICogaXRzIHdpZHRoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICAvLyBjbGVhciBkeW5hbWljTWluV2lkdGggYXMgaXQgd2lsbCBiZSBkaWZmZXJlbnQgYWZ0ZXIgd2UgcmUtd3JhcCBsaW5lXG4gICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IDA7XG4gICAgICAvLyB3cmFwIGxpbmVzXG4gICAgICB0aGlzLl9zdHlsZU1hcCA9IHRoaXMuX2dlbmVyYXRlU3R5bGVNYXAodGhpcy5fc3BsaXRUZXh0KCkpO1xuICAgICAgLy8gaWYgYWZ0ZXIgd3JhcHBpbmcsIHRoZSB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gZHluYW1pY01pbldpZHRoLCBjaGFuZ2UgdGhlIHdpZHRoIGFuZCByZS13cmFwXG4gICAgICBpZiAodGhpcy5keW5hbWljTWluV2lkdGggPiB0aGlzLndpZHRoKSB7XG4gICAgICAgIHRoaXMuX3NldCgnd2lkdGgnLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFyIGNhY2hlIGFuZCByZS1jYWxjdWxhdGUgaGVpZ2h0XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgdGhhdCB0cmFuc2xhdGVzIHRoZSBzdHlsZSBvYmplY3Qgc28gdGhhdCBpdCBpc1xuICAgICAqIGJyb2tlbiB1cCBieSB2aXN1YWwgbGluZXMgKG5ldyBsaW5lcyBhbmQgYXV0b21hdGljIHdyYXBwaW5nKS5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCBzdHlsZXMgb2JqZWN0IGlzIGJyb2tlbiB1cCBieSBhY3R1YWwgbGluZXMgKG5ldyBsaW5lcyBvbmx5KSxcbiAgICAgKiB3aGljaCBpcyBvbmx5IHN1ZmZpY2llbnQgZm9yIFRleHQgLyBJVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlU3R5bGVNYXA6IGZ1bmN0aW9uKHRleHRJbmZvKSB7XG4gICAgICB2YXIgcmVhbExpbmVDb3VudCAgICAgPSAwLFxuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMCxcbiAgICAgICAgICBjaGFyQ291bnQgICAgICAgICA9IDAsXG4gICAgICAgICAgbWFwICAgICAgICAgICAgICAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSA9PT0gJ1xcbicgJiYgaSA+IDApIHtcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgICAgcmVhbExpbmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnNwbGl0QnlHcmFwaGVtZSAmJiB0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QodGV4dEluZm8uZ3JhcGhlbWVUZXh0W2NoYXJDb3VudF0pICYmIGkgPiAwKSB7XG4gICAgICAgICAgLy8gdGhpcyBjYXNlIGRlYWxzIHdpdGggc3BhY2UncyB0aGF0IGFyZSByZW1vdmVkIGZyb20gZW5kIG9mIGxpbmVzIHdoZW4gd3JhcHBpbmdcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCsrO1xuICAgICAgICAgIGNoYXJDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwW2ldID0geyBsaW5lOiByZWFsTGluZUNvdW50LCBvZmZzZXQ6IHJlYWxMaW5lQ2hhckNvdW50IH07XG5cbiAgICAgICAgY2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgICByZWFsTGluZUNoYXJDb3VudCArPSB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzW2ldLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgYSBzdHlsZSBwcm9wZXJ0eSBvciBoYXMgaXQgb24gYSBzcGVjaWZpZWQgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0eWxlSGFzOiBmdW5jdGlvbihwcm9wZXJ0eSwgbGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fc3R5bGVNYXAgJiYgIXRoaXMuaXNXcmFwcGluZykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLlRleHQucHJvdG90eXBlLnN0eWxlSGFzLmNhbGwodGhpcywgcHJvcGVydHksIGxpbmVJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIG5vIHN0eWxpbmcgb3Igbm8gc3R5bGluZyBpbiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4ICwgbGluZUluZGV4IGlzIG9uIHdyYXBwZWQgbGluZXMuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgbmV4dExpbmVJbmRleCA9IGxpbmVJbmRleCArIDEsIG5leHRPZmZzZXQsIG9iaiwgc2hvdWxkTGltaXQgPSBmYWxzZSxcbiAgICAgICAgICBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdLCBtYXBOZXh0TGluZSA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdO1xuICAgICAgaWYgKG1hcCkge1xuICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgb2Zmc2V0ID0gbWFwLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXBOZXh0TGluZSkge1xuICAgICAgICBuZXh0TGluZUluZGV4ID0gbWFwTmV4dExpbmUubGluZTtcbiAgICAgICAgc2hvdWxkTGltaXQgPSBuZXh0TGluZUluZGV4ID09PSBsaW5lSW5kZXg7XG4gICAgICAgIG5leHRPZmZzZXQgPSBtYXBOZXh0TGluZS5vZmZzZXQ7XG4gICAgICB9XG4gICAgICBvYmogPSB0eXBlb2YgbGluZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc3R5bGVzIDogeyBsaW5lOiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdIH07XG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIGlmIChwMiA+PSBvZmZzZXQgJiYgKCFzaG91bGRMaW1pdCB8fCBwMiA8IG5leHRPZmZzZXQpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIGZvciAodmFyIHAzIGluIG9ialtwMV1bcDJdKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fc3R5bGVNYXAgJiYgIXRoaXMuaXNXcmFwcGluZykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgY2hhckluZGV4ID0gbWFwLm9mZnNldCArIGNoYXJJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignX2dldFN0eWxlRGVjbGFyYXRpb24nLCBsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgY2hhckluZGV4ID0gbWFwLm9mZnNldCArIGNoYXJJbmRleDtcblxuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBSZXR1cm5zIHRoZSByZWFsIHN0eWxlIGxpbmUgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSB3cmFwcGVkIGxpbmVJbmRleCBsaW5lXG4gICAgICogVXNlZCBqdXN0IHRvIHZlcmlmeSBpZiB0aGUgbGluZSBkb2VzIGV4aXN0IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGlmIHRoZSBsaW5lIGV4aXN0cyBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICByZXR1cm4gISF0aGlzLnN0eWxlc1ttYXAubGluZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGluZSBzdHlsZSB0byBhbiBlbXB0eSBvYmplY3Qgc28gdGhhdCBpcyBpbml0aWFsaXplZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICB0aGlzLnN0eWxlc1ttYXAubGluZV0gPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgdGV4dCB1c2luZyB0aGUgJ3dpZHRoJyBwcm9wZXJ0eSBvZiBUZXh0Ym94LiBGaXJzdCB0aGlzIGZ1bmN0aW9uXG4gICAgICogc3BsaXRzIHRleHQgb24gbmV3bGluZXMsIHNvIHdlIHByZXNlcnZlIG5ld2xpbmVzIGVudGVyZWQgYnkgdGhlIHVzZXIuXG4gICAgICogVGhlbiBpdCB3cmFwcyBlYWNoIGxpbmUgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGJ5IGNhbGxpbmdcbiAgICAgKiBfd3JhcExpbmUoKS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lcyBUaGUgc3RyaW5nIGFycmF5IG9mIHRleHQgdGhhdCBpcyBzcGxpdCBpbnRvIGxpbmVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRvXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBsaW5lc1xuICAgICAqL1xuICAgIF93cmFwVGV4dDogZnVuY3Rpb24obGluZXMsIGRlc2lyZWRXaWR0aCkge1xuICAgICAgdmFyIHdyYXBwZWQgPSBbXSwgaTtcbiAgICAgIHRoaXMuaXNXcmFwcGluZyA9IHRydWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQuY29uY2F0KHRoaXMuX3dyYXBMaW5lKGxpbmVzW2ldLCBpLCBkZXNpcmVkV2lkdGgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNXcmFwcGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHdyYXBwZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBtZWFzdXJlIGEgc3RyaW5nIG9mIHRleHQsIGdpdmVuIGl0cyBsaW5lSW5kZXggYW5kIGNoYXJJbmRleCBvZmZzZXRcbiAgICAgKiBpdCBnZXRzIGNhbGxlZCB3aGVuIGNoYXJCb3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgeWV0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhck9mZnNldFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWVhc3VyZVdvcmQ6IGZ1bmN0aW9uKHdvcmQsIGxpbmVJbmRleCwgY2hhck9mZnNldCkge1xuICAgICAgdmFyIHdpZHRoID0gMCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCA9IHRydWU7XG4gICAgICBjaGFyT2Zmc2V0ID0gY2hhck9mZnNldCB8fCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHdvcmQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuX2dldEdyYXBoZW1lQm94KHdvcmRbaV0sIGxpbmVJbmRleCwgaSArIGNoYXJPZmZzZXQsIHByZXZHcmFwaGVtZSwgc2tpcExlZnQpO1xuICAgICAgICB3aWR0aCArPSBib3gua2VybmVkV2lkdGg7XG4gICAgICAgIHByZXZHcmFwaGVtZSA9IHdvcmRbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgbGluZSBvZiB0ZXh0IHVzaW5nIHRoZSB3aWR0aCBvZiB0aGUgVGV4dGJveCBhbmQgYSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmUgVGhlIGdyYXBoZW1lIGFycmF5IHRoYXQgcmVwcmVzZW50IHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXNpcmVkV2lkdGggd2lkdGggeW91IHdhbnQgdG8gd3JhcCB0aGUgbGluZSB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZXNlcnZlZFNwYWNlIHNwYWNlIHRvIHJlbW92ZSBmcm9tIHdyYXBwaW5nIGZvciBjdXN0b20gZnVuY3Rpb25hbGl0aWVzXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBsaW5lKHMpIGludG8gd2hpY2ggdGhlIGdpdmVuIHRleHQgaXMgd3JhcHBlZFxuICAgICAqIHRvLlxuICAgICAqL1xuICAgIF93cmFwTGluZTogZnVuY3Rpb24oX2xpbmUsIGxpbmVJbmRleCwgZGVzaXJlZFdpZHRoLCByZXNlcnZlZFNwYWNlKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gMCxcbiAgICAgICAgICBzcGxpdEJ5R3JhcGhlbWUgPSB0aGlzLnNwbGl0QnlHcmFwaGVtZSxcbiAgICAgICAgICBncmFwaGVtZUxpbmVzID0gW10sXG4gICAgICAgICAgbGluZSA9IFtdLFxuICAgICAgICAgIC8vIHNwYWNlcyBpbiBkaWZmZXJlbnQgbGFuZ3VhZ2VzP1xuICAgICAgICAgIHdvcmRzID0gc3BsaXRCeUdyYXBoZW1lID8gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoX2xpbmUpIDogX2xpbmUuc3BsaXQodGhpcy5fd29yZEpvaW5lcnMpLFxuICAgICAgICAgIHdvcmQgPSAnJyxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIGluZml4ID0gc3BsaXRCeUdyYXBoZW1lID8gJycgOiAnICcsXG4gICAgICAgICAgd29yZFdpZHRoID0gMCxcbiAgICAgICAgICBpbmZpeFdpZHRoID0gMCxcbiAgICAgICAgICBsYXJnZXN0V29yZFdpZHRoID0gMCxcbiAgICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSB0cnVlLFxuICAgICAgICAgIGFkZGl0aW9uYWxTcGFjZSA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpLFxuICAgICAgICAgIHJlc2VydmVkU3BhY2UgPSByZXNlcnZlZFNwYWNlIHx8IDA7XG4gICAgICAvLyBmaXggYSBkaWZmZXJlbmNlIGJldHdlZW4gc3BsaXQgYW5kIGdyYXBoZW1lU3BsaXRcbiAgICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgd29yZHMucHVzaChbXSk7XG4gICAgICB9XG4gICAgICBkZXNpcmVkV2lkdGggLT0gcmVzZXJ2ZWRTcGFjZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gaWYgdXNpbmcgc3BsaXRCeUdyYXBoZW1lIHdvcmRzIGFyZSBhbHJlYWR5IGluIGdyYXBoZW1lcy5cbiAgICAgICAgd29yZCA9IHNwbGl0QnlHcmFwaGVtZSA/IHdvcmRzW2ldIDogZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQod29yZHNbaV0pO1xuICAgICAgICB3b3JkV2lkdGggPSB0aGlzLl9tZWFzdXJlV29yZCh3b3JkLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB3b3JkLmxlbmd0aDtcblxuICAgICAgICBsaW5lV2lkdGggKz0gaW5maXhXaWR0aCArIHdvcmRXaWR0aCAtIGFkZGl0aW9uYWxTcGFjZTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+IGRlc2lyZWRXaWR0aCAmJiAhbGluZUp1c3RTdGFydGVkKSB7XG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaW5lV2lkdGggKz0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lSnVzdFN0YXJ0ZWQgJiYgIXNwbGl0QnlHcmFwaGVtZSkge1xuICAgICAgICAgIGxpbmUucHVzaChpbmZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IGxpbmUuY29uY2F0KHdvcmQpO1xuXG4gICAgICAgIGluZml4V2lkdGggPSBzcGxpdEJ5R3JhcGhlbWUgPyAwIDogdGhpcy5fbWVhc3VyZVdvcmQoW2luZml4XSwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgbGluZUp1c3RTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbGFyZ2VzdCB3b3JkXG4gICAgICAgIGlmICh3b3JkV2lkdGggPiBsYXJnZXN0V29yZFdpZHRoKSB7XG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICYmIGdyYXBoZW1lTGluZXMucHVzaChsaW5lKTtcblxuICAgICAgaWYgKGxhcmdlc3RXb3JkV2lkdGggKyByZXNlcnZlZFNwYWNlID4gdGhpcy5keW5hbWljTWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSBsYXJnZXN0V29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlICsgcmVzZXJ2ZWRTcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFwaGVtZUxpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIHRleHQgbGluZSBpcyBlbmRlZCB3aXRoIGFuIGhhcmQgYnJlYWtcbiAgICAgKiB0ZXh0IGFuZCBpdGV4dCBkbyBub3QgaGF2ZSB3cmFwcGluZywgcmV0dXJuIGZhbHNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0ZXh0IHRvIHNwbGl0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VuZE9mV3JhcHBpbmc6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXggKyAxXSkge1xuICAgICAgICAvLyBpcyBsYXN0IGxpbmUsIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXggKyAxXS5saW5lICE9PSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdLmxpbmUpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBsYXN0IGxpbmUgYmVmb3JlIGEgbGluZSBicmVhaywgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYSBsaW5lIGhhcyBhIGxpbmVicmVhayBhbmQgc28gd2UgbmVlZCB0byBhY2NvdW50IGZvciBpdCB3aGVuIG1vdmluZ1xuICAgICAqIGFuZCBjb3VudGluZyBzdHlsZS5cbiAgICAgKiBAcmV0dXJuIE51bWJlclxuICAgICAqL1xuICAgIG1pc3NpbmdOZXdsaW5lT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLnNwbGl0QnlHcmFwaGVtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuZE9mV3JhcHBpbmcobGluZUluZGV4KSA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2V0cyBsaW5lcyBvZiB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgVGV4dGJveC4gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzXG4gICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnkgdGltZSBpdCBpcyBjYWxsZWQuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICogQG92ZXJyaWRlXG4gICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbmV3VGV4dCA9IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fc3BsaXRUZXh0SW50b0xpbmVzLmNhbGwodGhpcywgdGV4dCksXG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcyA9IHRoaXMuX3dyYXBUZXh0KG5ld1RleHQubGluZXMsIHRoaXMud2lkdGgpLFxuICAgICAgICAgIGxpbmVzID0gbmV3IEFycmF5KGdyYXBoZW1lTGluZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhlbWVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IGdyYXBoZW1lTGluZXNbaV0uam9pbignJyk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LmxpbmVzID0gbGluZXM7XG4gICAgICBuZXdUZXh0LmdyYXBoZW1lTGluZXMgPSBncmFwaGVtZUxpbmVzO1xuICAgICAgcmV0dXJuIG5ld1RleHQ7XG4gICAgfSxcblxuICAgIGdldE1pbldpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm1pbldpZHRoLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lc1RvS2VlcCA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLl9zdHlsZU1hcCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dExpbmVzW3Byb3BdKSB7XG4gICAgICAgICAgbGluZXNUb0tlZXBbdGhpcy5fc3R5bGVNYXBbcHJvcF0ubGluZV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGVzKSB7XG4gICAgICAgIGlmICghbGluZXNUb0tlZXBbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ21pbldpZHRoJywgJ3NwbGl0QnlHcmFwaGVtZSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dGJveCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dGJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHRib3gnLCBvYmplY3QsIGNhbGxiYWNrLCAndGV4dCcpO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY29udHJvbHNVdGlscyA9IGZhYnJpYy5jb250cm9sc1V0aWxzLFxuICAgICAgc2NhbGVTa2V3U3R5bGVIYW5kbGVyID0gY29udHJvbHNVdGlscy5zY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIsXG4gICAgICBzY2FsZVN0eWxlSGFuZGxlciA9IGNvbnRyb2xzVXRpbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIsXG4gICAgICBzY2FsaW5nRXF1YWxseSA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ0VxdWFsbHksXG4gICAgICBzY2FsaW5nWU9yU2tld2luZ1ggPSBjb250cm9sc1V0aWxzLnNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICAgIHNjYWxpbmdYT3JTa2V3aW5nWSA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgICAgc2NhbGVPclNrZXdBY3Rpb25OYW1lID0gY29udHJvbHNVdGlscy5zY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gICAgICBvYmplY3RDb250cm9scyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNvbnRyb2xzO1xuXG4gIG9iamVjdENvbnRyb2xzLm1sID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IDAsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubXIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAuNSxcbiAgICB5OiAwLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdYT3JTa2V3aW5nWSxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm1iID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWU9yU2tld2luZ1gsXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tdCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMCxcbiAgICB5OiAtMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLnRsID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy50ciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5ibCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogLTAuNSxcbiAgICB5OiAwLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5iciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm10ciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMCxcbiAgICB5OiAtMC41LFxuICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMucm90YXRpb25XaXRoU25hcHBpbmcsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBjb250cm9sc1V0aWxzLnJvdGF0aW9uU3R5bGVIYW5kbGVyLFxuICAgIG9mZnNldFk6IC00MCxcbiAgICB3aXRoQ29ubmVjdGlvbjogdHJ1ZSxcbiAgICBhY3Rpb25OYW1lOiAncm90YXRlJyxcbiAgfSk7XG5cbiAgaWYgKGZhYnJpYy5UZXh0Ym94KSB7XG4gICAgLy8gdGhpcyBpcyBicmVha2luZyB0aGUgcHJvdG90eXBlIGluaGVyaXRhbmNlLCBubyB0aW1lIC8gaWRlYXMgdG8gZml4IGl0LlxuICAgIC8vIGlzIGltcG9ydGFudCB0byBkb2N1bWVudCB0aGF0IGlmIHlvdSB3YW50IHRvIGhhdmUgYWxsIG9iamVjdHMgdG8gaGF2ZSBhXG4gICAgLy8gc3BlY2lmaWMgY3VzdG9tIGNvbnRyb2wsIHlvdSBoYXZlIHRvIGFkZCBpdCB0byBPYmplY3QgcHJvdG90eXBlIGFuZCB0byBUZXh0Ym94XG4gICAgLy8gcHJvdG90eXBlLiBUaGUgY29udHJvbHMgYXJlIHNoYXJlZCBhcyByZWZlcmVuY2VzLiBTbyBjaGFuZ2VzIHRvIGNvbnRyb2wgYHRyYFxuICAgIC8vIGNhbiBzdGlsbCBhcHBseSB0byBhbGwgb2JqZWN0cyBpZiBuZWVkZWQuXG4gICAgdmFyIHRleHRCb3hDb250cm9scyA9IGZhYnJpYy5UZXh0Ym94LnByb3RvdHlwZS5jb250cm9scyA9IHsgfTtcblxuICAgIHRleHRCb3hDb250cm9scy5tdHIgPSBvYmplY3RDb250cm9scy5tdHI7XG4gICAgdGV4dEJveENvbnRyb2xzLnRyID0gb2JqZWN0Q29udHJvbHMudHI7XG4gICAgdGV4dEJveENvbnRyb2xzLmJyID0gb2JqZWN0Q29udHJvbHMuYnI7XG4gICAgdGV4dEJveENvbnRyb2xzLnRsID0gb2JqZWN0Q29udHJvbHMudGw7XG4gICAgdGV4dEJveENvbnRyb2xzLmJsID0gb2JqZWN0Q29udHJvbHMuYmw7XG4gICAgdGV4dEJveENvbnRyb2xzLm10ID0gb2JqZWN0Q29udHJvbHMubXQ7XG4gICAgdGV4dEJveENvbnRyb2xzLm1iID0gb2JqZWN0Q29udHJvbHMubWI7XG5cbiAgICB0ZXh0Qm94Q29udHJvbHMubXIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgICAgeDogMC41LFxuICAgICAgeTogMCxcbiAgICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMuY2hhbmdlV2lkdGgsXG4gICAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICAgIGFjdGlvbk5hbWU6ICdyZXNpemluZycsXG4gICAgfSk7XG5cbiAgICB0ZXh0Qm94Q29udHJvbHMubWwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgICAgeDogLTAuNSxcbiAgICAgIHk6IDAsXG4gICAgICBhY3Rpb25IYW5kbGVyOiBjb250cm9sc1V0aWxzLmNoYW5nZVdpZHRoLFxuICAgICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgICBhY3Rpb25OYW1lOiAncmVzaXppbmcnLFxuICAgIH0pO1xuICB9XG59KSgpO1xuXG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvKiEgbm91aXNsaWRlciAtIDE0LjYuMyAtIDExLzE5LzIwMjAgKi9cbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIHdpbmRvdy5ub1VpU2xpZGVyID0gZmFjdG9yeSgpO1xuICAgIH1cbn0pKGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIFZFUlNJT04gPSBcIjE0LjYuM1wiO1xuXG4gICAgLy9yZWdpb24gSGVscGVyIE1ldGhvZHNcblxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGb3JtYXR0ZXIoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkudG8gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW50cnkuZnJvbSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICAgICAgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQmluZGFibGUgdmVyc2lvblxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5LlxuICAgIGZ1bmN0aW9uIHVuaXF1ZShhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpc1thXSA/ICh0aGlzW2FdID0gdHJ1ZSkgOiBmYWxzZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cblxuICAgIC8vIFJvdW5kIGEgdmFsdWUgdG8gdGhlIGNsb3Nlc3QgJ3RvJy5cbiAgICBmdW5jdGlvbiBjbG9zZXN0KHZhbHVlLCB0bykge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHRvKSAqIHRvO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KGVsZW0sIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTtcblxuICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY29udGFpbnMgbGVmdCBzY3JvbGwgaW4gQ2hyb21lIG9uIEFuZHJvaWQuXG4gICAgICAgIC8vIEkgaGF2ZW4ndCBmb3VuZCBhIGZlYXR1cmUgZGV0ZWN0aW9uIHRoYXQgcHJvdmVzIHRoaXMuIFdvcnN0IGNhc2VcbiAgICAgICAgLy8gc2NlbmFyaW8gb24gbWlzLW1hdGNoOiB0aGUgJ3RhcCcgZmVhdHVyZSBvbiBob3Jpem9udGFsIHNsaWRlcnMgYnJlYWtzLlxuICAgICAgICBpZiAoL3dlYmtpdC4qQ2hyb21lLipNb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICBwYWdlT2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uXG4gICAgICAgICAgICA/IHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3BcbiAgICAgICAgICAgIDogcmVjdC5sZWZ0ICsgcGFnZU9mZnNldC54IC0gZG9jRWxlbS5jbGllbnRMZWZ0O1xuICAgIH1cblxuICAgIC8vIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgbnVtZXJpY2FsLlxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4oYSkgJiYgaXNGaW5pdGUoYSk7XG4gICAgfVxuXG4gICAgLy8gU2V0cyBhIGNsYXNzIGFuZCByZW1vdmVzIGl0IGFmdGVyIFtkdXJhdGlvbl0gbXMuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3NGb3IoZWxlbWVudCwgY2xhc3NOYW1lLCBkdXJhdGlvbikge1xuICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGltaXRzIGEgdmFsdWUgdG8gMCAtIDEwMFxuICAgIGZ1bmN0aW9uIGxpbWl0KGEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGEsIDEwMCksIDApO1xuICAgIH1cblxuICAgIC8vIFdyYXBzIGEgdmFyaWFibGUgYXMgYW4gYXJyYXksIGlmIGl0IGlzbid0IG9uZSB5ZXQuXG4gICAgLy8gTm90ZSB0aGF0IGFuIGlucHV0IGFycmF5IGlzIHJldHVybmVkIGJ5IHJlZmVyZW5jZSFcbiAgICBmdW5jdGlvbiBhc0FycmF5KGEpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdO1xuICAgIH1cblxuICAgIC8vIENvdW50cyBkZWNpbWFsc1xuICAgIGZ1bmN0aW9uIGNvdW50RGVjaW1hbHMobnVtU3RyKSB7XG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xuICAgICAgICB2YXIgcGllY2VzID0gbnVtU3RyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcy5sZW5ndGggPiAxID8gcGllY2VzWzFdLmxlbmd0aCA6IDA7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL3lvdW1pZ2h0bm90bmVlZGpxdWVyeS5jb20vI2FkZF9jbGFzc1xuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCAmJiAhL1xccy8udGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwOi8veW91bWlnaHRub3RuZWVkanF1ZXJ5LmNvbS8jcmVtb3ZlX2NsYXNzXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0ICYmICEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLFxuICAgICAgICAgICAgICAgIFwiIFwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0XG4gICAgICAgICAgICA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAgICAgICA6IG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgY2xhc3NOYW1lICsgXCJcXFxcYlwiKS50ZXN0KGVsLmNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9zY3JvbGxZI05vdGVzXG4gICAgZnVuY3Rpb24gZ2V0UGFnZU9mZnNldChkb2MpIHtcbiAgICAgICAgdmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBpc0NTUzFDb21wYXQgPSAoZG9jLmNvbXBhdE1vZGUgfHwgXCJcIikgPT09IFwiQ1NTMUNvbXBhdFwiO1xuICAgICAgICB2YXIgeCA9IHN1cHBvcnRQYWdlT2Zmc2V0XG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWE9mZnNldFxuICAgICAgICAgICAgOiBpc0NTUzFDb21wYXRcbiAgICAgICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBzdXBwb3J0UGFnZU9mZnNldFxuICAgICAgICAgICAgPyB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XG4gICAgICAgICAgICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsVG9wO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byBjb21wdXRlIGNvbnN0YW50cyBpbnN0ZWFkXG4gICAgLy8gb2YgYWNjZXNzaW5nIHdpbmRvdy4qIGFzIHNvb24gYXMgdGhlIG1vZHVsZSBuZWVkcyBpdFxuICAgIC8vIHNvIHRoYXQgd2UgZG8gbm90IGNvbXB1dGUgYW55dGhpbmcgaWYgbm90IG5lZWRlZFxuICAgIGZ1bmN0aW9uIGdldEFjdGlvbnMoKSB7XG4gICAgICAgIC8vIERldGVybWluZSB0aGUgZXZlbnRzIHRvIGJpbmQuIElFMTEgaW1wbGVtZW50cyBwb2ludGVyRXZlbnRzIHdpdGhvdXRcbiAgICAgICAgLy8gYSBwcmVmaXgsIHdoaWNoIGJyZWFrcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIElFMTAgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsXG4gICAgICAgICAgICAgICAgICBtb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG4gICAgICAgICAgICAgICAgICBlbmQ6IFwicG9pbnRlcnVwXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbW92ZTogXCJNU1BvaW50ZXJNb3ZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBcIk1TUG9pbnRlclVwXCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJtb3VzZWRvd24gdG91Y2hzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogXCJtb3VzZXVwIHRvdWNoZW5kXCJcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcbiAgICAvLyBJc3N1ZSAjNzg1XG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNQYXNzaXZlKCkge1xuICAgICAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICAgIH1cblxuICAgIC8vZW5kcmVnaW9uXG5cbiAgICAvL3JlZ2lvbiBSYW5nZSBDYWxjdWxhdGlvblxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIGEgc3ViLXJhbmdlIGluIHJlbGF0aW9uIHRvIGEgZnVsbCByYW5nZS5cbiAgICBmdW5jdGlvbiBzdWJSYW5nZVJhdGlvKHBhLCBwYikge1xuICAgICAgICByZXR1cm4gMTAwIC8gKHBiIC0gcGEpO1xuICAgIH1cblxuICAgIC8vIChwZXJjZW50YWdlKSBIb3cgbWFueSBwZXJjZW50IGlzIHRoaXMgdmFsdWUgb2YgdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiBmcm9tUGVyY2VudGFnZShyYW5nZSwgdmFsdWUsIHN0YXJ0UmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAqIDEwMCkgLyAocmFuZ2Vbc3RhcnRSYW5nZSArIDFdIC0gcmFuZ2Vbc3RhcnRSYW5nZV0pO1xuICAgIH1cblxuICAgIC8vIChwZXJjZW50YWdlKSBXaGVyZSBpcyB0aGlzIHZhbHVlIG9uIHRoaXMgcmFuZ2U/XG4gICAgZnVuY3Rpb24gdG9QZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnJvbVBlcmNlbnRhZ2UocmFuZ2UsIHJhbmdlWzBdIDwgMCA/IHZhbHVlICsgTWF0aC5hYnMocmFuZ2VbMF0pIDogdmFsdWUgLSByYW5nZVswXSwgMCk7XG4gICAgfVxuXG4gICAgLy8gKHZhbHVlKSBIb3cgbXVjaCBpcyB0aGlzIHBlcmNlbnRhZ2Ugb24gdGhpcyByYW5nZT9cbiAgICBmdW5jdGlvbiBpc1BlcmNlbnRhZ2UocmFuZ2UsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkpIC8gMTAwICsgcmFuZ2VbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Sih2YWx1ZSwgYXJyKSB7XG4gICAgICAgIHZhciBqID0gMTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgPj0gYXJyW2pdKSB7XG4gICAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gajtcbiAgICB9XG5cbiAgICAvLyAocGVyY2VudGFnZSkgSW5wdXQgYSB2YWx1ZSwgZmluZCB3aGVyZSwgb24gYSBzY2FsZSBvZiAwLTEwMCwgaXQgYXBwbGllcy5cbiAgICBmdW5jdGlvbiB0b1N0ZXBwaW5nKHhWYWwsIHhQY3QsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFZhbCk7XG4gICAgICAgIHZhciB2YSA9IHhWYWxbaiAtIDFdO1xuICAgICAgICB2YXIgdmIgPSB4VmFsW2pdO1xuICAgICAgICB2YXIgcGEgPSB4UGN0W2ogLSAxXTtcbiAgICAgICAgdmFyIHBiID0geFBjdFtqXTtcblxuICAgICAgICByZXR1cm4gcGEgKyB0b1BlcmNlbnRhZ2UoW3ZhLCB2Yl0sIHZhbHVlKSAvIHN1YlJhbmdlUmF0aW8ocGEsIHBiKTtcbiAgICB9XG5cbiAgICAvLyAodmFsdWUpIElucHV0IGEgcGVyY2VudGFnZSwgZmluZCB3aGVyZSBpdCBpcyBvbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuICAgIGZ1bmN0aW9uIGZyb21TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyByYW5nZSBncm91cCB0aGF0IGZpdHMgMTAwXG4gICAgICAgIGlmICh2YWx1ZSA+PSAxMDApIHtcbiAgICAgICAgICAgIHJldHVybiB4VmFsLnNsaWNlKC0xKVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFBjdCk7XG4gICAgICAgIHZhciB2YSA9IHhWYWxbaiAtIDFdO1xuICAgICAgICB2YXIgdmIgPSB4VmFsW2pdO1xuICAgICAgICB2YXIgcGEgPSB4UGN0W2ogLSAxXTtcbiAgICAgICAgdmFyIHBiID0geFBjdFtqXTtcblxuICAgICAgICByZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvKHBhLCBwYikpO1xuICAgIH1cblxuICAgIC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cbiAgICBmdW5jdGlvbiBnZXRTdGVwKHhQY3QsIHhTdGVwcywgc25hcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAxMDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gZ2V0Sih2YWx1ZSwgeFBjdCk7XG4gICAgICAgIHZhciBhID0geFBjdFtqIC0gMV07XG4gICAgICAgIHZhciBiID0geFBjdFtqXTtcblxuICAgICAgICAvLyBJZiAnc25hcCcgaXMgc2V0LCBzdGVwcyBhcmUgdXNlZCBhcyBmaXhlZCBwb2ludHMgb24gdGhlIHNsaWRlci5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgheFN0ZXBzW2ogLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHhQY3RbaiAtIDFdICsgY2xvc2VzdCh2YWx1ZSAtIHhQY3RbaiAtIDFdLCB4U3RlcHNbaiAtIDFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFbnRyeVBvaW50KGluZGV4LCB2YWx1ZSwgdGhhdCkge1xuICAgICAgICB2YXIgcGVyY2VudGFnZTtcblxuICAgICAgICAvLyBXcmFwIG51bWVyaWNhbCBpbnB1dCBpbiBhbiBhcnJheS5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVqZWN0IGFueSBpbnZhbGlkIGlucHV0LCBieSB0ZXN0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gYXJyYXkuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyBjb250YWlucyBpbnZhbGlkIHZhbHVlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXG4gICAgICAgIGlmIChpbmRleCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgcGVyY2VudGFnZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dC5cbiAgICAgICAgaWYgKCFpc051bWVyaWMocGVyY2VudGFnZSkgfHwgIWlzTnVtZXJpYyh2YWx1ZVswXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyB2YWx1ZSBpc24ndCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHZhbHVlcy5cbiAgICAgICAgdGhhdC54UGN0LnB1c2gocGVyY2VudGFnZSk7XG4gICAgICAgIHRoYXQueFZhbC5wdXNoKHZhbHVlWzBdKTtcblxuICAgICAgICAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXG4gICAgICAgIC8vIGxvZ2dpbmcgY2xlYXIsIHNldCBzdGVwIGV4cGxpY2l0bHkuIE1ha2Ugc3VyZVxuICAgICAgICAvLyBub3QgdG8gb3ZlcnJpZGUgdGhlICdzdGVwJyBzZXR0aW5nIHdpdGggZmFsc2UuXG4gICAgICAgIGlmICghcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnhTdGVwc1swXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC54U3RlcHMucHVzaChpc05hTih2YWx1ZVsxXSkgPyBmYWxzZSA6IHZhbHVlWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXAucHVzaCgwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdGVwUG9pbnQoaSwgbiwgdGhhdCkge1xuICAgICAgICAvLyBJZ25vcmUgJ2ZhbHNlJyBzdGVwcGluZy5cbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcbiAgICAgICAgaWYgKHRoYXQueFZhbFtpXSA9PT0gdGhhdC54VmFsW2kgKyAxXSkge1xuICAgICAgICAgICAgdGhhdC54U3RlcHNbaV0gPSB0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwW2ldID0gdGhhdC54VmFsW2ldO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGYWN0b3IgdG8gcmFuZ2UgcmF0aW9cbiAgICAgICAgdGhhdC54U3RlcHNbaV0gPVxuICAgICAgICAgICAgZnJvbVBlcmNlbnRhZ2UoW3RoYXQueFZhbFtpXSwgdGhhdC54VmFsW2kgKyAxXV0sIG4sIDApIC8gc3ViUmFuZ2VSYXRpbyh0aGF0LnhQY3RbaV0sIHRoYXQueFBjdFtpICsgMV0pO1xuXG4gICAgICAgIHZhciB0b3RhbFN0ZXBzID0gKHRoYXQueFZhbFtpICsgMV0gLSB0aGF0LnhWYWxbaV0pIC8gdGhhdC54TnVtU3RlcHNbaV07XG4gICAgICAgIHZhciBoaWdoZXN0U3RlcCA9IE1hdGguY2VpbChOdW1iZXIodG90YWxTdGVwcy50b0ZpeGVkKDMpKSAtIDEpO1xuICAgICAgICB2YXIgc3RlcCA9IHRoYXQueFZhbFtpXSArIHRoYXQueE51bVN0ZXBzW2ldICogaGlnaGVzdFN0ZXA7XG5cbiAgICAgICAgdGhhdC54SGlnaGVzdENvbXBsZXRlU3RlcFtpXSA9IHN0ZXA7XG4gICAgfVxuXG4gICAgLy9lbmRyZWdpb25cblxuICAgIC8vcmVnaW9uIFNwZWN0cnVtXG5cbiAgICBmdW5jdGlvbiBTcGVjdHJ1bShlbnRyeSwgc25hcCwgc2luZ2xlU3RlcCkge1xuICAgICAgICB0aGlzLnhQY3QgPSBbXTtcbiAgICAgICAgdGhpcy54VmFsID0gW107XG4gICAgICAgIHRoaXMueFN0ZXBzID0gW3NpbmdsZVN0ZXAgfHwgZmFsc2VdO1xuICAgICAgICB0aGlzLnhOdW1TdGVwcyA9IFtmYWxzZV07XG4gICAgICAgIHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXAgPSBbXTtcblxuICAgICAgICB0aGlzLnNuYXAgPSBzbmFwO1xuXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgdmFyIG9yZGVyZWQgPSBbXTsgLy8gWzAsICdtaW4nXSwgWzEsICc1MCUnXSwgWzIsICdtYXgnXVxuXG4gICAgICAgIC8vIE1hcCB0aGUgb2JqZWN0IGtleXMgdG8gYW4gYXJyYXkuXG4gICAgICAgIGZvciAoaW5kZXggaW4gZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goW2VudHJ5W2luZGV4XSwgaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgYWxsIGVudHJpZXMgYnkgdmFsdWUgKG51bWVyaWMgc29ydCkuXG4gICAgICAgIGlmIChvcmRlcmVkLmxlbmd0aCAmJiB0eXBlb2Ygb3JkZXJlZFswXVswXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBlbnRyaWVzIHRvIHN1YnJhbmdlcy5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBhY3R1YWwgc3RlcCB2YWx1ZXMuXG4gICAgICAgIC8vIHhTdGVwcyBpcyBzb3J0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgeFBjdCBhbmQgeFZhbC5cbiAgICAgICAgdGhpcy54TnVtU3RlcHMgPSB0aGlzLnhTdGVwcy5zbGljZSgwKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBudW1lcmljIHN0ZXBzIHRvIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdWJyYW5nZSB0aGV5IHJlcHJlc2VudC5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy54TnVtU3RlcHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBoYW5kbGVTdGVwUG9pbnQoaW5kZXgsIHRoaXMueE51bVN0ZXBzW2luZGV4XSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBkaXN0YW5jZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGggLSAxOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBsYXN0IFwicmFuZ2VcIiBjYW4ndCBjb250YWluIHN0ZXAgc2l6ZSBhcyBpdCBpcyBwdXJlbHkgYW4gZW5kcG9pbnQuXG4gICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMueE51bVN0ZXBzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKHN0ZXAgJiYgKHZhbHVlIC8gc3RlcCkgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIm5vVWlTbGlkZXIgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZFUlNJT04gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpOiAnbGltaXQnLCAnbWFyZ2luJyBhbmQgJ3BhZGRpbmcnIG9mIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueFBjdFtpbmRleF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIlIHJhbmdlIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHN0ZXAuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcGVyY2VudHVhbCBkaXN0YW5jZSBpbiBjdXJyZW50IHJhbmdlIG9mIGxpbWl0LCBtYXJnaW4gb3IgcGFkZGluZ1xuICAgICAgICAgICAgZGlzdGFuY2VzW2luZGV4XSA9IGZyb21QZXJjZW50YWdlKHRoaXMueFZhbCwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0YW5jZXM7XG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvdmVyIHRoZSB3aG9sZSBzY2FsZSBvZiByYW5nZXMuXG4gICAgLy8gZGlyZWN0aW9uOiAwID0gYmFja3dhcmRzIC8gMSA9IGZvcndhcmRzXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmdldEFic29sdXRlRGlzdGFuY2UgPSBmdW5jdGlvbih2YWx1ZSwgZGlzdGFuY2VzLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHhQY3RfaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSByYW5nZSB3aGVyZSB0byBzdGFydCBjYWxjdWxhdGlvblxuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWUgPiB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICAgICAgeFBjdF9pbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0aGlzLnhQY3RbdGhpcy54UGN0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4ID0gdGhpcy54UGN0Lmxlbmd0aCAtIDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsb29raW5nIGJhY2t3YXJkcyBhbmQgdGhlIHZhbHVlIGlzIGV4YWN0bHkgYXQgYSByYW5nZSBzZXBhcmF0b3IgdGhlbiBsb29rIG9uZSByYW5nZSBmdXJ0aGVyXG4gICAgICAgIGlmICghZGlyZWN0aW9uICYmIHZhbHVlID09PSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIDFdKSB7XG4gICAgICAgICAgICB4UGN0X2luZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRfZmFjdG9yO1xuICAgICAgICB2YXIgcmVzdF9mYWN0b3IgPSAxO1xuXG4gICAgICAgIHZhciByZXN0X3JlbF9kaXN0YW5jZSA9IGRpc3RhbmNlc1t4UGN0X2luZGV4XTtcblxuICAgICAgICB2YXIgcmFuZ2VfcGN0ID0gMDtcblxuICAgICAgICB2YXIgcmVsX3JhbmdlX2Rpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIGFic19kaXN0YW5jZV9jb3VudGVyID0gMDtcbiAgICAgICAgdmFyIHJhbmdlX2NvdW50ZXIgPSAwO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGF0IHBhcnQgb2YgdGhlIHN0YXJ0IHJhbmdlIHRoZSB2YWx1ZSBpc1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBzdGFydF9mYWN0b3IgPSAodmFsdWUgLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pIC8gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRfZmFjdG9yID0gKHRoaXMueFBjdFt4UGN0X2luZGV4ICsgMV0gLSB2YWx1ZSkgLyAodGhpcy54UGN0W3hQY3RfaW5kZXggKyAxXSAtIHRoaXMueFBjdFt4UGN0X2luZGV4XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyB1bnRpbCB0aGUgY29tcGxldGUgZGlzdGFuY2UgYWNyb3NzIHJhbmdlcyBpcyBjYWxjdWxhdGVkXG4gICAgICAgIHdoaWxlIChyZXN0X3JlbF9kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBvZiB0b3RhbCByYW5nZVxuICAgICAgICAgICAgcmFuZ2VfcGN0ID0gdGhpcy54UGN0W3hQY3RfaW5kZXggKyAxICsgcmFuZ2VfY291bnRlcl0gLSB0aGlzLnhQY3RbeFBjdF9pbmRleCArIHJhbmdlX2NvdW50ZXJdO1xuXG4gICAgICAgICAgICAvLyBEZXRlY3QgaWYgdGhlIG1hcmdpbiwgcGFkZGluZyBvciBsaW1pdCBpcyBsYXJnZXIgdGhlbiB0aGUgY3VycmVudCByYW5nZSBhbmQgY2FsY3VsYXRlXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJlc3RfZmFjdG9yICsgMTAwIC0gc3RhcnRfZmFjdG9yICogMTAwID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGFyZ2VyIHRoZW4gdGFrZSB0aGUgcGVyY2VudHVhbCBkaXN0YW5jZSBvZiB0aGUgd2hvbGUgcmFuZ2VcbiAgICAgICAgICAgICAgICByZWxfcmFuZ2VfZGlzdGFuY2UgPSByYW5nZV9wY3QgKiBzdGFydF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgLy8gUmVzdCBmYWN0b3Igb2YgcmVsYXRpdmUgcGVyY2VudHVhbCBkaXN0YW5jZSBzdGlsbCB0byBiZSBjYWxjdWxhdGVkXG4gICAgICAgICAgICAgICAgcmVzdF9mYWN0b3IgPSAocmVzdF9yZWxfZGlzdGFuY2UgLSAxMDAgKiBzdGFydF9mYWN0b3IpIC8gZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgc3RhcnQgZmFjdG9yIHRvIDEgYXMgZm9yIG5leHQgcmFuZ2UgaXQgZG9lcyBub3QgYXBwbHkuXG4gICAgICAgICAgICAgICAgc3RhcnRfZmFjdG9yID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc21hbGxlciBvciBlcXVhbCB0aGVuIHRha2UgdGhlIHBlcmNlbnR1YWwgZGlzdGFuY2Ugb2YgdGhlIGNhbGN1bGF0ZSBwZXJjZW50dWFsIHBhcnQgb2YgdGhhdCByYW5nZVxuICAgICAgICAgICAgICAgIHJlbF9yYW5nZV9kaXN0YW5jZSA9ICgoZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJhbmdlX3BjdCkgLyAxMDApICogcmVzdF9mYWN0b3I7XG4gICAgICAgICAgICAgICAgLy8gTm8gcmVzdCBsZWZ0IGFzIHRoZSByZXN0IGZpdHMgaW4gY3VycmVudCByYW5nZVxuICAgICAgICAgICAgICAgIHJlc3RfZmFjdG9yID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGFic19kaXN0YW5jZV9jb3VudGVyID0gYWJzX2Rpc3RhbmNlX2NvdW50ZXIgLSByZWxfcmFuZ2VfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gTGltaXQgcmFuZ2UgdG8gZmlyc3QgcmFuZ2Ugd2hlbiBkaXN0YW5jZSBiZWNvbWVzIG91dHNpZGUgb2YgbWluaW11bSByYW5nZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnhQY3QubGVuZ3RoICsgcmFuZ2VfY291bnRlciA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlX2NvdW50ZXItLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFic19kaXN0YW5jZV9jb3VudGVyID0gYWJzX2Rpc3RhbmNlX2NvdW50ZXIgKyByZWxfcmFuZ2VfZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gTGltaXQgcmFuZ2UgdG8gbGFzdCByYW5nZSB3aGVuIGRpc3RhbmNlIGJlY29tZXMgb3V0c2lkZSBvZiBtYXhpbXVtIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMueFBjdC5sZW5ndGggLSByYW5nZV9jb3VudGVyID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VfY291bnRlcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzdCBvZiByZWxhdGl2ZSBwZXJjZW50dWFsIGRpc3RhbmNlIHN0aWxsIHRvIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIHJlc3RfcmVsX2Rpc3RhbmNlID0gZGlzdGFuY2VzW3hQY3RfaW5kZXggKyByYW5nZV9jb3VudGVyXSAqIHJlc3RfZmFjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgYWJzX2Rpc3RhbmNlX2NvdW50ZXI7XG4gICAgfTtcblxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZnJvbVN0ZXBwaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdGVwcGluZyh0aGlzLnhWYWwsIHRoaXMueFBjdCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0U3RlcCh0aGlzLnhQY3QsIHRoaXMueFN0ZXBzLCB0aGlzLnNuYXAsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXREZWZhdWx0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlLCBpc0Rvd24sIHNpemUpIHtcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xuXG4gICAgICAgIC8vIFdoZW4gYXQgdGhlIHRvcCBvciBzdGVwcGluZyBkb3duLCBsb29rIGF0IHRoZSBwcmV2aW91cyBzdWItcmFuZ2VcbiAgICAgICAgaWYgKHZhbHVlID09PSAxMDAgfHwgKGlzRG93biAmJiB2YWx1ZSA9PT0gdGhpcy54UGN0W2ogLSAxXSkpIHtcbiAgICAgICAgICAgIGogPSBNYXRoLm1heChqIC0gMSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRoaXMueFZhbFtqXSAtIHRoaXMueFZhbFtqIC0gMV0pIC8gc2l6ZTtcbiAgICB9O1xuXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmdldE5lYXJieVN0ZXBzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGVwQmVmb3JlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2ogLSAyXSxcbiAgICAgICAgICAgICAgICBzdGVwOiB0aGlzLnhOdW1TdGVwc1tqIC0gMl0sXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDJdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhpc1N0ZXA6IHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDFdLFxuICAgICAgICAgICAgICAgIHN0ZXA6IHRoaXMueE51bVN0ZXBzW2ogLSAxXSxcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqIC0gMV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGVwQWZ0ZXI6IHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbal0sXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbal0sXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbal1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmNvdW50U3RlcERlY2ltYWxzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGVwRGVjaW1hbHMgPSB0aGlzLnhOdW1TdGVwcy5tYXAoY291bnREZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBzdGVwRGVjaW1hbHMpO1xuICAgIH07XG5cbiAgICAvLyBPdXRzaWRlIHRlc3RpbmdcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXAodGhpcy50b1N0ZXBwaW5nKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIC8vZW5kcmVnaW9uXG5cbiAgICAvL3JlZ2lvbiBPcHRpb25zXG5cbiAgICAvKlx0RXZlcnkgaW5wdXQgb3B0aW9uIGlzIHRlc3RlZCBhbmQgcGFyc2VkLiBUaGlzJ2xsIHByZXZlbnRcbiAgICAgICAgZW5kbGVzcyB2YWxpZGF0aW9uIGluIGludGVybmFsIG1ldGhvZHMuIFRoZXNlIHRlc3RzIGFyZVxuICAgICAgICBzdHJ1Y3R1cmVkIHdpdGggYW4gaXRlbSBmb3IgZXZlcnkgb3B0aW9uIGF2YWlsYWJsZS4gQW5cbiAgICAgICAgb3B0aW9uIGNhbiBiZSBtYXJrZWQgYXMgcmVxdWlyZWQgYnkgc2V0dGluZyB0aGUgJ3InIGZsYWcuXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAgICAgICAgLSBUaGUgcHJvdmlkZWQgdmFsdWUgZm9yIHRoZSBvcHRpb247XG4gICAgICAgICAgICAtIEEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdDtcbiAgICAgICAgICAgIC0gVGhlIG5hbWUgZm9yIHRoZSBvcHRpb247XG5cbiAgICAgICAgVGhlIHRlc3RpbmcgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB3aGVuIGFuIGVycm9yIGlzIGRldGVjdGVkLFxuICAgICAgICBvciB0cnVlIHdoZW4gZXZlcnl0aGluZyBpcyBPSy4gSXQgY2FuIGFsc28gbW9kaWZ5IHRoZSBvcHRpb25cbiAgICAgICAgb2JqZWN0LCB0byBtYWtlIHN1cmUgYWxsIHZhbHVlcyBjYW4gYmUgY29ycmVjdGx5IGxvb3BlZCBlbHNld2hlcmUuICovXG5cbiAgICAvL3JlZ2lvbiBEZWZhdWx0c1xuXG4gICAgdmFyIGRlZmF1bHRGb3JtYXR0ZXIgPSB7XG4gICAgICAgIHRvOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudG9GaXhlZCgyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbTogTnVtYmVyXG4gICAgfTtcblxuICAgIHZhciBjc3NDbGFzc2VzID0ge1xuICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXG4gICAgICAgIGJhc2U6IFwiYmFzZVwiLFxuICAgICAgICBvcmlnaW46IFwib3JpZ2luXCIsXG4gICAgICAgIGhhbmRsZTogXCJoYW5kbGVcIixcbiAgICAgICAgaGFuZGxlTG93ZXI6IFwiaGFuZGxlLWxvd2VyXCIsXG4gICAgICAgIGhhbmRsZVVwcGVyOiBcImhhbmRsZS11cHBlclwiLFxuICAgICAgICB0b3VjaEFyZWE6IFwidG91Y2gtYXJlYVwiLFxuICAgICAgICBob3Jpem9udGFsOiBcImhvcml6b250YWxcIixcbiAgICAgICAgdmVydGljYWw6IFwidmVydGljYWxcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXG4gICAgICAgIGNvbm5lY3Q6IFwiY29ubmVjdFwiLFxuICAgICAgICBjb25uZWN0czogXCJjb25uZWN0c1wiLFxuICAgICAgICBsdHI6IFwibHRyXCIsXG4gICAgICAgIHJ0bDogXCJydGxcIixcbiAgICAgICAgdGV4dERpcmVjdGlvbkx0cjogXCJ0eHQtZGlyLWx0clwiLFxuICAgICAgICB0ZXh0RGlyZWN0aW9uUnRsOiBcInR4dC1kaXItcnRsXCIsXG4gICAgICAgIGRyYWdnYWJsZTogXCJkcmFnZ2FibGVcIixcbiAgICAgICAgZHJhZzogXCJzdGF0ZS1kcmFnXCIsXG4gICAgICAgIHRhcDogXCJzdGF0ZS10YXBcIixcbiAgICAgICAgYWN0aXZlOiBcImFjdGl2ZVwiLFxuICAgICAgICB0b29sdGlwOiBcInRvb2x0aXBcIixcbiAgICAgICAgcGlwczogXCJwaXBzXCIsXG4gICAgICAgIHBpcHNIb3Jpem9udGFsOiBcInBpcHMtaG9yaXpvbnRhbFwiLFxuICAgICAgICBwaXBzVmVydGljYWw6IFwicGlwcy12ZXJ0aWNhbFwiLFxuICAgICAgICBtYXJrZXI6IFwibWFya2VyXCIsXG4gICAgICAgIG1hcmtlckhvcml6b250YWw6IFwibWFya2VyLWhvcml6b250YWxcIixcbiAgICAgICAgbWFya2VyVmVydGljYWw6IFwibWFya2VyLXZlcnRpY2FsXCIsXG4gICAgICAgIG1hcmtlck5vcm1hbDogXCJtYXJrZXItbm9ybWFsXCIsXG4gICAgICAgIG1hcmtlckxhcmdlOiBcIm1hcmtlci1sYXJnZVwiLFxuICAgICAgICBtYXJrZXJTdWI6IFwibWFya2VyLXN1YlwiLFxuICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxuICAgICAgICB2YWx1ZUhvcml6b250YWw6IFwidmFsdWUtaG9yaXpvbnRhbFwiLFxuICAgICAgICB2YWx1ZVZlcnRpY2FsOiBcInZhbHVlLXZlcnRpY2FsXCIsXG4gICAgICAgIHZhbHVlTm9ybWFsOiBcInZhbHVlLW5vcm1hbFwiLFxuICAgICAgICB2YWx1ZUxhcmdlOiBcInZhbHVlLWxhcmdlXCIsXG4gICAgICAgIHZhbHVlU3ViOiBcInZhbHVlLXN1YlwiXG4gICAgfTtcblxuICAgIC8vIE5hbWVzcGFjZXMgb2YgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gICAgdmFyIElOVEVSTkFMX0VWRU5UX05TID0ge1xuICAgICAgICB0b29sdGlwczogXCIuX190b29sdGlwc1wiLFxuICAgICAgICBhcmlhOiBcIi5fX2FyaWFcIlxuICAgIH07XG5cbiAgICAvL2VuZHJlZ2lvblxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZW50cnkpIHtcbiAgICAgICAgLy8gQW55IG9iamVjdCB3aXRoIGEgdG8gYW5kIGZyb20gbWV0aG9kIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgaWYgKGlzVmFsaWRGb3JtYXR0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2Zvcm1hdCcgcmVxdWlyZXMgJ3RvJyBhbmQgJ2Zyb20nIG1ldGhvZHMuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RTdGVwKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdzdGVwJyBpcyBub3QgbnVtZXJpYy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc3RlcCBvcHRpb24gY2FuIHN0aWxsIGJlIHVzZWQgdG8gc2V0IHN0ZXBwaW5nXG4gICAgICAgIC8vIGZvciBsaW5lYXIgc2xpZGVycy4gT3ZlcndyaXR0ZW4gaWYgc2V0IGluICdyYW5nZScuXG4gICAgICAgIHBhcnNlZC5zaW5nbGVTdGVwID0gZW50cnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkUGFnZU11bHRpcGxpZXIocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2tleWJvYXJkUGFnZU11bHRpcGxpZXInIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFBhZ2VNdWx0aXBsaWVyID0gZW50cnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkRGVmYXVsdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2tleWJvYXJkRGVmYXVsdFN0ZXAnIGlzIG5vdCBudW1lcmljLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZERlZmF1bHRTdGVwID0gZW50cnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdFJhbmdlKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gRmlsdGVyIGluY29ycmVjdCBpbnB1dC5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncmFuZ2UnIGlzIG5vdCBhbiBvYmplY3QuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2F0Y2ggbWlzc2luZyBzdGFydCBvciBlbmQuXG4gICAgICAgIGlmIChlbnRyeS5taW4gPT09IHVuZGVmaW5lZCB8fCBlbnRyeS5tYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBNaXNzaW5nICdtaW4nIG9yICdtYXgnIGluICdyYW5nZScuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2F0Y2ggZXF1YWwgc3RhcnQgb3IgZW5kLlxuICAgICAgICBpZiAoZW50cnkubWluID09PSBlbnRyeS5tYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyAnbWluJyBhbmQgJ21heCcgY2Fubm90IGJlIGVxdWFsLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5zcGVjdHJ1bSA9IG5ldyBTcGVjdHJ1bShlbnRyeSwgcGFyc2VkLnNuYXAsIHBhcnNlZC5zaW5nbGVTdGVwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0U3RhcnQocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBlbnRyeSA9IGFzQXJyYXkoZW50cnkpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0LiBWYWx1ZXMgYXJlbid0IHRlc3RlZCwgYXMgdGhlIHB1YmxpYyAudmFsIG1ldGhvZFxuICAgICAgICAvLyB3aWxsIGFsd2F5cyBwcm92aWRlIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkgfHwgIWVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIG51bWJlciBvZiBoYW5kbGVzLlxuICAgICAgICBwYXJzZWQuaGFuZGxlcyA9IGVudHJ5Lmxlbmd0aDtcblxuICAgICAgICAvLyBXaGVuIHRoZSBzbGlkZXIgaXMgaW5pdGlhbGl6ZWQsIHRoZSAudmFsIG1ldGhvZCB3aWxsXG4gICAgICAgIC8vIGJlIGNhbGxlZCB3aXRoIHRoZSBzdGFydCBvcHRpb25zLlxuICAgICAgICBwYXJzZWQuc3RhcnQgPSBlbnRyeTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0U25hcChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIEVuZm9yY2UgMTAwJSBzdGVwcGluZyB3aXRoaW4gc3VicmFuZ2VzLlxuICAgICAgICBwYXJzZWQuc25hcCA9IGVudHJ5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdzbmFwJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEFuaW1hdGUocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cbiAgICAgICAgcGFyc2VkLmFuaW1hdGUgPSBlbnRyeTtcblxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnYW5pbWF0ZScgb3B0aW9uIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRpb25EdXJhdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHBhcnNlZC5hbmltYXRpb25EdXJhdGlvbiA9IGVudHJ5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2FuaW1hdGlvbkR1cmF0aW9uJyBvcHRpb24gbXVzdCBiZSBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0Q29ubmVjdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHZhciBjb25uZWN0ID0gW2ZhbHNlXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgLy8gTWFwIGxlZ2FjeSBvcHRpb25zXG4gICAgICAgIGlmIChlbnRyeSA9PT0gXCJsb3dlclwiKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFt0cnVlLCBmYWxzZV07XG4gICAgICAgIH0gZWxzZSBpZiAoZW50cnkgPT09IFwidXBwZXJcIikge1xuICAgICAgICAgICAgZW50cnkgPSBbZmFsc2UsIHRydWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGJvb2xlYW4gb3B0aW9uc1xuICAgICAgICBpZiAoZW50cnkgPT09IHRydWUgfHwgZW50cnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbm5lY3QucHVzaChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWplY3QgaW52YWxpZCBpbnB1dFxuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShlbnRyeSkgfHwgIWVudHJ5Lmxlbmd0aCB8fCBlbnRyeS5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzICsgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY29ubmVjdCcgb3B0aW9uIGRvZXNuJ3QgbWF0Y2ggaGFuZGxlIGNvdW50LlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbm5lY3QgPSBlbnRyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5jb25uZWN0ID0gY29ubmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0T3JpZW50YXRpb24ocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICAvLyBTZXQgb3JpZW50YXRpb24gdG8gYW4gYSBudW1lcmljYWwgdmFsdWUgZm9yIGVhc3lcbiAgICAgICAgLy8gYXJyYXkgc2VsZWN0aW9uLlxuICAgICAgICBzd2l0Y2ggKGVudHJ5KSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICAgICAgICAgIHBhcnNlZC5vcnQgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ29yaWVudGF0aW9uJyBvcHRpb24gaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0TWFyZ2luKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdtYXJnaW4nIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXNzdWUgIzU4MlxuICAgICAgICBpZiAoZW50cnkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZC5tYXJnaW4gPSBwYXJzZWQuc3BlY3RydW0uZ2V0RGlzdGFuY2UoZW50cnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RMaW1pdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbGltaXQnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmxpbWl0ID0gcGFyc2VkLnNwZWN0cnVtLmdldERpc3RhbmNlKGVudHJ5KTtcblxuICAgICAgICBpZiAoIXBhcnNlZC5saW1pdCB8fCBwYXJzZWQuaGFuZGxlcyA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIm5vVWlTbGlkZXIgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgVkVSU0lPTiArXG4gICAgICAgICAgICAgICAgICAgIFwiKTogJ2xpbWl0JyBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gbGluZWFyIHNsaWRlcnMgd2l0aCAyIG9yIG1vcmUgaGFuZGxlcy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RQYWRkaW5nKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgdmFyIGluZGV4O1xuXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSAmJiAhQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMgb3IgYXJyYXkgb2YgZXhhY3RseSAyIG51bWJlcnMuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkgJiYgIShlbnRyeS5sZW5ndGggPT09IDIgfHwgaXNOdW1lcmljKGVudHJ5WzBdKSB8fCBpc051bWVyaWMoZW50cnlbMV0pKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICAgICAgZW50cnkgPSBbZW50cnksIGVudHJ5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdnZXREaXN0YW5jZScgcmV0dXJucyBmYWxzZSBmb3IgaW52YWxpZCB2YWx1ZXMuXG4gICAgICAgIHBhcnNlZC5wYWRkaW5nID0gW3BhcnNlZC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlbnRyeVswXSksIHBhcnNlZC5zcGVjdHJ1bS5nZXREaXN0YW5jZShlbnRyeVsxXSldO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnNlZC5zcGVjdHJ1bS54TnVtU3RlcHMubGVuZ3RoIC0gMTsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gbGFzdCBcInJhbmdlXCIgY2FuJ3QgY29udGFpbiBzdGVwIHNpemUgYXMgaXQgaXMgcHVyZWx5IGFuIGVuZHBvaW50LlxuICAgICAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdW2luZGV4XSA8IDAgfHwgcGFyc2VkLnBhZGRpbmdbMV1baW5kZXhdIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKHMpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbFBhZGRpbmcgPSBlbnRyeVswXSArIGVudHJ5WzFdO1xuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IHBhcnNlZC5zcGVjdHJ1bS54VmFsWzBdO1xuICAgICAgICB2YXIgbGFzdFZhbHVlID0gcGFyc2VkLnNwZWN0cnVtLnhWYWxbcGFyc2VkLnNwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHRvdGFsUGFkZGluZyAvIChsYXN0VmFsdWUgLSBmaXJzdFZhbHVlKSA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IG5vdCBleGNlZWQgMTAwJSBvZiB0aGUgcmFuZ2UuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdERpcmVjdGlvbihwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFNldCBkaXJlY3Rpb24gYXMgYSBudW1lcmljYWwgdmFsdWUgZm9yIGVhc3kgcGFyc2luZy5cbiAgICAgICAgLy8gSW52ZXJ0IGNvbm5lY3Rpb24gZm9yIFJUTCBzbGlkZXJzLCBzbyB0aGF0IHRoZSBwcm9wZXJcbiAgICAgICAgLy8gaGFuZGxlcyBnZXQgdGhlIGNvbm5lY3QvYmFja2dyb3VuZCBjbGFzc2VzLlxuICAgICAgICBzd2l0Y2ggKGVudHJ5KSB7XG4gICAgICAgICAgICBjYXNlIFwibHRyXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VkLmRpciA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicnRsXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VkLmRpciA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2RpcmVjdGlvbicgb3B0aW9uIHdhcyBub3QgcmVjb2duaXplZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0QmVoYXZpb3VyKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBpbnB1dCBpcyBhIHN0cmluZy5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnYmVoYXZpb3VyJyBtdXN0IGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgb3B0aW9ucy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIGFueSBrZXl3b3Jkcy5cbiAgICAgICAgLy8gTm9uZSBhcmUgcmVxdWlyZWQuXG4gICAgICAgIHZhciB0YXAgPSBlbnRyeS5pbmRleE9mKFwidGFwXCIpID49IDA7XG4gICAgICAgIHZhciBkcmFnID0gZW50cnkuaW5kZXhPZihcImRyYWdcIikgPj0gMDtcbiAgICAgICAgdmFyIGZpeGVkID0gZW50cnkuaW5kZXhPZihcImZpeGVkXCIpID49IDA7XG4gICAgICAgIHZhciBzbmFwID0gZW50cnkuaW5kZXhPZihcInNuYXBcIikgPj0gMDtcbiAgICAgICAgdmFyIGhvdmVyID0gZW50cnkuaW5kZXhPZihcImhvdmVyXCIpID49IDA7XG4gICAgICAgIHZhciB1bmNvbnN0cmFpbmVkID0gZW50cnkuaW5kZXhPZihcInVuY29uc3RyYWluZWRcIikgPj0gMDtcblxuICAgICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWQuaGFuZGxlcyAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2ZpeGVkJyBiZWhhdmlvdXIgbXVzdCBiZSB1c2VkIHdpdGggMiBoYW5kbGVzXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgbWFyZ2luIHRvIGVuZm9yY2UgZml4ZWQgc3RhdGVcbiAgICAgICAgICAgIHRlc3RNYXJnaW4ocGFyc2VkLCBwYXJzZWQuc3RhcnRbMV0gLSBwYXJzZWQuc3RhcnRbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuY29uc3RyYWluZWQgJiYgKHBhcnNlZC5tYXJnaW4gfHwgcGFyc2VkLmxpbWl0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndW5jb25zdHJhaW5lZCcgYmVoYXZpb3VyIGNhbm5vdCBiZSB1c2VkIHdpdGggbWFyZ2luIG9yIGxpbWl0XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQuZXZlbnRzID0ge1xuICAgICAgICAgICAgdGFwOiB0YXAgfHwgc25hcCxcbiAgICAgICAgICAgIGRyYWc6IGRyYWcsXG4gICAgICAgICAgICBmaXhlZDogZml4ZWQsXG4gICAgICAgICAgICBzbmFwOiBzbmFwLFxuICAgICAgICAgICAgaG92ZXI6IGhvdmVyLFxuICAgICAgICAgICAgdW5jb25zdHJhaW5lZDogdW5jb25zdHJhaW5lZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RUb29sdGlwcyhwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyc2VkLmhhbmRsZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkLnRvb2x0aXBzID0gYXNBcnJheShlbnRyeSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZWQudG9vbHRpcHMubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogbXVzdCBwYXNzIGEgZm9ybWF0dGVyIGZvciBhbGwgaGFuZGxlcy5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uKGZvcm1hdHRlcikge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGZvcm1hdHRlciAhPT0gXCJib29sZWFuXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBmb3JtYXR0ZXIgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZvcm1hdHRlci50byAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICd0b29sdGlwcycgbXVzdCBiZSBwYXNzZWQgYSBmb3JtYXR0ZXIgb3IgJ2ZhbHNlJy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0QXJpYUZvcm1hdChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHBhcnNlZC5hcmlhRm9ybWF0ID0gZW50cnk7XG4gICAgICAgIHZhbGlkYXRlRm9ybWF0KGVudHJ5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0Rm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgcGFyc2VkLmZvcm1hdCA9IGVudHJ5O1xuICAgICAgICB2YWxpZGF0ZUZvcm1hdChlbnRyeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEtleWJvYXJkU3VwcG9ydChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFN1cHBvcnQgPSBlbnRyeTtcblxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAna2V5Ym9hcmRTdXBwb3J0JyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdERvY3VtZW50RWxlbWVudChwYXJzZWQsIGVudHJ5KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYWR2YW5jZWQgb3B0aW9uLiBQYXNzZWQgdmFsdWVzIGFyZSB1c2VkIHdpdGhvdXQgdmFsaWRhdGlvbi5cbiAgICAgICAgcGFyc2VkLmRvY3VtZW50RWxlbWVudCA9IGVudHJ5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RDc3NQcmVmaXgocGFyc2VkLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiICYmIGVudHJ5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY3NzUHJlZml4JyBtdXN0IGJlIGEgc3RyaW5nIG9yIGBmYWxzZWAuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkLmNzc1ByZWZpeCA9IGVudHJ5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RDc3NDbGFzc2VzKHBhcnNlZCwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnY3NzQ2xhc3NlcycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQuY3NzUHJlZml4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJzZWQuY3NzQ2xhc3NlcyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVudHJ5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXNba2V5XSA9IHBhcnNlZC5jc3NQcmVmaXggKyBlbnRyeVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRlc3QgYWxsIGRldmVsb3BlciBzZXR0aW5ncyBhbmQgcGFyc2UgdG8gYXNzdW1wdGlvbi1zYWZlIHZhbHVlcy5cbiAgICBmdW5jdGlvbiB0ZXN0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIC8vIFRvIHByb3ZlIGEgZml4IGZvciAjNTM3LCBmcmVlemUgb3B0aW9ucyBoZXJlLlxuICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIG1vZGlmaWVkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgICAgLy8gT2JqZWN0LmZyZWV6ZShvcHRpb25zKTtcblxuICAgICAgICB2YXIgcGFyc2VkID0ge1xuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgbGltaXQ6IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICBhcmlhRm9ybWF0OiBkZWZhdWx0Rm9ybWF0dGVyLFxuICAgICAgICAgICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0dGVyXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGVzdHMgYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBwcmVzZW50ZWQgaGVyZS5cbiAgICAgICAgdmFyIHRlc3RzID0ge1xuICAgICAgICAgICAgc3RlcDogeyByOiBmYWxzZSwgdDogdGVzdFN0ZXAgfSxcbiAgICAgICAgICAgIGtleWJvYXJkUGFnZU11bHRpcGxpZXI6IHsgcjogZmFsc2UsIHQ6IHRlc3RLZXlib2FyZFBhZ2VNdWx0aXBsaWVyIH0sXG4gICAgICAgICAgICBrZXlib2FyZERlZmF1bHRTdGVwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0S2V5Ym9hcmREZWZhdWx0U3RlcCB9LFxuICAgICAgICAgICAgc3RhcnQ6IHsgcjogdHJ1ZSwgdDogdGVzdFN0YXJ0IH0sXG4gICAgICAgICAgICBjb25uZWN0OiB7IHI6IHRydWUsIHQ6IHRlc3RDb25uZWN0IH0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IHsgcjogdHJ1ZSwgdDogdGVzdERpcmVjdGlvbiB9LFxuICAgICAgICAgICAgc25hcDogeyByOiBmYWxzZSwgdDogdGVzdFNuYXAgfSxcbiAgICAgICAgICAgIGFuaW1hdGU6IHsgcjogZmFsc2UsIHQ6IHRlc3RBbmltYXRlIH0sXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGlvbkR1cmF0aW9uIH0sXG4gICAgICAgICAgICByYW5nZTogeyByOiB0cnVlLCB0OiB0ZXN0UmFuZ2UgfSxcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiB7IHI6IGZhbHNlLCB0OiB0ZXN0T3JpZW50YXRpb24gfSxcbiAgICAgICAgICAgIG1hcmdpbjogeyByOiBmYWxzZSwgdDogdGVzdE1hcmdpbiB9LFxuICAgICAgICAgICAgbGltaXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RMaW1pdCB9LFxuICAgICAgICAgICAgcGFkZGluZzogeyByOiBmYWxzZSwgdDogdGVzdFBhZGRpbmcgfSxcbiAgICAgICAgICAgIGJlaGF2aW91cjogeyByOiB0cnVlLCB0OiB0ZXN0QmVoYXZpb3VyIH0sXG4gICAgICAgICAgICBhcmlhRm9ybWF0OiB7IHI6IGZhbHNlLCB0OiB0ZXN0QXJpYUZvcm1hdCB9LFxuICAgICAgICAgICAgZm9ybWF0OiB7IHI6IGZhbHNlLCB0OiB0ZXN0Rm9ybWF0IH0sXG4gICAgICAgICAgICB0b29sdGlwczogeyByOiBmYWxzZSwgdDogdGVzdFRvb2x0aXBzIH0sXG4gICAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHsgcjogdHJ1ZSwgdDogdGVzdEtleWJvYXJkU3VwcG9ydCB9LFxuICAgICAgICAgICAgZG9jdW1lbnRFbGVtZW50OiB7IHI6IGZhbHNlLCB0OiB0ZXN0RG9jdW1lbnRFbGVtZW50IH0sXG4gICAgICAgICAgICBjc3NQcmVmaXg6IHsgcjogdHJ1ZSwgdDogdGVzdENzc1ByZWZpeCB9LFxuICAgICAgICAgICAgY3NzQ2xhc3NlczogeyByOiB0cnVlLCB0OiB0ZXN0Q3NzQ2xhc3NlcyB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgY29ubmVjdDogZmFsc2UsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgICBiZWhhdmlvdXI6IFwidGFwXCIsXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHRydWUsXG4gICAgICAgICAgICBjc3NQcmVmaXg6IFwibm9VaS1cIixcbiAgICAgICAgICAgIGNzc0NsYXNzZXM6IGNzc0NsYXNzZXMsXG4gICAgICAgICAgICBrZXlib2FyZFBhZ2VNdWx0aXBsaWVyOiA1LFxuICAgICAgICAgICAga2V5Ym9hcmREZWZhdWx0U3RlcDogMTBcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBcmlhRm9ybWF0IGRlZmF1bHRzIHRvIHJlZ3VsYXIgZm9ybWF0LCBpZiBhbnkuXG4gICAgICAgIGlmIChvcHRpb25zLmZvcm1hdCAmJiAhb3B0aW9ucy5hcmlhRm9ybWF0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmFyaWFGb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1biBhbGwgb3B0aW9ucyB0aHJvdWdoIGEgdGVzdGluZyBtZWNoYW5pc20gdG8gZW5zdXJlIGNvcnJlY3RcbiAgICAgICAgLy8gaW5wdXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IG9wdGlvbnMgbWlnaHQgZ2V0IG1vZGlmaWVkIHRvXG4gICAgICAgIC8vIGJlIGhhbmRsZWQgcHJvcGVybHkuIEUuZy4gd3JhcHBpbmcgaW50ZWdlcnMgaW4gYXJyYXlzLlxuICAgICAgICBPYmplY3Qua2V5cyh0ZXN0cykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW9uIGlzbid0IHNldCwgYnV0IGl0IGlzIHJlcXVpcmVkLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmICghaXNTZXQob3B0aW9uc1tuYW1lXSkgJiYgZGVmYXVsdHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0c1tuYW1lXS5yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ1wiICsgbmFtZSArIFwiJyBpcyByZXF1aXJlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlc3RzW25hbWVdLnQocGFyc2VkLCAhaXNTZXQob3B0aW9uc1tuYW1lXSkgPyBkZWZhdWx0c1tuYW1lXSA6IG9wdGlvbnNbbmFtZV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGb3J3YXJkIHBpcHMgb3B0aW9uc1xuICAgICAgICBwYXJzZWQucGlwcyA9IG9wdGlvbnMucGlwcztcblxuICAgICAgICAvLyBBbGwgcmVjZW50IGJyb3dzZXJzIGFjY2VwdCB1bnByZWZpeGVkIHRyYW5zZm9ybS5cbiAgICAgICAgLy8gV2UgbmVlZCAtbXMtIGZvciBJRTkgYW5kIC13ZWJraXQtIGZvciBvbGRlciBBbmRyb2lkO1xuICAgICAgICAvLyBBc3N1bWUgdXNlIG9mIC13ZWJraXQtIGlmIHVucHJlZml4ZWQgYW5kIC1tcy0gYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9dHJhbnNmb3JtczJkXG4gICAgICAgIHZhciBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG1zUHJlZml4ID0gZC5zdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbm9QcmVmaXggPSBkLnN0eWxlLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHBhcnNlZC50cmFuc2Zvcm1SdWxlID0gbm9QcmVmaXggPyBcInRyYW5zZm9ybVwiIDogbXNQcmVmaXggPyBcIm1zVHJhbnNmb3JtXCIgOiBcIndlYmtpdFRyYW5zZm9ybVwiO1xuXG4gICAgICAgIC8vIFBpcHMgZG9uJ3QgbW92ZSwgc28gd2UgY2FuIHBsYWNlIHRoZW0gdXNpbmcgbGVmdC90b3AuXG4gICAgICAgIHZhciBzdHlsZXMgPSBbW1wibGVmdFwiLCBcInRvcFwiXSwgW1wicmlnaHRcIiwgXCJib3R0b21cIl1dO1xuXG4gICAgICAgIHBhcnNlZC5zdHlsZSA9IHN0eWxlc1twYXJzZWQuZGlyXVtwYXJzZWQub3J0XTtcblxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cblxuICAgIC8vZW5kcmVnaW9uXG5cbiAgICBmdW5jdGlvbiBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgICAgICAgdmFyIHN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lID0gZ2V0U3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUoKTtcbiAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IHN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lICYmIGdldFN1cHBvcnRzUGFzc2l2ZSgpO1xuXG4gICAgICAgIC8vIEFsbCB2YXJpYWJsZXMgbG9jYWwgdG8gJ3Njb3BlJyBhcmUgcHJlZml4ZWQgd2l0aCAnc2NvcGVfJ1xuXG4gICAgICAgIC8vIFNsaWRlciBET00gTm9kZXNcbiAgICAgICAgdmFyIHNjb3BlX1RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdmFyIHNjb3BlX0Jhc2U7XG4gICAgICAgIHZhciBzY29wZV9IYW5kbGVzO1xuICAgICAgICB2YXIgc2NvcGVfQ29ubmVjdHM7XG4gICAgICAgIHZhciBzY29wZV9QaXBzO1xuICAgICAgICB2YXIgc2NvcGVfVG9vbHRpcHM7XG5cbiAgICAgICAgLy8gU2xpZGVyIHN0YXRlIHZhbHVlc1xuICAgICAgICB2YXIgc2NvcGVfU3BlY3RydW0gPSBvcHRpb25zLnNwZWN0cnVtO1xuICAgICAgICB2YXIgc2NvcGVfVmFsdWVzID0gW107XG4gICAgICAgIHZhciBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZU51bWJlcnMgPSBbXTtcbiAgICAgICAgdmFyIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9IDA7XG4gICAgICAgIHZhciBzY29wZV9FdmVudHMgPSB7fTtcblxuICAgICAgICAvLyBFeHBvc2VkIEFQSVxuICAgICAgICB2YXIgc2NvcGVfU2VsZjtcblxuICAgICAgICAvLyBEb2N1bWVudCBOb2Rlc1xuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgICAgdmFyIHNjb3BlX0RvY3VtZW50RWxlbWVudCA9IG9wdGlvbnMuZG9jdW1lbnRFbGVtZW50IHx8IHNjb3BlX0RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHNjb3BlX0JvZHkgPSBzY29wZV9Eb2N1bWVudC5ib2R5O1xuXG4gICAgICAgIC8vIFBpcHMgY29uc3RhbnRzXG4gICAgICAgIHZhciBQSVBTX05PTkUgPSAtMTtcbiAgICAgICAgdmFyIFBJUFNfTk9fVkFMVUUgPSAwO1xuICAgICAgICB2YXIgUElQU19MQVJHRV9WQUxVRSA9IDE7XG4gICAgICAgIHZhciBQSVBTX1NNQUxMX1ZBTFVFID0gMjtcblxuICAgICAgICAvLyBGb3IgaG9yaXpvbnRhbCBzbGlkZXJzIGluIHN0YW5kYXJkIGx0ciBkb2N1bWVudHMsXG4gICAgICAgIC8vIG1ha2UgLm5vVWktb3JpZ2luIG92ZXJmbG93IHRvIHRoZSBsZWZ0IHNvIHRoZSBkb2N1bWVudCBkb2Vzbid0IHNjcm9sbC5cbiAgICAgICAgdmFyIHNjb3BlX0Rpck9mZnNldCA9IHNjb3BlX0RvY3VtZW50LmRpciA9PT0gXCJydGxcIiB8fCBvcHRpb25zLm9ydCA9PT0gMSA/IDAgOiAxMDA7XG5cbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5vZGUsIGFkZHMgaXQgdG8gdGFyZ2V0LCByZXR1cm5zIHRoZSBuZXcgbm9kZS5cbiAgICAgICAgZnVuY3Rpb24gYWRkTm9kZVRvKGFkZFRhcmdldCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YXIgZGl2ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGRpdiwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkVGFyZ2V0LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgYSBvcmlnaW4gdG8gdGhlIGJhc2VcbiAgICAgICAgZnVuY3Rpb24gYWRkT3JpZ2luKGJhc2UsIGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMub3JpZ2luKTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGROb2RlVG8ob3JpZ2luLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlKTtcblxuICAgICAgICAgICAgYWRkTm9kZVRvKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLnRvdWNoQXJlYSk7XG5cbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhbmRsZVwiLCBoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZFN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4XG4gICAgICAgICAgICAgICAgLy8gMCA9IGZvY3VzYWJsZSBhbmQgcmVhY2hhYmxlXG4gICAgICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50S2V5ZG93bihldmVudCwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzbGlkZXJcIik7XG4gICAgICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBvcHRpb25zLm9ydCA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiKTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmhhbmRsZUxvd2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlTnVtYmVyID09PSBvcHRpb25zLmhhbmRsZXMgLSAxKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlVXBwZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IG5vZGVzIGZvciBjb25uZWN0IGVsZW1lbnRzXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbm5lY3QoYmFzZSwgYWRkKSB7XG4gICAgICAgICAgICBpZiAoIWFkZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEVsZW1lbnRzKGNvbm5lY3RPcHRpb25zLCBiYXNlKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdEJhc2UgPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmNvbm5lY3RzKTtcblxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlcyA9IFtdO1xuICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMgPSBbXTtcblxuICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMucHVzaChhZGRDb25uZWN0KGNvbm5lY3RCYXNlLCBjb25uZWN0T3B0aW9uc1swXSkpO1xuXG4gICAgICAgICAgICAvLyBbOjo6Ok89PT09Tz09PT1PPT09PV1cbiAgICAgICAgICAgIC8vIGNvbm5lY3RPcHRpb25zID0gWzAsIDEsIDEsIDFdXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5oYW5kbGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIGEgbGlzdCBvZiBhbGwgYWRkZWQgaGFuZGxlcy5cbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzLnB1c2goYWRkT3JpZ2luKGJhc2UsIGkpKTtcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzW2ldID0gaTtcbiAgICAgICAgICAgICAgICBzY29wZV9Db25uZWN0cy5wdXNoKGFkZENvbm5lY3QoY29ubmVjdEJhc2UsIGNvbm5lY3RPcHRpb25zW2kgKyAxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhIHNpbmdsZSBzbGlkZXIuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFNsaWRlcihhZGRUYXJnZXQpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGNsYXNzZXMgYW5kIGRhdGEgdG8gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmx0cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnJ0bCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9ydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmhvcml6b250YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52ZXJ0aWNhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0RGlyZWN0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShhZGRUYXJnZXQpLmRpcmVjdGlvbjtcblxuICAgICAgICAgICAgaWYgKHRleHREaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50ZXh0RGlyZWN0aW9uUnRsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGV4dERpcmVjdGlvbkx0cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhZGROb2RlVG8oYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuYmFzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRUb29sdGlwKGhhbmRsZSwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhoYW5kbGUuZmlyc3RDaGlsZCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRvb2x0aXApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNTbGlkZXJEaXNhYmxlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9UYXJnZXQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNhYmxlIHRoZSBzbGlkZXIgZHJhZ2dpbmcgaWYgYW55IGhhbmRsZSBpcyBkaXNhYmxlZFxuICAgICAgICBmdW5jdGlvbiBpc0hhbmRsZURpc2FibGVkKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVPcmlnaW4uaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZW1vdmVUb29sdGlwcygpIHtcbiAgICAgICAgICAgIGlmIChzY29wZV9Ub29sdGlwcykge1xuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KFwidXBkYXRlXCIgKyBJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcyk7XG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbih0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KHRvb2x0aXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvb2x0aXBzIG9wdGlvbiBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuICAgICAgICBmdW5jdGlvbiB0b29sdGlwcygpIHtcbiAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzKCk7XG5cbiAgICAgICAgICAgIC8vIFRvb2x0aXBzIGFyZSBhZGRlZCB3aXRoIG9wdGlvbnMudG9vbHRpcHMgaW4gb3JpZ2luYWwgb3JkZXIuXG4gICAgICAgICAgICBzY29wZV9Ub29sdGlwcyA9IHNjb3BlX0hhbmRsZXMubWFwKGFkZFRvb2x0aXApO1xuXG4gICAgICAgICAgICBiaW5kRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLnRvb2x0aXBzLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSB2YWx1ZXNbaGFuZGxlTnVtYmVyXTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSBvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0udG8odW5lbmNvZGVkW2hhbmRsZU51bWJlcl0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlX1Rvb2x0aXBzW2hhbmRsZU51bWJlcl0uaW5uZXJIVE1MID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFyaWEoKSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudChcInVwZGF0ZVwiICsgSU5URVJOQUxfRVZFTlRfTlMuYXJpYSk7XG4gICAgICAgICAgICBiaW5kRXZlbnQoXCJ1cGRhdGVcIiArIElOVEVSTkFMX0VWRU5UX05TLmFyaWEsIGZ1bmN0aW9uKHZhbHVlcywgaGFuZGxlTnVtYmVyLCB1bmVuY29kZWQsIHRhcCwgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEFyaWEgVmFsdWVzIGZvciBhbGwgaGFuZGxlcywgYXMgYSBjaGFuZ2UgaW4gb25lIGNoYW5nZXMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgbmV4dC5cbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW4gPSBjaGVja0hhbmRsZVBvc2l0aW9uKHNjb3BlX0xvY2F0aW9ucywgaW5kZXgsIDAsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGluZGV4LCAxMDAsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBwb3NpdGlvbnNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdHRlZCB2YWx1ZSBmb3IgZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG9wdGlvbnMuYXJpYUZvcm1hdC50byh1bmVuY29kZWRbaW5kZXhdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYXAgdG8gc2xpZGVyIHJhbmdlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWluKS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobWF4KS50b0ZpeGVkKDEpO1xuICAgICAgICAgICAgICAgICAgICBub3cgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobm93KS50b0ZpeGVkKDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWluXCIsIG1pbik7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWF4XCIsIG1heCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbm93XCIsIG5vdyk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVldGV4dFwiLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0R3JvdXAobW9kZSwgdmFsdWVzLCBzdGVwcGVkKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHJhbmdlLlxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwicmFuZ2VcIiB8fCBtb2RlID09PSBcInN0ZXBzXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3ZhbHVlcycgKD49IDIpIHJlcXVpcmVkIGZvciBtb2RlICdjb3VudCcuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERpdmlkZSAwIC0gMTAwIGluICdjb3VudCcgcGFydHMuXG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gdmFsdWVzIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgc3ByZWFkID0gMTAwIC8gaW50ZXJ2YWw7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxuICAgICAgICAgICAgICAgIHdoaWxlIChpbnRlcnZhbC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpbnRlcnZhbF0gPSBpbnRlcnZhbCAqIHNwcmVhZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCgxMDApO1xuXG4gICAgICAgICAgICAgICAgbW9kZSA9IFwicG9zaXRpb25zXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInBvc2l0aW9uc1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFwIGFsbCBwZXJjZW50YWdlcyB0byBvbi1yYW5nZSB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhzdGVwcGVkID8gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInZhbHVlc1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIG11c3QgYmUgc3RlcHBlZCwgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgcGVyY2VudGFnZSBmaXJzdC5cbiAgICAgICAgICAgICAgICBpZiAoc3RlcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAoc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyh2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBjYW4gc2ltcGx5IHVzZSB0aGUgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZVNwcmVhZChkZW5zaXR5LCBtb2RlLCBncm91cCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gc2FmZUluY3JlbWVudCh2YWx1ZSwgaW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgZmxvYXRpbmcgcG9pbnQgdmFyaWFuY2UgYnkgZHJvcHBpbmcgdGhlIHNtYWxsZXN0IGRlY2ltYWwgcGxhY2VzLlxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgKyBpbmNyZW1lbnQpLnRvRml4ZWQoNykgLyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGZpcnN0SW5SYW5nZSA9IHNjb3BlX1NwZWN0cnVtLnhWYWxbMF07XG4gICAgICAgICAgICB2YXIgbGFzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsW3Njb3BlX1NwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgaWdub3JlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcHJldlBjdCA9IDA7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGdyb3VwLCBzb3J0IGl0IGFuZCBmaWx0ZXIgYXdheSBhbGwgZHVwbGljYXRlcy5cbiAgICAgICAgICAgIGdyb3VwID0gdW5pcXVlKFxuICAgICAgICAgICAgICAgIGdyb3VwLnNsaWNlKCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByYW5nZSBzdGFydHMgd2l0aCB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgICAgICAgIGlmIChncm91cFswXSAhPT0gZmlyc3RJblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAudW5zaGlmdChmaXJzdEluUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlnbm9yZUZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGlrZXdpc2UgZm9yIHRoZSBsYXN0IG9uZS5cbiAgICAgICAgICAgIGlmIChncm91cFtncm91cC5sZW5ndGggLSAxXSAhPT0gbGFzdEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBncm91cC5wdXNoKGxhc3RJblJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZ25vcmVMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihjdXJyZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXG4gICAgICAgICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIHE7XG4gICAgICAgICAgICAgICAgdmFyIGxvdyA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBncm91cFtpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdQY3Q7XG4gICAgICAgICAgICAgICAgdmFyIHBjdERpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgdmFyIHBjdFBvcztcbiAgICAgICAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHM7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWxTdGVwcztcbiAgICAgICAgICAgICAgICB2YXIgc3RlcFNpemU7XG4gICAgICAgICAgICAgICAgdmFyIGlzU3RlcHMgPSBtb2RlID09PSBcInN0ZXBzXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nICdzdGVwcycgbW9kZSwgdXNlIHRoZSBwcm92aWRlZCBzdGVwcy5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlJ2xsIHN0ZXAgb24gdG8gdGhlIG5leHQgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLnhOdW1TdGVwc1tpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBhICdmdWxsJyBzdGVwLlxuICAgICAgICAgICAgICAgIGlmICghc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBzdGVwID0gaGlnaCAtIGxvdztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMb3cgY2FuIGJlIDAsIHNvIHRlc3QgZm9yIGZhbHNlLiBJbmRleCAwIGlzIGFscmVhZHkgaGFuZGxlZC5cbiAgICAgICAgICAgICAgICBpZiAobG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgaGlnaCBpcyB1bmRlZmluZWQgd2UgYXJlIGF0IHRoZSBsYXN0IHN1YnJhbmdlLiBNYWtlIHN1cmUgaXQgaXRlcmF0ZXMgb25jZSAoIzEwODgpXG4gICAgICAgICAgICAgICAgaWYgKGhpZ2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBoaWdoID0gbG93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdGVwIGlzbid0IDAsIHdoaWNoIHdvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgKCM2NTQpXG4gICAgICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBzdGVwcyBpbiB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IGhpZ2g7IGkgPSBzYWZlSW5jcmVtZW50KGksIHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIGZvciB0aGUgc3VicmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIG5ld1BjdCA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcoaSk7XG4gICAgICAgICAgICAgICAgICAgIHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xuXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gcGN0RGlmZmVyZW5jZSAvIGRlbnNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWxTdGVwcyA9IE1hdGgucm91bmQoc3RlcHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmF0aW8gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHBlcmNlbnRhZ2Utc3BhY2UgYSBwb2ludCBpbmRpY2F0ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIGRlbnNpdHkgMSB0aGUgcG9pbnRzL3BlcmNlbnRhZ2UgPSAxLiBGb3IgZGVuc2l0eSAyLCB0aGF0IHBlcmNlbnRhZ2UgbmVlZHMgdG8gYmUgcmUtZGl2aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdGhlIHBlcmNlbnRhZ2Ugb2Zmc2V0IHRvIGFuIGV2ZW4gbnVtYmVyLCB0aGVuIGRpdmlkZSBieSB0d29cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gc3ByZWFkIHRoZSBvZmZzZXQgb24gYm90aCBzaWRlcyBvZiB0aGUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gcGN0RGlmZmVyZW5jZSAvIHJlYWxTdGVwcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBEaXZpZGUgYWxsIHBvaW50cyBldmVubHksIGFkZGluZyB0aGUgY29ycmVjdCBudW1iZXIgdG8gdGhpcyBzdWJyYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHVwIHRvIDw9IHNvIHRoYXQgMTAwJSBnZXRzIGEgcG9pbnQsIGV2ZW50IGlmIGlnbm9yZUxhc3QgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSAxOyBxIDw9IHJlYWxTdGVwczsgcSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmF0aW8gYmV0d2VlbiB0aGUgcm91bmRlZCB2YWx1ZSBhbmQgdGhlIGFjdHVhbCBzaXplIG1pZ2h0IGJlIH4xJSBvZmYuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGVyIHN1YnJhbmdlLiBkZW5zaXR5ID0gMSB3aWxsIHJlc3VsdCBpbiAxMDAgcG9pbnRzIG9uIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnVsbCByYW5nZSwgMiBmb3IgNTAsIDQgZm9yIDI1LCBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwY3RQb3MgPSBwcmV2UGN0ICsgcSAqIHN0ZXBTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1twY3RQb3MudG9GaXhlZCg1KV0gPSBbc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHBjdFBvcyksIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb2ludCB0eXBlLlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gZ3JvdXAuaW5kZXhPZihpKSA+IC0xID8gUElQU19MQVJHRV9WQUxVRSA6IGlzU3RlcHMgPyBQSVBTX1NNQUxMX1ZBTFVFIDogUElQU19OT19WQUxVRTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbmZvcmNlIHRoZSAnaWdub3JlRmlyc3QnIG9wdGlvbiBieSBvdmVyd3JpdGluZyB0aGUgdHlwZSBmb3IgMC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmRleCAmJiBpZ25vcmVGaXJzdCAmJiBpICE9PSBoaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPT09IGhpZ2ggJiYgaWdub3JlTGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlICd0eXBlJyBvZiB0aGlzIHBvaW50LiAwID0gcGxhaW4sIDEgPSByZWFsIHZhbHVlLCAyID0gc3RlcCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXNbbmV3UGN0LnRvRml4ZWQoNSldID0gW2ksIHR5cGVdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwZXJjZW50YWdlIGNvdW50LlxuICAgICAgICAgICAgICAgICAgICBwcmV2UGN0ID0gbmV3UGN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGVfRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlU2l6ZUNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhbHVlU2l6ZUNsYXNzZXNbUElQU19OT19WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVOb3JtYWw7XG4gICAgICAgICAgICB2YWx1ZVNpemVDbGFzc2VzW1BJUFNfTEFSR0VfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlTGFyZ2U7XG4gICAgICAgICAgICB2YWx1ZVNpemVDbGFzc2VzW1BJUFNfU01BTExfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlU3ViO1xuXG4gICAgICAgICAgICB2YXIgbWFya2VyU2l6ZUNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfTk9fVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlck5vcm1hbDtcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfTEFSR0VfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckxhcmdlO1xuICAgICAgICAgICAgbWFya2VyU2l6ZUNsYXNzZXNbUElQU19TTUFMTF9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyU3ViO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlSG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlVmVydGljYWxdO1xuICAgICAgICAgICAgdmFyIG1hcmtlck9yaWVudGF0aW9uQ2xhc3NlcyA9IFtvcHRpb25zLmNzc0NsYXNzZXMubWFya2VySG9yaXpvbnRhbCwgb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclZlcnRpY2FsXTtcblxuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHMpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgb3B0aW9ucy5vcnQgPT09IDAgPyBvcHRpb25zLmNzc0NsYXNzZXMucGlwc0hvcml6b250YWwgOiBvcHRpb25zLmNzc0NsYXNzZXMucGlwc1ZlcnRpY2FsKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2xhc3Nlcyh0eXBlLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHNvdXJjZSA9PT0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XG4gICAgICAgICAgICAgICAgdmFyIHNpemVDbGFzc2VzID0gYSA/IHZhbHVlU2l6ZUNsYXNzZXMgOiBtYXJrZXJTaXplQ2xhc3NlcztcblxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UgKyBcIiBcIiArIG9yaWVudGF0aW9uQ2xhc3Nlc1tvcHRpb25zLm9ydF0gKyBcIiBcIiArIHNpemVDbGFzc2VzW3R5cGVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRTcHJlYWQob2Zmc2V0LCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgZnVuY3Rpb24sIGlmIGl0IGlzIHNldC5cbiAgICAgICAgICAgICAgICB0eXBlID0gZmlsdGVyRnVuYyA/IGZpbHRlckZ1bmModmFsdWUsIHR5cGUpIDogdHlwZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBQSVBTX05PTkUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhIG1hcmtlciBmb3IgZXZlcnkgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFkZE5vZGVUbyhlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXIpO1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcblxuICAgICAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgb25seSBhcHBlbmRlZCBmb3IgcG9pbnRzIG1hcmtlZCAnMScgb3IgJzInLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlID4gUElQU19OT19WQUxVRSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBnZXRDbGFzc2VzKHR5cGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBmb3JtYXR0ZXIudG8odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXBwZW5kIGFsbCBwb2ludHMuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzcHJlYWQpLmZvckVhY2goZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYWRkU3ByZWFkKG9mZnNldCwgc3ByZWFkW29mZnNldF1bMF0sIHNwcmVhZFtvZmZzZXRdWzFdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVBpcHMoKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGVfUGlwcykge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQoc2NvcGVfUGlwcyk7XG4gICAgICAgICAgICAgICAgc2NvcGVfUGlwcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwaXBzKGdyaWQpIHtcbiAgICAgICAgICAgIC8vIEZpeCAjNjY5XG4gICAgICAgICAgICByZW1vdmVQaXBzKCk7XG5cbiAgICAgICAgICAgIHZhciBtb2RlID0gZ3JpZC5tb2RlO1xuICAgICAgICAgICAgdmFyIGRlbnNpdHkgPSBncmlkLmRlbnNpdHkgfHwgMTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBncmlkLmZpbHRlciB8fCBmYWxzZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBncmlkLnZhbHVlcyB8fCBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzdGVwcGVkID0gZ3JpZC5zdGVwcGVkIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ2V0R3JvdXAobW9kZSwgdmFsdWVzLCBzdGVwcGVkKTtcbiAgICAgICAgICAgIHZhciBzcHJlYWQgPSBnZW5lcmF0ZVNwcmVhZChkZW5zaXR5LCBtb2RlLCBncm91cCk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gZ3JpZC5mb3JtYXQgfHwge1xuICAgICAgICAgICAgICAgIHRvOiBNYXRoLnJvdW5kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzY29wZV9QaXBzID0gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXIsIGZvcm1hdCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfUGlwcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxuICAgICAgICBmdW5jdGlvbiBiYXNlU2l6ZSgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2NvcGVfQmFzZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBhbHQgPSBcIm9mZnNldFwiICsgW1wiV2lkdGhcIiwgXCJIZWlnaHRcIl1bb3B0aW9ucy5vcnRdO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMub3J0ID09PSAwID8gcmVjdC53aWR0aCB8fCBzY29wZV9CYXNlW2FsdF0gOiByZWN0LmhlaWdodCB8fCBzY29wZV9CYXNlW2FsdF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGVyIGZvciBhdHRhY2hpbmcgZXZlbnRzIHRyb3VnaCBhIHByb3h5LlxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudChldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvICdmaWx0ZXInIGV2ZW50cyB0byB0aGUgc2xpZGVyLlxuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhIG5vZGUsIG5vdCBhIG5vZGVMaXN0XG5cbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGZpeEV2ZW50KGUsIGRhdGEucGFnZU9mZnNldCwgZGF0YS50YXJnZXQgfHwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXhFdmVudCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZXZlbnQgaGFzIGEgZGlmZmVyZW50IHRhcmdldFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gaGFuZGxpbmcgKG11bHRpLSkgdG91Y2ggZXZlbnRzO1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG9Ob3RSZWplY3QgaXMgcGFzc2VkIGJ5IGFsbCBlbmQgZXZlbnRzIHRvIG1ha2Ugc3VyZSByZWxlYXNlZCB0b3VjaGVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdCByZWplY3RlZCwgbGVhdmluZyB0aGUgc2xpZGVyIFwic3R1Y2tcIiB0byB0aGUgY3Vyc29yO1xuICAgICAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0b3AgaWYgYW4gYWN0aXZlICd0YXAnIHRyYW5zaXRpb24gaXMgdGFraW5nIHBsYWNlLlxuICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXApICYmICFkYXRhLmRvTm90UmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cyA9PT0gYWN0aW9ucy5zdGFydCAmJiBlLmJ1dHRvbnMgIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbnMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAnc3VwcG9ydHNQYXNzaXZlJyBpcyBvbmx5IHRydWUgaWYgYSBicm93c2VyIGFsc28gc3VwcG9ydHMgdG91Y2gtYWN0aW9uOiBub25lIGluIENTUy5cbiAgICAgICAgICAgICAgICAvLyBpT1Mgc2FmYXJpIGRvZXMgbm90LCBzbyBpdCBkb2Vzbid0IGdldCB0byBiZW5lZml0IGZyb20gcGFzc2l2ZSBzY3JvbGxpbmcuIGlPUyBkb2VzIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAvLyB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbiwgYnV0IHRoYXQgYWxsb3dzIHBhbm5pbmcsIHdoaWNoIGJyZWFrc1xuICAgICAgICAgICAgICAgIC8vIHNsaWRlcnMgYWZ0ZXIgem9vbWluZy9vbiBub24tcmVzcG9uc2l2ZSBwYWdlcy5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzMxMTJcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzUGFzc2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZS5jYWxjUG9pbnQgPSBlLnBvaW50c1tvcHRpb25zLm9ydF07XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGRhdGEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cbiAgICAgICAgICAgIGV2ZW50cy5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBtZXRob2QsIHN1cHBvcnRzUGFzc2l2ZSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogZmFsc2UpO1xuICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZXZlbnROYW1lLCBtZXRob2RdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxuICAgICAgICBmdW5jdGlvbiBmaXhFdmVudChlLCBwYWdlT2Zmc2V0LCBldmVudFRhcmdldCkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBldmVudCB0byByZWdpc3RlciB0aGUgdHlwZSwgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAvLyB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlci4gT2Zmc2V0IGNoYW5nZXMgbmVlZCB0byBiZVxuICAgICAgICAgICAgLy8gbWFkZSBvbiBhbiBldmVudCBzcGVjaWZpYyBiYXNpcy5cbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGUudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPT09IDA7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpID09PSAwO1xuICAgICAgICAgICAgdmFyIHBvaW50ZXIgPSBlLnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgPT09IDA7XG5cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG5cbiAgICAgICAgICAgIC8vIElFMTAgaW1wbGVtZW50ZWQgcG9pbnRlciBldmVudHMgd2l0aCBhIHByZWZpeDtcbiAgICAgICAgICAgIGlmIChlLnR5cGUuaW5kZXhPZihcIk1TUG9pbnRlclwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFcnJvbmVvdXMgZXZlbnRzIHNlZW0gdG8gYmUgcGFzc2VkIGluIG9jY2FzaW9uYWxseSBvbiBpT1MvaVBhZE9TIGFmdGVyIHVzZXIgZmluaXNoZXMgaW50ZXJhY3Rpbmcgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIHNsaWRlci4gVGhleSBhcHBlYXIgdG8gYmUgb2YgdHlwZSBNb3VzZUV2ZW50LCB5ZXQgdGhleSBkb24ndCBoYXZlIHVzdWFsIHByb3BlcnRpZXMgc2V0LiBJZ25vcmVcbiAgICAgICAgICAgIC8vIGV2ZW50cyB0aGF0IGhhdmUgbm8gdG91Y2hlcyBvciBidXR0b25zIGFzc29jaWF0ZWQgd2l0aCB0aGVtLiAoIzEwNTcsICMxMDc5LCAjMTA5NSlcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwibW91c2Vkb3duXCIgJiYgIWUuYnV0dG9ucyAmJiAhZS50b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgb25seSB0aGluZyBvbmUgaGFuZGxlIHNob3VsZCBiZSBjb25jZXJuZWQgYWJvdXQgaXMgdGhlIHRvdWNoZXMgdGhhdCBvcmlnaW5hdGVkIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAgIGlmICh0b3VjaCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIG9yaWdpbmF0ZWQgb24gdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaE9uVGFyZ2V0ID0gZnVuY3Rpb24oY2hlY2tUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb3VjaC50YXJnZXQgPT09IGV2ZW50VGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5jb250YWlucyhjaGVja1RvdWNoLnRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGVja1RvdWNoLnRhcmdldC5zaGFkb3dSb290ICYmIGNoZWNrVG91Y2gudGFyZ2V0LnNoYWRvd1Jvb3QuY29udGFpbnMoZXZlbnRUYXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0b3VjaHN0YXJ0IGV2ZW50cywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlcmUgaXMgc3RpbGwgbm8gbW9yZSB0aGFuIG9uZVxuICAgICAgICAgICAgICAgIC8vIHRvdWNoIG9uIHRoZSB0YXJnZXQgc28gd2UgbG9vayBhbW9uZ3N0IGFsbCB0b3VjaGVzLlxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGUudG91Y2hlcywgaXNUb3VjaE9uVGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gb25lIHRvdWNoIHBlciBoYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0VG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2ggPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUuY2hhbmdlZFRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGlmIHRoZSB0YXJnZXQgdG91Y2ggaGFzIG5vdCBtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IHRhcmdldFRvdWNoLnBhZ2VYO1xuICAgICAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0VG91Y2gucGFnZVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KHNjb3BlX0RvY3VtZW50KTtcblxuICAgICAgICAgICAgaWYgKG1vdXNlIHx8IHBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICB4ID0gZS5jbGllbnRYICsgcGFnZU9mZnNldC54O1xuICAgICAgICAgICAgICAgIHkgPSBlLmNsaWVudFkgKyBwYWdlT2Zmc2V0Lnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucGFnZU9mZnNldCA9IHBhZ2VPZmZzZXQ7XG4gICAgICAgICAgICBlLnBvaW50cyA9IFt4LCB5XTtcbiAgICAgICAgICAgIGUuY3Vyc29yID0gbW91c2UgfHwgcG9pbnRlcjsgLy8gRml4ICM0MzVcblxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFuc2xhdGUgYSBjb29yZGluYXRlIGluIHRoZSBkb2N1bWVudCB0byBhIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxuICAgICAgICBmdW5jdGlvbiBjYWxjUG9pbnRUb1BlcmNlbnRhZ2UoY2FsY1BvaW50KSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjYWxjUG9pbnQgLSBvZmZzZXQoc2NvcGVfQmFzZSwgb3B0aW9ucy5vcnQpO1xuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKGxvY2F0aW9uICogMTAwKSAvIGJhc2VTaXplKCk7XG5cbiAgICAgICAgICAgIC8vIENsYW1wIHByb3Bvc2FsIGJldHdlZW4gMCUgYW5kIDEwMCVcbiAgICAgICAgICAgIC8vIE91dC1vZi1ib3VuZCBjb29yZGluYXRlcyBtYXkgb2NjdXIgd2hlbiAubm9VaS1iYXNlIHBzZXVkby1lbGVtZW50c1xuICAgICAgICAgICAgLy8gYXJlIHVzZWQgKGUuZy4gY29udGFpbmVkIGhhbmRsZXMgZmVhdHVyZSlcbiAgICAgICAgICAgIHByb3Bvc2FsID0gbGltaXQocHJvcG9zYWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kaXIgPyAxMDAgLSBwcm9wb3NhbCA6IHByb3Bvc2FsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCBoYW5kbGUgY2xvc2VzdCB0byBhIGNlcnRhaW4gcGVyY2VudGFnZSBvbiB0aGUgc2xpZGVyXG4gICAgICAgIGZ1bmN0aW9uIGdldENsb3Nlc3RIYW5kbGUoY2xpY2tlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc21hbGxlc3REaWZmZXJlbmNlID0gMTAwO1xuICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlciA9IGZhbHNlO1xuXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIERpc2FibGVkIGhhbmRsZXMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNIYW5kbGVEaXNhYmxlZChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVQb3NpdGlvbiA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZSA9IE1hdGguYWJzKGhhbmRsZVBvc2l0aW9uIC0gY2xpY2tlZFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAgICAgICAgICAgICB2YXIgY2xpY2tBdEVkZ2UgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPT09IDEwMCAmJiBzbWFsbGVzdERpZmZlcmVuY2UgPT09IDEwMDtcblxuICAgICAgICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB0aGlzIGhhbmRsZSBpcyBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzbHkgY2hlY2tlZCBoYW5kbGVcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9zZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPCBzbWFsbGVzdERpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2xvc2VyQWZ0ZXIgPSBkaWZmZXJlbmNlV2l0aFRoaXNIYW5kbGUgPD0gc21hbGxlc3REaWZmZXJlbmNlICYmIGNsaWNrZWRQb3NpdGlvbiA+IGhhbmRsZVBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2VyIHx8IGlzQ2xvc2VyQWZ0ZXIgfHwgY2xpY2tBdEVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0RGlmZmVyZW5jZSA9IGRpZmZlcmVuY2VXaXRoVGhpc0hhbmRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU51bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcmUgJ2VuZCcgd2hlbiBhIG1vdXNlIG9yIHBlbiBsZWF2ZXMgdGhlIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBkb2N1bWVudExlYXZlKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJtb3VzZW91dFwiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJIVE1MXCIgJiYgZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGV2ZW50RW5kKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBtb3ZlbWVudCBvbiBkb2N1bWVudCBmb3IgaGFuZGxlIGFuZCByYW5nZSBkcmFnLlxuICAgICAgICBmdW5jdGlvbiBldmVudE1vdmUoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIEZpeCAjNDk4XG4gICAgICAgICAgICAvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXG4gICAgICAgICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzkyNzAwNS9tb2JpbGUtaWUxMC13aW5kb3dzLXBob25lLWJ1dHRvbnMtcHJvcGVydHktb2YtcG9pbnRlcm1vdmUtZXZlbnQtYWx3YXlzLXplcm9cbiAgICAgICAgICAgIC8vIElFOSBoYXMgLmJ1dHRvbnMgYW5kIC53aGljaCB6ZXJvIG9uIG1vdXNlbW92ZS5cbiAgICAgICAgICAgIC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXCJNU0lFIDlcIikgPT09IC0xICYmIGV2ZW50LmJ1dHRvbnMgPT09IDAgJiYgZGF0YS5idXR0b25zUHJvcGVydHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgbW92aW5nIHVwIG9yIGRvd25cbiAgICAgICAgICAgIHZhciBtb3ZlbWVudCA9IChvcHRpb25zLmRpciA/IC0xIDogMSkgKiAoZXZlbnQuY2FsY1BvaW50IC0gZGF0YS5zdGFydENhbGNQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG1vdmVtZW50IGludG8gYSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgd2lkdGgvaGVpZ2h0XG4gICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSAobW92ZW1lbnQgKiAxMDApIC8gZGF0YS5iYXNlU2l6ZTtcblxuICAgICAgICAgICAgbW92ZUhhbmRsZXMobW92ZW1lbnQgPiAwLCBwcm9wb3NhbCwgZGF0YS5sb2NhdGlvbnMsIGRhdGEuaGFuZGxlTnVtYmVycyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmJpbmQgbW92ZSBldmVudHMgb24gZG9jdW1lbnQsIGNhbGwgY2FsbGJhY2tzLlxuICAgICAgICBmdW5jdGlvbiBldmVudEVuZChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gVGhlIGhhbmRsZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyByZW1vdmUgdGhlIGNsYXNzLlxuICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZGF0YS5oYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5hY3RpdmUpO1xuICAgICAgICAgICAgICAgIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxuICAgICAgICAgICAgZGF0YS5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfRG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoY1swXSwgY1sxXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBkcmFnZ2luZyBjbGFzcy5cbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnKTtcbiAgICAgICAgICAgICAgICBzZXRaaW5kZXgoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJzb3Igc3R5bGVzIGFuZCB0ZXh0LXNlbGVjdGlvbiBldmVudHMgYm91bmQgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdHN0YXJ0XCIsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEuaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcImVuZFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxuICAgICAgICBmdW5jdGlvbiBldmVudFN0YXJ0KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQgaWYgYW55IGhhbmRsZSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlTnVtYmVycy5zb21lKGlzSGFuZGxlRGlzYWJsZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGFuZGxlO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVPcmlnaW4gPSBzY29wZV9IYW5kbGVzW2RhdGEuaGFuZGxlTnVtYmVyc1swXV07XG5cbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGVPcmlnaW4uY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgc2NvcGVfQWN0aXZlSGFuZGxlc0NvdW50ICs9IDE7XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSBoYW5kbGUgYXMgJ2FjdGl2ZScgc28gaXQgY2FuIGJlIHN0eWxlZC5cbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5hY3RpdmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBIGRyYWcgc2hvdWxkIG5ldmVyIHByb3BhZ2F0ZSB1cCB0byB0aGUgJ3RhcCcgZXZlbnQuXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgbW92ZSBhbmQgZW5kIGV2ZW50cy5cbiAgICAgICAgICAgIHZhciBtb3ZlRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLm1vdmUsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZXZlbnRNb3ZlLCB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHRhcmdldCBoYXMgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgd2Uga2VlcFxuICAgICAgICAgICAgICAgIC8vIHJlbHlpbmcgb24gaXQgdG8gZXh0cmFjdCB0YXJnZXQgdG91Y2hlcy5cbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVycyxcbiAgICAgICAgICAgICAgICBzdGFydENhbGNQb2ludDogZXZlbnQuY2FsY1BvaW50LFxuICAgICAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHBhZ2VPZmZzZXQ6IGV2ZW50LnBhZ2VPZmZzZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogZGF0YS5oYW5kbGVOdW1iZXJzLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnNQcm9wZXJ0eTogZXZlbnQuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbnM6IHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGVuZEV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5lbmQsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZXZlbnRFbmQsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVycyxcbiAgICAgICAgICAgICAgICBkb05vdFJlamVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgb3V0RXZlbnQgPSBhdHRhY2hFdmVudChcIm1vdXNlb3V0XCIsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZG9jdW1lbnRMZWF2ZSwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIGRvTm90UmVqZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVyc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIHB1c2hlZCB0aGUgbGlzdGVuZXJzIGluIHRoZSBsaXN0ZW5lciBsaXN0IHJhdGhlciB0aGFuIGNyZWF0aW5nXG4gICAgICAgICAgICAvLyBhIG5ldyBvbmUgYXMgaXQgaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBtb3ZlRXZlbnQuY29uY2F0KGVuZEV2ZW50LCBvdXRFdmVudCkpO1xuXG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBpc24ndCBhbiBpc3N1ZSBvbiB0b3VjaCBkZXZpY2VzLFxuICAgICAgICAgICAgLy8gc28gYWRkaW5nIGN1cnNvciBzdHlsZXMgY2FuIGJlIHNraXBwZWQuXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cbiAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IGdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSB0YXJnZXQgd2l0aCBhIGRyYWdnaW5nIHN0YXRlLlxuICAgICAgICAgICAgICAgIGlmIChzY29wZV9IYW5kbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiB3aGVuIGRyYWdnaW5nIHRoZSBoYW5kbGVzLlxuICAgICAgICAgICAgICAgIC8vIEluIG5vVWlTbGlkZXIgPD0gOS4yLjAsIHRoaXMgd2FzIGhhbmRsZWQgYnkgY2FsbGluZyBwcmV2ZW50RGVmYXVsdCBvbiBtb3VzZS90b3VjaCBzdGFydC9tb3ZlLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHNjcm9sbCBibG9ja2luZy4gVGhlIHNlbGVjdHN0YXJ0IGV2ZW50IGlzIHN1cHBvcnRlZCBieSBGaXJlRm94IHN0YXJ0aW5nIGZyb20gdmVyc2lvbiA1MixcbiAgICAgICAgICAgICAgICAvLyBtZWFuaW5nIHRoZSBvbmx5IGhvbGRvdXQgaXMgaU9TIFNhZmFyaS4gVGhpcyBkb2Vzbid0IG1hdHRlcjogdGV4dCBzZWxlY3Rpb24gaXNuJ3QgdHJpZ2dlcmVkIHRoZXJlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSAnY3Vyc29yJyBmbGFnIGlzIGZhbHNlLlxuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9c2VsZWN0c3RhcnRcbiAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLCBwcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzdGFydFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIGNsb3Nlc3QgaGFuZGxlIHRvIHRhcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRUYXAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0YXAgZXZlbnQgc2hvdWxkbid0IHByb3BhZ2F0ZSB1cFxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xuICAgICAgICAgICAgdmFyIGhhbmRsZU51bWJlciA9IGdldENsb3Nlc3RIYW5kbGUocHJvcG9zYWwpO1xuXG4gICAgICAgICAgICAvLyBUYWNrbGUgdGhlIGNhc2UgdGhhdCBhbGwgaGFuZGxlcyBhcmUgJ2Rpc2FibGVkJy5cbiAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGbGFnIHRoZSBzbGlkZXIgYXMgaXQgaXMgbm93IGluIGEgdHJhbnNpdGlvbmFsIHN0YXRlLlxuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0YWtlcyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgbXMgKGRlZmF1bHQgMzAwKS4gUmUtZW5hYmxlIHRoZSBzbGlkZXIgYWZ0ZXIgdGhhdC5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5ldmVudHMuc25hcCkge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHByb3Bvc2FsLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgc2V0WmluZGV4KCk7XG5cbiAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV2ZW50cy5zbmFwKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRTdGFydChldmVudCwgeyBoYW5kbGVOdW1iZXJzOiBbaGFuZGxlTnVtYmVyXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcmVzIGEgJ2hvdmVyJyBldmVudCBmb3IgYSBob3ZlcmVkIG1vdXNlL3BlbiBwb3NpdGlvbi5cbiAgICAgICAgZnVuY3Rpb24gZXZlbnRIb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XG5cbiAgICAgICAgICAgIHZhciB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAocHJvcG9zYWwpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHRvKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKHRhcmdldEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZV9TZWxmLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlcyBrZXlkb3duIG9uIGZvY3VzZWQgaGFuZGxlc1xuICAgICAgICAvLyBEb24ndCBtb3ZlIHRoZSBkb2N1bWVudCB3aGVuIHByZXNzaW5nIGFycm93IGtleXMgb24gZm9jdXNlZCBoYW5kbGVzXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50S2V5ZG93bihldmVudCwgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoaXNTbGlkZXJEaXNhYmxlZCgpIHx8IGlzSGFuZGxlRGlzYWJsZWQoaGFuZGxlTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsS2V5cyA9IFtcIkRvd25cIiwgXCJVcFwiXTtcbiAgICAgICAgICAgIHZhciBsYXJnZVN0ZXBLZXlzID0gW1wiUGFnZURvd25cIiwgXCJQYWdlVXBcIl07XG4gICAgICAgICAgICB2YXIgZWRnZUtleXMgPSBbXCJIb21lXCIsIFwiRW5kXCJdO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXIgJiYgIW9wdGlvbnMub3J0KSB7XG4gICAgICAgICAgICAgICAgLy8gT24gYW4gcmlnaHQtdG8tbGVmdCBzbGlkZXIsIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzIGFjdCBpbnZlcnRlZFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcnQgJiYgIW9wdGlvbnMuZGlyKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gYSB0b3AtdG8tYm90dG9tIHNsaWRlciwgdGhlIHVwIGFuZCBkb3duIGtleXMgYWN0IGludmVydGVkXG4gICAgICAgICAgICAgICAgdmVydGljYWxLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBsYXJnZVN0ZXBLZXlzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgXCJBcnJvd1wiIGZvciBJRSBjb21wYXRpYmlsaXR5LiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlcbiAgICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXkucmVwbGFjZShcIkFycm93XCIsIFwiXCIpO1xuXG4gICAgICAgICAgICB2YXIgaXNMYXJnZURvd24gPSBrZXkgPT09IGxhcmdlU3RlcEtleXNbMF07XG4gICAgICAgICAgICB2YXIgaXNMYXJnZVVwID0ga2V5ID09PSBsYXJnZVN0ZXBLZXlzWzFdO1xuICAgICAgICAgICAgdmFyIGlzRG93biA9IGtleSA9PT0gdmVydGljYWxLZXlzWzBdIHx8IGtleSA9PT0gaG9yaXpvbnRhbEtleXNbMF0gfHwgaXNMYXJnZURvd247XG4gICAgICAgICAgICB2YXIgaXNVcCA9IGtleSA9PT0gdmVydGljYWxLZXlzWzFdIHx8IGtleSA9PT0gaG9yaXpvbnRhbEtleXNbMV0gfHwgaXNMYXJnZVVwO1xuICAgICAgICAgICAgdmFyIGlzTWluID0ga2V5ID09PSBlZGdlS2V5c1swXTtcbiAgICAgICAgICAgIHZhciBpc01heCA9IGtleSA9PT0gZWRnZUtleXNbMV07XG5cbiAgICAgICAgICAgIGlmICghaXNEb3duICYmICFpc1VwICYmICFpc01pbiAmJiAhaXNNYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgdmFyIHRvO1xuXG4gICAgICAgICAgICBpZiAoaXNVcCB8fCBpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMua2V5Ym9hcmRQYWdlTXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gaXNEb3duID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBzdGVwc1tkaXJlY3Rpb25dO1xuXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGVkZ2Ugb2YgYSBzbGlkZXIsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm8gc3RlcCBzZXQsIHVzZSB0aGUgZGVmYXVsdCBvZiAxMCUgb2YgdGhlIHN1Yi1yYW5nZVxuICAgICAgICAgICAgICAgIGlmIChzdGVwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGVwID0gc2NvcGVfU3BlY3RydW0uZ2V0RGVmYXVsdFN0ZXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMua2V5Ym9hcmREZWZhdWx0U3RlcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0xhcmdlVXAgfHwgaXNMYXJnZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RlcCAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0ZXAgb3ZlciB6ZXJvLWxlbmd0aCByYW5nZXMgKCM5NDgpO1xuICAgICAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heChzdGVwLCAwLjAwMDAwMDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gRGVjcmVtZW50IGZvciBkb3duIHN0ZXBzXG4gICAgICAgICAgICAgICAgc3RlcCA9IChpc0Rvd24gPyAtMSA6IDEpICogc3RlcDtcblxuICAgICAgICAgICAgICAgIHRvID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gKyBzdGVwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01heCkge1xuICAgICAgICAgICAgICAgIC8vIEVuZCBrZXlcbiAgICAgICAgICAgICAgICB0byA9IG9wdGlvbnMuc3BlY3RydW0ueFZhbFtvcHRpb25zLnNwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhvbWUga2V5XG4gICAgICAgICAgICAgICAgdG8gPSBvcHRpb25zLnNwZWN0cnVtLnhWYWxbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2xpZGVcIiwgaGFuZGxlTnVtYmVyKTtcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgZmlyZUV2ZW50KFwiY2hhbmdlXCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJzZXRcIiwgaGFuZGxlTnVtYmVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0YWNoIGV2ZW50cyB0byBzZXZlcmFsIHNsaWRlciBwYXJ0cy5cbiAgICAgICAgZnVuY3Rpb24gYmluZFNsaWRlckV2ZW50cyhiZWhhdmlvdXIpIHtcbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgc3RhbmRhcmQgZHJhZyBldmVudCB0byB0aGUgaGFuZGxlcy5cbiAgICAgICAgICAgIGlmICghYmVoYXZpb3VyLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZXZlbnRzIGFyZSBvbmx5IGJvdW5kIHRvIHRoZSB2aXN1YWwgaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQsIG5vdCB0aGUgJ3JlYWwnIG9yaWdpbiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBoYW5kbGUuY2hpbGRyZW5bMF0sIGV2ZW50U3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IFtpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgdGFwIGV2ZW50IHRvIHRoZSBzbGlkZXIgYmFzZS5cbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIudGFwKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgc2NvcGVfQmFzZSwgZXZlbnRUYXAsIHt9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlyZSBob3ZlciBldmVudHNcbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuaG92ZXIpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLm1vdmUsIHNjb3BlX0Jhc2UsIGV2ZW50SG92ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgaG92ZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcmFuZ2UgZHJhZ2dhYmxlLlxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5kcmFnKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfQ29ubmVjdHMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdCA9PT0gZmFsc2UgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVCZWZvcmUgPSBzY29wZV9IYW5kbGVzW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVBZnRlciA9IHNjb3BlX0hhbmRsZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRIb2xkZXJzID0gW2Nvbm5lY3RdO1xuXG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGNvbm5lY3QsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5kcmFnZ2FibGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHJhbmdlIGlzIGZpeGVkLCB0aGUgZW50aXJlIHJhbmdlIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBkcmFnZ2VkIGJ5IHRoZSBoYW5kbGVzLiBUaGUgaGFuZGxlIGluIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW4gd2lsbCBwcm9wYWdhdGUgdGhlIHN0YXJ0IGV2ZW50IHVwd2FyZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGl0IG5lZWRzIHRvIGJlIGJvdW5kIG1hbnVhbGx5IG9uIHRoZSBvdGhlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW91ci5maXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQmVmb3JlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5wdXNoKGhhbmRsZUFmdGVyLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SG9sZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50SG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBldmVudEhvbGRlciwgZXZlbnRTdGFydCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXM6IFtoYW5kbGVCZWZvcmUsIGhhbmRsZUFmdGVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBbaW5kZXggLSAxLCBpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dGFjaCBhbiBldmVudCB0byB0aGlzIHNsaWRlciwgcG9zc2libHkgaW5jbHVkaW5nIGEgbmFtZXNwYWNlXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudChuYW1lc3BhY2VkRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSA9IHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0ucHVzaChjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBldmVudCBib3VuZCBpcyAndXBkYXRlLCcgZmlyZSBpdCBpbW1lZGlhdGVseSBmb3IgYWxsIGhhbmRsZXMuXG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlZEV2ZW50LnNwbGl0KFwiLlwiKVswXSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNJbnRlcm5hbE5hbWVzcGFjZShuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc3BhY2UgPT09IElOVEVSTkFMX0VWRU5UX05TLmFyaWEgfHwgbmFtZXNwYWNlID09PSBJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuZG8gYXR0YWNobWVudCBvZiBldmVudFxuICAgICAgICBmdW5jdGlvbiByZW1vdmVFdmVudChuYW1lc3BhY2VkRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5hbWVzcGFjZWRFdmVudCAmJiBuYW1lc3BhY2VkRXZlbnQuc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGV2ZW50ID8gbmFtZXNwYWNlZEV2ZW50LnN1YnN0cmluZyhldmVudC5sZW5ndGgpIDogbmFtZXNwYWNlZEV2ZW50O1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24oYmluZCkge1xuICAgICAgICAgICAgICAgIHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KFwiLlwiKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdE5hbWVzcGFjZSA9IGJpbmQuc3Vic3RyaW5nKHRFdmVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICgoIWV2ZW50IHx8IGV2ZW50ID09PSB0RXZlbnQpICYmICghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gdE5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBkZWxldGUgcHJvdGVjdGVkIGludGVybmFsIGV2ZW50IGlmIGludGVudGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbE5hbWVzcGFjZSh0TmFtZXNwYWNlKSB8fCBuYW1lc3BhY2UgPT09IHROYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVybmFsIGV2ZW50IGhhbmRsaW5nXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVFdmVudChldmVudE5hbWUsIGhhbmRsZU51bWJlciwgdGFwKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNsaWRlciBwdWJsaWMgQVBJIGFzIHRoZSBzY29wZSAoJ3RoaXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1NlbGYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHZhbHVlcyBhcyBhcnJheSwgc28gYXJnXzFbYXJnXzJdIGlzIGFsd2F5cyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaW5kZXgsIDAgb3IgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1mb3JtYXR0ZWQgc2xpZGVyIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX1ZhbHVlcy5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW50IGlzIGZpcmVkIGJ5IHRhcCwgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IG9mZnNldCBvZiB0aGUgaGFuZGxlLCBpbiByZWxhdGlvbiB0byB0aGUgc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfTG9jYXRpb25zLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBzbGlkZXIgcHVibGljIEFQSSB0byBhbiBhY2Nlc3NpYmxlIHBhcmFtZXRlciB3aGVuIHRoaXMgaXMgdW5hdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9TZWxmXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwbGl0IG91dCB0aGUgaGFuZGxlIHBvc2l0aW9uaW5nIGxvZ2ljIHNvIHRoZSBNb3ZlIGV2ZW50IGNhbiB1c2UgaXQsIHRvb1xuICAgICAgICBmdW5jdGlvbiBjaGVja0hhbmRsZVBvc2l0aW9uKHJlZmVyZW5jZSwgaGFuZGxlTnVtYmVyLCB0bywgbG9va0JhY2t3YXJkLCBsb29rRm9yd2FyZCwgZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gRm9yIHNsaWRlcnMgd2l0aCBtdWx0aXBsZSBoYW5kbGVzLCBsaW1pdCBtb3ZlbWVudCB0byB0aGUgb3RoZXIgaGFuZGxlLlxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIG1hcmdpbiBvcHRpb24gYnkgYWRkaW5nIGl0IHRvIHRoZSBoYW5kbGUgcG9zaXRpb25zLlxuICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSAmJiAhb3B0aW9ucy5ldmVudHMudW5jb25zdHJhaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHNjb3BlX1NwZWN0cnVtLmdldEFic29sdXRlRGlzdGFuY2UocmVmZXJlbmNlW2hhbmRsZU51bWJlciAtIDFdLCBvcHRpb25zLm1hcmdpbiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG9va0ZvcndhcmQgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZShyZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0sIG9wdGlvbnMubWFyZ2luLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGxpbWl0IG9wdGlvbiBoYXMgdGhlIG9wcG9zaXRlIGVmZmVjdCwgbGltaXRpbmcgaGFuZGxlcyB0byBhXG4gICAgICAgICAgICAvLyBtYXhpbXVtIGRpc3RhbmNlIGZyb20gYW5vdGhlci4gTGltaXQgbXVzdCBiZSA+IDAsIGFzIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gaGFuZGxlcyB3b3VsZCBiZSB1bm1vdmFibGUuXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSwgb3B0aW9ucy5saW1pdCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG9va0ZvcndhcmQgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gc2NvcGVfU3BlY3RydW0uZ2V0QWJzb2x1dGVEaXN0YW5jZShyZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0sIG9wdGlvbnMubGltaXQsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgcGFkZGluZyBvcHRpb24ga2VlcHMgdGhlIGhhbmRsZXMgYSBjZXJ0YWluIGRpc3RhbmNlIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBlZGdlcyBvZiB0aGUgc2xpZGVyLiBQYWRkaW5nIG11c3QgYmUgPiAwLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGFkZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKDAsIG9wdGlvbnMucGFkZGluZ1swXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBzY29wZV9TcGVjdHJ1bS5nZXRBYnNvbHV0ZURpc3RhbmNlKDEwMCwgb3B0aW9ucy5wYWRkaW5nWzFdLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG8gPSBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHRvKTtcblxuICAgICAgICAgICAgLy8gTGltaXQgcGVyY2VudGFnZSB0byB0aGUgMCAtIDEwMCByYW5nZVxuICAgICAgICAgICAgdG8gPSBsaW1pdCh0byk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiBoYW5kbGUgY2FuJ3QgbW92ZVxuICAgICAgICAgICAgaWYgKHRvID09PSByZWZlcmVuY2VbaGFuZGxlTnVtYmVyXSAmJiAhZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZXMgc2xpZGVyIG9yaWVudGF0aW9uIHRvIGNyZWF0ZSBDU1MgcnVsZXMuIGEgPSBiYXNlIHZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBpblJ1bGVPcmRlcih2LCBhKSB7XG4gICAgICAgICAgICB2YXIgbyA9IG9wdGlvbnMub3J0O1xuICAgICAgICAgICAgcmV0dXJuIChvID8gYSA6IHYpICsgXCIsIFwiICsgKG8gPyB2IDogYSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlcyBoYW5kbGUocykgYnkgYSBwZXJjZW50YWdlXG4gICAgICAgIC8vIChib29sLCAlIHRvIG1vdmUsIFslIHdoZXJlIGhhbmRsZSBzdGFydGVkLCAuLi5dLCBbaW5kZXggaW4gc2NvcGVfSGFuZGxlcywgLi4uXSlcbiAgICAgICAgZnVuY3Rpb24gbW92ZUhhbmRsZXModXB3YXJkLCBwcm9wb3NhbCwgbG9jYXRpb25zLCBoYW5kbGVOdW1iZXJzKSB7XG4gICAgICAgICAgICB2YXIgcHJvcG9zYWxzID0gbG9jYXRpb25zLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIHZhciBiID0gWyF1cHdhcmQsIHVwd2FyZF07XG4gICAgICAgICAgICB2YXIgZiA9IFt1cHdhcmQsICF1cHdhcmRdO1xuXG4gICAgICAgICAgICAvLyBDb3B5IGhhbmRsZU51bWJlcnMgc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSBkYXRhc2V0XG4gICAgICAgICAgICBoYW5kbGVOdW1iZXJzID0gaGFuZGxlTnVtYmVycy5zbGljZSgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgd2hpY2ggaGFuZGxlIGlzICdsZWFkaW5nJy5cbiAgICAgICAgICAgIC8vIElmIHRoYXQgb25lIGNhbid0IG1vdmUgdGhlIHNlY29uZCBjYW4ndCBlaXRoZXIuXG4gICAgICAgICAgICBpZiAodXB3YXJkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMTogZ2V0IHRoZSBtYXhpbXVtIHBlcmNlbnRhZ2UgdGhhdCBhbnkgb2YgdGhlIGhhbmRsZXMgY2FuIG1vdmVcbiAgICAgICAgICAgIGlmIChoYW5kbGVOdW1iZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyLCBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0byA9IGNoZWNrSGFuZGxlUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYltvXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZbb10sXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgaWYgb25lIG9mIHRoZSBoYW5kbGVzIGNhbid0IG1vdmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsID0gdG8gLSBwcm9wb3NhbHNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdID0gdG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdXNpbmcgb25lIGhhbmRsZSwgY2hlY2sgYmFja3dhcmQgQU5EIGZvcndhcmRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSBmID0gW3RydWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gU3RlcCAyOiBUcnkgdG8gc2V0IHRoZSBoYW5kbGVzIHdpdGggdGhlIGZvdW5kIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIsIG8pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIGxvY2F0aW9uc1toYW5kbGVOdW1iZXJdICsgcHJvcG9zYWwsIGJbb10sIGZbb10pIHx8IHN0YXRlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMzogSWYgYSBoYW5kbGUgbW92ZWQsIGZpcmUgZXZlbnRzXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzbGlkZVwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFrZXMgYSBiYXNlIHZhbHVlIGFuZCBhbiBvZmZzZXQuIFRoaXMgb2Zmc2V0IGlzIHVzZWQgZm9yIHRoZSBjb25uZWN0IGJhciBzaXplLlxuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBkZXNpZ24gZm9yIHRoaXMgZmVhdHVyZSwgdGhlIG9yaWdpbiBlbGVtZW50IHdhcyAxJSB3aWRlLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBhIHJvdW5kaW5nIGJ1ZyBpbiBDaHJvbWUgbWFrZXMgaXQgaW1wb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBmZWF0dXJlXG4gICAgICAgIC8vIGluIHRoaXMgbWFubmVyOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD03OTgyMjNcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRpciA/IDEwMCAtIGEgLSBiIDogYTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZXMgc2NvcGVfTG9jYXRpb25zIGFuZCBzY29wZV9WYWx1ZXMsIHVwZGF0ZXMgdmlzdWFsIHN0YXRlXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUhhbmRsZVBvc2l0aW9uKGhhbmRsZU51bWJlciwgdG8pIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsb2NhdGlvbnMuXG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSA9IHRvO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byB0aGUgc2xpZGVyIHN0ZXBwaW5nL3JhbmdlLlxuICAgICAgICAgICAgc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcodG8pO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSAxMCAqICh0cmFuc2Zvcm1EaXJlY3Rpb24odG8sIDApIC0gc2NvcGVfRGlyT2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVSdWxlID0gXCJ0cmFuc2xhdGUoXCIgKyBpblJ1bGVPcmRlcih0cmFuc2xhdGlvbiArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcblxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSB0cmFuc2xhdGVSdWxlO1xuXG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0KGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0KGhhbmRsZU51bWJlciArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlcyBiZWZvcmUgdGhlIHNsaWRlciBtaWRkbGUgYXJlIHN0YWNrZWQgbGF0ZXIgPSBoaWdoZXIsXG4gICAgICAgIC8vIEhhbmRsZXMgYWZ0ZXIgdGhlIG1pZGRsZSBsYXRlciBpcyBsb3dlclxuICAgICAgICAvLyBbWzddIFs4XSAuLi4uLi4uLi4uIHwgLi4uLi4uLi4uLiBbNV0gWzRdXG4gICAgICAgIGZ1bmN0aW9uIHNldFppbmRleCgpIHtcbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0gPiA1MCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB2YXIgekluZGV4ID0gMyArIChzY29wZV9IYW5kbGVzLmxlbmd0aCArIGRpciAqIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBzdWdnZXN0ZWQgdmFsdWVzIGFuZCBhcHBseSBtYXJnaW4sIHN0ZXAuXG4gICAgICAgIC8vIGlmIGV4YWN0SW5wdXQgaXMgdHJ1ZSwgZG9uJ3QgcnVuIGNoZWNrSGFuZGxlUG9zaXRpb24sIHRoZW4gdGhlIGhhbmRsZSBjYW4gYmUgcGxhY2VkIGluIGJldHdlZW4gc3RlcHMgKCM0MzYpXG4gICAgICAgIGZ1bmN0aW9uIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBleGFjdElucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWV4YWN0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICB0byA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZUhhbmRsZVBvc2l0aW9uKGhhbmRsZU51bWJlciwgdG8pO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZXMgc3R5bGUgYXR0cmlidXRlIGZvciBjb25uZWN0IG5vZGVzXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3QoaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFNraXAgY29ubmVjdHMgc2V0IHRvIGZhbHNlXG4gICAgICAgICAgICBpZiAoIXNjb3BlX0Nvbm5lY3RzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICAgICAgdmFyIGggPSAxMDA7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGwgPSBzY29wZV9Mb2NhdGlvbnNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBzY29wZV9Db25uZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgaCA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIHVzZSB0d28gcnVsZXM6XG4gICAgICAgICAgICAvLyAndHJhbnNsYXRlJyB0byBjaGFuZ2UgdGhlIGxlZnQvdG9wIG9mZnNldDtcbiAgICAgICAgICAgIC8vICdzY2FsZScgdG8gY2hhbmdlIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudDtcbiAgICAgICAgICAgIC8vIEFzIHRoZSBlbGVtZW50IGhhcyBhIHdpZHRoIG9mIDEwMCUsIGEgdHJhbnNsYXRpb24gb2YgMTAwJSBpcyBlcXVhbCB0byAxMDAlIG9mIHRoZSBwYXJlbnQgKC5ub1VpLWJhc2UpXG4gICAgICAgICAgICB2YXIgY29ubmVjdFdpZHRoID0gaCAtIGw7XG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlUnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodHJhbnNmb3JtRGlyZWN0aW9uKGwsIGNvbm5lY3RXaWR0aCkgKyBcIiVcIiwgXCIwXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB2YXIgc2NhbGVSdWxlID0gXCJzY2FsZShcIiArIGluUnVsZU9yZGVyKGNvbm5lY3RXaWR0aCAvIDEwMCwgXCIxXCIpICsgXCIpXCI7XG5cbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzW2luZGV4XS5zdHlsZVtvcHRpb25zLnRyYW5zZm9ybVJ1bGVdID0gdHJhbnNsYXRlUnVsZSArIFwiIFwiICsgc2NhbGVSdWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2VzIHZhbHVlIHBhc3NlZCB0byAuc2V0IG1ldGhvZC4gUmV0dXJucyBjdXJyZW50IHZhbHVlIGlmIG5vdCBwYXJzZS1hYmxlLlxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlVG9WYWx1ZSh0bywgaGFuZGxlTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBTZXR0aW5nIHdpdGggbnVsbCBpbmRpY2F0ZXMgYW4gJ2lnbm9yZScuXG4gICAgICAgICAgICAvLyBJbnB1dHRpbmcgJ2ZhbHNlJyBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgaWYgKHRvID09PSBudWxsIHx8IHRvID09PSBmYWxzZSB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIGZvcm1hdHRlZCBudW1iZXIgd2FzIHBhc3NlZCwgYXR0ZW1wdCB0byBkZWNvZGUgaXQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdG8gPSBTdHJpbmcodG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0byA9IG9wdGlvbnMuZm9ybWF0LmZyb20odG8pO1xuICAgICAgICAgICAgdG8gPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHRvKTtcblxuICAgICAgICAgICAgLy8gSWYgcGFyc2luZyB0aGUgbnVtYmVyIGZhaWxlZCwgdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc05hTih0bykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgc2xpZGVyIHZhbHVlLlxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldChpbnB1dCwgZmlyZVNldEV2ZW50LCBleGFjdElucHV0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gYXNBcnJheShpbnB1dCk7XG4gICAgICAgICAgICB2YXIgaXNJbml0ID0gc2NvcGVfTG9jYXRpb25zWzBdID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIEV2ZW50IGZpcmVzIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGZpcmVTZXRFdmVudCA9IGZpcmVTZXRFdmVudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZmlyZVNldEV2ZW50O1xuXG4gICAgICAgICAgICAvLyBBbmltYXRpb24gaXMgb3B0aW9uYWwuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGluaXRpYWwgdmFsdWVzIHdlcmUgc2V0IGJlZm9yZSB1c2luZyBhbmltYXRlZCBwbGFjZW1lbnQuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICYmICFpc0luaXQpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJzdCBwYXNzLCB3aXRob3V0IGxvb2tBaGVhZCBidXQgd2l0aCBsb29rQmFja3dhcmQuIFZhbHVlcyBhcmUgc2V0IGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCByZXNvbHZlVG9WYWx1ZSh2YWx1ZXNbaGFuZGxlTnVtYmVyXSwgaGFuZGxlTnVtYmVyKSwgdHJ1ZSwgZmFsc2UsIGV4YWN0SW5wdXQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBpID0gc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGggPT09IDEgPyAwIDogMTtcblxuICAgICAgICAgICAgLy8gU2Vjb25kYXJ5IHBhc3Nlcy4gTm93IHRoYXQgYWxsIGJhc2UgdmFsdWVzIGFyZSBzZXQsIGFwcGx5IGNvbnN0cmFpbnRzLlxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBhbGwgaGFuZGxlcyB0byBlbnN1cmUgY29uc3RyYWludHMgYXJlIGFwcGxpZWQgZm9yIHRoZSBlbnRpcmUgc2xpZGVyIChJc3N1ZSAjMTAwOSlcbiAgICAgICAgICAgIGZvciAoOyBpIDwgc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0sIHRydWUsIHRydWUsIGV4YWN0SW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRaaW5kZXgoKTtcblxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgZXZlbnQgb25seSBmb3IgaGFuZGxlcyB0aGF0IHJlY2VpdmVkIGEgbmV3IHZhbHVlLCBhcyBwZXIgIzU3OVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaGFuZGxlTnVtYmVyXSAhPT0gbnVsbCAmJiBmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCBzbGlkZXIgdG8gaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgZnVuY3Rpb24gdmFsdWVSZXNldChmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlU2V0KG9wdGlvbnMuc3RhcnQsIGZpcmVTZXRFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdmFsdWUgZm9yIGEgc2luZ2xlIGhhbmRsZVxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHZhbHVlLCBmaXJlU2V0RXZlbnQsIGV4YWN0SW5wdXQpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBudW1lcmljIGlucHV0XG4gICAgICAgICAgICBoYW5kbGVOdW1iZXIgPSBOdW1iZXIoaGFuZGxlTnVtYmVyKTtcblxuICAgICAgICAgICAgaWYgKCEoaGFuZGxlTnVtYmVyID49IDAgJiYgaGFuZGxlTnVtYmVyIDwgc2NvcGVfSGFuZGxlTnVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBpbnZhbGlkIGhhbmRsZSBudW1iZXIsIGdvdDogXCIgKyBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb29rIGJvdGggYmFja3dhcmQgYW5kIGZvcndhcmQsIHNpbmNlIHdlIGRvbid0IHdhbnQgdGhpcyBoYW5kbGUgdG8gXCJwdXNoXCIgb3RoZXIgaGFuZGxlcyAoIzk2MCk7XG4gICAgICAgICAgICAvLyBUaGUgZXhhY3RJbnB1dCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBpZ25vcmUgc2xpZGVyIHN0ZXBwaW5nICgjNDM2KVxuICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgcmVzb2x2ZVRvVmFsdWUodmFsdWUsIGhhbmRsZU51bWJlciksIHRydWUsIHRydWUsIGV4YWN0SW5wdXQpO1xuXG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcblxuICAgICAgICAgICAgaWYgKGZpcmVTZXRFdmVudCkge1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzbGlkZXIgdmFsdWUuXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlR2V0KCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHNjb3BlX1ZhbHVlcy5tYXAob3B0aW9ucy5mb3JtYXQudG8pO1xuXG4gICAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlcyBjbGFzc2VzIGZyb20gdGhlIHJvb3QgYW5kIGVtcHRpZXMgaXQuXG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgcHJvdGVjdGVkIGludGVybmFsIGxpc3RlbmVyc1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnQoSU5URVJOQUxfRVZFTlRfTlMuYXJpYSk7XG4gICAgICAgICAgICByZW1vdmVFdmVudChJTlRFUk5BTF9FVkVOVF9OUy50b29sdGlwcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNzc0NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuY3NzQ2xhc3Nlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlc1trZXldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHNjb3BlX1RhcmdldC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVfVGFyZ2V0LnJlbW92ZUNoaWxkKHNjb3BlX1RhcmdldC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKGhhbmRsZU51bWJlcikge1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XG4gICAgICAgICAgICB2YXIgbmVhcmJ5U3RlcHMgPSBzY29wZV9TcGVjdHJ1bS5nZXROZWFyYnlTdGVwcyhsb2NhdGlvbik7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXTtcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGVwO1xuICAgICAgICAgICAgdmFyIGRlY3JlbWVudCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHNuYXBwZWQsIGRpcmVjdGx5IHVzZSBkZWZpbmVkIHN0ZXAgdmFsdWVcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNuYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuc3RhcnRWYWx1ZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSAtIHZhbHVlIHx8IG51bGxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCB2YWx1ZSBpbiB0aGlzIHN0ZXAgbW92ZXMgaW50byB0aGUgbmV4dCBzdGVwLFxuICAgICAgICAgICAgLy8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSArIGluY3JlbWVudCA+IG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYmV5b25kIHRoZSBzdGFydGluZyBwb2ludFxuICAgICAgICAgICAgaWYgKHZhbHVlID4gbmVhcmJ5U3RlcHMudGhpc1N0ZXAuc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuc3RlcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYSBoYW5kbGUgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgc3RlcCwgaXQgYWx3YXlzIHN0ZXBzIGJhY2sgaW50byB0aGUgcHJldmlvdXMgc3RlcCBmaXJzdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gdmFsdWUgLSBuZWFyYnlTdGVwcy5zdGVwQmVmb3JlLmhpZ2hlc3RTdGVwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3csIGlmIGF0IHRoZSBzbGlkZXIgZWRnZXMsIHRoZXJlIGlzIG5vIGluL2RlY3JlbWVudFxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFzIHBlciAjMzkxLCB0aGUgY29tcGFyaXNvbiBmb3IgdGhlIGRlY3JlbWVudCBzdGVwIGNhbiBoYXZlIHNvbWUgcm91bmRpbmcgaXNzdWVzLlxuICAgICAgICAgICAgdmFyIHN0ZXBEZWNpbWFscyA9IHNjb3BlX1NwZWN0cnVtLmNvdW50U3RlcERlY2ltYWxzKCk7XG5cbiAgICAgICAgICAgIC8vIFJvdW5kIHBlciAjMzkxXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ICE9PSBudWxsICYmIGluY3JlbWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBOdW1iZXIoaW5jcmVtZW50LnRvRml4ZWQoc3RlcERlY2ltYWxzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnQgIT09IG51bGwgJiYgZGVjcmVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IE51bWJlcihkZWNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtkZWNyZW1lbnQsIGluY3JlbWVudF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RlcCBzaXplIGZvciB0aGUgc2xpZGVyLlxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVfSGFuZGxlTnVtYmVycy5tYXAoZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZWFibGU6IG1hcmdpbiwgbGltaXQsIHBhZGRpbmcsIHN0ZXAsIHJhbmdlLCBhbmltYXRlLCBzbmFwXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9uc1RvVXBkYXRlLCBmaXJlU2V0RXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFNwZWN0cnVtIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIHJhbmdlLCBzbmFwLCBkaXJlY3Rpb24gYW5kIHN0ZXAgb3B0aW9ucy5cbiAgICAgICAgICAgIC8vICdzbmFwJyBhbmQgJ3N0ZXAnIGNhbiBiZSB1cGRhdGVkLlxuICAgICAgICAgICAgLy8gSWYgJ3NuYXAnIGFuZCAnc3RlcCcgYXJlIG5vdCBwYXNzZWQsIHRoZXkgc2hvdWxkIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlR2V0KCk7XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVBYmxlID0gW1xuICAgICAgICAgICAgICAgIFwibWFyZ2luXCIsXG4gICAgICAgICAgICAgICAgXCJsaW1pdFwiLFxuICAgICAgICAgICAgICAgIFwicGFkZGluZ1wiLFxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIixcbiAgICAgICAgICAgICAgICBcImFuaW1hdGVcIixcbiAgICAgICAgICAgICAgICBcInNuYXBcIixcbiAgICAgICAgICAgICAgICBcInN0ZXBcIixcbiAgICAgICAgICAgICAgICBcImZvcm1hdFwiLFxuICAgICAgICAgICAgICAgIFwicGlwc1wiLFxuICAgICAgICAgICAgICAgIFwidG9vbHRpcHNcIlxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgLy8gT25seSBjaGFuZ2Ugb3B0aW9ucyB0aGF0IHdlJ3JlIGFjdHVhbGx5IHBhc3NlZCB0byB1cGRhdGUuXG4gICAgICAgICAgICB1cGRhdGVBYmxlLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB1bmRlZmluZWQuIG51bGwgcmVtb3ZlcyB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNUb1VwZGF0ZVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB0ZXN0T3B0aW9ucyhvcmlnaW5hbE9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBMb2FkIG5ldyBvcHRpb25zIGludG8gdGhlIHNsaWRlciBzdGF0ZVxuICAgICAgICAgICAgdXBkYXRlQWJsZS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IG5ld09wdGlvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNjb3BlX1NwZWN0cnVtID0gbmV3T3B0aW9ucy5zcGVjdHJ1bTtcblxuICAgICAgICAgICAgLy8gTGltaXQsIG1hcmdpbiBhbmQgcGFkZGluZyBkZXBlbmQgb24gdGhlIHNwZWN0cnVtIGJ1dCBhcmUgc3RvcmVkIG91dHNpZGUgb2YgaXQuICgjNjc3KVxuICAgICAgICAgICAgb3B0aW9ucy5tYXJnaW4gPSBuZXdPcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICAgIG9wdGlvbnMubGltaXQgPSBuZXdPcHRpb25zLmxpbWl0O1xuICAgICAgICAgICAgb3B0aW9ucy5wYWRkaW5nID0gbmV3T3B0aW9ucy5wYWRkaW5nO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGlwcywgcmVtb3ZlcyBleGlzdGluZy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcbiAgICAgICAgICAgICAgICBwaXBzKG9wdGlvbnMucGlwcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZVBpcHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRvb2x0aXBzLCByZW1vdmVzIGV4aXN0aW5nLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHMpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwcygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVUb29sdGlwcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIHNvIHZhbHVlU2V0IGZvcmNlcyBhbiB1cGRhdGUuXG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhbHVlU2V0KG9wdGlvbnNUb1VwZGF0ZS5zdGFydCB8fCB2LCBmaXJlU2V0RXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gc3RlcHNcbiAgICAgICAgZnVuY3Rpb24gc2V0dXBTbGlkZXIoKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGJhc2UgZWxlbWVudCwgaW5pdGlhbGl6ZSBIVE1MIGFuZCBzZXQgY2xhc3Nlcy5cbiAgICAgICAgICAgIC8vIEFkZCBoYW5kbGVzIGFuZCBjb25uZWN0IGVsZW1lbnRzLlxuICAgICAgICAgICAgc2NvcGVfQmFzZSA9IGFkZFNsaWRlcihzY29wZV9UYXJnZXQpO1xuXG4gICAgICAgICAgICBhZGRFbGVtZW50cyhvcHRpb25zLmNvbm5lY3QsIHNjb3BlX0Jhc2UpO1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggdXNlciBldmVudHMuXG4gICAgICAgICAgICBiaW5kU2xpZGVyRXZlbnRzKG9wdGlvbnMuZXZlbnRzKTtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBwdWJsaWMgdmFsdWUgbWV0aG9kIHRvIHNldCB0aGUgc3RhcnQgdmFsdWVzLlxuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9ucy5zdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcbiAgICAgICAgICAgICAgICBwaXBzKG9wdGlvbnMucGlwcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJpYSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dXBTbGlkZXIoKTtcblxuICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgICAgIHNjb3BlX1NlbGYgPSB7XG4gICAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICAgICAgc3RlcHM6IGdldE5leHRTdGVwcyxcbiAgICAgICAgICAgIG9uOiBiaW5kRXZlbnQsXG4gICAgICAgICAgICBvZmY6IHJlbW92ZUV2ZW50LFxuICAgICAgICAgICAgZ2V0OiB2YWx1ZUdldCxcbiAgICAgICAgICAgIHNldDogdmFsdWVTZXQsXG4gICAgICAgICAgICBzZXRIYW5kbGU6IHZhbHVlU2V0SGFuZGxlLFxuICAgICAgICAgICAgcmVzZXQ6IHZhbHVlUmVzZXQsXG4gICAgICAgICAgICAvLyBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcsIGRvbid0IHVzZSB0aGlzIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgICAgICBfX21vdmVIYW5kbGVzOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgbW92ZUhhbmRsZXMoYSwgYiwgc2NvcGVfTG9jYXRpb25zLCBjKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zOiBvcmlnaW5hbE9wdGlvbnMsIC8vIElzc3VlICM2MDAsICM2NzhcbiAgICAgICAgICAgIHVwZGF0ZU9wdGlvbnM6IHVwZGF0ZU9wdGlvbnMsXG4gICAgICAgICAgICB0YXJnZXQ6IHNjb3BlX1RhcmdldCwgLy8gSXNzdWUgIzU5N1xuICAgICAgICAgICAgcmVtb3ZlUGlwczogcmVtb3ZlUGlwcyxcbiAgICAgICAgICAgIHJlbW92ZVRvb2x0aXBzOiByZW1vdmVUb29sdGlwcyxcbiAgICAgICAgICAgIGdldFRvb2x0aXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfVG9vbHRpcHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0T3JpZ2luczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0hhbmRsZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGlwczogcGlwcyAvLyBJc3N1ZSAjNTk0XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlX1NlbGY7XG4gICAgfVxuXG4gICAgLy8gUnVuIHRoZSBzdGFuZGFyZCBpbml0aWFsaXplclxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemUodGFyZ2V0LCBvcmlnaW5hbE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5ub2RlTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBjcmVhdGUgcmVxdWlyZXMgYSBzaW5nbGUgZWxlbWVudCwgZ290OiBcIiArIHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiB0aGUgc2xpZGVyIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkLlxuICAgICAgICBpZiAodGFyZ2V0Lm5vVWlTbGlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogU2xpZGVyIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3QgdGhlIG9wdGlvbnMgYW5kIGNyZWF0ZSB0aGUgc2xpZGVyIGVudmlyb25tZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRlc3RPcHRpb25zKG9yaWdpbmFsT3B0aW9ucywgdGFyZ2V0KTtcbiAgICAgICAgdmFyIGFwaSA9IHNjb3BlKHRhcmdldCwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKTtcblxuICAgICAgICB0YXJnZXQubm9VaVNsaWRlciA9IGFwaTtcblxuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH1cblxuICAgIC8vIFVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIGZvciBmdXR1cmUgZXhwYW5kYWJpbGl0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcsIGRvbid0IHVzZSB0aGlzIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgIF9fc3BlY3RydW06IFNwZWN0cnVtLFxuICAgICAgICB2ZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgZGVmYXVsdCBjbGFzc2VzLCBhbGxvd3MgZ2xvYmFsIGNoYW5nZXMuXG4gICAgICAgIC8vIFVzZSB0aGUgY3NzQ2xhc3NlcyBvcHRpb24gZm9yIGNoYW5nZXMgdG8gb25lIHNsaWRlci5cbiAgICAgICAgY3NzQ2xhc3NlczogY3NzQ2xhc3NlcyxcbiAgICAgICAgY3JlYXRlOiBpbml0aWFsaXplXG4gICAgfTtcbn0pO1xuIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiBtb2R1bGVbJ2RlZmF1bHQnXSA6XG5cdFx0KCkgPT4gbW9kdWxlO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2FwcC9sYXlvdXQuanNcIik7XG4vLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdleHBvcnRzJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4iXSwic291cmNlUm9vdCI6IiJ9